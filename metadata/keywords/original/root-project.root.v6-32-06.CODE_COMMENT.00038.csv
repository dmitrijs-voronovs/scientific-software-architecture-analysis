id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:678,Availability,avail,available,678,"//===- ConstantMerge.cpp - Merge duplicate global constants ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface to a pass that merges duplicate global; // constants together into a single constant that is shared. This is useful; // because some passes (ie TraceValues) insert a lot of string constants into; // the program, regardless of whether or not an existing string is available.; //; // Algorithm: ConstantMerge is designed to build up a map of available constants; // and eliminate duplicates when it is initialized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:755,Availability,avail,available,755,"//===- ConstantMerge.cpp - Merge duplicate global constants ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface to a pass that merges duplicate global; // constants together into a single constant that is shared. This is useful; // because some passes (ie TraceValues) insert a lot of string constants into; // the program, regardless of whether or not an existing string is available.; //; // Algorithm: ConstantMerge is designed to build up a map of available constants; // and eliminate duplicates when it is initialized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:405,Integrability,interface,interface,405,"//===- ConstantMerge.cpp - Merge duplicate global constants ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface to a pass that merges duplicate global; // constants together into a single constant that is shared. This is useful; // because some passes (ie TraceValues) insert a lot of string constants into; // the program, regardless of whether or not an existing string is available.; //; // Algorithm: ConstantMerge is designed to build up a map of available constants; // and eliminate duplicates when it is initialized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:28,Modifiability,variab,variables,28,// Don't touch thread-local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:127,Performance,perform,perform,127,"// This transformation is legal for weak ODR globals in the sense it; // doesn't change semantics, but we really don't want to perform it; // anyway; it's likely to pessimize code generation, and some tools; // (like the Darwin linker in cases involving CFString) don't expect it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:91,Safety,avoid,avoid,91,"// Now that we have figured out which replacements must be made, do them all; // now. This avoid invalidating the pointers in CMap, which are unneeded; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CrossDSOCFI.cpp:62,Testability,stub,stub,62,// Take over the existing function. The frontend emits a weak stub so that the; // linker knows about the symbol; this pass replaces the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CrossDSOCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CrossDSOCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:51,Safety,safe,safe,51,"// Okay, we know we can transform this function if safe. Scan its body; // looking for calls marked musttail or calls to llvm.vastart.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:275,Performance,load,load,275,"// We cannot change the arguments if this TU does not define the function or; // if the linker may choose a function body from another TU, even if the; // nominal linkage indicates that other copies of the function have the same; // semantics. In the below example, the dead load from %p may not have been; // eliminated from the linker-chosen copy of f, so replacing %p with poison; // in callers may introduce undefined behavior.; //; // define linkonce_odr void @f(i32* %p) {; // %v = load i32 %p; // ret void; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:488,Performance,load,load,488,"// We cannot change the arguments if this TU does not define the function or; // if the linker may choose a function body from another TU, even if the; // nominal linkage indicates that other copies of the function have the same; // semantics. In the below example, the dead load from %p may not have been; // eliminated from the linker-chosen copy of f, so replacing %p with poison; // in callers may introduce undefined behavior.; //; // define linkonce_odr void @f(i32* %p) {; // %v = load i32 %p; // ret void; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:95,Availability,alive,alive,95,"// Functions with local linkage should already have been handled, except if; // they are fully alive (e.g., called indirectly) and except for the fragile; // (variadic) ones. In these cases, we may still be able to improve their; // statically known call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:93,Availability,alive,alive,93,"/// Looks at a single use of an argument or return value and determines if it; /// should be alive or not. Adds this use to MaybeLiveUses if it causes the; /// used value to become MaybeLive.; ///; /// RetValNum is the return value number to use when this use is used in a; /// return instruction. This is used in the recursion, you should always leave; /// it at 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:21,Integrability,depend,depending,21,"// We might be live, depending on the liveness of Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:21,Integrability,depend,depending,21,"// We might be live, depending on the liveness of Use. If any; // sub-value is live, then the entire value is considered live. This; // is a conservative choice, and better tracking is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:76,Integrability,depend,depends,76,"// The use we are examining is inserted into an aggregate. Our liveness; // depends on all uses of that aggregate, but if it is used as a return; // value, only index at which we were inserted counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:298,Availability,alive,alive,298,"/// Performs the initial survey of the specified function, checking out whether; /// it uses any of its incoming arguments or whether any callers use the return; /// value. This fills in the LiveValues set and Uses map.; ///; /// We consider arguments of non-internal functions to be intrinsically alive as; /// well as arguments to functions which have their ""address taken"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:4,Performance,Perform,Performs,4,"/// Performs the initial survey of the specified function, checking out whether; /// it uses any of its incoming arguments or whether any callers use the return; /// value. This fills in the LiveValues set and Uses map.; ///; /// We consider arguments of non-internal functions to be intrinsically alive as; /// well as arguments to functions which have their ""address taken"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:3,Usability,Clear,Clear,3,// Clear the vector again for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:29,Integrability,depend,depending,29,"/// Marks the liveness of RA depending on L. If L is MaybeLive, it also takes; /// all uses in MaybeLiveUses and records them in Uses, such that RA will be; /// marked live if any use in MaybeLiveUses gets marked live later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:31,Availability,alive,alive,31,"/// Mark the given Function as alive, meaning that it cannot be changed in any; /// way. Additionally, mark any values that are used as this function's; /// parameters or by its return values (according to Uses) live as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:38,Availability,alive,alive,38,// Remember which arguments are still alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:695,Integrability,depend,depending,695,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:970,Performance,perform,performance,970,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:372,Usability,clear,clear,372,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:40,Availability,down,down,40,// More than one return type? Reduce it down to size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:30,Energy Efficiency,Reduce,Reduce,30,// More than one return type? Reduce it down to size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:27,Usability,simpl,simple,27,"// One return type? Just a simple value then, but only if we didn't use to; // return a struct with that simple value before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:105,Usability,simpl,simple,105,"// One return type? Just a simple value then, but only if we didn't use to; // return a struct with that simple value before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:126,Availability,alive,alive,126,"// Loop over those operands, corresponding to the normal arguments to the; // original function, and add those that are still alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:177,Availability,alive,alive,177,"// If the return type has changed, then get rid of 'returned' on the; // call site. The alternative is to make all 'returned' attributes on; // call sites keep the return value alive just like 'returned'; // attributes on function declaration, but it's less clearly a win and; // this is not an expected case anyway",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:258,Usability,clear,clearly,258,"// If the return type has changed, then get rid of 'returned' on the; // call site. The alternative is to make all 'returned' attributes on; // call sites keep the return value alive just like 'returned'; // attributes on function declaration, but it's less clearly a win and; // this is not an expected case anyway",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:57,Modifiability,rewrite,rewrite,57,// If we change the return value of the function we must rewrite any return; // instructions. Check this now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:31,Usability,simpl,simple,31,"// We are now only returning a simple value, so just return the; // extracted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:232,Safety,safe,safe,232,"// If either the return value(s) or argument(s) are removed, then probably the; // function does not follow standard calling conventions anymore. Hence, add; // DW_CC_nocall to DISubroutineType to inform debugger that it may not be safe; // to call this function or try to interpret the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:20,Usability,simpl,simple,20,"// First pass: Do a simple check to see if any functions can have their ""...""; // removed. We can do this if they never call va_start. This loop cannot be; // fused with the next loop, because deleting a function invalidates; // information computed while surveying other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:423,Availability,avail,available,423,"//===- ElimAvailExtern.cpp - DCE unreachable internal functions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transform is designed to eliminate available external global; // definitions from the program, turning them into declarations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:297,Deployability,update,updated,297,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:492,Deployability,pipeline,pipeline,492,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:181,Testability,test,tests,181,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:334,Usability,GUID,GUID,334,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:24,Availability,avail,available,24,// Drop initializers of available externally global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:52,Modifiability,variab,variables,52,// Drop initializers of available externally global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:22,Availability,avail,available,22,// Drop the bodies of available externally functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, just give all GlobalValues ExternalLinkage. A trickier; // implementation could figure out which GlobalValues are actually; // referenced by the Named set, and which GlobalValues in the rest of; // the module are referenced by the NamedSet, and get away with leaving; // more internal and private things internal and private. But for now,; // be conservative and simple.; // Visit the GlobalVariables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp:382,Usability,simpl,simple,382,"// For simplicity, just give all GlobalValues ExternalLinkage. A trickier; // implementation could figure out which GlobalValues are actually; // referenced by the Named set, and which GlobalValues in the rest of; // the module are referenced by the NamedSet, and get away with leaving; // more internal and private things internal and private. But for now,; // be conservative and simple.; // Visit the GlobalVariables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:10,Security,access,accesses,10,// Ignore accesses to known-invariant or local memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:416,Performance,optimiz,optimized,416,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:23,Security,access,access,23,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:662,Security,access,access,662,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:24,Security,access,accessed,24,// Additional locations accessed if the SCC accesses argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:44,Security,access,accesses,44,// Additional locations accessed if the SCC accesses argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:75,Safety,Detect,Detect,75,"// Some instructions can be ignored even if they read or write memory.; // Detect these now, skipping to the next instruction if one is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:212,Integrability,depend,depending,212,"// We can optimistically ignore calls to functions in the same SCC, with; // two caveats:; // * Calls with operand bundles may have additional effects.; // * Argument memory accesses may imply additional effects depending on; // what the argument location is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:174,Security,access,accesses,174,"// We can optimistically ignore calls to functions in the same SCC, with; // two caveats:; // * Calls with operand bundles may have additional effects.; // * Argument memory accesses may imply additional effects depending on; // what the argument location is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:48,Security,access,accessed,48,// Keep track of which additional locations are accessed if the SCC; // turns out to access argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:85,Security,access,access,85,// Keep track of which additional locations are accessed if the SCC; // turns out to access argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:23,Security,access,access,23,"// If the call doesn't access memory, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:190,Performance,optimiz,optimizations,190,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:247,Performance,optimiz,optimized,247,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:140,Security,access,access,140,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:15,Security,access,accesses,15,"// If the call accesses captured memory (currently part of ""other"") and; // an argument is captured (currently not tracked), then it may also; // access argument memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:146,Security,access,access,146,"// If the call accesses captured memory (currently part of ""other"") and; // an argument is captured (currently not tracked), then it may also; // access argument memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:93,Security,access,access,93,"// Check whether all pointer arguments point to local memory, and; // ignore calls that only access local memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:70,Security,access,accessed,70,"// If no location is known, conservatively assume anything can be; // accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:27,Security,access,access,27,// Volatile operations may access inaccessible memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:14,Security,access,accesses,14,"// If the SCC accesses argmem, add recursive accesses resulting from that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:45,Security,access,accesses,45,"// If the SCC accesses argmem, add recursive accesses resulting from that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:1288,Availability,Avail,AvailableExternally,1288,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:1493,Availability,Avail,AvailableExternally,1493,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:1726,Availability,Avail,AvailableExternally,1726,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:2094,Performance,optimiz,optimize,2094,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:468,Testability,assert,assert,468,"/// At this point, prevailing symbols have been resolved. The following leads; /// to returning a conservative result:; /// - Multiple instances with local linkage. Normally local linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:232,Usability,GUID,GUID,232,"/// At this point, prevailing symbols have been resolved. The following leads; /// to returning a conservative result:; /// - Multiple instances with local linkage. Normally local linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:279,Usability,guid,guid,279,"/// At this point, prevailing symbols have been resolved. The following leads; /// to returning a conservative result:; /// - Multiple instances with local linkage. Normally local linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:57,Usability,simpl,simply,57,"// If the callee can save a copy into other memory, then simply; // scanning uses of the call is insufficient. We have no way; // of tracking copies of the pointer through memory to see; // if a reloaded copy is written to, thus we must give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:7,Security,access,accessors,7,// The accessors used on call site here do the right thing for calls and; // invokes with operand bundles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:14,Performance,load,load,14,// A volatile load has side effects beyond what readonly can be relied; // upon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:268,Modifiability,enhance,enhanced,268,"// For an argument attribute to transfer from a callsite to the parent, the; // call must be guaranteed to execute every time the parent is called.; // Conservatively, just check for calls in the entry block that are guaranteed; // to execute.; // TODO: This could be enhanced by testing if the callsite post-dominates the; // entry block or by doing simple forward walks or backward walks to the; // callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:280,Testability,test,testing,280,"// For an argument attribute to transfer from a callsite to the parent, the; // call must be guaranteed to execute every time the parent is called.; // Conservatively, just check for calls in the entry block that are guaranteed; // to execute.; // TODO: This could be enhanced by testing if the callsite post-dominates the; // entry block or by doing simple forward walks or backward walks to the; // callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:351,Usability,simpl,simple,351,"// For an argument attribute to transfer from a callsite to the parent, the; // call must be guaranteed to execute every time the parent is called.; // Conservatively, just check for calls in the entry block that are guaranteed; // to execute.; // TODO: This could be enhanced by testing if the callsite post-dominates the; // entry block or by doing simple forward walks or backward walks to the; // callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:81,Deployability,update,update,81,"// Otherwise, remove potentially conflicting attribute, add the new one,; // and update statistics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:163,Integrability,depend,dependent,163,"// Can we determine that it's readonly/readnone/writeonly without doing; // an SCC? Note that we don't allow any calls at all here, or else our; // result will be dependent on the iteration order through the; // functions in the SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:13,Security,access,access,13,// Infer the access attributes given the new nocapture one,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Testability,Test,Tests,4,"/// Tests whether a function is ""malloc-like"".; ///; /// A function is ""malloc-like"" if it returns either null or a pointer that; /// doesn't alias any other pointer visible to the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Modifiability,Extend,Extend,3,// Extend the analysis by looking upwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Testability,Test,Tests,4,"/// Tests whether this function is known to not return null.; ///; /// Requires that the function returns a pointer.; ///; /// Returns true if it believes the function will not return a null, and sets; /// \p Speculative based on whether the returned conclusion is a speculative; /// conclusion due to SCC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Modifiability,Extend,Extend,3,// Extend the analysis by looking upwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:9,Performance,perform,perform,9,// TODO: perform context-sensitive analysis?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:55,Performance,perform,performs,55,/// Collects a set of attribute inference requests and performs them all in one; /// go on a single SCC Node. Inference involves scanning function bodies; /// looking for instructions that violate attribute assumptions.; /// As soon as all the bodies are fine we are free to set the attribute.; /// Customization of inference for individual attributes is performed by; /// providing a handful of predicates for each attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:355,Performance,perform,performed,355,/// Collects a set of attribute inference requests and performs them all in one; /// go on a single SCC Node. Inference involves scanning function bodies; /// looking for instructions that violate attribute assumptions.; /// As soon as all the bodies are fine we are free to set the attribute.; /// Customization of inference for individual attributes is performed by; /// providing a handful of predicates for each attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:119,Performance,optimiz,optimization,119,"/// Returns true if this function does not have to be handled.; /// General intent for this predicate is to provide an optimization; /// for functions that do not need this attribute inference at all; /// (say, for functions that already have the attribute).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Performance,Perform,Perform,4,/// Perform all the requested attribute inference actions according to the; /// attribute predicates stored before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:243,Integrability,synchroniz,synchronizing,243,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:334,Safety,risk,risk,334,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:327,Usability,simpl,simply,327,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:16,Integrability,synchroniz,synchronize,16,// Volatile may synchronize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:25,Integrability,synchroniz,synchronize,25,// An ordered atomic may synchronize. (See comment about on monotonic.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Performance,Perform,Perform,3,// Perform all the requested attribute inference actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:257,Integrability,depend,depending,257,// Request to infer nounwind attribute for all the functions in the SCC if; // every callsite within the SCC is not throwing (except for calls to; // functions within the SCC). Note that nounwind attribute suffers from; // derefinement - results may change depending on how functions are; // optimized. Thus it can be inferred only from exact definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:292,Performance,optimiz,optimized,292,// Request to infer nounwind attribute for all the functions in the SCC if; // every callsite within the SCC is not throwing (except for calls to; // functions within the SCC). Note that nounwind attribute suffers from; // derefinement - results may change depending on how functions are; // optimized. Thus it can be inferred only from exact definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:281,Integrability,depend,depending,281,// Request to infer nofree attribute for all the functions in the SCC if; // every callsite within the SCC does not directly or indirectly free; // memory (except for calls to functions within the SCC). Note that nofree; // attribute suffers from derefinement - results may change depending on; // how functions are optimized. Thus it can be inferred only from exact; // definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:316,Performance,optimiz,optimized,316,// Request to infer nofree attribute for all the functions in the SCC if; // every callsite within the SCC does not directly or indirectly free; // memory (except for calls to functions within the SCC). Note that nofree; // attribute suffers from derefinement - results may change depending on; // how functions are optimized. Thus it can be inferred only from exact; // definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Performance,Perform,Perform,3,// Perform all the requested attribute inference actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:113,Safety,detect,detects,113,"// If all of the calls in F are identifiable and are to norecurse functions, F; // is norecurse. This check also detects self-recursion as F is not currently; // marked norecurse, so any called from F to F will not be marked norecurse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:42,Performance,optimiz,optimize,42,// Treat any function we're trying not to optimize as if it were an; // indirect call and omit it from the node set used below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:152,Integrability,rout,routines,152,"// Track whether any functions in this SCC have an unknown call edge.; // Note: if this is ever a performance hit, we can common it with; // subsequent routines which also do scans over the instructions of the; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:98,Performance,perform,performance,98,"// Track whether any functions in this SCC have an unknown call edge.; // Note: if this is ever a performance hit, we can common it with; // subsequent routines which also do scans over the instructions of the; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:254,Usability,simpl,simply,254,"// Finally, infer the maximal set of attributes from the ones we've inferred; // above. This is handling the cases where one attribute on a signature; // implies another, but for implementation reasons the inference rule for; // the later is missing (or simply less sophisticated).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:136,Performance,optimiz,optimization,136,"// Skip non-recursive functions if requested.; // Only infer argument attributes for non-recursive functions, because; // it can affect optimization behavior in conjunction with noalias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:72,Safety,avoid,avoid,72,// We check the preconditions for the function prior to calling this to avoid; // the cost of building up a reversible post-order list. We assert them here; // to make sure none of the invariants this relies on were violated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:139,Testability,assert,assert,139,// We check the preconditions for the function prior to calling this to avoid; // the cost of building up a reversible post-order list. We assert them here; // to make sure none of the invariants this relies on were violated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:459,Safety,detect,detects,459,"// If F is internal and all of its uses are calls from a non-recursive; // functions, then none of its calls could in fact recurse without going; // through a function marked norecurse, and so we can mark this function too; // as norecurse. Note that the uses must actually be calls -- otherwise; // a pointer to this function could be returned from a norecurse function but; // this function could be recursively (indirectly) called. Note that this; // also detects if F is directly recursive as F is not yet marked as; // a norecurse function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:264,Safety,detect,detection,264,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:178,Usability,simpl,simpler,178,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:499,Usability,clear,clearly,499,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:41,Performance,tune,tuned,41,// FIXME: This multiplier was not really tuned up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:14,Testability,test,testing,14,/// Used when testing importing from distributed indexes via opt; // -function-import.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Performance,Load,Load,3,// Load lazily a module from \p FileName in \p Context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:18,Performance,load,loaded,18,"// Metadata isn't loaded until functions are imported, to minimize; // the memory overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:96,Security,hash,hash,96,"// Ignore any callees that aren't actually functions. This could happen; // in the case of GUID hash collisions. It could also happen in theory; // for SamplePGO profiles collected on old versions of the code after; // renaming, since we synthesize edges to any inlined callees appearing; // in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:91,Usability,GUID,GUID,91,"// Ignore any callees that aren't actually functions. This could happen; // in the case of GUID hash collisions. It could also happen in theory; // for SamplePGO profiles collected on old versions of the code after; // renaming, since we synthesize edges to any inlined callees appearing; // in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:181,Availability,failure,failure,181,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:503,Energy Efficiency,reduce,reduce,503,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:426,Performance,optimiz,optimized,426,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:202,Availability,avail,available,202,"// We should not skip import if the module contains a non-prevailing; // definition with interposable linkage type. This is required for; // correctness in the situation where there is a prevailing def available; // for import and marked read-only. In this case, the non-prevailing def; // will be converted to a declaration, while the prevailing one becomes; // internal, thus no definitions will be available for linking. In order to; // prevent undefined symbol link error, the prevailing definition must be; // imported.; // FIXME: Consider adding a check that the suitable prevailing definition; // exists and marked read-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:401,Availability,avail,available,401,"// We should not skip import if the module contains a non-prevailing; // definition with interposable linkage type. This is required for; // correctness in the situation where there is a prevailing def available; // for import and marked read-only. In this case, the non-prevailing def; // will be converted to a declaration, while the prevailing one becomes; // internal, thus no definitions will be available for linking. In order to; // prevent undefined symbol link error, the prevailing definition must be; // imported.; // FIXME: Consider adding a check that the suitable prevailing definition; // exists and marked read-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:470,Availability,error,error,470,"// We should not skip import if the module contains a non-prevailing; // definition with interposable linkage type. This is required for; // correctness in the situation where there is a prevailing def available; // for import and marked read-only. In this case, the non-prevailing def; // will be converted to a declaration, while the prevailing one becomes; // internal, thus no definitions will be available for linking. In order to; // prevent undefined symbol link error, the prevailing definition must be; // imported.; // FIXME: Consider adding a check that the suitable prevailing definition; // exists and marked read-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:22,Modifiability,variab,variable,22,"// If this is a local variable, make sure we import the copy; // in the caller's module. The only time a local variable can; // share an entry in the index is if there is a local with the same name; // in another module that had the same source file name (in a different; // directory), where each was compiled in their own directory so there; // was not distinguishing path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:111,Modifiability,variab,variable,111,"// If this is a local variable, make sure we import the copy; // in the caller's module. The only time a local variable can; // share an entry in the index is if there is a local with the same name; // in another module that had the same source file name (in a different; // directory), where each was compiled in their own directory so there; // was not distinguishing path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:301,Modifiability,refactor,refactor,301,"// Functions could be referenced by global vars - e.g. a vtable; but we; // don't currently imagine a reason those would be imported here, rather; // than as part of the logic deciding which functions to import (i.e.; // based on profile information). Should we decide to handle them here,; // we can refactor accordingly at that time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:170,Testability,log,logic,170,"// Functions could be referenced by global vars - e.g. a vtable; but we; // don't currently imagine a reason those would be imported here, rather; // than as part of the logic deciding which functions to import (i.e.; // based on profile information). Should we decide to handle them here,; // we can refactor accordingly at that time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:8,Deployability,update,update,8,// Only update stat and exports if we haven't already imported this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:72,Modifiability,variab,variable,72,// Only update stat and exports if we haven't already imported this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:159,Energy Efficiency,efficient,efficient,159,"// Any references made by this variable will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:31,Modifiability,variab,variable,31,"// Any references made by this variable will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:6,Modifiability,variab,variable,6,// If variable is not writeonly we attempt to recursively analyze; // its references in order to import referenced constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:95,Availability,avail,available,95,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:727,Availability,avail,avail-extern-to-local,727,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:251,Performance,optimiz,optimizations,251,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:142,Safety,safe,safely,142,// FIXME: Consider not skipping import if the module contains; // a non-prevailing def with interposable linkage. The prevailing copy; // can safely be imported (see shouldImportGlobal()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Update,Update,3,// Update with new larger threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:144,Availability,failure,failure,144,// Update with new larger threshold if this was a retry (otherwise; // we would have already inserted with NewThreshold above). Also; // update failure info if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Update,Update,3,// Update with new larger threshold if this was a retry (otherwise; // we would have already inserted with NewThreshold above). Also; // update failure info if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:137,Deployability,update,update,137,// Update with new larger threshold if this was a retry (otherwise; // we would have already inserted with NewThreshold above). Also; // update failure info if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:40,Usability,GUID,GUID,40,// We previously decided to import this GUID definition if it was already; // inserted in the set of imports from the exporting module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:165,Energy Efficiency,efficient,efficient,165,"// Any calls/references made by this function will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:132,Availability,down,down,132,"// Worklist contains the list of function imported in this module, for which; // we will analyse the callees and may import further down the callgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:123,Safety,avoid,avoided,123,// FIXME: Change the GVSummaryMapTy to hold ValueInfo instead of GUID; // so this map look up (and possibly others) can be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:65,Usability,GUID,GUID,65,// FIXME: Change the GVSummaryMapTy to hold ValueInfo instead of GUID; // so this map look up (and possibly others) can be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:26,Modifiability,variab,variables,26,// Skip import for global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:19,Usability,GUID,GUIDs,19,"// Checks that all GUIDs of read/writeonly vars we see in export lists; // are also in the import lists. Otherwise we my face linker undefs,; // because readonly and writeonly vars are internalized in their; // source modules. The exception would be if it has a linkage type indicating; // that there may have been a copy existing in the importing module (e.g.; // linkonce_odr). In that case we cannot accurately do this checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:219,Energy Efficiency,efficient,efficient,219,"// When computing imports we only added the variables and functions being; // imported to the export list. We also need to mark any references and calls; // they make as exported as well. We do this here, as it is more efficient; // since we may import the same values multiple times into different modules; // during the import computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:44,Modifiability,variab,variables,44,"// When computing imports we only added the variables and functions being; // imported to the export list. We also need to mark any references and calls; // they make as exported as well. We do this here, as it is more efficient; // since we may import the same values multiple times into different modules; // during the import computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:35,Modifiability,variab,variables,35,"// Export referenced functions and variables. We don't export/promote; // objects referenced by writeonly variable initializer, because; // we convert such variables initializers to ""zeroinitializer"".; // See processGlobalForThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:106,Modifiability,variab,variable,106,"// Export referenced functions and variables. We don't export/promote; // objects referenced by writeonly variable initializer, because; // we convert such variables initializers to ""zeroinitializer"".; // See processGlobalForThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:156,Modifiability,variab,variables,156,"// Export referenced functions and variables. We don't export/promote; // objects referenced by writeonly variable initializer, because; // we convert such variables initializers to ""zeroinitializer"".; // See processGlobalForThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:217,Energy Efficiency,efficient,efficient,217,"// Prune list computed above to only include values defined in the exporting; // module. We do this after the above insertion since we may hit the same; // ref/call target multiple times in above loop, and it is more efficient to; // avoid a set lookup each time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:234,Safety,avoid,avoid,234,"// Prune list computed above to only include values defined in the exporting; // module. We do this after the above insertion since we may hit the same; // ref/call target multiple times in above loop, and it is more efficient to; // avoid a set lookup each time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:148,Usability,GUID,GUID,148,/// Compute all the imports for the given module using the Index.; ///; /// \p isPrevailing is a callback that will be called with a global value's GUID; /// and summary and should return whether the module corresponding to the; /// summary contains the linker-prevailing copy of that value.; ///; /// \p ImportList will be populated with a map that can be passed to; /// FunctionImporter::importFunctions() above (see description there).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:58,Usability,GUID,GUID,58,// Collect the list of functions this module defines.; // GUID -> Summary,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:92,Testability,test,testing,92,/// Mark all external summaries in \p Index for import into the given module.; /// Used for testing the case of distributed builds using a distributed index.; ///; /// \p ImportList will be populated with a map that can be passed to; /// FunctionImporter::importFunctions() above (see description there).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:174,Usability,GUID,GUID,174,"// For SamplePGO, the indirect call targets for local functions will; // have its original name annotated in profile. We try to find the; // corresponding PGOFuncName as the GUID, and fix up the edges; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Update,Update,3,// Update the edge to point directly to the correct GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:52,Usability,GUID,GUID,52,// Update the edge to point directly to the correct GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:90,Modifiability,variab,variable,90,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:254,Modifiability,variab,variable,254,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:375,Modifiability,variab,variable,375,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:34,Usability,GUID,GUID,34,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:52,Usability,GUID,GUID,52,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:306,Usability,GUID,GUID,306,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:65,Testability,test,tests,65,"// Don't do anything when nothing is live, this is friendly with tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:17,Deployability,update,update,17,// Still need to update indirect calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:248,Availability,down,downstreams,248,"// We only keep live symbols that are known to be non-prevailing if any are; // available_externally, linkonceodr, weakodr. Those symbols are discarded; // later in the EliminateAvailableExternally pass and setting them to; // not-live could break downstreams users of liveness information (PR36483); // or limit optimization opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:313,Performance,optimiz,optimization,313,"// We only keep live symbols that are known to be non-prevailing if any are; // available_externally, linkonceodr, weakodr. Those symbols are discarded; // later in the EliminateAvailableExternally pass and setting them to; // not-live could break downstreams users of liveness information (PR36483); // or limit optimization opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:123,Usability,simpl,simply,123,"// Check for a non-prevailing def that has interposable linkage; // (e.g. non-odr weak or linkonce). In that case we can't simply; // convert to available_externally, since it would lose the; // interposable property and possibly get inlined. Simply drop; // the definition in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:243,Usability,Simpl,Simply,243,"// Check for a non-prevailing def that has interposable linkage; // (e.g. non-odr weak or linkonce). In that case we can't simply; // convert to available_externally, since it would lose the; // interposable property and possibly get inlined. Simply drop; // the definition in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:111,Usability,simpl,simplicity,111,"// If an alias references a GlobalValue in a non-prevailing comdat, change; // it to available_externally. For simplicity we only handle GlobalValue and; // ConstantExpr with a base object. ConstantExpr without a base object is; // unlikely used in a COMDAT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:146,Availability,avail,available,146,"// It may be the case that GV is on a chain of an ifunc, its alias and; // subsequent aliases. In this case, the summary for the value is not; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:92,Security,access,access,92,// Must have been promoted (possibly conservatively). Find original; // name so that we can access the correct summary and see if it can; // be internalized again.; // FIXME: Eventually we should control promotion instead of promoting; // and internalizing again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:46,Performance,load,loading,46,"// If modules were created with lazy metadata loading, materialize it; // now, before linking it (otherwise this will be a noop).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade debug info after we're done materializing all the globals and we; // have loaded all the required metadata!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:85,Performance,load,loaded,85,// Upgrade debug info after we're done materializing all the globals and we; // have loaded all the required metadata!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:81,Testability,test,testing,81,"// If requested, simply import all functions in the index. This is used; // when testing distributed backend handling via the opt tool, when; // we have distributed indexes containing exactly the summaries to import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:17,Usability,simpl,simply,17,"// If requested, simply import all functions in the index. This is used; // when testing distributed backend handling via the opt tool, when; // we have distributed indexes containing exactly the summaries to import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:61,Integrability,interface,interface,61,"// Conservatively mark all internal values as promoted. This interface is; // only used when doing importing via the function importing pass. The pass; // is only enabled when testing importing via the 'opt' tool, which does; // not do the ThinLink that would normally determine what values to promote.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:176,Testability,test,testing,176,"// Conservatively mark all internal values as promoted. This interface is; // only used when doing importing via the function importing pass. The pass; // is only enabled when testing importing via the 'opt' tool, which does; // not do the ThinLink that would normally determine what values to promote.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Performance,Perform,Perform,3,// Perform the import now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:37,Availability,Error,Errors,37,// FIXME: Probably need to propagate Errors through the pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:135,Availability,avail,available,135,"// This is only used for testing the function import pass via opt, where we; // don't have prevailing information from the LTO context available, so just; // conservatively assume everything is prevailing (which is fine for the very; // limited use of prevailing checking in this pass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:25,Testability,test,testing,25,"// This is only used for testing the function import pass via opt, where we; // don't have prevailing information from the LTO context available, so just; // conservatively assume everything is prevailing (which is fine for the very; // limited use of prevailing checking in this pass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Performance,Cache,Cache,3,// Cache the iterator before visiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:157,Energy Efficiency,reduce,reduced,157,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:778,Modifiability,variab,variables,778,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:815,Modifiability,variab,variables,815,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:127,Performance,optimiz,optimization,127,// ssa_copy intrinsics are introduced by the SCCP solver. These intrinsics; // interfere with the promoteConstantStackValues() optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:17,Availability,down,down,17,"// It is safe to down cast from int64_t, NumInsts is always positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:9,Safety,safe,safe,9,"// It is safe to down cast from int64_t, NumInsts is always positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Deployability,Update,Update,3,// Update the known call sites to call the clone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Deployability,Update,Update,3,"// Update the rest of the call sites - these are the recursive calls, calls; // to discarded specialisations and calls that may match a specialisation; // after the solver runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:56,Modifiability,rewrite,rewrite,56,"// Existing specialisation. Add the call to the list to rewrite, unless; // it's a recursive call. A specialisation, generated because of a; // recursive call may end up as not the best specialisation for all; // the cloned instances of this call, which result from specialising; // functions. Hence we don't rewrite the call directly, but match it with; // the best specialisation once all specialisations are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:309,Modifiability,rewrite,rewrite,309,"// Existing specialisation. Add the call to the list to rewrite, unless; // it's a recursive call. A specialisation, generated because of a; // recursive call may end up as not the best specialisation for all; // the cloned instances of this call, which result from specialising; // functions. Hence we don't rewrite the call directly, but match it with; // the best specialisation once all specialisations are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:11,Performance,latency,latency,11,// Minimum latency savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:12,Performance,optimiz,optimizing,12,"// If we're optimizing the function for size, we shouldn't specialize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:424,Performance,perform,performing,424,"// Get the cost of inlining the called function at this call site. Note; // that this is only an estimate. The called function may eventually; // change in a way that leads to it not being inlined here, even though; // inlining looks profitable now. For example, one of its called; // functions may be inlined into it, making the called function too large; // to be inlined into this call site.; //; // We apply a boost for performing indirect call promotion by increasing; // the default threshold by the threshold for indirect calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:88,Modifiability,variab,variable,88,"// Don't specialize on (anything derived from) the address of a non-constant; // global variable, unless explicitly enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:554,Availability,alive,alive,554,"//===-- GlobalDCE.cpp - DCE unreachable internal functions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transform is designed to eliminate unreachable internal globals from the; // program. It uses an aggressive algorithm, searching out globals that are; // known to be alive. After it finds all of the globals which are needed, it; // deletes whatever is left over. This allows it to delete recursive chunks of; // the program which are unreachable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:40,Integrability,depend,depends,40,/// Compute the set of GlobalValue that depends from V.; /// The recursion stops as soon as a GlobalValue is met.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:3,Safety,Avoid,Avoid,3,// Avoid walking the whole tree of a big ConstantExprs multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:164,Safety,safe,safe,164,"// If the type corresponding to the vtable is private to this translation; // unit, we know that we can see all virtual functions which might use it,; // so VFE is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:16,Performance,load,load,16,"// type.checked.load with a non-constant offset, so assume every entry; // in every matching vtable is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:136,Performance,optimiz,optimization,136,"// If the Virtual Function Elim module flag is present and set to zero, then; // the vcall_visibility metadata was inserted for another optimization (WPD); // and we may not have type checked loads on all accesses to the vtable.; // Don't attempt VFE in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:192,Performance,load,loads,192,"// If the Virtual Function Elim module flag is present and set to zero, then; // the vcall_visibility metadata was inserted for another optimization (WPD); // and we may not have type checked loads on all accesses to the vtable.; // Don't attempt VFE in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:205,Security,access,accesses,205,"// If the Virtual Function Elim module flag is present and set to zero, then; // the vcall_visibility metadata was inserted for another optimization (WPD); // and we may not have type checked loads on all accesses to the vtable.; // Don't attempt VFE in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:461,Availability,alive,alive,461,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:52,Modifiability,variab,variables,52,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:133,Modifiability,variab,variables,133,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:264,Modifiability,variab,variables,264,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:7,Integrability,depend,dependencies,7,"// Add dependencies between virtual call sites and the virtual functions they; // might call, if we have that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:18,Integrability,depend,dependencies,18,// Compute direct dependencies of aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:18,Integrability,depend,dependencies,18,// Compute direct dependencies of ifuncs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:76,Integrability,depend,dependencies,76,// Propagate liveness from collected Global Values through the computed; // dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:52,Availability,Alive,AliveGlobals,52,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:132,Availability,alive,alive,132,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:196,Modifiability,variab,variables,196,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:123,Safety,safe,safe,123,"// Virtual functions might still be referenced by one or more vtables,; // but if we've proven them to be unused then it's safe to replace the; // virtual function pointers with null, allowing us to remove the; // function itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:3,Safety,Detect,Detect,3,"// Detect vfuncs that are referenced as ""relative pointers"" which are used; // in Swift vtables, i.e. entries in the form of:; //; // i32 trunc (i64 sub (i64 ptrtoint @f, i64 ptrtoint ...)) to i32); //; // In this case, replace the whole ""sub"" expression with constant 0 to; // avoid leaving a weird sub(0, symbol) expression behind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:278,Safety,avoid,avoid,278,"// Detect vfuncs that are referenced as ""relative pointers"" which are used; // in Swift vtables, i.e. entries in the form of:; //; // i32 trunc (i64 sub (i64 ptrtoint @f, i64 ptrtoint ...)) to i32); //; // In this case, replace the whole ""sub"" expression with constant 0 to; // avoid leaving a weird sub(0, symbol) expression behind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:32,Deployability,release,released,32,// Make sure that all memory is released,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,Modifiability,Variab,Variables,39,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:418,Modifiability,variab,variables,418,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:541,Modifiability,variab,variables,541,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:23,Performance,Optimiz,Optimize,23,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:404,Usability,simpl,simple,404,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:19,Modifiability,variab,variable,19,"/// Is this global variable possibly used by a leak checker as a root? If so,; /// we might not really want to eliminate the stores to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:12,Modifiability,variab,variable,12,"// A global variable is a root if it is a pointer, or could plausibly contain; // a pointer. There are two challenges; one is that we could have a struct; // the has an inner member which is a pointer. We recurse through the type to; // detect these (up to a point). The other is that we may actually be a union; // of a pointer and another type, and so our LLVM type is an integer which; // gets converted into a pointer, or our type is an [i8 x #] with a pointer; // potentially contained here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:237,Safety,detect,detect,237,"// A global variable is a root if it is a pointer, or could plausibly contain; // a pointer. There are two challenges; one is that we could have a struct; // the has an inner member which is a pointer. We recurse through the type to; // detect these (up to a point). The other is that we may actually be a union; // of a pointer and another type, and so our LLVM type is an integer which; // gets converted into a pointer, or our type is an [i8 x #] with a pointer; // potentially contained here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:89,Safety,safe,safe,89,"/// Given a value that is stored to a global but never read, determine whether; /// it's safe to remove the store and the chain of computation that feeds the; /// store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:162,Energy Efficiency,allocate,allocated,162,/// This GV is a pointer root. Loop over all users of the global and clean up; /// any that obviously don't assign the global a value that isn't dynamically; /// allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:380,Availability,down,down,380,"// A brief explanation of leak checkers. The goal is to find bugs where; // pointers are forgotten, causing an accumulating growth in memory; // usage over time. The common strategy for leak checkers is to explicitly; // allow the memory pointed to by globals at exit. This is popular because it; // also solves another problem where the main thread of a C++ program may shut; // down before other threads that are still expecting to use those globals. To; // handle that case, we expect the program may create a singleton and never; // destroy it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,Energy Efficiency,allocate,allocated,46,// Constants can't be pointers to dynamically allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:5,Performance,load,load,5,"// A load from a uniform value is always the same, regardless of any; // applied offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:81,Performance,load,loads,81,"/// Part of the global at a specific offset, which is only accessed through; /// loads and stores with the given type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:59,Security,access,accessed,59,"/// Part of the global at a specific offset, which is only accessed through; /// loads and stores with the given type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,Security,access,accesses,39,// TODO: We currently require that all accesses at a given offset must; // use the same type. This could be relaxed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Scalab,Scalable,3,// Scalable types not currently supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,Modifiability,variab,variable,35,/// Copy over the debug info for a variable to its SRA replacements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:11,Modifiability,variab,variable,11,"// Current variable ends before start of fragment, ignore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:11,Modifiability,variab,variable,11,"// Current variable fits in (not greater than) the fragment,; // does not need fragment expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:11,Modifiability,variab,variable,11,"// Current variable does not fit in single fragment,; // emit a fragment expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:69,Modifiability,variab,variable,69,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:294,Modifiability,variab,variable,294,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:4,Performance,Perform,Perform,4,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:114,Performance,optimiz,optimizations,114,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:253,Safety,safe,safe,253,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:9,Performance,perform,perform,9,"// Don't perform SRA if we would have to split into many globals. Ignore; // parts that are either only loaded or only stored, because we expect them; // to be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:104,Performance,load,loaded,104,"// Don't perform SRA if we would have to split into many globals. Ignore; // parts that are either only loaded or only stored, because we expect them; // to be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:160,Performance,optimiz,optimized,160,"// Don't perform SRA if we would have to split into many globals. Ignore; // parts that are either only loaded or only stored, because we expect them; // to be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:8,Security,access,accesses,8,"// Some accesses go beyond the end of the global, don't bother.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:129,Integrability,depend,depend,129,"// Calculate the known alignment of the field. If the original aggregate; // had 256 byte alignment for example, something might depend on that:; // propagate info to each field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:36,Modifiability,variab,variable,36,// Copy over the debug info for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Deployability,Update,Update,3,// Update the pointer operand and recalculate alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:149,Safety,avoid,avoid,149,/// Return true if all users of the specified value will trap if the value is; /// dynamically null. PHIs keeps track of any phi nodes we've seen to avoid; /// reprocessing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:198,Modifiability,variab,variable,198,// This and only this kind of non-signed ICmpInst is to be replaced with; // the comparing of the value of the created global init bool later in; // optimizeGlobalAddressOfAllocation for the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:149,Performance,optimiz,optimizeGlobalAddressOfAllocation,149,// This and only this kind of non-signed ICmpInst is to be replaced with; // the comparing of the value of the created global init bool later in; // optimizeGlobalAddressOfAllocation for the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,Performance,load,loads,35,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:66,Performance,load,loaded,66,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:140,Performance,load,loaded,140,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:44,Modifiability,variab,variable,44,/// Get all the loads/store uses for global variable \p GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,Performance,load,loads,16,/// Get all the loads/store uses for global variable \p GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:99,Performance,load,loaded,99,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:135,Performance,load,loaded,135,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:234,Performance,optimiz,optimize,234,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:252,Performance,load,load,252,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:23,Performance,load,loads,23,// Replace all uses of loads with uses of uses of the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:45,Performance,load,loads,45,// If we were able to delete all uses of the loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:75,Performance,load,loaded,75,// If we get here we could have other crazy uses that are transitively; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Performance,load,loads,26,"// If we nuked all of the loads, then none of the stores are needed either,; // nor is the global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,Safety,avoid,avoid,39,// Advance UI to the next non-I use to avoid invalidating it!; // Instructions could multiply use V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:45,Modifiability,variab,variable,45,"/// This function takes the specified global variable, and transforms the; /// program as if it always contained the result of the specified malloc.; /// Because it is always the result of the specified malloc, there is no reason; /// to actually DO the malloc. Instead, turn the malloc into a global, and any; /// loads of GV as uses of the new global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:315,Performance,load,loads,315,"/// This function takes the specified global variable, and transforms the; /// program as if it always contained the result of the specified malloc.; /// Because it is always the result of the specified malloc, there is no reason; /// to actually DO the malloc. Instead, turn the malloc into a global, and any; /// loads of GV as uses of the new global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:55,Energy Efficiency,allocate,allocated,55,"// Create the new global variable. The contents of the allocated memory is; // undefined initially, so initialize with an undef value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:25,Modifiability,variab,variable,25,"// Create the new global variable. The contents of the allocated memory is; // undefined initially, so initialize with an undef value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Deployability,Update,Update,3,// Update users of the allocation to use the new global instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:20,Performance,optimiz,optimizations,20,"// To further other optimizations, loop over all users of NewGV and try to; // constant prop them. This will promote GEP instructions with constant; // indices into GEP constant-exprs, which will allow global-opt to hack on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:103,Usability,simpl,simple,103,"/// Scan the use-list of GV checking to make sure that there are no complex uses; /// of GV. We permit simple things like dereferencing the pointer, but not; /// storing through the address, unless it is to the specified global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:154,Energy Efficiency,allocate,allocated,154,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:208,Safety,avoid,avoids,208,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:235,Security,access,accessing,235,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:259,Security,expose,exposes,259,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:12,Performance,optimiz,optimize,12,"// We can't optimize this global unless all uses of it are *known* to be; // of the malloc value, not of the null initializer value (consider a use; // that compares the global's value against zero to see if the malloc has; // been reached). To do this, we check to see if all uses of the global; // would trap if the global were null: this proves that they must all; // happen after the malloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:12,Performance,optimiz,optimize,12,"// We can't optimize this if the malloc itself is used in a complex way,; // for example, being stored into multiple globals. This allows the; // malloc to be stored into the specified global, loaded, gep, icmp'd.; // These are all things we could transform to using the global for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:193,Performance,load,loaded,193,"// We can't optimize this if the malloc itself is used in a complex way,; // for example, being stored into multiple globals. This allows the; // malloc to be stored into the specified global, loaded, gep, icmp'd.; // These are all things we could transform to using the global for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:10,Performance,optimiz,optimize,10,// Try to optimize globals based on the knowledge that only one value (besides; // its initializer) is ever stored to the global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:137,Performance,optimiz,optimize,137,"// If we are dealing with a pointer global that is initialized to null and; // only has one (non-null) value stored into it, then we can optimize any; // users of the loaded value (often calls and loads) that would trap if the; // value was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:167,Performance,load,loaded,167,"// If we are dealing with a pointer global that is initialized to null and; // only has one (non-null) value stored into it, then we can optimize any; // users of the loaded value (often calls and loads) that would trap if the; // value was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:197,Performance,load,loads,197,"// If we are dealing with a pointer global that is initialized to null and; // only has one (non-null) value stored into it, then we can optimize any; // users of the loaded value (often calls and loads) that would trap if the; // value was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away any trapping uses of the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:42,Performance,load,loaded,42,// Optimize away any trapping uses of the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:271,Performance,optimiz,optimizations,271,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:231,Security,expose,exposes,231,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:27,Usability,learn,learned,27,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:127,Performance,optimiz,optimization,127,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:347,Performance,load,loads,347,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:226,Usability,simpl,simplification,226,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:62,Performance,load,load,62,"// Walk the use list of the global seeing if all the uses are load or store.; // If there is anything else, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:261,Integrability,depend,depending,261,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:55,Modifiability,variab,variable,55,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:126,Modifiability,variab,variable,126,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:45,Performance,optimiz,optimized,45,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:98,Performance,optimiz,optimization,98,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:40,Performance,load,loaded,40,// Only do this if we weren't storing a loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:42,Performance,load,loaded,42,"// Otherwise, we are storing a previously loaded copy. To do this,; // change the copy from copying the original value to just copying the; // bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:113,Performance,load,load,113,"// If we've already replaced the input, StoredVal will be a cast or; // select instruction. If not, it will be a load of the original; // global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,Performance,load,load,16,"// Insert a new load, to preserve the saved value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:14,Performance,load,load,14,// Change the load into a load of bool then a select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Performance,load,load,26,// Change the load into a load of bool then a select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:61,Modifiability,inherit,inherit,61,"// Since LI is split into two instructions, NLI and NSI both inherit the; // same DebugLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:37,Modifiability,variab,variable,37,// Retain the name of the old global variable. People who are debugging their; // programs may expect these variables to be named the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:108,Modifiability,variab,variables,108,// Retain the name of the old global variable. People who are debugging their; // programs may expect these variables to be named the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:429,Usability,simpl,simply,429,"// Find all uses of GV. We expect them all to be in F, and if we can't; // identify any of the uses we bail out.; //; // On each of these uses, identify if the memory that GV points to is; // used/required/live at the start of the function. If it is not, for example; // if the first thing the function does is store to the GV, the GV can; // possibly be demoted.; //; // We don't do an exhaustive search for memory operations - simply look; // through bitcasts as they're quite common and benign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:106,Integrability,depend,depend,106,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:42,Performance,load,loads,42,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:207,Performance,load,load,207,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:478,Energy Efficiency,power,powerful,478,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:274,Performance,load,load,274,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:487,Performance,optimiz,optimization,487,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:70,Testability,test,tests,70,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:7,Performance,load,load,7,// The load is only dominated by the store if DomTree says so; // and the number of bits loaded in L is less than or equal to; // the number of bits stored in S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:89,Performance,load,loaded,89,// The load is only dominated by the store if DomTree says so; // and the number of bits loaded in L is less than or equal to; // the number of bits stored in S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:24,Integrability,depend,dependences,24,"// All loads have known dependences inside F, so the global can be localized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:7,Performance,load,loads,7,"// All loads have known dependences inside F, so the global can be localized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,Modifiability,variab,variable,16,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:68,Performance,load,loads,68,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:85,Performance,load,loads,85,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:103,Performance,load,load,103,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:18,Performance,optimiz,optimization,18,"// We can do this optimization for non-constants in nosync + norecurse; // functions, but globals used in exactly one norecurse functions are already; // promoted to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:34,Performance,load,loads,34,// Only compute DT if we have any loads to examine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:33,Modifiability,variab,variable,33,"/// Analyze the specified global variable and optimize; /// it if possible. If we make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,Performance,optimiz,optimize,46,"/// Analyze the specified global variable and optimize; /// it if possible. If we make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:52,Security,access,accessing,52,"// If this is a first class global and has only one accessing function and; // this function is non-recursive, we replace the global with a local alloca; // in this function.; //; // NOTE: It doesn't make sense to promote non-single-value types since we; // are just replacing static memory to stack memory.; //; // If the global is in different address space, don't bring it to stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Performance,load,loaded,26,"// If the global is never loaded (but may be stored to), it is dead.; // Delete it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:187,Modifiability,variab,variable,187,// Don't actually mark a global constant if it's atomic because atomic loads; // are implemented by a trivial cmpxchg in some edge-cases and that usually; // requires write access to the variable even if it's not actually changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:71,Performance,load,loads,71,// Don't actually mark a global constant if it's atomic because atomic loads; // are implemented by a trivial cmpxchg in some edge-cases and that usually; // requires write access to the variable even if it's not actually changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:173,Security,access,access,173,// Don't actually mark a global constant if it's atomic because atomic loads; // are implemented by a trivial cmpxchg in some edge-cases and that usually; // requires write access to the variable even if it's not actually changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Usability,simpl,simplifiable,26,// Clean up any obviously simplifiable users now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:49,Performance,optimiz,optimize,49,// Fall through to the next check; see if we can optimize further.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Usability,simpl,simplifiable,26,// Clean up any obviously simplifiable users now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:10,Performance,optimiz,optimize,10,// Try to optimize globals based on the knowledge that only one value; // (besides its initializer) is ever stored to the global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,Performance,load,loads,35,"// Try to forward the store to any loads. If we have more than one store, we; // may have a store of the initializer between StoredOnceStore and a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:147,Performance,load,load,147,"// Try to forward the store to any loads. If we have more than one store, we; // may have a store of the initializer between StoredOnceStore and a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:95,Performance,optimiz,optimization,95,"// Otherwise, if the global was not a boolean, we can shrink it to be a; // boolean. Skip this optimization for AS that doesn't allow an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:33,Modifiability,variab,variable,33,"/// Analyze the specified global variable and optimize it if possible. If we; /// make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,Performance,optimiz,optimize,46,"/// Analyze the specified global variable and optimize it if possible. If we; /// make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:20,Performance,optimiz,optimizations,20,// Do more involved optimizations if the global is internal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:196,Performance,perform,performance,196,"/// Return true if this is a calling convention that we'd like to change. The; /// idea here is that we don't want to mess with the convention if the user; /// explicitly requested something with performance implications like coldcc,; /// GHC, or anyregcc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:214,Integrability,depend,dependent,214,"// Skip over intrinsics since they won't remain as function calls.; // Important to do this check before the linkage check below so we; // won't bail out on debug intrinsics, possibly making the generated; // code dependent on the presence of debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:9,Performance,perform,perform,9,// Don't perform global opt pass on naked functions; we don't want fast; // calling conventions for naked functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:424,Testability,log,logic,424,"// LLVM's definition of dominance allows instructions that are cyclic; // in unreachable blocks, e.g.:; // %pat = select i1 %condition, @global, i16* %pat; // because any instruction dominates an instruction in a block that's; // not reachable from entry.; // So, remove unreachable blocks from the function, because a) there's; // no point in analyzing them and b) GlobalOpt should otherwise grow; // some more complicated logic to break these cycles.; // Notify the analysis manager that we've modified the function's CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:115,Performance,optimiz,optimizations,115,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:48,Safety,safe,safely,48,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:150,Safety,safe,safe,150,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:60,Testability,test,testing,60,// Change the calling convention to coldcc if either stress testing is; // enabled or the target would like to use coldcc on functions which are; // cold at all call sites and the callers contain no other non coldcc; // calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:64,Safety,safe,safe,64,"// The function is not used by a trampoline intrinsic, so it is safe; // to remove the 'nest' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:10,Modifiability,variab,variables,10,// Global variables without names cannot be referenced outside this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Usability,Simpl,Simplify,3,// Simplify the initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:15,Security,access,access,15,/// An easy to access representation of llvm.used and llvm.compiler.used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:63,Usability,simpl,simplify,63,"// If the alias is externally visible, we may still be able to simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:254,Security,access,access,254,"// We can't trivially replace the alias with the aliasee if the aliasee is; // non-trivial in some way. We also can't replace the alias with the aliasee; // if the aliasee may be preemptible at runtime. On ELF, a non-preemptible; // alias can be used to access the definition as if preemption did not; // happen.; // TODO: Try to handle non-zero GEPs of local aliasees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:140,Performance,optimiz,optimization,140,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:173,Usability,simpl,simplified,173,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:204,Usability,simpl,simply,204,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:513,Availability,failure,failure,513,"/// Itanium C++ ABI p3.3.5:; ///; /// After constructing a global (or local static) object, that will require; /// destruction on exit, a termination function is registered as follows:; ///; /// extern ""C"" int __cxa_atexit ( void (*f)(void *), void *p, void *d );; ///; /// This registration, e.g. __cxa_atexit(f,p,d), is intended to cause the; /// call f(p) when DSO d is unloaded, before all such termination calls; /// registered before this one. It returns zero if registration is; /// successful, nonzero on failure.; // This pass will look for calls to __cxa_atexit where the function is trivial; // and remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize global_ctors list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize non-address-taken globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:19,Usability,clear,clear,19,// We made sure to clear analyses for deleted functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:32,Modifiability,variab,variable,32,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:634,Performance,optimiz,optimization,634,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:664,Security,integrity,integrity,664,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:111,Performance,load,loads,111,"// Verify that each user of the global is an inrange getelementptr constant.; // From this it follows that any loads from or stores to that global must use; // a pointer derived from an inrange getelementptr constant, which is; // sufficient to allow us to apply the splitting transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:316,Modifiability,variab,variables,316,"// Type metadata may be attached one byte after the end of the vtable, for; // classes without virtual methods in Itanium ABI. AFAIK, it is never; // attached to the first byte of a vtable. Subtract one to get the right; // slice.; // This is making an assumption that vtable groups are the only kinds of; // global variables that !type metadata can be attached to, and that they; // are either Itanium ABI vtable groups or contain a single vtable (i.e.; // Microsoft ABI vtables).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:87,Performance,load,load,87,"// First, see if the module uses either of the llvm.type.test or; // llvm.type.checked.load intrinsics, which indicates that splitting globals; // may be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:57,Testability,test,test,57,"// First, see if the module uses either of the llvm.type.test or; // llvm.type.checked.load intrinsics, which indicates that splitting globals; // may be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:1041,Safety,safe,safe,1041,"//===- HotColdSplitting.cpp -- Outline Cold Regions -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// The goal of hot/cold splitting is to improve the memory locality of code.; /// The splitting pass does this by identifying cold blocks and moving them into; /// separate functions.; ///; /// When the splitting pass finds a cold block (referred to as ""the sink""), it; /// grows a maximal cold region around that block. The maximal region contains; /// all blocks (post-)dominated by the sink [*]. In theory, these blocks are as; /// cold as the sink. Once a region is found, it's split out of the original; /// function provided it's profitable to do so.; ///; /// [*] In practice, there is some added complexity because some blocks are not; /// safe to extract.; ///; /// TODO: Use the PM to get domtrees, and preserve BFI/BPI.; /// TODO: Reorder outlined functions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:83,Security,sanitiz,sanitizer,83,"// The block is cold if it calls/invokes a cold function. However, do not; // mark sanitizer traps as cold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:23,Safety,safe,safe,23,/// Check whether it's safe to outline \p BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:15,Safety,unsafe,unsafe,15,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:338,Safety,safe,safe,338,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:233,Usability,Resume,Resumes,233,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:92,Deployability,Update,UpdateEntryCount,92,"/// Mark \p F cold. Based on this assumption, also optimize it for minimum size.; /// If \p UpdateEntryCount is true (set when this is a new split function and; /// module has profile data), set entry count to 0 to ensure treated as cold.; /// Return true if the function is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:51,Performance,optimiz,optimize,51,"/// Mark \p F cold. Based on this assumption, also optimize it for minimum size.; /// If \p UpdateEntryCount is true (set when this is a new split function and; /// module has profile data), set entry count to 0 to ensure treated as cold.; /// Return true if the function is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:81,Performance,optimiz,optimization,81,// Returns false if the function should not be considered for hot-cold split; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:68,Modifiability,coupling,coupling,68,// Sum up the code size costs of non-terminator instructions. Tight coupling; // with \ref getOutliningPenalty is needed to model the costs of terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:29,Deployability,update,update,29,// TODO: Pass BFI and BPI to update profile information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Performance,Perform,Perform,3,// Perform a simple cost/benefit analysis to decide whether or not to permit; // splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:13,Usability,simpl,simple,13,// Perform a simple cost/benefit analysis to decide whether or not to permit; // splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Deployability,Update,Update,3,// Update the suggested entry point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:49,Performance,perform,performs,49,"// Set up an RPO traversal. Experimentally, this performs better (outlines; // more) than a PO traversal, because we prevent region overlap by keeping; // the first region to contain a block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:35,Energy Efficiency,reduce,reduces,35,// Calculate domtrees lazily. This reduces compile-time significantly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:79,Energy Efficiency,reduce,reduces,79,"// Calculate BFI lazily (it's only used to query ProfileSummaryInfo). This; // reduces compile-time significantly. TODO: When we *do* use BFI, we should; // be able to salvage its domtrees instead of recomputing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Performance,Cache,Cache,3,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:51,Safety,avoid,avoid,51,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Safety,Detect,Detect,3,// Detect inherently cold functions and mark them as such.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:168,Safety,avoid,avoid,168,// We only infer things using the prototype and the name; we don't need; // definitions. This ensures libfuncs are annotated and also allows our; // CGSCC inference to avoid needing to duplicate the inference from other; // attribute logic on all calls to declarations (as declarations aren't; // explicitly visited by CGSCC passes in the new pass manager.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:234,Testability,log,logic,234,// We only infer things using the prototype and the name; we don't need; // definitions. This ensures libfuncs are annotated and also allows our; // CGSCC inference to avoid needing to duplicate the inference from other; // attribute logic on all calls to declarations (as declarations aren't; // explicitly visited by CGSCC passes in the new pass manager.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:70,Usability,clear,clear,70,"// Otherwise, we may have changed fundamental function attributes, so clear; // out all the passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:119,Deployability,pipeline,pipeline,119,"/// A flag for test, so we can print the content of the advisor when running it; /// as part of the default (e.g. -O3) pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:15,Testability,test,test,15,"/// A flag for test, so we can print the content of the advisor when running it; /// as part of the default (e.g. -O3) pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:85,Testability,test,test,85,"// It should still be possible to run the inliner as a stand-alone SCC pass,; // for test scenarios. In that case, we default to the; // DefaultInlineAdvisor, which doesn't need to keep state between SCC pass; // runs. It also uses just the default InlineParams.; // In this case, we need to use the provided FAM, which is valid for the; // duration of the inliner pass, and thus the lifetime of the owned advisor.; // The one we would get from the MAM can be invalidated as a result of the; // inliner's activity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:358,Safety,avoid,avoid,358,"// We use a single common worklist for calls across the entire SCC. We; // process these in-order and append new calls introduced during inlining to; // the end. The PriorityInlineOrder is optional here, in which the smaller; // callee would have a higher priority to inline.; //; // Note that this particular order of processing is actually critical to; // avoid very bad behaviors. Consider *highly connected* call graphs where; // each function contains a small amount of code and a couple of calls to; // other functions. Because the LLVM inliner is fundamentally a bottom-up; // inliner, it can handle gracefully the fact that these all appear to be; // reasonable inlining candidates as it will flatten things until they become; // too big to inline, and then move on and flatten another batch.; //; // However, when processing call edges *within* an SCC we cannot rely on this; // bottom-up behavior. As a consequence, with heavily connected *SCCs* of; // functions we can end up incrementally inlining N calls into each of; // N functions because each incremental inlining decision looks good and we; // don't have a topological ordering to prevent explosions.; //; // To compensate for this, we don't process transitive edges made immediate; // by inlining until we've done one pass of inlining across the entire SCC.; // Large, highly connected SCCs still lead to some amount of code bloat in; // this model, but it is uniformly spread across all the functions in the SCC; // and eventually they all become too large to inline, rather than; // incrementally maknig a single function grow in a super linear fashion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:47,Availability,down,down,47,// We want to generally process call sites top-down in order for; // simplifications stemming from replacing the call with the returned value; // after inlining to be visible to subsequent inlining decisions.; // FIXME: Using instructions sequence is a really bad way to do this.; // Instead we should do an actual RPO walk of the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:69,Usability,simpl,simplifications,69,// We want to generally process call sites top-down in order for; // simplifications stemming from replacing the call with the returned value; // after inlining to be visible to subsequent inlining decisions.; // FIXME: Using instructions sequence is a really bad way to do this.; // Instead we should do an actual RPO walk of the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:21,Modifiability,variab,variable,21,// Capture updatable variable for the current SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:147,Safety,avoid,avoid,147,"// When inlining a callee produces new call sites, we want to keep track of; // the fact that they were inlined from the callee. This allows us to avoid; // infinite inlining in some obscure cases. To represent this, we use an; // index into the InlineHistory vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:162,Usability,simpl,simplified,162,// Track a set vector of inlined callees so that we can augment the caller; // with all of their edges in the call graph before pruning out the ones that; // got simplified away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:144,Deployability,update,updates,144,// Track the dead functions to delete once finished with inlining calls. We; // defer deleting these to make it easier to handle the call graph updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:59,Performance,cache,cache,59,// Loop forward over all of the calls. Note that we cannot cache the size as; // inlining can introduce new calls that need to be processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:138,Deployability,update,update,138,// Now process as many calls as we have within this caller in the sequence.; // We bail out as soon as the caller has to change so we can update the; // call graph and prepare the context of that new caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:86,Integrability,rout,routine,86,// Setup the data structure used to plumb customization into the; // `InlineFunction` routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:509,Performance,perform,performance,509,"// Continually inlining through an SCC can result in huge compile; // times and bloated code since we arbitrarily stop at some point; // when the inliner decides it's not profitable to inline anymore.; // We attempt to mitigate this by making these calls exponentially; // more expensive.; // This doesn't apply to calls in the same SCC since if we do; // inline through the SCC the function will end up being; // self-recursive which the inliner bails out on, and inlining; // within an SCC is necessary for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:194,Energy Efficiency,reduce,reduce,194,"// For local functions or discardable functions without comdats, check; // whether this makes the callee trivially dead. In that case, we can drop; // the body of the function eagerly which may reduce the number of callers; // of other functions to one, changing inline cost thresholds. Non-local; // discardable functions with comdats are checked later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:154,Availability,error,error,154,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:104,Deployability,update,updates,104,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:22,Performance,queue,queue,22,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:3,Usability,Clear,Clear,3,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:383,Deployability,update,update,383,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:399,Deployability,update,update,399,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:307,Testability,log,logic,307,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:145,Usability,simpl,simplification,145,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:190,Usability,simpl,simplification,190,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:687,Energy Efficiency,efficient,efficient,687,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:1220,Energy Efficiency,efficient,efficient,1220,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:90,Safety,risk,risk,90,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:475,Safety,avoid,avoid,475,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:656,Safety,avoid,avoided,656,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:149,Security,expose,expose,149,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:108,Performance,cache,cached,108,"// Get the necessary information out of the call graph and nuke the; // function there. Also, clear out any cached analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:94,Usability,clear,clear,94,"// Get the necessary information out of the call graph and nuke the; // function there. Also, clear out any cached analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:10,Deployability,update,updated,10,"// If the updated SCC was the one containing the deleted function, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:67,Usability,clear,clear,67,"// If the updated SCC was the one containing the deleted function, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:32,Deployability,update,update,32,"// Even if we change the IR, we update the core CGSCC data structures and so; // can preserve the proxy to the function analysis manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:117,Performance,optimiz,optimized,117,"// Run the inliner first. The theory is that we are walking bottom-up and so; // the callees have already been fully optimized, and we want to inline them; // into the callers so that our optimizations can reflect that.; // For PreLinkThinLTO pass, we disable hot-caller heuristic for sample PGO; // because it makes profile annotation in the backend inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:188,Performance,optimiz,optimizations,188,"// Run the inliner first. The theory is that we are walking bottom-up and so; // the callees have already been fully optimized, and we want to inline them; // into the callers so that our optimizations can reflect that.; // For PreLinkThinLTO pass, we disable hot-caller heuristic for sample PGO; // because it makes profile annotation in the backend inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:21,Deployability,pipeline,pipeline,21,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:271,Deployability,pipeline,pipeline,271,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:6,Integrability,wrap,wrap,6,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:409,Integrability,wrap,wrapper,409,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:83,Safety,detect,detect,83,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:45,Integrability,wrap,wrapper,45,// Print some info about passes added to the wrapper. This is however; // incomplete as InlineAdvisorAnalysis part isn't included (which also depends; // on Params and Mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:142,Integrability,depend,depends,142,// Print some info about passes added to the wrapper. This is however; // incomplete as InlineAdvisorAnalysis part isn't included (which also depends; // on Params and Mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:429,Modifiability,variab,variables,429,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:483,Modifiability,variab,variable,483,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:732,Safety,safe,safe,732,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:878,Safety,safe,safe,878,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:13,Performance,load,load,13,// Helper to load an API list to preserve from file and expose it as a functor; // for internalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:56,Security,expose,expose,56,// Helper to load an API list to preserve from file and expose it as a functor; // for internalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:31,Performance,load,loaded,31,// Contains the set of symbols loaded from file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:3,Performance,Load,Load,3,// Load the APIFile...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:3,Availability,Avail,Available,3,"// Available externally is really just a ""declaration with a body"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:48,Modifiability,variab,variables,48,"// As the name suggests, externally initialized variables need preserving as; // they would be initialized elsewhere externally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:125,Integrability,depend,dependencies,125,"// If a comdat with one member is not externally visible, we can drop it.; // Otherwise, the comdat can be used to establish dependencies among the; // group of sections. Thus we have to keep the comdat but switch it to; // nodeduplicate.; // Note: nodeduplicate is not necessary for COFF. wasm doesn't support; // nodeduplicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:56,Deployability,update,update,56,"// If GV is part of a comdat and is externally visible, update the comdat size; // and keep track of its comdat so that we don't internalize any of its members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:19,Modifiability,variab,variables,19,// Mark all global variables with initializers that are not in the api as; // internal as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:29,Testability,test,test,29,// This is a debug option to test small pieces of code to ensure that outlining; // works correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:80,Safety,avoid,avoid,80,/// Tracker counting backwards from the highest unsigned value possible to; /// avoid conflicting with the GVNs of assigned values. We start at -3 since; /// -2 and -1 are assigned by the DenseMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite the BranchInsts in the incoming blocks to \p PHIBlock that are found; /// in \p Included to branch to BasicBlock \p Replace if they currently branch; /// to the BasicBlock \p Find. This is used to fix up the incoming basic blocks; /// when PHINodes are included in outlined regions.; ///; /// \param PHIBlock - The BasicBlock containing the PHINodes that need to be; /// checked.; /// \param Find - The successor block to be replaced.; /// \param Replace - The new succesor block to branch to.; /// \param Included - The set of blocks about to be outlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:305,Modifiability,variab,variable,305,"// We iterate over the instructions in the region, if we find a PHINode, we; // check if there are predecessors outside of the region, if there are,; // we ignore this region since we are unable to handle the severing of the; // phi node right now.; // TODO: Handle extraneous inputs for PHINodes through variable number of; // inputs, similar to how outputs are handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:96,Deployability,update,updated,96,"// If there was a PHINode with an incoming block outside the region,; // make sure is correctly updated in the newly split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:73,Deployability,update,updated,73,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:167,Deployability,update,updated,167,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:284,Deployability,update,updated,284,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:355,Deployability,update,update,355,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:666,Deployability,update,update,666,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:265,Testability,log,logic,265,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:20,Performance,optimiz,optimized,20,/* Outlined code is optimized code by definition. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:21,Modifiability,variab,variables,21,// Don't add any new variables to the subprogram.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:50,Deployability,Update,Update,50,// Loop info metadata may contain line locations. Update them to have no; // value in the new subprogram since the outlined code could be from; // several locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:4,Testability,Test,Test,4,"/// Test whether \p CurrentExitFromRegion contains any PhiNodes that should be; /// considered outputs. A PHINodes is an output when more than one incoming; /// value has been marked by the CodeExtractor as an output.; ///; /// \param CurrentExitFromRegion [in] - The block to analyze.; /// \param PotentialExitsFromRegion [in] - The potential exit blocks from the; /// region.; /// \param RegionBlocks [in] - The basic blocks in the region.; /// \param Outputs [in, out] - The existing outputs for the region, we may add; /// PHINodes to this as we find that they replace output values.; /// \param OutputsReplacedByPHINode [out] - A set containing outputs that are; /// totally replaced by a PHINode.; /// \param OutputsWithNonPhiUses [out] - A set containing outputs that are used; /// in PHINodes, but have other uses, and should still be considered outputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:233,Security,hash,hash,233,"/// Encode \p PND as an integer for easy lookup based on the argument location,; /// the parent BasicBlock canonical numbering, and the canonical numbering of; /// the values stored in the PHINode.; ///; /// \param PND - The data to hash.; /// \returns The hash code of \p PND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:257,Security,hash,hash,257,"/// Encode \p PND as an integer for easy lookup based on the argument location,; /// the parent BasicBlock canonical numbering, and the canonical numbering of; /// the values stored in the PHINode.; ///; /// \param PND - The data to hash.; /// \returns The hash code of \p PND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:96,Security,hash,hash,96,"/// Create a special GVN for PHINodes that will be used outside of; /// the region. We create a hash code based on the Canonical number of the; /// parent BasicBlock, the canonical numbering of the values stored in the; /// PHINode and the aggregate argument location. This is used to find whether; /// this PHINode type has been given a canonical numbering already. If not, we; /// assign it a value and store it for later use. The value is returned to; /// identify different output schemes for the set of regions.; ///; /// \param Region - The region that \p PN is an output for.; /// \param PN - The PHINode we are analyzing.; /// \param Blocks - The blocks for the region we are analyzing.; /// \param AggArgIdx - The argument \p PN will be stored into.; /// \returns An optional holding the assigned canonical number, or std::nullopt; /// if there is some attribute of the PHINode blocking it from being used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:85,Security,hash,hash,85,// Find the incoming block and use the canonical numbering as well to define; // the hash for the PHINode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:179,Security,hash,hash,179,"// Now that we have the GVNs for the incoming values, we are going to combine; // them with the GVN of the incoming bock, and the output location of the; // PHINode to generate a hash value representing this instance of the PHINode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:9,Energy Efficiency,Adapt,Adapt,9,// TODO: Adapt to the extra input from the PHINode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:9,Modifiability,Adapt,Adapt,9,// TODO: Adapt to the extra input from the PHINode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:344,Integrability,depend,dependent,344,"// Values outside the region can be combined into PHINode when we; // have multiple exits. We collect both of these into a list to identify; // which values are being used in the PHINode. Each list identifies a; // different PHINode, and a different output. We store the PHINode as it's; // own canonical value. These canonical values are also dependent on the; // output argument it is saved to.; // If two PHINodes have the same canonical values, but different aggregate; // argument locations, then they will have distinct Canonical Values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:198,Usability,simpl,simply,198,"// If the arguments are the same size, there are not values that need to be; // made into an argument, the argument ordering has not been change, or; // different output registers to handle. We can simply replace the called; // function in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:87,Usability,simpl,simply,87,"// If we found the mapping from the extracted function to the overall; // function, we simply add it to the argument list. We use the same; // value, it just needs to honor the new order of arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:27,Usability,simpl,simply,27,"// If it is a constant, we simply add it to the argument list as a value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:39,Usability,simpl,simply,39,"// The argument is an input, so we can simply replace it with the overall; // argument value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:60,Performance,perform,performs,60,"/// It is possible that there is a basic block that already performs the same; /// stores. This returns a duplicate block, if it exists; ///; /// \param OutputBBs [in] the blocks we are looking for a duplicate of.; /// \param OutputStoreBBs [in] The existing output blocks.; /// \returns an optional value with the number output block if there is a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:77,Testability,stub,stub,77,// Move the return value to the final block instead of the original exit; // stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:24,Performance,load,load,24,"// Each output incurs a load after the call, so we add that to the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:53,Performance,load,loading,53,"// For each argument, we must add an instruction for loading the argument; // out of the register and into a value inside of the newly outlined function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:36,Performance,load,loaded,36,// Each argument needs to either be loaded into a register or onto the stack.; // Some arguments will only be loaded into the stack once the argument; // registers are filled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:110,Performance,load,loaded,110,// Each argument needs to either be loaded into a register or onto the stack.; // Some arguments will only be loaded into the stack once the argument; // registers are filled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:11,Performance,load,load,11,// For and load instructions following the call,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:111,Safety,avoid,avoid,111,// Creating OutlinableGroups for each SimilarityCandidate to be used in; // each of the following for loops to avoid making an allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:390,Integrability,wrap,wrapper,390,"//===- LoopExtractor.cpp - Extract each loop into a new function ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pass wrapper around the ExtractLoop() scalar transformation to extract each; // top-level loop into its own new function. If the loop is the ONLY loop in a; // given function, it is not touched. This is a pass most useful for debugging; // via bugpoint.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:105,Integrability,wrap,wrapper,105,"// If the loop is in LoopSimplify form, then extract it only if this function; // is more than a minimal wrapper around the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:31,Availability,avail,available,31,"// If LoopSimplify form is not available, stay out of trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:441,Testability,test,test,441,"//===- LowerTypeTests.cpp - type metadata lowering pass -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass lowers type metadata and calls to the llvm.type.test intrinsic.; // It also ensures that globals are properly laid out for the; // llvm.icall.branch.funnel intrinsic.; // See http://llvm.org/docs/TypeMetadata.html for more information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:157,Availability,mask,mask,157,"// Normalize each offset against the minimum observed offset, and compute; // the bitwise OR of each of the offsets. The number of trailing zeros; // in the mask gives us the log2 of the alignment of all offsets, which; // allows us to compress the bitset by only storing one bit per aligned; // address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:140,Deployability,update,update,140,"// This index belongs to an existing fragment. Copy the elements of the; // old fragment into this one and clear the old fragment. We don't update; // the fragment map just yet, this ensures that any further references to; // indices from the old fragment in this fragment do not insert any more; // indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:107,Usability,clear,clear,107,"// This index belongs to an existing fragment. Copy the elements of the; // old fragment into this one and clear the old fragment. We don't update; // the fragment map just yet, this ensures that any further references to; // indices from the old fragment in this fragment do not insert any more; // indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Deployability,Update,Update,3,// Update the fragment map to point our object indices to this fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:306,Energy Efficiency,reduce,reduce,306,"/// A POD-like structure that we use to store a global reference together with; /// its metadata types. In this pass we frequently need to query the set of; /// metadata types referenced by a global, which at the IR level is an expensive; /// operation involving a map lookup; this data structure helps to reduce the; /// number of times we need to do this lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:380,Modifiability,variab,variables,380,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:163,Safety,avoid,avoid,163,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:199,Safety,avoid,avoid,199,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:310,Safety,avoid,avoid,310,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:64,Testability,test,test,64,// Set when the client has invoked this to simply drop all type test assume; // sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:43,Usability,simpl,simply,43,// Set when the client has invoked this to simply drop all type test assume; // sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:9,Modifiability,variab,variable,9,// Cache variable used by hasBranchTargetEnforcement().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Performance,Cache,Cache,3,// Cache variable used by hasBranchTargetEnforcement().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:203,Deployability,pipeline,pipeline,203,"// Mapping from type identifiers to the call sites that test them, as well as; // whether the type identifier needs to be exported to ThinLTO backends as; // part of the regular LTO phase of the ThinLTO pipeline (see exportTypeId).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:56,Testability,test,test,56,"// Mapping from type identifiers to the call sites that test them, as well as; // whether the type identifier needs to be exported to ThinLTO backends as; // part of the regular LTO phase of the ThinLTO pipeline (see exportTypeId).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:47,Testability,test,tests,47,"/// This structure describes how to lower type tests for a particular type; /// identifier. It is either built directly from the global analysis (during; /// regular LTO or the regular LTO phase of ThinLTO), or indirectly using type; /// identifier summaries and external symbol references (in ThinLTO backends).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:33,Testability,test,test,33,/// ByteArray: the byte array to test the address against.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:23,Availability,mask,mask,23,/// ByteArray: the bit mask to apply to bytes loaded from the byte array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:46,Performance,load,loaded,46,/// ByteArray: the bit mask to apply to bytes loaded from the byte array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:20,Availability,mask,mask,20,/// Inline: the bit mask to test the address against.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:28,Testability,test,test,28,/// Inline: the bit mask to test the address against.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:91,Testability,test,testing,91,// Lower the module using the action and summary passed as command line; // arguments. For testing purposes only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:12,Testability,test,test,12,/// Build a test that bit BitOffset mod sizeof(Bits)*8 is set in; /// Bits. This pattern matches to the bt instruction on x86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:50,Availability,mask,masks,50,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:184,Availability,mask,mask,184,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:131,Energy Efficiency,allocate,allocateByteArrays,131,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:157,Testability,test,test,157,// Create an alias instead of RAUW'ing the gep directly. On x86 this ensures; // that the pc-relative displacement is folded into the lea instead of the; // test instruction getting another displacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:12,Testability,test,test,12,"/// Build a test that bit BitOffset is set in the type identifier that was; /// lowered to TIL, which must be either an Inline or a ByteArray.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:56,Performance,load,load,56,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:48,Safety,avoid,avoid,48,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:68,Testability,test,testing,68,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:162,Security,secur,security,162,"// Each use of the byte array uses a different alias. This makes the; // backend less likely to reuse previously computed byte array addresses,; // improving the security of the CFI mechanism based on this pass.; // This won't work when importing because TheByteArray is external.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:22,Testability,test,test,22,/// Lower a llvm.type.test call to its implementation. Returns the value to; /// replace the call with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:146,Performance,perform,performing,146,"// We need to check that the offset both falls within our range and is; // suitably aligned. We can check both properties at the same time by; // performing a right rotate by log2(alignment) followed by an integer; // comparison against the bitset size. The rotate will move the lower; // order bits that need to be zero into the higher order bits of the; // result, causing the comparison to fail if they are nonzero. The rotate; // also conveniently gives us a bit offset to use during the load from; // the bitset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:492,Performance,load,load,492,"// We need to check that the offset both falls within our range and is; // suitably aligned. We can check both properties at the same time by; // performing a right rotate by log2(alignment) followed by an integer; // comparison against the bitset size. The rotate will move the lower; // order bits that need to be zero into the higher order bits of the; // result, causing the comparison to fail if they are nonzero. The rotate; // also conveniently gives us a bit offset to use during the load from; // the bitset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:31,Testability,test,testing,31,"// If the bit set is all ones, testing against it is unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:82,Testability,test,test,82,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:152,Testability,test,test,152,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:196,Usability,simpl,simpler,196,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Deployability,Update,Update,3,// Update phis in Else resulting from InitialBB being split,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:61,Performance,load,load,61,"// Now that we know that the offset is in range and aligned, load the; // appropriate bit from the bitset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:127,Performance,load,loaded,127,"// The value we want is 0 if we came directly from the initial block; // (having failed the range or alignment checks), or the loaded bit if; // we came from the block in which we loaded it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:180,Performance,load,loaded,180,"// The value we want is 0 if we came directly from the initial block; // (having failed the range or alignment checks), or the loaded bit if; // we came from the block in which we loaded it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:127,Testability,test,test,127,"/// Given a disjoint set of type identifiers and globals, lay out the globals,; /// build the bit sets and lower the llvm.type.test calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:294,Energy Efficiency,power,power,294,// Build a new global with the combined contents of the referenced globals.; // This global is a struct whose even-indexed elements contain the original; // contents of the referenced globals and whose odd-indexed elements contain; // any padding required to align the next element to the next power of 2 plus; // any additional padding required to meet its alignment requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:192,Performance,perform,performance,192,// Experiments of different caps with Chromium on both x64 and ARM64; // have shown that the 32-byte cap generates the smallest binary on; // both platforms while different caps yield similar performance.; // (see https://lists.llvm.org/pipermail/llvm-dev/2018-July/124694.html),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:167,Testability,test,test,167,"/// Export the given type identifier so that ThinLTO backends may import it.; /// Type identifiers are exported by adding coarse-grained information about how; /// to test the type identifier to the summary, and creating symbols in the; /// object file (aliases and absolute symbols) containing fine-grained; /// information about the type identifier.; ///; /// Returns a pointer to the location in which to store the bitmask, if; /// applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:164,Performance,optimiz,optimizations,164,"// If this is a local unpromoted type, which doesn't have a metadata string,; // treat as Unknown and delay lowering, so that we can still utilize it for; // later optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:59,Deployability,update,update,59,// ThinLTO backend: the function F has a jump table entry; update this module; // accordingly. isJumpTableCanonical describes the type of the jump table entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:32,Testability,test,test,32,// Lower each call to llvm.type.test for this type identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:855,Energy Efficiency,power,power-of-two,855,"// In Armv6-M, this sequence will generate a branch without corrupting; // any registers. We use two stack words; in the second, we construct the; // address we'll pop into pc, and the first is used to save and restore; // r0 which we use as a temporary register.; //; // To support position-independent use cases, the offset of the target; // function is stored as a relative offset (which will expand into an; // R_ARM_REL32 relocation in ELF, and presumably the equivalent in other; // object file types), and added to pc after we load it. (The alternative; // B.W is automatically pc-relative.); //; // There are five 16-bit Thumb instructions here, so the .balign 4 adds a; // sixth halfword of padding, and then the offset consumes a further 4; // bytes, for a total of 16, which is very convenient since entries in; // this jump table need to have power-of-two size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:534,Performance,load,load,534,"// In Armv6-M, this sequence will generate a branch without corrupting; // any registers. We use two stack words; in the second, we construct the; // address we'll pop into pc, and the first is used to save and restore; // r0 which we use as a temporary register.; //; // To support position-independent use cases, the offset of the target; // function is stored as a relative offset (which will expand into an; // R_ARM_REL32 relocation in ELF, and presumably the equivalent in other; // object file types), and added to pc after we load it. (The alternative; // B.W is automatically pc-relative.); //; // There are five 16-bit Thumb instructions here, so the .balign 4 adds a; // sixth halfword of padding, and then the offset consumes a further 4; // bytes, for a total of 16, which is very convenient since entries in; // this jump table need to have power-of-two size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:133,Integrability,depend,dependently,133,"/// Given a disjoint set of type identifiers and functions, build the bit sets; /// and lower the llvm.type.test calls, architecture dependently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:108,Testability,test,test,108,"/// Given a disjoint set of type identifiers and functions, build the bit sets; /// and lower the llvm.type.test calls, architecture dependently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:29,Deployability,update,update,29,"// For phi nodes, we need to update the incoming value for all operands; // with the same predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:70,Testability,test,test,70,// Each jump table must be either ARM or Thumb as a whole for the bit-test math; // to work. Pick one that matches the majority of members to minimize interop; // veneers inserted by the linker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:7,Testability,stub,stubs,7,// PLT stubs are always ARM.; // FIXME: This is the wrong heuristic for non-canonical jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:88,Safety,safe,safely,88,"// Check if all entries have the NoUnwind attribute.; // If all entries have it, we can safely mark the; // cfi.jumptable as NoUnwind, otherwise, direct calls; // to the jump table will not handle exceptions properly",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:102,Safety,avoid,avoid,102,"// When -mbranch-protection= is used, the inline asm adds a BTI. Suppress BTI; // for the function to avoid double BTI. This is a no-op without; // -mbranch-protection=.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:103,Safety,avoid,avoid,103,"// When -fcf-protection= is used, the inline asm adds an ENDBR. Suppress ENDBR; // for the function to avoid double ENDBR. This is a no-op without; // -fcf-protection=.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:146,Testability,test,test,146,"/// Given a disjoint set of type identifiers and functions, build a jump table; /// for the functions, build the bit sets and lower the llvm.type.test calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:1842,Energy Efficiency,power,power,1842,"itset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find a better way to represent the jumptable in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:289,Integrability,depend,depend,289,"// Unlike the global bitset builder, the function bitset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:1929,Usability,simpl,simple,1929,"itset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find a better way to represent the jumptable in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:11,Usability,simpl,simple,11,// Build a simple layout based on the regular layout of jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:140,Testability,test,test,140,"/// Assign a dummy layout using an incrementing counter, tag each function; /// with its index represented as metadata, and lower each type test to an; /// integer range comparison. During generation of the indirect function call; /// table in the backend, it will assign the given indexes.; /// Note: Dynamic linking is not supported, as the WebAssembly ABI has not yet; /// been finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:49,Safety,avoid,avoid,49,"// Skip functions that are not address taken, to avoid bloating the table",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:19,Testability,test,tests,19,/// Lower all type tests in this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:103,Availability,error,errors,103,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:63,Testability,test,testing,63,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:24,Safety,avoid,avoid,24,// Save unique users to avoid processing operand replacement; // more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:60,Testability,test,test,60,// Find and erase llvm.assume intrinsics for this llvm.type.test call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:112,Usability,Simpl,Simply,112,"// If the assume was merged with another assume, we might have a use on a; // phi (which will feed the assume). Simply replace the use on the phi; // with ""true"" and leave the merged assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:124,Performance,perform,performing,124,"// Normally we'd have already removed all @llvm.public.type.test calls,; // except for in the case where we originally were performing ThinLTO but; // decided not to in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:60,Testability,test,test,60,"// Normally we'd have already removed all @llvm.public.type.test calls,; // except for in the case where we originally were performing ThinLTO but; // decided not to in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:231,Availability,error,error,231,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:63,Performance,perform,perform,63,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:140,Testability,test,tests,140,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:271,Usability,simpl,simply,271,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:74,Energy Efficiency,efficient,efficiently,74,// Verify the type metadata and build a few data structures to let us; // efficiently enumerate the type identifiers associated with a global:; // a list of GlobalTypeMembers (a GlobalObject stored alongside a vector; // of associated type metadata) and a mapping from type identifiers to their; // list of GlobalTypeMembers and last observed index in the list of globals.; // The indices will be used later to deterministically order the list of type; // identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Deployability,Update,Update,3,// Update the linkage for extern_weak declarations when a definition; // exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:126,Deployability,update,updated,126,"// TODO: The logic here checks only that the function is address taken,; // not that the address takers are live. This can be updated to check; // their liveness and emit fewer jumptable entries once monolithic LTO; // builds also emit summaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:13,Testability,log,logic,13,"// TODO: The logic here checks only that the function is address taken,; // not that the address takers are live. This can be updated to check; // their liveness and emit fewer jumptable entries once monolithic LTO; // builds also emit summaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:242,Modifiability,rewrite,rewrite,242,"// If this type test is only used by llvm.assume instructions, it; // was used for whole program devirtualization, and is being kept; // for use by other optimization passes. We do not need or want to; // lower it here. We also don't want to rewrite any associated globals; // unnecessarily. These will be removed by a subsequent LTT invocation; // with the DropTypeTests flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:154,Performance,optimiz,optimization,154,"// If this type test is only used by llvm.assume instructions, it; // was used for whole program devirtualization, and is being kept; // for use by other optimization passes. We do not need or want to; // lower it here. We also don't want to rewrite any associated globals; // unnecessarily. These will be removed by a subsequent LTT invocation; // with the DropTypeTests flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:16,Testability,test,test,16,"// If this type test is only used by llvm.assume instructions, it; // was used for whole program devirtualization, and is being kept; // for use by other optimization passes. We do not need or want to; // lower it here. We also don't want to rewrite any associated globals; // unnecessarily. These will be removed by a subsequent LTT invocation; // with the DropTypeTests flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:487,Performance,optimiz,optimization,487,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:670,Performance,perform,performed,670,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:864,Performance,perform,performed,864,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:687,Security,expose,expose,687,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:475,Usability,guid,guided,475,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:85,Integrability,interface,interfaces,85,// Indicate we are linking with an allocator that supports hot/cold operator; // new interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:362,Deployability,update,updated,362,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:761,Deployability,update,update,761,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:465,Performance,perform,performed,465,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:794,Performance,perform,performed,794,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:24,Performance,perform,perform,24,/// Main entry point to perform analysis and transformations on graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Performance,Perform,Perform,4,/// Perform cloning on the graph necessary to uniquely identify the allocation; /// behavior of an allocation based on its context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:112,Energy Efficiency,efficient,efficient,112,// Edges to all callees in the profiled call stacks.; // TODO: Should this be a map (from Callee node) for more efficient lookup?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:112,Energy Efficiency,efficient,efficient,112,// Edges to all callers in the profiled call stacks.; // TODO: Should this be a map (from Caller node) for more efficient lookup?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:162,Performance,perform,performed,162,"/// Matches all callsite metadata (or summary) to the nodes created for; /// allocation memprof MIB metadata, synthesizing new nodes to reflect any; /// inlining performed on those callsite instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Deployability,Update,Update,4,/// Update graph to conservatively handle any callsite stack nodes that target; /// multiple different callee target functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:316,Deployability,update,updateStackNodes,316,"/// Assigns the given Node to calls at or inlined into the location with; /// the Node's stack id, after post order traversing and processing its; /// caller nodes. Uses the call information recorded in the given; /// StackIdToMatchingCalls map, and creates new nodes for inlined sequences; /// as needed. Called by updateStackNodes which sets up the given; /// StackIdToMatchingCalls map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:103,Deployability,update,updates,103,"/// Connect the NewNode to OrigNode's callees if TowardsCallee is true,; /// else to its callers. Also updates OrigNode's edges to remove any context; /// ids moved to the newly created edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:346,Deployability,update,updated,346,"/// Returns true if the given call targets the callee of the given edge, or if; /// we were able to identify the call chain through intermediate tail calls.; /// In the latter case new context nodes are added to the graph for the; /// identified tail calls, and their synthesized nodes are added to; /// TailCallToContextNodeMap. The EdgeIter is updated in either case to the; /// next element after the input position (either incremented or updated after; /// removing the old edge).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:442,Deployability,update,updated,442,"/// Returns true if the given call targets the callee of the given edge, or if; /// we were able to identify the call chain through intermediate tail calls.; /// In the latter case new context nodes are added to the graph for the; /// identified tail calls, and their synthesized nodes are added to; /// TailCallToContextNodeMap. The EdgeIter is updated in either case to the; /// next element after the input position (either incremented or updated after; /// removing the old edge).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Deployability,Update,Update,4,/// Update the allocation call to record type of allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:49,Energy Efficiency,allocate,allocated,49,/// Update the allocation call to record type of allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Deployability,Update,Update,4,/// Update non-allocation call to invoke (possibly cloned) function; /// CalleeFunc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:128,Performance,optimiz,optimized,128,"/// Returns the alloction type of the intersection of the contexts of two; /// nodes (based on their provided context id sets), optimized for the case; /// when Node1Ids is smaller than Node2Ids.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:136,Deployability,update,updates,136,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:202,Deployability,update,updated,202,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:80,Performance,perform,performing,80,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:127,Deployability,update,updates,127,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:193,Deployability,update,updated,193,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:66,Performance,perform,performing,66,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:16,Performance,perform,perform,16,"/// Recursively perform cloning on the graph for the given Node and its; /// callers, in order to uniquely identify the allocation behavior of an; /// allocation given its context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Performance,Perform,Perform,4,/// Perform sanity checks on graph when requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:12,Safety,sanity check,sanity checks,12,/// Perform sanity checks on graph when requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:45,Safety,safe,safe,45,"// Now that we are done with the graph it is safe to add the new; // CallsiteInfo structs to the function summary vectors. The graph nodes; // point into locations within these vectors, so we don't want to add them; // any earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:24,Deployability,update,updated,24,// Alloc type should be updated as we add in the MIBs. We should assert; // afterwards that it is not still None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:65,Testability,assert,assert,65,// Alloc type should be updated as we add in the MIBs. We should assert; // afterwards that it is not still None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update alloc type and context ids for this MIB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:14,Deployability,update,update,14,// Now add or update nodes for each stack id in alloc's context.; // Later when processing the stack ids on non-alloc callsites we will adjust; // for any inlining in the context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:122,Safety,detect,detecting,122,"// Look for recursion (direct recursion should have been collapsed by; // module summary analysis, here we should just be detecting mutual; // recursion). Mark these nodes so we don't try to clone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:15,Deployability,update,update,15,// Recursively update context ids sets along caller edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:71,Deployability,update,update,71,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:124,Testability,log,logic,124,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:109,Usability,simpl,simplifies,109,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:133,Deployability,update,update,133,"// Remove any matching context ids from Edge, return set that were found and; // removed, these are the new edge's context ids. Also update the remaining; // (not found ids).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:42,Deployability,update,update,42,"// If this node's stack id is in the map, update the graph to contain new; // nodes representing any inlining at interior callsites. Note we move the; // associated context ids over to the new nodes.; // Ignore this node if it is for an allocation or we didn't record any; // stack id lists ending at it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:14,Usability,simpl,simple,14,"// Handle the simple case first. A single call with a single stack id.; // In this case there is no need to create any new context nodes, simply; // assign the context node for stack id to this Call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:138,Usability,simpl,simply,138,"// Handle the simple case first. A single call with a single stack id.; // In this case there is no need to create any new context nodes, simply; // assign the context node for stack id to this Call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,Deployability,update,updates,79,// Connect to callees of innermost stack frame in inlined call chain.; // This updates context ids for FirstNode's callee's to reflect those; // moved to NewNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,Deployability,update,updates,79,// Connect to callers of outermost stack frame in inlined call chain.; // This updates context ids for FirstNode's caller's to reflect those; // moved to NewNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:148,Performance,perform,performed,148,"// Map of stack id to all calls with that as the last (outermost caller); // callsite id that has a context node (some might not due to pruning; // performed during matching of the allocation profile contexts).; // The CallContextInfo contains the Call and a list of its stack ids with; // ContextNodes, the function containing Call, and the set of context ids; // the analysis will eventually identify for use in any new node created; // for that callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:243,Performance,Perform,Perform,243,"// First make a pass through all stack ids that correspond to a call,; // as identified in the above loop. Compute the context ids corresponding to; // each of these calls when they correspond to multiple stack ids due to; // due to inlining. Perform any duplication of context ids required when; // there is more than one call with the same stack ids. Their (possibly newly; // duplicated) context ids are saved in the StackIdToMatchingCalls map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update the context ids, which is the intersection of the ids along; // all edges in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:139,Modifiability,extend,extend,139,"// If some of this call's stack ids did not have corresponding nodes (due; // to pruning), don't include any context ids for contexts that extend; // beyond these nodes. Otherwise we would be matching part of unrelated /; // not fully matching stack contexts. To do this, subtract any context ids; // found in caller nodes of the last node found above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:391,Security,access,access,391,"// If we don't have duplicate context ids, then we can assign all the; // context ids computed for the original node sequence to this call.; // If there are duplicate calls with the same stack ids then we synthesize; // new context ids that are duplicates of the originals. These are; // assigned to SavedContextIds, which is a reference into the map entry; // for this call, allowing us to access these ids later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update saved last node's context ids to remove those that are; // assigned to other calls, so that it is ready for the next call at; // this stack id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:192,Deployability,update,update,192,"// Now perform a post-order traversal over the graph, starting with the; // allocation nodes, essentially processing nodes from callers to callees.; // For any that contains an id in the map, update the graph to contain new; // nodes representing any inlining at interior callsites. Note we move the; // associated context ids over to the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:7,Performance,perform,perform,7,"// Now perform a post-order traversal over the graph, starting with the; // allocation nodes, essentially processing nodes from callers to callees.; // For any that contains an id in the map, update the graph to contain new; // nodes representing any inlining at interior callsites. Note we move the; // associated context ids over to the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:283,Performance,optimiz,optimization,283,"// We should only add the prevailing nodes. Otherwise we may try to clone; // in a weak copy that won't be linked (and may be different than the; // prevailing version).; // We only keep the memprof summary on the prevailing copy now when; // building the combined index, as a space optimization, however don't; // rely on this optimization. The linker doesn't resolve local linkage; // values so don't check whether those are prevailing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:328,Performance,optimiz,optimization,328,"// We should only add the prevailing nodes. Otherwise we may try to clone; // in a weak copy that won't be linked (and may be different than the; // prevailing version).; // We only keep the memprof summary on the prevailing copy now when; // building the combined index, as a space optimization, however don't; // rely on this optimization. The linker doesn't resolve local linkage; // values so don't check whether those are prevailing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:244,Performance,perform,perform,244,"// Look for and workaround callsites that call multiple functions.; // This can happen for indirect calls, which needs better handling, and in; // more rare cases (e.g. macro expansion).; // TODO: To fix this for indirect calls we will want to perform speculative; // devirtualization using either the normal PGO info with ICP, or using the; // information in the profiled MemProf contexts. We can do this prior to; // this transformation for regular LTO, and for ThinLTO we can simulate that; // effect in the summary and perform the actual speculative devirtualization; // while cloning in the ThinLTO backend.; // Keep track of the new nodes synthesized for discovered tail calls missing; // from the profiled contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:523,Performance,perform,perform,523,"// Look for and workaround callsites that call multiple functions.; // This can happen for indirect calls, which needs better handling, and in; // more rare cases (e.g. macro expansion).; // TODO: To fix this for indirect calls we will want to perform speculative; // devirtualization using either the normal PGO info with ICP, or using the; // information in the profiled MemProf contexts. We can do this prior to; // this transformation for regular LTO, and for ThinLTO we can simulate that; // effect in the summary and perform the actual speculative devirtualization; // while cloning in the ThinLTO backend.; // Keep track of the new nodes synthesized for discovered tail calls missing; // from the profiled contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:122,Testability,assert,assert,122,"// Work around by setting Node to have a null call, so it gets; // skipped during cloning. Otherwise assignFunctions will assert; // because its data structures are not designed to handle this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:59,Deployability,update,update,59,"// If there is already an edge between these nodes, simply update it and; // return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:52,Usability,simpl,simply,52,"// If there is already an edge between these nodes, simply update it and; // return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:275,Performance,perform,perform,275,"// Look for tail calls in this function, and check if they either call the; // profiled callee directly, or indirectly (via a recursive search).; // Only succeed if there is a single unique tail call chain found between the; // profiled caller and callee, otherwise we could perform incorrect cloning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:47,Availability,avail,available,47,// StackIds is empty (we don't have debug info available in the index for; // these callsites),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:275,Performance,perform,perform,275,"// Look for tail calls in this function, and check if they either call the; // profiled callee directly, or indirectly (via a recursive search).; // Only succeed if there is a single unique tail call chain found between the; // profiled caller and callee, otherwise we could perform incorrect cloning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:17,Deployability,update,update,17,// Don't need to update Edge's context ids since we are simply reconnecting; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:56,Usability,simpl,simply,56,// Don't need to update Edge's context ids since we are simply reconnecting; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update context ids / alloc type on corresponding edge to NewCallee.; // There is a chance this may not exist if we are reusing an existing; // clone, specifically during function assignment, where we would have; // removed none type edges after creating the clone. If we can't find; // a corresponding edge there, fall through to the cloning below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:163,Usability,simpl,simply,163,// Don't clone if doing so will not disambiguate any alloc types amongst; // caller edges (including the callee edges that would be cloned).; // Otherwise we will simply move all edges to the clone.; //; // First check if by cloning we will disambiguate the caller allocation; // type from node's allocation type. Query allocTypeToUse so that we don't; // bother cloning to distinguish NotCold+Cold from NotCold. Note that; // neither of these should be None type.; //; // Then check if by cloning node at least one of the callee edges will be; // disambiguated by splitting out different context ids.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that no alloc types on clone or its edges are None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:43,Deployability,update,updateAllocationCall,43,"// We assign the allocation type later (in updateAllocationCall), just add; // an entry for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:40,Deployability,update,updateCall,40,"// We assign the clone number later (in updateCall), just add an entry for; // it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update caller node to call function version CalleeFunc, by recording the; // assignment in CallsiteToCalleeFuncCloneMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:232,Deployability,update,update,232,"// First locate which copy of OrigFunc to clone again. If a caller; // of this callsite clone was already assigned to call a particular; // function clone, we need to redirect all of those callers to the; // new function clone, and update their other callees within this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:143,Deployability,update,update,143,"// If no caller callsites were already assigned to a clone of this; // function, we can simply assign this clone to the new func clone; // and update all callers to it, then skip to the next clone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:88,Usability,simpl,simply,88,"// If no caller callsites were already assigned to a clone of this; // function, we can simply assign this clone to the new func clone; // and update all callers to it, then skip to the next clone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:64,Performance,perform,perform,64,// We subsequently fall through to later handling that; // will perform any additional cloning required for; // callers that were calling other function clones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:389,Deployability,update,update,389,"// If we are cloning a function that was already assigned to some; // callers, then essentially we are creating new callsite clones; // of the other callsites in that function that are reached by those; // callers. Clone the other callees of the current callsite's caller; // that were already assigned to PreviousAssignedFuncClone; // accordingly. This is important since we subsequently update the; // calls from the nodes in the graph and their assignments to callee; // functions recorded in CallsiteToCalleeFuncCloneMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update NewClone with the new Call clone of this callsite's Call; // created for the new function clone created earlier.; // Recall that we have already ensured when building the graph; // that each caller can only call callsites within the same; // function, so we are guaranteed that Callee Call is in the; // current OrigFunc.; // CallMap is set up as indexed by original Call at clone 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:37,Performance,perform,perform,37,// Fall through to handling below to perform the recording of the; // function for this callsite clone. This enables handling of cases; // where the callers were assigned to different clones of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:56,Availability,avail,available,56,"// First we need to confirm that this function clone is available; // for use by this callsite node clone.; //; // While FuncCloneToCurNodeCloneMap is built only for this Node and; // its callsite clones, one of those callsite clones X could have; // been assigned to the same function clone called by Edge's caller; // - if Edge's caller calls another callsite within Node's original; // function, and that callsite has another caller reaching clone X.; // We need to clone Node again in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Detect,Detect,3,"// Detect when we have multiple callers of this callsite that; // have already been assigned to specific, and different, clones; // of OrigFunc (due to other unrelated callsites in Func they; // reach via call contexts). Is this Clone of callsite Node; // assigned to a different clone of OrigFunc? If so, clone Node; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:129,Availability,avail,available,129,// Find first function in FuncClonesToCallMap without an assigned; // clone of this callsite Node. We should always have one; // available at this point due to the earlier cloning when the; // FuncClonesToCallMap size was smaller than the clone number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update callers to record function version called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:29,Deployability,update,update,29,"// Skip if either no call to update, or if we ended up with no context ids; // (we moved all edges onto other clones).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:60,Deployability,update,update,60,"// Performs DFS traversal starting from allocation nodes to update calls to; // reflect cloning decisions recorded earlier. For regular LTO this will; // update the actual calls in the IR to call the appropriate function clone; // (and add attributes to allocation calls), whereas for ThinLTO the decisions; // are recorded in the summary entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:154,Deployability,update,update,154,"// Performs DFS traversal starting from allocation nodes to update calls to; // reflect cloning decisions recorded earlier. For regular LTO this will; // update the actual calls in the IR to call the appropriate function clone; // (and add attributes to allocation calls), whereas for ThinLTO the decisions; // are recorded in the summary entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Performance,Perform,Performs,3,"// Performs DFS traversal starting from allocation nodes to update calls to; // reflect cloning decisions recorded earlier. For regular LTO this will; // update the actual calls in the IR to call the appropriate function clone; // (and add attributes to allocation calls), whereas for ThinLTO the decisions; // are recorded in the summary entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:47,Usability,GUID,GUID,47,"// FIXME: Ideally we would retain the original GUID in some fashion on the; // function (e.g. as metadata), but for now do our best to locate the; // summary without that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:90,Safety,avoid,avoids,90,"// See if theFn was internalized, by checking index directly with; // original name (this avoids the name adjustment done by getGUID() for; // internal symbols).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:61,Performance,perform,performed,61,// Now query with the original name before any promotion was performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,Availability,down,down,79,"// Could be a promoted local imported from another module. We need to pass; // down more info here to find the original module id. For now, try with; // the OrigName which might have been stored in the OidGuidMap in the; // index. This would not work if there were same-named locals in multiple; // modules, however.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:17,Performance,perform,performed,17,"// If we already performed cloning of this function, confirm that the; // requested number of clones matches (the thin link should ensure the; // number of clones for each constituent callsite is consistent within; // each function), before returning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Performance,Perform,Perform,3,// Perform cloning if not yet done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update the calls per the summary info.; // Save orig name since it gets updated in the first iteration; // below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:75,Deployability,update,updated,75,// Update the calls per the summary info.; // Save orig name since it gets updated in the first iteration; // below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that the MIB stack ids match between the summary and; // instruction metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:34,Usability,simpl,simply,34,"// If this is a direct recursion, simply skip the duplicate; // entries, to be consistent with how the summary ids were; // generated during ModuleSummaryAnalysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Performance,Perform,Perform,3,// Perform cloning if not yet done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update the allocation types per the summary info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that the stack ids match between the summary and; // instruction metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:456,Integrability,depend,dependences,456,"// TODO: If/when other types of memprof cloning are enabled beyond just for; // hot and cold, we will need to change this to individually control the; // AllocationType passed to addStackNodesForMIB during CCG construction.; // Note that we specifically check this after applying imports above, so that; // the option isn't needed to be passed to distributed ThinLTO backend; // clang processes, which won't necessarily have visibility into the linker; // dependences. Instead the information is communicated from the LTO link to; // the backends via the combined summary index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:166,Deployability,pipeline,pipeline,166,"// The MemProfImportSummary should only be used for testing ThinLTO; // distributed backend handling via opt, in which case we don't have a; // summary from the pass pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:52,Testability,test,testing,52,"// The MemProfImportSummary should only be used for testing ThinLTO; // distributed backend handling via opt, in which case we don't have a; // summary from the pass pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1112,Performance,perform,perform,1112,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for equivalent functions that are mergable and folds them.; //; // Order relation is defined on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave tw",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1430,Performance,optimiz,optimization,1430,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3514,Safety,detect,detect,3514," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1446,Security,hash,hash,1446,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1560,Security,hash,hash,1560,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1571,Security,hash,hash,1571,"unction is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1693,Security,hash,hash,1693,"unction is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1704,Security,hash,hash,1704,"unction is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1839,Security,hash,hash,1839," and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1403,Testability,log,log,1403,"--------------------------===//; //; // This pass looks for equivalent functions that are mergable and folds them.; //; // Order relation is defined on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual fu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3448,Testability,test,test-suite,3448," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:2818,Usability,learn,learn,2818," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3291,Usability,Simpl,Simplest,3291," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:12,Security,hash,hash,12,"// Note the hash is recalculated potentially multiple times, but it is cheap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:18,Security,hash,hashes,18,"// Order first by hashes, then full function comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:11,Performance,queue,queue,11,/// A work queue of functions that may have been modified and should be; /// analyzed again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:42,Performance,queue,queue,42,/// Remove a Function from the FnTree and queue it up for a second sweep of; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:80,Performance,queue,queue,80,/// Find the functions that use this Value and remove them from FnTree and; /// queue the functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:21,Usability,simpl,simple,21,"/// Replace G with a simple tail call to bitcast(F). Also (unless; /// MergeFunctionsPDI holds) replace direct uses of G with bitcast(F),; /// delete G.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:111,Energy Efficiency,efficient,efficient,111,/// The set of all distinct functions. Use the insert() and remove() methods; /// to modify it. The map allows efficient lookup and deferring of Functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:106,Deployability,update,updated,106,"// Map functions to the iterators of the FunctionNode which contains them; // in the FnTree. This must be updated carefully whenever the FnTree is; // modified, i.e. in insert(), remove(), and replaceFunctionInTree(), to avoid; // dangling iterators into FnTree. The invariant that preserves this is that; // there is exactly one mapping F -> FN for each FunctionNode FN in FnTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:221,Safety,avoid,avoid,221,"// Map functions to the iterators of the FunctionNode which contains them; // in the FnTree. This must be updated carefully whenever the FnTree is; // modified, i.e. in insert(), remove(), and replaceFunctionInTree(), to avoid; // dangling iterators into FnTree. The invariant that preserves this is that; // there is exactly one mapping F -> FN for each FunctionNode FN in FnTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:48,Availability,failure,failure,48,"// If F1 <= F2, then F2 >= F1, otherwise report failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:43,Security,hash,hash,43,"// All functions in the module, ordered by hash. Functions with a unique; // hash value are easily eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:77,Security,hash,hash,77,"// All functions in the module, ordered by hash. Functions with a unique; // hash value are easily eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:10,Security,hash,hash,10,"// If the hash value matches the previous value or the next one, we must; // consider merging it. Otherwise it is dropped and never considered again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:78,Usability,simpl,simpler,78,"// Helper for writeThunk,; // Selects proper bitcast operation,; // but a bit simpler then CastInst::getCastOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce G to its entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:20,Usability,simpl,simple,20,"// Replace G with a simple tail call to bitcast(F). Also (unless; // MergeFunctionsPDI holds) replace direct uses of G with bitcast(F),; // delete G. Under MergeFunctionsPDI, we use G itself for creating; // the thunk as we preserve the debug info (and associated instructions); // from G's entry block pertaining to G's incoming arguments which are; // passed on as corresponding arguments in the call that G makes to F.; // For better debugability, under MergeFunctionsPDI, we do not modify G's; // call sites to point to F even when within the same translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:88,Testability,test,test,88,"// It should still be possible to run the inliner as a stand-alone module; // pass, for test scenarios. In that case, we default to the; // DefaultInlineAdvisor, which doesn't need to keep state between module; // pass runs. It also uses just the default InlineParams. In this case, we; // need to use the provided FAM, which is valid for the duration of the; // inliner pass, and thus the lifetime of the owned advisor. The one we; // would get from the MAM can be invalidated as a result of the inliner's; // activity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:512,Modifiability,refactor,refactoring,512,"// In the module inliner, a priority-based worklist is used for calls across; // the entire Module. With this module inliner, the inline order is not; // limited to bottom-up order. More globally scope inline order is enabled.; // Also, the inline deferral logic become unnecessary in this module inliner.; // It is possible to use other priority heuristics, e.g. profile-based; // heuristic.; //; // TODO: Here is a huge amount duplicate code between the module inliner and; // the SCC inliner, which need some refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:257,Testability,log,logic,257,"// In the module inliner, a priority-based worklist is used for calls across; // the entire Module. With this module inliner, the inline order is not; // limited to bottom-up order. More globally scope inline order is enabled.; // Also, the inline deferral logic become unnecessary in this module inliner.; // It is possible to use other priority heuristics, e.g. profile-based; // heuristic.; //; // TODO: Here is a huge amount duplicate code between the module inliner and; // the SCC inliner, which need some refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:147,Safety,avoid,avoid,147,"// When inlining a callee produces new call sites, we want to keep track of; // the fact that they were inlined from the callee. This allows us to avoid; // infinite inlining in some obscure cases. To represent this, we use an; // index into the InlineHistory vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:144,Deployability,update,updates,144,// Track the dead functions to delete once finished with inlining calls. We; // defer deleting these to make it easier to handle the call graph updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:86,Integrability,rout,routine,86,// Setup the data structure used to plumb customization into the; // `InlineFunction` routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:153,Energy Efficiency,reduce,reduce,153,"// For local functions, check whether this makes the callee trivially; // dead. In that case, we can drop the body of the function eagerly; // which may reduce the number of callers of other functions to one,; // changing inline cost thresholds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:131,Availability,error,error,131,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:22,Performance,queue,queue,22,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:3,Usability,Clear,Clear,3,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:17,Performance,cache,cached,17,// Clear out any cached analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:3,Usability,Clear,Clear,3,// Clear out any cached analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:58,Performance,optimiz,optimizations,58,"//===-- IPO/OpenMPOpt.cpp - Collection of OpenMP specific optimizations ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // OpenMP specific optimizations:; //; // - Deduplication of runtime calls, e.g., omp_get_thread_num.; // - Replacing globalized device memory with stack memory.; // - Replacing globalized device memory with shared memory.; // - Parallel region merging.; // - Transforming generic-mode device kernels to SPMD mode.; // - Specializing the state machine for generic-mode device kernels.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:399,Performance,optimiz,optimizations,399,"//===-- IPO/OpenMPOpt.cpp - Collection of OpenMP specific optimizations ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // OpenMP specific optimizations:; //; // - Deduplication of runtime calls, e.g., omp_get_thread_num.; // - Replacing globalized device memory with stack memory.; // - Replacing globalized device memory with shared memory.; // - Parallel region merging.; // - Transforming generic-mode device kernels to SPMD mode.; // - Specializing the state machine for generic-mode device kernels.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Deployability,Configurat,ConfigurationEnvironmentTy,10,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:368,Deployability,Configurat,ConfigurationEnvironmentTy,368,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:395,Deployability,Configurat,Configuration,395,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Modifiability,Config,ConfigurationEnvironmentTy,10,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:368,Modifiability,Config,ConfigurationEnvironmentTy,368,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:395,Modifiability,Config,Configuration,395,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:59,Modifiability,variab,variable,59,/// Generic information that describes an internal control variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Modifiability,variab,variable,16,/// Environment variable associated with this ICV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Availability,avail,available,23,/// The declaration if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Usability,Clear,Clear,4,/// Clear UsesMap for runtime function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:46,Modifiability,variab,variable,46,/// Helper to initialize all internal control variable information for those; /// defined in OMPKinds.def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:22,Modifiability,inherit,inherit,22,// Helper function to inherit the calling convention of the function callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:89,Safety,abort,abort,89,"/// The __kmpc_target_init call in this kernel, if any. If we find more than; /// one we abort as the kernel is malformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:91,Safety,abort,abort,91,"/// The __kmpc_target_deinit call in this kernel, if any. If we find more than; /// one we abort as the kernel is malformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:19,Integrability,interface,interface,19,/// Abstract State interface; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:19,Performance,optimiz,optimizations,19,/// Run all OpenMP optimizations on the underlying SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:33,Testability,test,testing,33,/// Print initial ICV values for testing.; /// FIXME: This should be done from the Attributor once it is added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:33,Testability,test,testing,33,/// Print OpenMP GPU kernels for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:38,Safety,safe,safe,38,/// Merge parallel regions when it is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:133,Integrability,synchroniz,synchronization,133,"/// Create a sequential execution region within a merged parallel region,; /// encapsulated in a master construct with a barrier for synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:52,Deployability,update,update,52,// Emit a store instruction in the sequential BB to update the; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Performance,load,load,10,// Emit a load instruction and replace the use of the output value; // with it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:146,Availability,redundant,redundantly,146,// Helper to merge the __kmpc_fork_call calls in MergableCIs. They are all; // contained in BB and only separated by instructions that can be; // redundantly executed in parallel. The block BB is split before the first; // call (in MergableCIs) and after the last so the entire region we merge; // into a single parallel region is contained in a single basic block; // without any other instructions. We use the OpenMPIRBuilder to outline; // that block and call the resulting function via __kmpc_fork_call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:146,Safety,redund,redundantly,146,// Helper to merge the __kmpc_fork_call calls in MergableCIs. They are all; // contained in BB and only separated by instructions that can be; // redundantly executed in parallel. The block BB is split before the first; // call (in MergableCIs) and after the last so the entire region we merge; // into a single parallel region is contained in a single basic block; // without any other instructions. We use the OpenMPIRBuilder to outline; // that block and call the resulting function via __kmpc_fork_call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:20,Integrability,interface,interface,20,"// TODO: Change the interface to allow single CIs expanded, e.g, to; // include an outer loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:71,Safety,avoid,avoid,71,"// Create the merged parallel region with default proc binding, to; // avoid overriding binding settings, and without explicit cancellation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Performance,Perform,Perform,3,// Perform the actual outlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:68,Safety,safe,safe,68,"// Find mergable parallel regions within a basic block that are; // safe to merge, that is any in-between instructions can safely; // execute in parallel after merging.; // TODO: support merging across basic-blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:123,Safety,safe,safely,123,"// Find mergable parallel regions within a basic block that are; // safe to merge, that is any in-between instructions can safely; // execute in parallel after merging.; // TODO: support merging across basic-blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:277,Safety,detect,detect,277,// Return false (unmergable) if the call before the parallel; // region calls an explicit affinity (proc_bind) or number of; // threads (num_threads) compiler-generated function. Those settings; // may be incompatible with following parallel regions.; // TODO: ICV tracking to detect compatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:55,Safety,safe,safe,55,// Find maximal number of parallel region CIs that are safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:125,Performance,optimiz,optimized,125,// The RPC client symbol is defined in `libc` and indicates that something; // required an RPC server. If its users were all optimized out then we can; // safely remove it.; // TODO: This should be somewhere more common in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:155,Safety,safe,safely,155,// The RPC client symbol is defined in `libc` and indicates that something; // required an RPC server. If its users were all optimized out then we can; // safely remove it.; // TODO: This should be somewhere more common in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:235,Availability,down,downards,235,"/// Tries to hide the latency of runtime calls that involve host to; /// device memory transfers by splitting them into their ""issue"" and ""wait""; /// versions. The ""issue"" is moved upwards as much as possible. The ""wait"" is; /// moved downards as much as possible. The ""issue"" issues the memory transfer; /// asynchronously, returning a handle. The ""wait"" waits in the returned; /// handle for the memory transfer to finish.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:22,Performance,latency,latency,22,"/// Tries to hide the latency of runtime calls that involve host to; /// device memory transfers by splitting them into their ""issue"" and ""wait""; /// versions. The ""issue"" is moved upwards as much as possible. The ""wait"" is; /// moved downards as much as possible. The ""issue"" issues the memory transfer; /// asynchronously, returning a handle. The ""wait"" waits in the returned; /// handle for the memory transfer to finish.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:255,Energy Efficiency,allocate,allocate,255,"// A runtime call that involves memory offloading looks something like:; // call void @__tgt_target_data_begin_mapper(arg0, arg1,; // i8** %offload_baseptrs, i8** %offload_ptrs, i64* %offload_sizes,; // ...); // So, the idea is to access the allocas that allocate space for these; // offload arrays, offload_baseptrs, offload_ptrs, offload_sizes.; // Therefore:; // i8** %offload_baseptrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:231,Security,access,access,231,"// A runtime call that involves memory offloading looks something like:; // call void @__tgt_target_data_begin_mapper(arg0, arg1,; // i8** %offload_baseptrs, i8** %offload_ptrs, i64* %offload_sizes,; // ...); // So, the idea is to access the allocas that allocate space for these; // offload arrays, offload_baseptrs, offload_ptrs, offload_sizes.; // Therefore:; // i8** %offload_baseptrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:226,Availability,avail,available,226,/// Prints the values in the OffloadArrays \p OAs using LLVM_DEBUG.; /// For now this is a way to test that the function getValuesInOffloadArrays; /// is working properly.; /// TODO: Move this to a unittest when unittests are available for OpenMPOpt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:98,Testability,test,test,98,/// Prints the values in the OffloadArrays \p OAs using LLVM_DEBUG.; /// For now this is a way to test that the function getValuesInOffloadArrays; /// is working properly.; /// TODO: Move this to a unittest when unittests are available for OpenMPOpt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:17,Safety,detect,detect,17,// TODO: Once we detect the regions to be offloaded we should use the; // alias analysis manager to check if CurrentI may modify one of; // the offloaded regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Energy Efficiency,allocate,allocated,16,"// Create stack allocated handle (__tgt_async_info) at the beginning of the; // function. Used for storing information of the async transfer, allowing to; // wait on it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:28,Performance,perform,perform,28,// TODO: Below we basically perform a fixpoint iteration with a pessimistic; // initialization. We could define an AbstractAttribute instead and; // run the Attributor here once it can be run as an SCC pass.; // Helper to check the argument \p ArgNo at all call sites of \p F for; // a GTId.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:140,Modifiability,extend,extended,140,// Transitively search for more arguments by looking at the users of the; // ones we know already. During the search the GTIdArgs vector is extended; // so we cannot cache the size nor can we use a range based for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:166,Performance,cache,cache,166,// Transitively search for more arguments by looking at the users of the; // ones we know already. During the search the GTIdArgs vector is extended; // so we cannot cache the size nor can we use a range based for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:18,Performance,optimiz,optimizations,18,/// Kernel (=GPU) optimizations and utility functions; ///; ///{{; /// Cache to remember the unique kernel for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:71,Performance,Cache,Cache,71,/// Kernel (=GPU) optimizations and utility functions; ///; ///{{; /// Cache to remember the unique kernel for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite the device (=GPU) code state machine create in non-SPMD mode in; /// the cases we can avoid taking the address of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:98,Safety,avoid,avoid,98,/// Rewrite the device (=GPU) code state machine create in non-SPMD mode in; /// the cases we can avoid taking the address of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:176,Performance,Optimiz,OptimizationRemark,176,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:220,Performance,optimiz,optimization,220,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:248,Performance,Optimiz,OptimizationRemarkMissed,248,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:292,Performance,optimiz,optimization,292,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:320,Performance,Optimiz,OptimizationRemarkAnalysis,320,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:395,Performance,optimiz,optimization,395,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Deployability,update,update,16,"/// Callback to update the call graph, the first argument is a removed call,; /// the second an optional replacement call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Performance,Optimiz,OptimizationRemarkEmitter,23,/// Callback to get an OptimizationRemarkEmitter from a Function *,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:32,Performance,cache,cache,32,/// OpenMP-specific information cache. Also Used for Attributor runs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:43,Performance,Cache,CachedKernel,43,// Use a scope to keep the lifetime of the CachedKernel short.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:149,Energy Efficiency,power,powerful,149,"// TODO: We should use an AA to create an (optimistic and callback; // call-aware) call graph. For now we stick to simple patterns that; // are less powerful, basically the worst fixpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:115,Usability,simpl,simple,115,"// TODO: We should use an AA to create an (optimistic and callback; // call-aware) call graph. For now we stick to simple patterns that; // are less powerful, basically the worst fixpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:39,Performance,Optimiz,OptimizationRemarks,39,// See https://openmp.llvm.org/remarks/OptimizationRemarks.html,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Performance,Cache,Cache,3,// Cache the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:8,Integrability,wrap,wrapper,8,// Find wrapper functions that represent parallel kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:131,Usability,clear,clear,131,"/// Return an assumed unique ICV value if a single candidate is found. If; /// there cannot be one, return a nullptr. If it is not clear yet, return; /// std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:30,Safety,avoid,avoid,30,/// TODO: Figure out a way to avoid adding entry in; /// ICVReplacementValuesMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:103,Safety,avoid,avoid,103,// If we actually eliminated a barrier we need to eliminate the associated; // llvm.assumes as well to avoid creating UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Integrability,interface,interface,10,"/// Query interface, see AAExecutionDomain; ///{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:65,Safety,detect,detection,65,// Delayed decision on the forward pass to allow aligned barrier detection; // in the backwards traversal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Deployability,update,update,10,"// First, update the barrier ED kept in the separate CEDMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,Update,3,// Update the state with the new value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,Update,3,// Update free call users of found malloc calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:41,Usability,simpl,simple,41,"/// The callee value is tracked beyond a simple stripPointerCasts, so we allow; /// unknown callees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:157,Safety,avoid,avoid,157,// This is a high-level transform that might change the constant arguments; // of the init and dinit calls. We need to tell the Attributor about this; // to avoid other parts using the current constant value for simpliication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:212,Usability,simpl,simpliication,212,// This is a high-level transform that might change the constant arguments; // of the init and dinit calls. We need to tell the Attributor about this; // to avoid other parts using the current constant value for simpliication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:18,Performance,perform,perform,18,"// For kernels we perform more initialization work, first we find the init; // and deinit calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:30,Deployability,update,updates,30,// Add a dependence to ensure updates if the state changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:9,Integrability,depend,dependence,9,// Add a dependence to ensure updates if the state changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:26,Modifiability,rewrite,rewrite,26,// Not needed if we can't rewrite due to an invalid state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Performance,perform,perform,16,// If we do not perform SPMDzation we do not need the virtual uses below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:15,Performance,perform,perform,15,// Whenever we perform SPMDzation we will insert; // __kmpc_get_hardware_thread_id_in_block calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:15,Performance,perform,perform,15,"// Whenever we perform SPMDzation with guarding we will insert; // __kmpc_simple_barrier_spmd calls. If SPMDzation failed, there is; // nothing to guard, or there are no parallel regions, we don't need; // the calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Security,Sanitiz,Sanitize,4,/// Sanitize the string \p S such that it is a suitable global symbol name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:12,Deployability,update,update,12,"// At last, update the KernelEnvc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:458,Performance,load,load,458,// Create all the blocks and logic.; // ParentBB:; // goto RegionCheckTidBB; // RegionCheckTidBB:; // Tid = __kmpc_hardware_thread_id(); // if (Tid != 0); // goto RegionBarrierBB; // RegionStartBB:; // <execute instructions guarded>; // goto RegionEndBB; // RegionEndBB:; // <store escaping values to shared mem>; // goto RegionBarrierBB; // RegionBarrierBB:; // __kmpc_simple_barrier_spmd(); // // second barrier is omitted if lacking escaping values.; // <load escaping values from shared mem>; // __kmpc_simple_barrier_spmd(); // goto RegionExitBB; // RegionExitBB:; // <execute rest of instructions>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:29,Testability,log,logic,29,// Create all the blocks and logic.; // ParentBB:; // goto RegionCheckTidBB; // RegionCheckTidBB:; // Tid = __kmpc_hardware_thread_id(); // if (Tid != 0); // goto RegionBarrierBB; // RegionStartBB:; // <execute instructions guarded>; // goto RegionEndBB; // RegionEndBB:; // <store escaping values to shared mem>; // goto RegionBarrierBB; // RegionBarrierBB:; // __kmpc_simple_barrier_spmd(); // // second barrier is omitted if lacking escaping values.; // <load escaping values from shared mem>; // __kmpc_simple_barrier_spmd(); // goto RegionExitBB; // RegionExitBB:; // <execute rest of instructions>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:17,Modifiability,variab,variable,17,// Emit a global variable in shared memory to store the broadcasted; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:31,Deployability,update,update,31,// Emit a store instruction to update the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Performance,load,load,10,// Emit a load instruction and replace uses of the output value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:62,Deployability,update,updated,62,"// First barrier for synchronization, ensures main thread has updated; // values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:21,Integrability,synchroniz,synchronization,21,"// First barrier for synchronization, ensures main thread has updated; // values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:40,Deployability,update,update,40,// If instruction I needs to be guarded update the guarded region; // bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:65,Availability,avail,availible,65,// We cannot change to SPMD mode if the runtime functions aren't availible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:89,Integrability,wrap,wrapper,89,"// Get the actual kernel, could be the caller of the anchor scope if we have; // a debug wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:37,Modifiability,rewrite,rewrites,37,"// If we have disabled state machine rewrites, don't make a custom one",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:9,Modifiability,rewrite,rewrite,9,// Don't rewrite the state machine if we are not in a valid state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:24,Deployability,configurat,configuration,24,// Check if the current configuration is non-SPMD and generic state machine.; // If we already have SPMD mode or a custom state machine we do not need to; // go any further. If it is anything but a constant something is weird and; // we give up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:24,Modifiability,config,configuration,24,// Check if the current configuration is non-SPMD and generic state machine.; // If we already have SPMD mode or a custom state machine we do not need to; // go any further. If it is anything but a constant something is weird and; // we give up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:92,Usability,simpl,simply,92,"// If we don't actually need a state machine we are done here. This can; // happen if there simply are no parallel regions. In the resulting kernel; // all worker threads will simply exit right away, leaving the main thread; // to do the work alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:176,Usability,simpl,simply,176,"// If we don't actually need a state machine we are done here. This can; // happen if there simply are no parallel regions. In the resulting kernel; // all worker threads will simply exit right away, leaving the main thread; // to do the work alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Deployability,update,update,23,/// Fixpoint iteration update function. Will be called every time a dependence; /// changed its state (and in the beginning).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:68,Integrability,depend,dependence,68,/// Fixpoint iteration update function. Will be called every time a dependence; /// changed its state (and in the beginning).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:85,Deployability,update,updated,85,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:102,Integrability,depend,depending,102,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:154,Usability,simpl,simplification,154,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Deployability,Update,Update,4,/// Update info regarding reaching kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Deployability,Update,Update,4,/// Update info regarding parallel levels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:119,Deployability,update,updated,119,"// Any function that is called by `__kmpc_parallel_51` will not be; // folded as the parallel level in the function is updated. In order to; // get it right, all the analysis would depend on the implentation. That; // said, if in the future any change to the implementation, the analysis; // could be wrong. As a consequence, we are just conservative here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:181,Integrability,depend,depend,181,"// Any function that is called by `__kmpc_parallel_51` will not be; // folded as the parallel level in the function is updated. In order to; // get it right, all the analysis would depend on the implentation. That; // said, if in the future any change to the implementation, the analysis; // could be wrong. As a consequence, we are just conservative here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:150,Usability,simpl,simply,150,"/// The call site kernel info abstract attribute, basically, what can we say; /// about a call site with regards to the KernelInfoState. For now this simply; /// forwards the information from the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:287,Deployability,update,updateImpl,287,"// Next we check if we know the callee. If it is a known OpenMP function; // we will handle them explicitly in the switch below. If it is not, we; // will use an AAKernelInfo object on the callee to gather information and; // merge that into the current state. The latter happens in the updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:11,Deployability,update,updated,11,"// We have updated the state for this unknown call properly, there; // won't be any change so we indicate a fixpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:58,Deployability,update,update,58,"// If the callee is known and can be used in IPO, we will update the; // state based on the callee state in updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:108,Deployability,update,updateImpl,108,"// If the callee is known and can be used in IPO, we will update the; // state based on the callee state in updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:13,Energy Efficiency,schedul,schedule,13,// Check the schedule and allow static schedule in SPMD mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:39,Energy Efficiency,schedul,schedule,39,// Check the schedule and allow static schedule in SPMD mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:56,Deployability,update,updateImpl,56,"// Return without setting a fixpoint, to be resolved in updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:214,Deployability,update,update,214,// All other OpenMP runtime calls will not reach parallel regions so they; // can be safely ignored for now. Since it is a known OpenMP runtime call; // we have now modeled all effects and there is no need for any update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:85,Safety,safe,safely,85,// All other OpenMP runtime calls will not reach parallel regions so they; // can be safely ignored for now. Since it is a known OpenMP runtime call; // we have now modeled all effects and there is no need for any update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:32,Energy Efficiency,allocate,allocates,32,"// F is a runtime function that allocates or frees memory, check; // AAHeapToStack and AAHeapToShared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:42,Deployability,Update,Update,42,// All reaching kernels are in SPMD mode. Update all function calls to; // __kmpc_is_spmd_exec_mode to 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:46,Deployability,Update,Update,46,// All reaching kernels are in non-SPMD mode. Update all function; // calls to __kmpc_is_spmd_exec_mode to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:123,Usability,Simpl,SimplifiedValue,123,"// We have empty reaching kernels, therefore we cannot tell if the; // associated call site can be folded. At this moment, SimplifiedValue; // must be none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:158,Usability,simpl,simplified,158,"/// An optional value the associated value is assumed to fold to. That is, we; /// assume the associated value (which is a call) can be replaced by this; /// simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,UpdateAfterInit,3,/* UpdateAfterInit */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:77,Deployability,update,update,77,// Ensure we create the AAKernelInfo AAs first and without triggering an; // update. This will make sure we register all value simplification; // callbacks before any other AA has the chance to create an AAValueSimplify; // or similar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:127,Usability,simpl,simplification,127,// Ensure we create the AAKernelInfo AAs first and without triggering an; // update. This will make sure we register all value simplification; // callbacks before any other AA has the chance to create an AAValueSimplify; // or similar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,UpdateAfterInit,3,/* UpdateAfterInit */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:61,Performance,perform,performance,61,// Optionally inline device functions for potentially better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:393,Performance,perform,performs,393,"//===- PartialInlining.cpp - Inline parts of functions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs partial inlining, typically by inlining an if statement; // that surrounds the body of the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:68,Modifiability,variab,variables,68,// Command line option to force outlining in regions with live exit variables.; // The default is false:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:29,Testability,test,testing,29,// This is an option used by testing:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:173,Energy Efficiency,reduce,reduces,173,// Used to determine if a cold region is worth outlining based on; // its inlining cost compared to the original function. Default is set at 10%.; // ie. if the cold region reduces the inlining cost of the original function by; // at least 10%.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:11,Performance,tune,tune,11,// Used to tune the minimum number of execution counts needed in the predecessor; // block to the cold edge. ie. confidence interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:282,Deployability,update,update,282,"// Do function outlining for region after early return block(s).; // NOTE: For vararg functions that do the vararg handling in the outlined; // function, we temporarily generate IR that does not properly; // forward varargs to the outlined function. Calling InlineFunction; // will update calls to the outlined functions to properly forward; // the varargs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:182,Usability,clear,clear,182,"// Compute the 'InlineCost' of block BB. InlineCost is a proxy used to; // approximate both the size and runtime cost (Note that in the current; // inline cost analysis, there is no clear distinction there either).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:257,Energy Efficiency,reduce,reduced,257,// Use Depth First Search on the basic blocks to find CFG edges that are; // considered cold.; // Cold regions considered must also have its inline cost compared to the; // overall inline cost of the original function. The region is outlined only; // if it reduced the inline cost of the function by 'MinOutlineRegionCost' or; // more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:198,Modifiability,variab,variables,198,"// For now, ignore blocks that belong to a SISE region that is a; // candidate for outlining. In the future, we may want to look; // at inner regions because the outer region may have live-exit; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Safety,Detect,Detect,3,// Detect a triangular shape:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:16,Deployability,update,update,16,// Now grow and update OutlininigInfo:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:28,Availability,avail,available,28,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:119,Safety,predict,prediction,119,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:307,Safety,predict,predicted,307,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:496,Safety,predict,predicted,496,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:529,Safety,predict,predicted,529,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:87,Usability,simpl,simplified,87,// TODO: Ideally we should share Inliner's InlineCost Analysis code.; // For now use a simplified version. The returned 'InlineCost' will be used; // to esimate the size cost as well as runtime cost of the BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:53,Testability,stub,stub,53,// The code extractor introduces a new root and exit stub blocks with; // additional unconditional branches. Those branches will be eliminated; // later with bb layout. The cost should be adjusted accordingly:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:65,Deployability,update,update,65,"// Create the callsite to profile count map which is; // used to update the original function's entry count,; // after the function is partially inlined into the callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:16,Deployability,update,update,16,"// Go ahead and update all uses to the duplicate, so that we can just; // use the inliner functionality when we're done hacking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:48,Deployability,update,update,48,// Go through all Outline Candidate Regions and update all BasicBlock; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:16,Deployability,update,update,16,"// Go ahead and update all uses to the duplicate, so that we can just; // use the inliner functionality when we're done hacking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:105,Usability,simpl,simplicity,105,"// Special hackery is needed with PHI nodes that have inputs from more than; // one extracted block. For simplicity, just split the PHIs into a two-level; // sequence of PHIs, some of which will go in the extracted region, and some; // of which will go outside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:198,Performance,load,load,198,"// After incoming values splitting, the old phi may become trivial.; // Keeping the trivial phi can introduce definition inside the outline; // region which is live-out, causing necessary overhead (load, store; // arg passing etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Performance,Cache,Cache,3,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:51,Safety,avoid,avoid,51,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:46,Modifiability,variab,variables,46,// Do not extract regions that have live exit variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:54,Modifiability,rewrite,rewrite,54,"// Ditch the duplicate, since we're done with it, and rewrite all remaining; // users (function pointers, etc.) back to the original function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:7,Deployability,update,update,7,// Now update the entry count:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Deployability,Update,Update,3,// Update the stats,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp:52,Deployability,update,update,52,"// Walk through nodes in the moved the subtree, and update; // FunctionSamples' context as for the context promotion.; // We also need to set new parant link for all children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp:238,Performance,load,loader,238,"// We may have inlined callees during pre-LTO compilation, in which case; // we need to rely on the inline stack from !dbg to mark context profile; // as inlined, instead of `MarkContextSamplesInlined` during inlining.; // Sample profile loader walks through all instructions to get profile,; // which calls this function. So once that is done, all previously inlined; // context profile should be marked properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:41,Performance,optimiz,optimization,41,"// Local to global var promotion used by optimization like thinlto; // will rename the var and add suffix like "".llvm.xxx"" to the; // original local name. In sample profile, the suffixes of function; // names are all stripped. Since it is possible that the mapper is; // built in post-thin-link phase and var promotion has been done,; // we need to add the substring of function name without the suffix; // into the GUIDToFuncNameMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:416,Usability,GUID,GUIDToFuncNameMap,416,"// Local to global var promotion used by optimization like thinlto; // will rename the var and add suffix like "".llvm.xxx"" to the; // original local name. In sample profile, the suffixes of function; // names are all stripped. Since it is possible that the mapper is; // built in post-thin-link phase and var promotion has been done,; // we need to add the substring of function name without the suffix; // into the GUIDToFuncNameMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Deployability,Update,Update,3,// Update GUIDToFuncNameMap for each function including inlinees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:10,Usability,GUID,GUIDToFuncNameMap,10,// Update GUIDToFuncNameMap for each function including inlinees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:9,Usability,GUID,GUIDToFuncNameMap,9,// Reset GUIDToFuncNameMap for of each function as they're no; // longer valid at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:50,Usability,guid,guide,50,"// Prorated callsite count, which will be used to guide inlining. For example,; // if a callsite is duplicated in LTO prelink, then in LTO postlink the two; // copies will get their own distribution factors and their prorated counts; // will be used to decide if they should be inlined independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,Usability,GUID,GUID,21,// Tie breaker using GUID so we have stable/deterministic inlining order,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:238,Usability,GUID,GUIDs,238,"/// Flag indicating which LTO/ThinLTO phase the pass is invoked in.; ///; /// We need to know the LTO phase because for example in ThinLTOPrelink; /// phase, in annotation, we should not promote indirect calls. Instead,; /// we will mark GUIDs that needs to be annotated to the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Usability,GUID,GUIDToFuncNameMap,3,"// GUIDToFuncNameMap saves the mapping from GUID to the symbol name, for; // all the function symbols defined or declared in current module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:44,Usability,GUID,GUID,44,"// GUIDToFuncNameMap saves the mapping from GUID to the symbol name, for; // all the function symbols defined or declared in current module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:92,Integrability,depend,depends,92,"// MD5 version of NamesInProfile. Either NamesInProfile or GUIDsInProfile is; // populated, depends on whether the profile uses MD5. Because the name table; // generally contains several magnitude more entries than the number of; // functions, we do not want to convert all names from one form to another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:59,Usability,GUID,GUIDsInProfile,59,"// MD5 version of NamesInProfile. Either NamesInProfile or GUIDsInProfile is; // populated, depends on whether the profile uses MD5. Because the name table; // generally contains several magnitude more entries than the number of; // functions, we do not want to convert all names from one form to another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:4,Deployability,Update,Update,4,"/// Update indirect call target profile metadata for \p Inst.; /// Usually \p Sum is the sum of counts of all the targets for \p Inst.; /// If it is 0, it means updateIDTMetaData is used to mark a; /// certain target to be promoted already. If it is not zero,; /// we expect to use it to update the total count in the value profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:161,Deployability,update,updateIDTMetaData,161,"/// Update indirect call target profile metadata for \p Inst.; /// Usually \p Sum is the sum of counts of all the targets for \p Inst.; /// If it is 0, it means updateIDTMetaData is used to mark a; /// certain target to be promoted already. If it is not zero,; /// we expect to use it to update the total count in the value profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:288,Deployability,update,update,288,"/// Update indirect call target profile metadata for \p Inst.; /// Usually \p Sum is the sum of counts of all the targets for \p Inst.; /// If it is 0, it means updateIDTMetaData is used to mark a; /// certain target to be promoted already. If it is not zero,; /// we expect to use it to update the total count in the value profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:121,Deployability,update,updateIDTMetaData,121,// Bail out early if MaxNumPromotions is zero.; // This prevents allocating an array of zero length below.; //; // Note `updateIDTMetaData` is called in two places so check; // `MaxNumPromotions` inside it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:438,Security,expose,exposed,438,/// Attempt to promote indirect call and also inline the promoted call.; ///; /// \param F Caller function.; /// \param Candidate ICP and inline candidate.; /// \param SumOrigin Original sum of target counts for indirect call before; /// promoting given candidate.; /// \param Sum Prorated sum of remaining target counts for indirect call; /// after promoting given candidate.; /// \param InlinedCallSite Output vector for new call sites exposed after; /// inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:28,Performance,load,loader,28,// Bail out early if sample-loader inliner is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:337,Usability,simpl,simply,337,"// R->getValue() != &F is to prevent promoting a recursive call.; // If it is a recursive call, we do not inline it as it could bloat; // the code exponentially. There is way to better handle this, e.g.; // clone the caller first, and inline the cloned caller if it is; // recursive. As llvm does not inline recursive calls, we will; // simply ignore it instead of handling it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:111,Availability,down,down,111,"// Do not prorate the indirect callsite distribution since the original; // distribution will be used to scale down non-promoted profile target; // counts later. By doing this we lose track of the real callsite count; // for the leftover indirect callsite as a trade off for accurate call; // target counts.; // TODO: Ideally we would have two separate factors, one for call site; // counts and one is used to prorate call target counts.; // Do not update the promoted direct callsite distribution at this; // point since the original distribution combined with the callee profile; // will be used to prorate callsites from the callee if inlined. Once not; // inlined, the direct callsite distribution should be prorated so that; // the it will reflect the real callsite counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:449,Deployability,update,update,449,"// Do not prorate the indirect callsite distribution since the original; // distribution will be used to scale down non-promoted profile target; // counts later. By doing this we lose track of the real callsite count; // for the leftover indirect callsite as a trade off for accurate call; // target counts.; // TODO: Ideally we would have two separate factors, one for call site; // counts and one is used to prorate call target counts.; // Do not update the promoted direct callsite distribution at this; // point since the original distribution combined with the callee profile; // will be used to prorate callsites from the callee if inlined. Once not; // inlined, the direct callsite distribution should be prorated so that; // the it will reflect the real callsite counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:78,Usability,GUID,GUID,78,"// Samples may not exist for replayed function, if so; // just add the direct GUID and move on",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:102,Performance,queue,queue,102,"// In some rare cases, call instruction could be changed after being pushed; // into inline candidate queue, this is because earlier inlining may expose; // constant propagation which can change indirect call to direct call. When; // this happens, we may fail to find matching function samples for the; // candidate later, even if a match was found when the candidate was enqueued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:146,Security,expose,expose,146,"// In some rare cases, call instruction could be changed after being pushed; // into inline candidate queue, this is because earlier inlining may expose; // constant propagation which can change indirect call to direct call. When; // this happens, we may fail to find matching function samples for the; // candidate later, even if a match was found when the candidate was enqueued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:44,Availability,avail,available,44,"// Import hot CallTargets, which may not be available in IR because full; // profile annotation cannot be done until backend compilation in ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:765,Deployability,update,updated,765,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:879,Deployability,update,updated,879,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:814,Performance,perform,perform,814,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:902,Usability,GUID,GUIDs,902,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:54,Testability,assert,assertion,54,// ProfAccForSymsInList is used in callsiteIsHot. The assertion makes sure; // Profile symbol list is ignored when profile-sample-accurate is on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:64,Performance,load,loader-inlining,64,// Do not attempt to inline a candidate if; // --disable-sample-loader-inlining is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:34,Security,expose,exposed,34,// Now populate the list of newly exposed call sites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:54,Testability,assert,assertion,54,// ProfAccForSymsInList is used in callsiteIsHot. The assertion makes sure; // Profile symbol list is ignored when profile-sample-accurate is on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:169,Availability,down,down,169,"// Cap the size growth from profile guided inlining. This is needed even; // though cost of each inline candidate already accounts for callee size,; // because with top-down inlining, we can grow inliner size significantly; // with large number of smaller inlinees each pass the cost check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:36,Usability,guid,guided,36,"// Cap the size growth from profile guided inlining. This is needed even; // though cost of each inline candidate already accounts for callee size,; // because with top-down inlining, we can grow inliner size significantly; // with large number of smaller inlinees each pass the cost check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Performance,Perform,Perform,3,// Perform iterative BFS call site prioritized inlining,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:61,Deployability,update,update,61,"// Attach function profile for promoted indirect callee, and update; // call site count for the promoted inline candidate too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:40,Performance,optimiz,optimizations,40,// A function call can be replicated by optimizations like callsite; // splitting or jump threading and the replicates end up sharing the; // sample nested callee profile instead of slicing the original; // inlinee's profile. We want to do merge exactly once by filtering out; // callee profiles with a non-zero head sample count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:147,Availability,down,down,147,// Note that we have to do the merge right after processing function.; // This allows OutlineFS's profile to be used for annotation during; // top-down processing of functions' annotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:75,Usability,clear,clear,75,// Set profile metadata (possibly annotated by LTO prelink) to zero or; // clear it for cold code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:47,Availability,error,errors,47,// Weight is added by one to avoid propagation errors introduced by; // 0 weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:29,Safety,avoid,avoid,29,// Weight is added by one to avoid propagation errors introduced by; // 0 weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:491,Usability,clear,cleared,491,"// Only set weights if there is at least one non-zero weight.; // In any other case, let the analyzer set weights.; // Do not set weights if the weights are present unless under; // OverwriteExistingWeights. In ThinLTO, the profile annotation is done; // twice. If the first annotation already set the weights, the second pass; // does not need to set it. With OverwriteExistingWeights, Blocks with zero; // weight should have their existing metadata (possibly annotated by LTO; // prelink) cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:63,Availability,down,down,63,"// Disable ProfileMergeInlinee if profile is not loaded in top down order,; // because the profile for a function may be used for the profile; // annotation of its outline copy before the profile merging of its; // non-inlined inline instances, and that is not the way how; // ProfileMergeInlinee is supposed to work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:49,Performance,load,loaded,49,"// Disable ProfileMergeInlinee if profile is not loaded in top down order,; // because the profile for a function may be used for the profile; // annotation of its outline copy before the profile merging of its; // non-inlined inline instances, and that is not the way how; // ProfileMergeInlinee is supposed to work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:46,Availability,down,down,46,"// Use profiled call edges to augment the top-down order. There are cases; // that the top-down order computed based on the static call graph doesn't; // reflect real execution order. For example; //; // 1. Incomplete static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // ext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:91,Availability,down,down,91,"// Use profiled call edges to augment the top-down order. There are cases; // that the top-down order computed based on the static call graph doesn't; // reflect real execution order. For example; //; // 1. Incomplete static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // ext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:726,Availability,down,down,726,"// Use profiled call edges to augment the top-down order. There are cases; // that the top-down order computed based on the static call graph doesn't; // reflect real execution order. For example; //; // 1. Incomplete static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // ext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:1210,Availability,down,down,1210,"e static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2300,Availability,down,down,2300,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2082,Deployability,pipeline,pipeline,2082,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2094,Performance,optimiz,optimize,2094,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:63,Availability,avail,available,63,// Apply tweaks if context-sensitive or probe-based profile is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:172,Availability,avail,available,172,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:134,Safety,detect,detected,134,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:113,Security,checksum,checksum,113,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:222,Security,checksum,checksum,222,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Performance,Load,Load,3,// Load pseudo probe descriptors for probe-based function samples.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,Availability,recover,recover,21,"// For inlined code, recover the original callsite and callee by finding the; // top-level inline frame. e.g. For frame stack ""main:1 @ foo:2 @ bar:3"", the; // top-level frame is ""main:1"", the callsite is ""1"" and the callee is ""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,Safety,recover,recover,21,"// For inlined code, recover the original callsite and callee by finding the; // top-level inline frame. e.g. For frame stack ""main:1 @ foo:2 @ bar:3"", the; // top-level frame is ""main:1"", the callsite is ""1"" and the callee is ""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:136,Energy Efficiency,reduce,reduce,136,"// Since indirect call does not have CalleeName, check conservatively if; // callsite in the profile is a callsite location. This is to reduce num of; // false positive since otherwise all the indirect call samples will be; // reported as mismatching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Safety,Detect,Detect,3,// Detect profile mismatch for profile staleness metrics report.; // Skip reporting the metrics for imported functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:28,Security,checksum,checksum,28,"// Run profile matching for checksum mismatched profile, currently only; // support for pseudo-probe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:219,Safety,avoid,avoid,219,"// Failiing to insert means there is already an entry in SymbolMap,; // thus there are multiple functions that are mapped to the same; // stripped name. In this case of name conflicting, set the value; // to nullptr to avoid confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:156,Safety,avoid,avoid,156,"// By default the entry count is initialized to -1, which will be treated; // conservatively by getEntryCount as the same as unknown (None). This is; // to avoid newly added code to be treated as cold. If we have samples; // this will be overwritten in emitAnnotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:37,Testability,assert,assertion,37,"// profile-sample-accurate is a user assertion which has a higher precedence; // than symbol list. When profile-sample-accurate is on, ignore symbol list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:115,Performance,perform,performance,115,"// Function in the symbol list but without sample will be regarded as; // cold. To minimize the potential negative performance impact it could; // have, we want to be a little conservative here saying if a function; // shows up in the profile, no matter as outline function, inline instance; // or call targets, treat the function as not being cold. This will handle; // the cases such as most callsites of a function are inlined in sampled; // binary but not inlined in current build (because of source code drift,; // imprecise debug information, or the callsites are all cold individually; // but not cold accumulatively...), so the outline function showing up as; // cold in sampled binary will actually not be cold after current build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:3,Deployability,Update,Update,3,// Update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:11,Security,Hash,Hash,11,"// Compute Hash value for the CFG: the lower 32 bits are CRC32 of the index; // value of each BB in the CFG. The higher 32 bits record the number of edges; // preceded by the number of indirect calls.; // This is derived from FuncPGOInstrumentation<Edge, BBInfo>::computeCFGHash().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:58,Energy Efficiency,reduce,reduce,58,// Insert pseudo probe to non-cold blocks only. This will reduce IR size as; // well as the binary size while retaining the profile quality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:13,Usability,GUID,GUID,13,"// Since the GUID from probe desc and inline stack are computed seperately, we; // need to make sure their names are consistent, so here also use the name; // from debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:351,Performance,optimiz,optimizations,351,"// Insert a probe before an instruction with a valid debug line number which; // will be assigned to the probe. The line number will be used later to; // model the inline context when the probe is inlined into other functions.; // Debug instructions, phi nodes and lifetime markers do not have an valid; // line number. Real instructions generated by optimizations may not come; // with a line number either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:135,Deployability,pipeline,pipeline,135,// Reset the dwarf discriminator if the debug location comes with any. The; // discriminator field may be used by FS-AFDO later in the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:196,Deployability,pipeline,pipeline,196,// Levarge the 32-bit discriminator field of debug data to store the ID; // and type of a callsite probe. This gets rid of the dependency on; // plumbing a customized metadata through the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:127,Integrability,depend,dependency,127,// Levarge the 32-bit discriminator field of debug data to store the ID; // and type of a callsite probe. This gets rid of the dependency on; // plumbing a customized metadata through the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:56,Modifiability,variab,variables,56,"// Determine if we can track any of the module's global variables. If so, add; // the global variables we can track to the solver's set of tracked global; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:93,Modifiability,variab,variables,93,"// Determine if we can track any of the module's global variables. If so, add; // the global variables we can track to the solver's set of tracked global; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:158,Modifiability,variab,variables,158,"// Determine if we can track any of the module's global variables. If so, add; // the global variables we can track to the solver's set of tracked global; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:109,Deployability,Update,Update,109,"// If we replaced an argument, we may now also access a global (currently; // classified as ""other"" memory). Update memory attribute to reflect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:47,Security,access,access,47,"// If we replaced an argument, we may now also access a global (currently; // classified as ""other"" memory). Update memory attribute to reflect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:610,Performance,optimiz,optimizable,610,"// If we inferred constant or undef return values for a function, we replaced; // all call uses with the inferred value. This means we don't need to bother; // actually returning anything from the function. Replace all return; // instructions with return undef.; //; // Do this in two stages: first identify the functions we should process, then; // actually zap their returns. This is important because we can only do this; // if the address of the function isn't taken. In cases where a return is the; // last use of a function, the order of processing functions would affect; // whether other functions are optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:55,Modifiability,variab,variables,55,"// If we inferred constant or undef values for globals variables, we can; // delete the global and any stores that remain to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:60,Modifiability,variab,variable,60,// Try to create a debug constant expression for the global variable; // initializer value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripDeadPrototypes.cpp:580,Availability,avail,available,580,"//===-- StripDeadPrototypes.cpp - Remove unused function declarations ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions in the input module, looking for; // dead declarations and removes them. Dead declarations are declarations of; // functions for which no implementation is available (i.e., declarations for; // unused library functions).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripDeadPrototypes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripDeadPrototypes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:120,Availability,resilien,resilient,120,"// Find all debug info in F. This is actually overkill in terms of what we; // want to do, but we want to try and be as resilient as possible in the face; // of potential debug info changes by using the formal interfaces given to us; // as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:210,Integrability,interface,interfaces,210,"// Find all debug info in F. This is actually overkill in terms of what we; // want to do, but we want to try and be as resilient as possible in the face; // of potential debug info changes by using the formal interfaces given to us; // as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:54,Modifiability,variab,variables,54,"// For each compile unit, find the live set of global variables/functions and; // replace the current list of potentially dead global variables/functions; // with the live list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:134,Modifiability,variab,variables,134,"// For each compile unit, find the live set of global variables/functions and; // replace the current list of potentially dead global variables/functions; // with the live list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:26,Modifiability,variab,variable,26,// Create our live global variable list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:39,Modifiability,variab,variable,39,// Make sure we only visit each global variable only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:15,Modifiability,variab,variable,15,"// If a global variable references DIG, the global variable is live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:51,Modifiability,variab,variable,51,"// If a global variable references DIG, the global variable is live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:27,Modifiability,variab,variables,27,"// If we found dead global variables, replace the current global; // variable list with our new live global variable list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:69,Modifiability,variab,variable,69,"// If we found dead global variables, replace the current global; // variable list with our new live global variable list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:108,Modifiability,variab,variable,108,"// If we found dead global variables, replace the current global; // variable list with our new live global variable list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp:1010,Availability,down,down,1010,"//=- SyntheticCountsPropagation.cpp - Propagate function counts --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a transformation that synthesizes entry counts for; // functions and attaches !prof metadata to functions with the synthesized; // counts. The presence of !prof metadata with counter name set to; // 'synthesized_function_entry_count' indicate that the value of the counter is; // an estimation of the likely execution count of the function. This transform; // is applied only in non PGO mode as functions get 'real' profile-based; // function entry counts in the PGO mode.; //; // The transformation works by first assigning some initial values to the entry; // counts of all functions and then doing a top-down traversal of the; // callgraph-scc to propagate the counts. For each function the set of callsites; // and their relative block frequency is gathered. The relative block frequency; // multiplied by the entry count of the caller and added to the callee's entry; // count. For non-trivial SCCs, the new counts are computed from the previous; // counts and updated in one shot.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp:1369,Deployability,update,updated,1369,"//=- SyntheticCountsPropagation.cpp - Propagate function counts --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a transformation that synthesizes entry counts for; // functions and attaches !prof metadata to functions with the synthesized; // counts. The presence of !prof metadata with counter name set to; // 'synthesized_function_entry_count' indicate that the value of the counter is; // an estimation of the likely execution count of the function. This transform; // is applied only in non PGO mode as functions get 'real' profile-based; // function entry counts in the PGO mode.; //; // The transformation works by first assigning some initial values to the entry; // counts of all functions and then doing a top-down traversal of the; // callgraph-scc to propagate the counts. For each function the set of callsites; // and their relative block frequency is gathered. The relative block frequency; // multiplied by the entry count of the caller and added to the callee's entry; // count. For non-trivial SCCs, the new counts are computed from the previous; // counts and updated in one shot.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:60,Safety,safe,safe,60,// Promotion aliases are used only in inline assembly. It's safe to; // simply skip unusual names. Subset of MCAsmInfo::isAcceptableChar(); // and MCAsmInfoXCOFF::isAcceptableChar().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:72,Usability,simpl,simply,72,// Promotion aliases are used only in inline assembly. It's safe to; // simply skip unusual names. Subset of MCAsmInfo::isAcceptableChar(); // and MCAsmInfoXCOFF::isAcceptableChar().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:50,Safety,avoid,avoid,50,// Create a local alias with the original name to avoid breaking; // references from inline assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:47,Modifiability,variab,variable,47,"// Finally, add them to a llvm[.compiler].used variable in DestM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:543,Performance,optimiz,optimized,543,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:646,Performance,optimiz,optimizations,646,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:793,Performance,perform,perform,793,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:807,Performance,optimiz,optimization,807,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:128,Security,access,access,128,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:384,Testability,test,test,384,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:452,Testability,test,testing,452,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:19,Security,hash,hash,19,"// Save the module hash produced for the full bitcode, which will; // be used in the backends, and use that in the minimized bitcode; // produced for the full link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:66,Security,hash,hash,66,"// Write it out as an unsplit ThinLTO module.; // Save the module hash produced for the full bitcode, which will; // be used in the backends, and use that in the minimized bitcode; // produced for the full link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1633,Deployability,pipeline,pipelines,1633,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:995,Modifiability,rewrite,rewrite,995,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:59,Performance,optimiz,optimization,59,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:418,Performance,optimiz,optimization,418,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1026,Performance,load,load,1026,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1086,Performance,optimiz,optimization,1086,"ptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1287,Performance,optimiz,optimization,1287," program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolut",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1701,Performance,optimiz,optimization,1701,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1833,Performance,optimiz,optimization,1833,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1934,Performance,load,load,1934,"he return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; // the link. It computes a resolution for each virtual call and stores it in; // the type identifier summary. Only single implementation devirtualization; // is supported.; // - Import phase: (same as with hybrid case above).; //; //===---",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1907,Testability,test,test,1907,"aluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; // the link. It computes a resolution for each virtual call and stores it in; // the type identifier summary. Only single implementation devirtualization; // is supported.; // - Import phase: (same as with hybr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:62,Testability,test,tests,62,/// Provide a way to force enable whole program visibility in tests.; /// This is needed to support legacy tests that don't contain; /// !vcall_visibility metadata (the mere presense of type tests; /// previously implied hidden visibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:107,Testability,test,tests,107,/// Provide a way to force enable whole program visibility in tests.; /// This is needed to support legacy tests that don't contain; /// !vcall_visibility metadata (the mere presense of type tests; /// previously implied hidden visibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:191,Testability,test,tests,191,/// Provide a way to force enable whole program visibility in tests.; /// This is needed to support legacy tests that don't contain; /// !vcall_visibility metadata (the mere presense of type tests; /// previously implied hidden visibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:229,Availability,failure,failures,229,"/// Mechanism to add runtime checking of devirtualization decisions, optionally; /// trapping or falling back to indirect call on any that are not correct.; /// Trapping mode is useful for debugging undefined behavior leading to failures; /// with WPD. Fallback mode is useful for ensuring safety when whole program; /// visibility may be compromised.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:290,Safety,safe,safety,290,"/// Mechanism to add runtime checking of devirtualization decisions, optionally; /// trapping or falling back to indirect call on any that are not correct.; /// Trapping mode is useful for debugging undefined behavior leading to failures; /// with WPD. Fallback mode is useful for ensuring safety when whole program; /// visibility may be compromised.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:332,Energy Efficiency,allocate,allocated,332,"// Build a vector of arrays of bytes covering, for each target, a slice of the; // used region (see AccumBitVector::BytesUsed in; // llvm/Transforms/IPO/WholeProgramDevirt.h) starting at MinByte. Effectively,; // this aligns the used regions to start at MinByte.; //; // In this example, A, B and C are vtables, # is a byte already allocated for; // a virtual function pointer, AAAA... (etc.) are the used regions for the; // vtables and Offset(X) is the value computed for the Offset variable below; // for X.; //; // Offset(A); // | |; // |MinByte; // A: ################AAAAAAAA|AAAAAAAA; // B: ########BBBBBBBBBBBBBBBB|BBBB; // C: ########################|CCCCCCCCCCCCCCCC; // | Offset(B) |; //; // This code produces the slices of A, B and C that appear after the divider; // at MinByte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:485,Modifiability,variab,variable,485,"// Build a vector of arrays of bytes covering, for each target, a slice of the; // used region (see AccumBitVector::BytesUsed in; // llvm/Transforms/IPO/WholeProgramDevirt.h) starting at MinByte. Effectively,; // this aligns the used regions to start at MinByte.; //; // In this example, A, B and C are vtables, # is a byte already allocated for; // a virtual function pointer, AAAA... (etc.) are the used regions for the; // vtables and Offset(X) is the value computed for the Offset variable below; // for X.; //; // Offset(A); // | |; // |MinByte; // A: ################AAAAAAAA|AAAAAAAA; // B: ########BBBBBBBBBBBBBBBB|BBBB; // C: ########################|CCCCCCCCCCCCCCCC; // | Offset(B) |; //; // This code produces the slices of A, B and C that appear after the divider; // at MinByte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:320,Usability,GUID,GUID,320,"// end namespace llvm; // Returns true if the function must be unreachable based on ValueInfo.; //; // In particular, identifies a function as unreachable in the following; // conditions; // 1) All summaries are live.; // 2) All function summaries indicate it's unreachable; // 3) There is no non-function with the same GUID (which is rare)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:50,Usability,GUID,GUID,50,// Be conservative if a non-function has the same GUID (which is rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:38,Performance,load,loaded,38,"// A virtual call site. VTable is the loaded virtual table pointer, and CS is; // the indirect virtual call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:52,Safety,unsafe,unsafe,52,"// If non-null, this field points to the associated unsafe use count stored in; // the DevirtModule::NumUnsafeUsesForTypeTest map below. See the description; // of that field for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Safety,unsafe,unsafe,25,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:191,Testability,test,test,191,// These fields are used during the export phase of ThinLTO and reflect; // information collected from function summaries.; /// Whether any function summary contains an llvm.assume(llvm.type.test) for; /// this slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:105,Performance,load,load,105,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:178,Testability,test,test,178,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:452,Testability,test,test,452,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:314,Usability,clear,clear,314,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,Performance,optimiz,optimized,32,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:103,Performance,load,loads,103,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:156,Performance,optimiz,optimize,156,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:99,Performance,optimiz,optimization,99,// Store calls that had their ptrauth bundle removed. They are to be deleted; // at the end of the optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:60,Performance,load,loaded,60,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:209,Performance,load,loaded,209,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:42,Safety,unsafe,unsafe,42,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:176,Safety,unsafe,unsafe,176,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:274,Safety,unsafe,unsafe,274,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:125,Testability,test,test,125,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:514,Testability,test,test,514,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:67,Performance,load,load,67,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:36,Safety,unsafe,unsafe,36,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:107,Testability,test,tests,107,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:91,Testability,test,testing,91,// Lower the module using the action and summary passed as command line; // arguments. For testing purposes only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:30,Usability,GUID,GUIDs,30,"// The set in which to record GUIDs exported from their module by; // devirtualization, used by client to ensure they are not internalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:47,Deployability,upgrade,upgrade,47,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definitions to linkage unit visibility in; /// Module IR (for regular or hybrid LTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,Testability,assert,asserted,32,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definitions to linkage unit visibility in; /// Module IR (for regular or hybrid LTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:38,Modifiability,variab,variable,38,"// Add linkage unit visibility to any variable with type metadata, which are; // the vtable definitions. We won't have an existing vcall_visibility; // metadata on vtable definitions with public visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:9,Deployability,upgrade,upgrade,9,"// Don't upgrade the visibility for symbols exported to the dynamic; // linker, as we have no information on their eventual use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:8,Security,validat,validation,8,"// With validation enabled, we want to exclude symbols visible to; // regular objects. Local symbols will be in this group due to the; // current implementation but those with VCallVisibilityTranslationUnit; // will have already been marked in clang so are unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:54,Usability,GUID,GUIDS,54,"/// Based on typeID string, get all associated vtable GUIDS that are; /// visible to regular objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:47,Deployability,upgrade,upgrade,47,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definition summaries to linkage unit; /// visibility in Module summary index (for ThinLTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,Testability,assert,asserted,32,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definition summaries to linkage unit; /// visibility in Module summary index (for ThinLTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:9,Deployability,upgrade,upgrade,9,"// Don't upgrade the visibility for symbols exported to the dynamic; // linker, as we have no information on their eventual use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:8,Security,validat,validation,8,"// With validation enabled, we want to exclude symbols visible to regular; // objects. Local symbols will be in this group due to the current; // implementation but those with VCallVisibilityTranslationUnit will have; // already been marked in clang so are unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:61,Performance,perform,performing,61,"// Check that summary index contains regular LTO module when performing; // export to prevent occasional use of index from pure ThinLTO compilation; // (-fno-split-lto-module). This kind of summary index is passed to; // DevirtIndex::run, not to DevirtModule::run used by opt/runForTesting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:103,Availability,error,errors,103,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,Testability,test,testing,63,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:13,Performance,perform,perform,13,// We cannot perform whole program devirtualization analysis on a vtable; // with public LTO visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:296,Availability,error,error,296,"// Find a representative copy of the vtable initializer.; // We can have multiple available_externally, linkonce_odr and weak_odr; // vtable initializers. We can also have multiple external vtable; // initializers in the case of comdats, which we cannot check here.; // The linker should give an error in this case.; //; // Also, handle the case of same-named local Vtables with the same path; // and therefore the same GUID. This can happen if there isn't enough; // distinguishing path when compiling the source file. In that case we; // conservatively return false early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:420,Usability,GUID,GUID,420,"// Find a representative copy of the vtable initializer.; // We can have multiple available_externally, linkonce_odr and weak_odr; // vtable initializers. We can also have multiple external vtable; // initializers in the case of comdats, which we cannot check here.; // The linker should give an error in this case.; //; // Also, handle the case of same-named local Vtables with the same path; // and therefore the same GUID. This can happen if there isn't enough; // distinguishing path when compiling the source file. In that case we; // conservatively return false early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:403,Safety,avoid,avoid,403,"// Previously clang did not attach the necessary type metadata to; // available_externally vtables, in which case there would not; // be any vtable functions listed in the summary and we need; // to treat this case conservatively (in case the bitcode is old).; // However, we will also not have any vtable functions in the; // case of a pure virtual base class. In that case we do want; // to set VS to avoid treating it conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:13,Performance,perform,perform,13,// We cannot perform whole program devirtualization analysis on a vtable; // with public LTO visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:120,Performance,perform,perform,120,// There will be no VS if all copies are available_externally having no; // type metadata. In that case we can't safely perform WPD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:113,Safety,safe,safely,113,// There will be no VS if all copies are available_externally having no; // type metadata. In that case we can't safely perform WPD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:144,Performance,perform,perform,144,"// If trap checking is enabled, add support to compare the virtual; // function pointer to the devirtualized target. In case of a mismatch,; // perform a debug trap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:46,Usability,clear,clear,46,"// Since the new call site is direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and; // !callees metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:104,Performance,perform,perform,104,"// Additionally, we should remove them from the fallback indirect call,; // so that we don't attempt to perform indirect call promotion later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:46,Usability,clear,clear,46,"// Since the call site is now direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and; // !callees metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule for deletion at the end of pass run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Safety,unsafe,unsafe,25,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:127,Testability,test,tests,127,"// Insert calls into the summary index so that the devirtualized targets; // are eligible for import.; // FIXME: Annotate type tests with hotness. For now, mark these as hot; // to better ensure we have the opportunity to inline them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:10,Deployability,update,update,10,"// If so, update each call site to call that implementation directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:136,Performance,load,load,136,"// When finding devirtualizable calls, it's possible to find the same; // vtable passed to multiple llvm.type.test or llvm.type.checked.load; // calls, which can cause duplicate call sites to be recorded in; // [Const]CallSites. If we've already found one of these; // call instances, just ignore it. It will be replaced later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:110,Testability,test,test,110,"// When finding devirtualizable calls, it's possible to find the same; // vtable passed to multiple llvm.type.test or llvm.type.checked.load; // calls, which can cause duplicate call sites to be recorded in; // [Const]CallSites. If we've already found one of these; // call instances, just ignore it. It will be replaced later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Safety,unsafe,unsafe,25,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:159,Testability,test,test,159,"// Don't mark as devirtualized because there may be callers compiled without; // retpoline mitigation, which would mean that they are lowered to; // llvm.type.test and therefore require an llvm.type.test resolution for the; // type identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:199,Testability,test,test,199,"// Don't mark as devirtualized because there may be callers compiled without; // retpoline mitigation, which would mean that they are lowered to; // llvm.type.test and therefore require an llvm.type.test resolution for the; // type identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:165,Performance,optimiz,optimization,165,"// TODO: Skip for now if the vtable symbol was an alias to a function,; // need to evaluate whether it would be correct to analyze the aliasee; // function for this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:24,Performance,optimiz,optimization,24,"// Uniform return value optimization. If all functions return the same; // constant, replace all calls with that constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Deployability,Update,Update,3,// Update devirtualization statistics for targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:165,Performance,optimiz,optimization,165,"// TODO: Skip for now if the vtable symbol was an alias to a function,; // need to evaluate whether it would be correct to analyze the aliasee; // function for this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:376,Performance,optimiz,optimized,376,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:479,Performance,optimiz,optimizations,479,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:626,Performance,perform,perform,626,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:640,Performance,optimiz,optimization,640,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:53,Security,access,access,53,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:217,Testability,test,test,217,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:285,Testability,test,testing,285,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:165,Performance,optimiz,optimization,165,"// TODO: Skip for now if the vtable symbol was an alias to a function,; // need to evaluate whether it would be correct to analyze the aliasee; // function for this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each call to a load from OffsetByte/OffsetBit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:26,Performance,load,load,26,// Rewrite each call to a load from OffsetByte/OffsetBit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:115,Testability,test,test,115,"// Find all virtual calls via a virtual table pointer %p under an assumption; // of the form llvm.assume(llvm.type.test(%p, %md)). This indicates that %p; // points to a member of the type identifier %md. Group calls by (type ID,; // offset) pair (effectively the identity of the virtual function) and store; // to CallSlots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:45,Testability,test,test,45,// We no longer need the assumes or the type test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:205,Energy Efficiency,efficient,efficient,205,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:42,Testability,test,test,42,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:449,Testability,test,test,449,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:596,Testability,test,test,596,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:666,Testability,test,test,666,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:568,Performance,optimiz,optimization,568,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:53,Testability,test,test,53,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:231,Testability,test,test,231,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:493,Testability,test,test,493,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:58,Performance,load,loads,58,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:109,Performance,perform,performs,109,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:173,Performance,load,load,173,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:239,Performance,load,load,239,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:290,Safety,avoid,avoid,290,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Testability,test,test,25,// Likewise for the type test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:17,Safety,unsafe,unsafe,17,// The number of unsafe uses is initially the number of uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:161,Safety,unsafe,unsafe,161,"// If the function pointer has a non-call user, we cannot eliminate the type; // check, as one of those users may eventually call the pointer. Increment; // the unsafe use count to make sure it cannot reach zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:30,Usability,GUID,GUID,30,// Look up ValueInfo with the GUID in the current linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:28,Usability,GUID,GUID,28,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:51,Usability,GUID,GUID,51,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:313,Usability,GUID,GUID,313,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:10,Usability,learn,learn,10,"// First, learn unreachability by analyzing function IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Usability,Learn,Learn,3,// Learn unreachability from ExportSummary if ExportSummary is present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:231,Availability,error,error,231,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,Performance,perform,perform,63,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:140,Testability,test,tests,140,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:271,Usability,simpl,simply,271,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:397,Safety,detect,detection,397,"// For any type id used on a global's type metadata, create the type id; // summary resolution regardless of whether we can devirtualize, so that; // lower type tests knows the type id is not Unsat. If it was not used on; // a global's type metadata, the TypeIdMap entry set will be empty, and; // we don't want to create an entry (with the default Unknown type; // resolution), which can prevent detection of the Unsat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:161,Testability,test,tests,161,"// For any type id used on a global's type metadata, create the type id; // summary resolution regardless of whether we can devirtualize, so that; // lower type tests knows the type id is not Unsat. If it was not used on; // a global's type metadata, the TypeIdMap entry set will be empty, and; // we don't want to create an entry (with the default Unknown type; // resolution), which can prevent detection of the Unsat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,Performance,load,load,63,"// CFI-specific: if we are exporting and any llvm.type.checked.load; // intrinsics were *not* devirtualized, we need to add the resulting; // llvm.type.test intrinsics to the function summaries so that the; // LowerTypeTests pass will export them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:152,Testability,test,test,152,"// CFI-specific: if we are exporting and any llvm.type.checked.load; // intrinsics were *not* devirtualized, we need to add the resulting; // llvm.type.test intrinsics to the function summaries so that the; // LowerTypeTests pass will export them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:108,Testability,test,tests,108,"// Create the type id summary resolution regardlness of whether we can; // devirtualize, so that lower type tests knows the type id is used on; // a global and not Unsat. We do this here rather than in the loop over the; // CallSlots, since that handling will only see type tests that directly; // feed assumes, and we would miss any that aren't currently handled by WPD; // (such as type tests that feed assumes via phis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:274,Testability,test,tests,274,"// Create the type id summary resolution regardlness of whether we can; // devirtualize, so that lower type tests knows the type id is used on; // a global and not Unsat. We do this here rather than in the loop over the; // CallSlots, since that handling will only see type tests that directly; // feed assumes, and we would miss any that aren't currently handled by WPD; // (such as type tests that feed assumes via phis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:389,Testability,test,tests,389,"// Create the type id summary resolution regardlness of whether we can; // devirtualize, so that lower type tests knows the type id is used on; // a global and not Unsat. We do this here rather than in the loop over the; // CallSlots, since that handling will only see type tests that directly; // feed assumes, and we would miss any that aren't currently handled by WPD; // (such as type tests that feed assumes via phis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:39,Integrability,message,message,39,// Optionally have the thin link print message for each devirtualized; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:42,Performance,Optimiz,Optimization,42,"//===- ARCRuntimeEntryPoints.h - ObjC ARC Optimization ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains a class ARCRuntimeEntryPoints for use in; /// creating/managing references to entry points to the arc objective c runtime.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:96,Safety,avoid,avoid,96,/// Declarations for ObjC runtime functions and constants. These are initialized; /// lazily to avoid cluttering up the Module with unused declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:4,Performance,Cache,Cached,4,/// Cached reference to the module which we will insert declarations into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:7,Integrability,Depend,DependencyAnalysis,7,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:422,Integrability,depend,dependency,422,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:442,Integrability,rout,routines,442,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:41,Performance,Optimiz,Optimization,41,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:480,Performance,Optimiz,Optimizations,480,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:4,Testability,Test,Test,4,/// Test whether the given instruction can result in a reference count; /// modification (positive or negative) for the pointer's object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:9,Performance,perform,perform,9,// First perform a quick check if Class can not touch ref counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:4,Testability,Test,Test,4,"/// Test whether the given instruction can ""use"" the given pointer's object in a; /// way that requires the reference count to be positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:74,Integrability,depend,dependence,74,"// If we can't tell what the underlying object was, assume there is a; // dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:25,Integrability,depend,dependencies,25,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:89,Integrability,depend,dependencies,89,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:4,Testability,Test,Test,4,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:83,Testability,test,tests,83,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:90,Integrability,depend,dependencies,90,/// Walk up the CFG from StartPos (which is in StartBB) and find local and; /// non-local dependencies on Arg.; ///; /// TODO: Cache results?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:127,Performance,Cache,Cache,127,/// Walk up the CFG from StartPos (which is in StartBB) and find local and; /// non-local dependencies on Arg.; ///; /// TODO: Cache results?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:138,Performance,optimiz,optimizations,138,"// Determine whether the original StartBB post-dominates all of the blocks we; // visited. If not, insert a sentinel indicating that most optimizations are; // not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:164,Safety,safe,safe,164,"// Determine whether the original StartBB post-dominates all of the blocks we; // visited. If not, insert a sentinel indicating that most optimizations are; // not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:7,Integrability,Depend,DependencyAnalysis,7,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:423,Integrability,depend,dependency,423,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:443,Integrability,rout,routines,443,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:39,Performance,Optimiz,Optimization,39,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:481,Performance,Optimiz,Optimizations,481,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:10,Integrability,Depend,DependenceKind,10,/// \enum DependenceKind; /// Defines different dependence kinds among various ARC constructs.; ///; /// There are several kinds of dependence-like concepts in use here.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:48,Integrability,depend,dependence,48,/// \enum DependenceKind; /// Defines different dependence kinds among various ARC constructs.; ///; /// There are several kinds of dependence-like concepts in use here.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:132,Integrability,depend,dependence-like,132,/// \enum DependenceKind; /// Defines different dependence kinds among various ARC constructs.; ///; /// There are several kinds of dependence-like concepts in use here.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:9,Integrability,depend,dependent,9,"/// Find dependent instructions. If there is exactly one dependent instruction,; /// return it. Otherwise, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:57,Integrability,depend,dependent,57,"/// Find dependent instructions. If there is exactly one dependent instruction,; /// return it. Otherwise, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:4,Testability,Test,Test,4,"/// Test whether the given instruction can ""use"" the given pointer's object in a; /// way that requires the reference count to be positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:4,Testability,Test,Test,4,/// Test whether the given instruction can result in a reference count; /// modification (positive or negative) for the pointer's object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h:28,Performance,Optimiz,Optimization,28,"//===- ObjCARC.h - ObjC ARC Optimization --------------*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common definitions/declarations used by the ObjC ARC; /// Optimizer. ARC stands for Automatic Reference Counting and is a system for; /// managing reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h:467,Performance,Optimiz,Optimizer,467,"//===- ObjCARC.h - ObjC ARC Optimization --------------*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common definitions/declarations used by the ObjC ARC; /// Optimizer. ARC stands for Automatic Reference Counting and is a system for; /// managing reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:36,Performance,Optimiz,Optimization,36,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:423,Performance,optimiz,optimizations,423,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:606,Performance,optimiz,optimizations,606,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:98,Testability,test,testcases,98,// This recursion depth limit is arbitrary. It's just great; // enough to cover known interesting testcases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:30,Modifiability,variab,variable,30,"// Find the llvm.global_ctors variable, as the first step in; // identifying the global constructors. In theory, unnecessary autorelease; // pools could occur anywhere, but in practice it's pretty rare. Global; // ctors are a place where autorelease pools get inserted automatically,; // so it's pretty common for them to be unnecessary, and it's pretty; // profitable to eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:62,Performance,optimiz,optimize,62,"// Ok, a single-block constructor function definition. Try to optimize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:615,Integrability,contract,contracting,615,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:38,Performance,Optimiz,Optimization,38,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:423,Performance,optimiz,optimizations,423,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:13,Performance,optimiz,optimizations,13,"/// Late ARC optimizations; ///; /// These change the IR in a way that makes it difficult to be analyzed by; /// ObjCARCOpt, so it's run late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,Performance,optimiz,optimization,86,/// The inline asm string to insert between calls and RetainRV calls to make; /// the optimization work on targets which need it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:36,Performance,Load,Load,36,// Get the location associated with Load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:8,Availability,down,down,8,"// Walk down to find the store and the release, which may be in either order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:39,Deployability,release,release,39,"// Walk down to find the store and the release, which may be in either order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:57,Deployability,release,release,57,"// If we found the store we were looking for and saw the release,; // break. There is no more work to be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:61,Deployability,release,release,61,"// Now we know that we have not seen either the store or the release. If I; // is the release, mark that we saw the release and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,Deployability,release,release,86,"// Now we know that we have not seen either the store or the release. If I; // is the release, mark that we saw the release and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:116,Deployability,release,release,116,"// Now we know that we have not seen either the store or the release. If I; // is the release, mark that we saw the release and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:42,Deployability,release,release,42,"// If we have seen the store, but not the release...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:52,Deployability,release,release,52,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:175,Deployability,Release,Release,175,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:236,Deployability,Release,Release,236,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:35,Safety,safe,safe,35,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:134,Performance,load,load,134,"// Ok, now we know we have not seen a store yet.; // If Inst is a retain, we don't care about it as it doesn't prevent moving; // the load to the store.; //; // TODO: This is one area where the optimization could be made more; // aggressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:194,Performance,optimiz,optimization,194,"// Ok, now we know we have not seen a store yet.; // If Inst is a retain, we don't care about it as it doesn't prevent moving; // the load to the store.; //; // TODO: This is one area where the optimization could be made more; // aggressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:32,Performance,load,load,32,"// See if Inst can write to our load location, if it can not, just ignore; // the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:207,Performance,load,load,207,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:40,Usability,simpl,simple,40,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:104,Usability,simpl,simple,104,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:51,Deployability,release,release,51,"// If we did not find the store or did not see the release, fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:111,Deployability,release,release,111,// It is only safe to move the retain to the store if we can prove; // conservatively that nothing besides the release can decrement reference; // counts in between the retain and the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:14,Safety,safe,safe,14,// It is only safe to move the retain to the store if we can prove; // conservatively that nothing besides the release can decrement reference; // counts in between the retain and the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:353,Deployability,release,release,353,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:426,Deployability,release,releases,426,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:950,Deployability,release,release,950,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:51,Performance,load,load,51,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:251,Performance,Load,Load,251,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:285,Performance,load,load,285,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:742,Performance,optimiz,optimization,742,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:873,Performance,perform,perform,873,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:891,Performance,optimiz,optimization,891,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:940,Performance,load,load,940,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:727,Safety,safe,safety,727,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:915,Safety,safe,safe,915,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:1053,Safety,safe,safe,1053,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:50,Performance,load,loaded,50,// See if we are releasing something that we just loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:14,Availability,down,down,14,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:31,Performance,Load,Load,31,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,Performance,Load,Load,86,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:188,Safety,safe,safe,188,"// We can't set the tail flag yet, because we haven't yet determined; // whether there are any escaping allocas. Remember this call, so that; // we can set the tail flag once we know it's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:22,Integrability,rout,routines,22,"// Only these library routines return their argument. In particular,; // objc_retainBlock does not necessarily return its argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:24,Performance,optimiz,optimization,24,"// If we succeed in our optimization, fall through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:79,Availability,redundant,redundant,79,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:79,Safety,redund,redundant,79,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:186,Safety,avoid,avoids,186,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:193,Usability,undo,undoing,193,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:122,Usability,undo,undo,122,"// If this isn't a bundled call, and the target doesn't need a special; // inline-asm marker, we're done: return now, and undo objc-arc-expand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:45,Deployability,release,release,45,"// Try to form an objc store strong from our release. If we fail, there is; // nothing further to do below, so continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:2,Integrability,Contract,ContractPass,2,/*ContractPass=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:199,Safety,unsafe,unsafe,199,"// Track whether it's ok to mark objc_storeStrong calls with the ""tail""; // keyword. Be conservative if the function has variadic arguments.; // It seems that functions which ""return twice"" are also unsafe for the; // ""tail"" argument, because they are setjmp, which could need to; // return to an earlier stack state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:158,Energy Efficiency,reduce,reduces,158,"// For ObjC library calls which return their argument, replace uses of the; // argument with uses of the call return value, if it dominates the use. This; // reduces register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:85,Usability,undo,undoing,85,"// First try to peephole Inst. If there is nothing further we can do in; // terms of undoing objc-arc-expand, process the next inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:21,Usability,undo,undo,21,"// Otherwise, try to undo objc-arc-expand.; // Don't use GetArgRCIdentityRoot because we don't want to look through bitcasts; // and such; to do the replacement, the argument must have type i8*.; // Function for replacing uses of Arg dominated by Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:80,Modifiability,rewrite,rewrite,80,"// If the call's return value dominates a use of the call's argument; // value, rewrite the use to use the return value. We check for; // reachability here because an unreachable call is considered to; // trivially dominate itself, which would lead us to rewriting its; // argument in terms of its return value, which would lead to; // infinite loops in GetArgRCIdentityRoot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:21,Modifiability,rewrite,rewrite,21,"// While we're here, rewrite all edges for this PHI, rather; // than just one use at a time, to minimize the number of; // bitcasts we emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:36,Performance,Optimiz,Optimization,36,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:418,Performance,optimiz,optimizations,418,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:607,Performance,optimiz,optimizations,607,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:627,Performance,perform,perform,627,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:232,Integrability,contract,contract,232,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:66,Performance,optimiz,optimization,66,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:111,Performance,optimiz,optimizations,111,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:159,Performance,optimiz,optimization,159,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:137,Usability,Undo,Undo,137,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:626,Availability,redundant,redundant,626,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:652,Availability,redundant,redundant,652,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:731,Availability,redundant,redundant,731,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Performance,Optimiz,Optimization,34,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:422,Performance,optimiz,optimizations,422,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:579,Performance,optimiz,optimizations,579,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:593,Performance,perform,performed,593,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:626,Safety,redund,redundant,626,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:652,Safety,redund,redundant,652,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:731,Safety,redund,redundant,731,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:785,Usability,simpl,simplifications,785,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:635,Deployability,release,release,635,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:1450,Deployability,release,release,1450,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Performance,Optimiz,Optimization,38,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:858,Performance,optimiz,optimizer,858,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:972,Performance,Optimiz,OptimizeSequences,972,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:12,Availability,down,down,12,/// The top-down traversal uses this to record information known about a; /// pointer at the bottom of each block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:59,Availability,down,down,59,/// Attempt to find the PtrState object describing the top down state for; /// pointer Arg. Return a new initialized PtrState describing the top down; /// state for Arg if we do not find one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:145,Availability,down,down,145,/// Attempt to find the PtrState object describing the top down state for; /// pointer Arg. Return a new initialized PtrState describing the top down; /// state for Arg if we do not find one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:152,Availability,down,down,152,/// Compute the number of possible unique paths from an entry to an exit; /// which pass through this block. This is only valid after both the; /// top-down and bottom-up traversals are complete.; ///; /// Returns true if overflow occurred. Returns false if overflow did not; /// occur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:12,Availability,down,down,12,/// The top-down traversal uses this to merge information about predecessors to; /// form the initial state for a new block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,Availability,down,down,47,"// In order to be consistent, we clear the top down pointers when by adding; // TopDownPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,Usability,clear,clear,33,"// In order to be consistent, we clear the top down pointers when by adding; // TopDownPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,Availability,down,down,47,"// In order to be consistent, we clear the top down pointers when by adding; // BottomUpPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,Usability,clear,clear,33,"// In order to be consistent, we clear the top down pointers when by adding; // BottomUpPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Performance,optimiz,optimization,17,/// The main ARC optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,cache,cache,6,/// A cache of references to runtime entry point constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,cache,cache,6,/// A cache of MDKinds that can be passed into other functions to propagate; /// MDKind identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:81,Deployability,release,release,81,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Performance,optimiz,optimization,34,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:105,Performance,perform,performed,105,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize an individual call, optionally passing the; /// GetArgRCIdentityRoot if it has already been computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:11,Performance,optimiz,optimize,11,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:83,Performance,optimiz,optimization,83,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:56,Safety,Unsafe,UnsafeClaimRV,56,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:55,Deployability,Release,Release,55,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:144,Deployability,Release,Release,144,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Safety,Unsafe,UnsafeClaimRV,3,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:125,Safety,Unsafe,UnsafeClaimRV,125,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:35,Deployability,Release,Release,35,// Run the normal optimizations on Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:18,Performance,optimiz,optimizations,18,// Run the normal optimizations on Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:45,Usability,simpl,simplifications,45,"/// Visit each call, one at a time, and make simplifications without doing any; /// additional analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:98,Safety,Unsafe,UnsafeClaimRV,98,"// Store any delayed AutoreleaseRV intrinsics, so they can be easily paired; // with RetainRV and UnsafeClaimRV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:49,Testability,log,logic,49,"// Nothing to delay, but we may as well skip the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:163,Performance,Optimiz,OptimizeInlinedAutoreleaseRVCall,163,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:74,Safety,Unsafe,UnsafeClaimRV,74,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:103,Safety,safe,safe,103,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:118,Performance,optimiz,optimize,118,"// This is a non-ARC instruction. If we're delaying an AutoreleaseRV,; // check if it's safe to skip over it; if not, optimize the AutoreleaseRV; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:88,Safety,safe,safe,88,"// This is a non-ARC instruction. If we're delaying an AutoreleaseRV,; // check if it's safe to skip over it; if not, optimize the AutoreleaseRV; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:115,Safety,safe,safely,115,/// This function returns true if the value is inert. An ObjC ARC runtime call; /// taking an inert operand can be safely deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:180,Performance,optimiz,optimizer,180,"// Delete no-op casts. These function calls have special semantics, but; // the semantics are entirely implemented via lowering in the front-end,; // so by the time they reach the optimizer, they are just no-op calls; // which return their argument.; //; // There are gray areas here, as the ability to cast reference-counted; // pointers to raw void* and back allows code to break ARC assumptions,; // however these are currently considered to be unimportant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Deployability,release,release,34,"// Keep track of which of retain, release, autorelease, and retain_block; // are actually present in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:223,Deployability,release,release,223,"// If Arg is a PHI, and one or more incoming values to the; // PHI are null, and the call is control-equivalent to the PHI, and there; // are no relevant side effects between the PHI and the call, and the call; // is not a release that doesn't have the clang.imprecise_release tag, the; // call could be pushed up to just those paths with non-null incoming; // values. For now, don't bother splitting critical edges for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:51,Performance,optimiz,optimize,51,"// If we have null operands and no critical edges, optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:41,Integrability,depend,depends,41,"// Don't move these; the RV optimization depends on the autoreleaseRV; // being tail called, and the retainRV being immediately after a call; // (which might still happen if we get lucky with codegen layout, but; // it's not worth taking the chance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:28,Performance,optimiz,optimization,28,"// Don't move these; the RV optimization depends on the autoreleaseRV; // being tail called, and the retainRV being immediately after a call; // (which might still happen if we get lucky with codegen layout, but; // it's not worth taking the chance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:21,Availability,down,down,21,"/// If we have a top down pointer in the S_Use state, make sure that there are; /// no CFG hazards by checking the states of various bottom up pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:91,Safety,hazard,hazards,91,"/// If we have a top down pointer in the S_Use state, make sure that there are; /// no CFG hazards by checking the states of various bottom up pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:21,Availability,Down,Down,21,"/// If we have a Top Down pointer in the S_CanRelease state, make sure that; /// there are no CFG hazards by checking the states of various bottom up; /// pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:98,Safety,hazard,hazards,98,"/// If we have a Top Down pointer in the S_CanRelease state, make sure that; /// there are no CFG hazards by checking the states of various bottom up; /// pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:14,Availability,down,down,14,"// If any top-down local-use or possible-dec has a succ which is earlier in; // the sequence, forget it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:31,Availability,down,down,31,// Make sure that if extra top down states are added in the future that this; // code is updated to handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:89,Deployability,update,updated,89,// Make sure that if extra top down states are added in the future that this; // code is updated to handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:180,Deployability,release,releases,180,"// If bottom up, the pointer is in an S_None state, clear the sequence; // progress since the sequence in the bottom up state finished; // suggesting a mismatch in between retains/releases. This is true for; // all three cases that we are handling here: S_Retain, S_Use, and; // S_CanRelease.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:52,Usability,clear,clear,52,"// If bottom up, the pointer is in an S_None state, clear the sequence; // progress since the sequence in the bottom up state finished; // suggesting a mismatch in between retains/releases. This is true for; // all three cases that we are handling here: S_Retain, S_Use, and; // S_CanRelease.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:37,Performance,perform,perform,37,"// If we have S_Use or S_CanRelease, perform our check for cfg hazard; // checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:63,Safety,hazard,hazard,63,"// If we have S_Use or S_CanRelease, perform our check for cfg hazard; // checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:240,Performance,perform,perform,240,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:79,Safety,safe,safe,79,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:140,Safety,safe,safe,140,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:20,Usability,clear,cleared,20,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,Energy Efficiency,reduce,reduced,48,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,Optimiz,OptimizeIndividualCalls,6,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:60,Performance,optimiz,optimizable,60,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:176,Performance,optimiz,optimizable,176,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:19,Deployability,release,release,19,"// Don't do retain+release tracking for ARCInstKind::RetainRV, because; // it's better to let it remain as the first instruction after a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:19,Usability,clear,clear,19,"// Conservatively, clear MyStates for all known pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:8,Deployability,Release,ReleaseInsertPtToRCIdentityRoots,8,"// Fill ReleaseInsertPtToRCIdentityRoots, which is a map from insertion points; // to the set of RC identity roots that would be released by the release calls; // moved to the insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:129,Deployability,release,released,129,"// Fill ReleaseInsertPtToRCIdentityRoots, which is a map from insertion points; // to the set of RC identity roots that would be released by the release calls; // moved to the insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:145,Deployability,release,release,145,"// Fill ReleaseInsertPtToRCIdentityRoots, which is a map from insertion points; // to the set of RC identity roots that would be released by the release calls; // moved to the insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:67,Deployability,release,release,67,// Collect all the insertion points of the objc_release calls that release; // the RC identity root of the objc_retain call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:279,Availability,down,down,279,"// Disable code motion if the current position is S_Retain to prevent; // moving the objc_retain call past objc_release calls. If it's; // S_CanRelease or larger, it's not necessary to disable code motion as; // the insertion points that prevent the objc_retain call from moving down; // should have been set already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,Energy Efficiency,reduce,reduced,48,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,Optimiz,OptimizeIndividualCalls,6,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:60,Performance,optimiz,optimizable,60,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:176,Performance,optimiz,optimizable,176,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:84,Availability,down,down,84,// Try to form a tentative pair in between this release instruction and the; // top down pointers that we are tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,Deployability,release,release,48,// Try to form a tentative pair in between this release instruction and the; // top down pointers that we are tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:43,Deployability,Release,Release,43,"// If we succeed, copy S's RRInfo into the Release -> {Retain Set; // Map}. Then we clear S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:84,Usability,clear,clear,84,"// If we succeed, copy S's RRInfo into the Release -> {Retain Set; // Map}. Then we clear S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:19,Usability,clear,clear,19,"// Conservatively, clear MyStates for all known pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:35,Availability,down,down,35,"// Visit all the instructions, top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:31,Availability,down,down,31,// Visit the function both top-down and bottom-up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:179,Deployability,release,release,179,"// Use reverse-postorder traversals, because we magically know that loops; // will be well behaved, i.e. they won't repeatedly call retain on a single; // pointer without doing a release. We can't use the ReversePostOrderTraversal; // class here because we want the reverse-CFG postorder to consider each; // function exit point, and we want to ignore selected cycle edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,Availability,down,down,33,// Use reverse-postorder for top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:40,Deployability,Release,ReleasesToMove,40,/// Move the calls in RetainsToMove and ReleasesToMove.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:29,Deployability,release,release,29,// Insert the new retain and release calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Deployability,release,release,34,// Delete the original retain and release calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:36,Availability,down,down-collected,36,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:93,Deployability,Release,ReleasesToMove,93,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:200,Deployability,release,releases,200,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:10,Deployability,release,release,10,"// If the release does not have a reference to the retain as well,; // something happened which is unaccounted for. Do not do anything.; //; // This can happen if we catch an additive overflow during path count; // merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:13,Deployability,Release,ReleaseMetadata,13,// Merge the ReleaseMetadata and IsTailCallRelease values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:50,Deployability,release,release,50,"// If the retain does not have a reference to the release as well,; // something happened which is unaccounted for. Do not do anything.; //; // This can happen if we catch an additive overflow during path count; // merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,Safety,safe,safe,47,// We can only remove pointers if we are known safe in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:97,Deployability,release,release,97,"// Determine whether the new insertion points we computed preserve the; // balance of retain and release calls through the program.; // TODO: If the fully aggressive solution isn't valid, try to find a; // less aggressive solution which is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:170,Performance,perform,perform,170,"// At this point, we are not going to remove any RR pairs, but we still are; // able to move RR pairs. If one of our pointers is afflicted with; // CFGHazards, we cannot perform such code motion so exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:81,Deployability,release,release,81,"// Determine whether the original call points are balanced in the retain and; // release calls through the program. If not, conservatively don't touch; // them.; // TODO: It's theoretically possible to do code motion in this case, as; // long as the existing imbalances are maintained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:46,Deployability,release,releases,46,"/// Identify pairings between the retains and releases, and delete and/or move; /// them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:23,Deployability,release,released,23,"// If the object being released is in static or stack storage, we know it's; // not being managed by ObjC reference counting, so we can delete pairs; // regardless of what possible decrements or uses lie between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:36,Availability,down,down-collected,36,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:93,Deployability,Release,ReleasesToMove,93,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Performance,optimiz,optimizations,17,/// Weak pointer optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Performance,optimiz,optimizations,38,"// First, do memdep-style RLE and S2L optimizations. We can't use memdep; // itself because it uses AliasAnalysis and we need to do provenance; // queries instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:43,Availability,avail,available,43,"// TODO: For now, just look for an earlier available version of this value; // within the same block. Theoretically, we could do memdep-style non-local; // analysis too, but that would want caching. A better approach would be to; // use the technique that EarlyCSE uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:14,Performance,load,loading,14,"// If this is loading from the same pointer, replace this load's value; // with that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:58,Performance,load,load,58,"// If this is loading from the same pointer, replace this load's value; // with that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:10,Performance,load,load,10,"// If the load has a builtin retain, insert a plain retain for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Availability,redundant,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:27,Performance,load,load,27,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Safety,redund,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:86,Performance,load,load,86,// If this is storing to the same pointer and has the same size etc.; // replace this load's value with the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:10,Performance,load,load,10,"// If the load has a builtin retain, insert a plain retain for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Availability,redundant,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:27,Performance,load,load,27,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Safety,redund,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:66,Deployability,release,releases,66,/// Identify program paths which execute sequences of retains and releases which; /// can be eliminated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Deployability,Release,Releases,3,"// Releases, Retains - These are used to store the results of the main flow; // analysis. These use Value* as the key instead of Instruction* so that the; // map stays valid when we get around to rewriting code and calls get; // replaced by arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:24,Integrability,depend,dependent,24,/// Check if there is a dependent call earlier that does not have anything in; /// between the Retain and the call that can affect the reference count of their; /// shared pointer argument. Note that Retain need not be in BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:11,Integrability,depend,dependent,11,/// Find a dependent retain that precedes the given autorelease for which there; /// is nothing in between the two instructions that can affect the ref count of; /// Arg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:44,Integrability,depend,dependent,44,/// Look for an ``autorelease'' instruction dependent on Arg such that there are; /// no instructions dependent on Arg that need a positive ref count in between; /// the autorelease and the ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:102,Integrability,depend,dependent,102,/// Look for an ``autorelease'' instruction dependent on Arg such that there are; /// no instructions dependent on Arg that need a positive ref count in between; /// the autorelease and the ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:80,Integrability,depend,dependent,80,// Look for an ``autorelease'' instruction that is a predecessor of Ret and; // dependent on Arg such that there are no instructions dependent on Arg; // that need a positive ref count in between the autorelease and Ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:133,Integrability,depend,dependent,133,// Look for an ``autorelease'' instruction that is a predecessor of Ret and; // dependent on Arg such that there are no instructions dependent on Arg; // that need a positive ref count in between the autorelease and Ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Usability,Intuit,Intuitively,3,"// Intuitively, objc_retain and others are nocapture, however in practice; // they are not, because they return their argument value. And objc_release; // calls finalizers which can have arbitrary side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Performance,cache,cache,38,// Initialize our runtime entry point cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:2,Integrability,Contract,ContractPass,2,/*ContractPass=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:13,Performance,perform,performs,13,"// This pass performs several distinct transformations. As a compile-time aid; // when compiling code that isn't ObjC, skip these if the relevant ObjC; // library functions aren't declared.; // Preliminary optimizations. This also computes UsedInThisFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:206,Performance,optimiz,optimizations,206,"// This pass performs several distinct transformations. As a compile-time aid; // when compiling code that isn't ObjC, skip these if the relevant ObjC; // library functions aren't declared.; // Preliminary optimizations. This also computes UsedInThisFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations for weak pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:28,Deployability,release,release,28,// Optimizations for retain+release pairs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations for retain+release pairs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:79,Deployability,release,release,79,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:7,Performance,Optimiz,OptimizeSequences,7,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:103,Safety,detect,detected,103,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations if objc_autorelease is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:27,Performance,optimiz,optimization,27,// Gather statistics after optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:41,Performance,Optimiz,Optimization,41,"//===- ProvenanceAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file defines a special form of Alias Analysis called ``Provenance; /// Analysis''. The word ``provenance'' refers to the history of the ownership; /// of an object. Thus ``Provenance Analysis'' is an analysis which attempts to; /// use various techniques to determine if locally; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:85,Energy Efficiency,efficient,efficient,85,"// If the values are PHIs in the same block, we can do a more precise as well; // as efficient check: just check for relations between the values on; // corresponding edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:4,Testability,Test,Test,4,"/// Test if the value of P, or any value covered by its provenance, is ever; /// stored within the function (not counting callees).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:43,Performance,load,load,43,// An ObjC-Identified object can't alias a load if it is never locally stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h:39,Performance,Optimiz,Optimization,39,"//===- ProvenanceAnalysis.h - ObjC ARC Optimization -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file declares a special form of Alias Analysis called ``Provenance; /// Analysis''. The word ``provenance'' refers to the history of the ownership; /// of an object. Thus ``Provenance Analysis'' is an analysis which attempts to; /// use various techniques to determine if locally; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp:50,Performance,Optimiz,Optimization,50,"//===- ProvenanceAnalysisEvaluator.cpp - ObjC ARC Optimization ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:21,Deployability,release,releases,21,"// If both sides are releases, choose the more conservative one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:28,Deployability,Release,ReleaseMetadata,28,// Conservatively merge the ReleaseMetadata information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:117,Safety,avoid,avoid,117,"// If we're doing a merge on a path that's previously seen a partial; // merge, conservatively drop the sequence, to avoid doing partial; // RR elimination. If the branch predicates for the two merge differ,; // mixing them is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:227,Safety,unsafe,unsafe,227,"// If we're doing a merge on a path that's previously seen a partial; // merge, conservatively drop the sequence, to avoid doing partial; // RR elimination. If the branch predicates for the two merge differ,; // mixing them is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:17,Deployability,release,releases,17,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:163,Deployability,release,release,163,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:218,Deployability,release,release,218,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:293,Deployability,release,release,293,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:381,Safety,avoid,avoids,381,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:370,Usability,simpl,simple,370,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:82,Deployability,release,release,82,"// If OldSeq is not S_Use or OldSeq is S_Use and we are tracking an; // imprecise release, clear our reverse insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:91,Usability,clear,clear,91,"// If OldSeq is not S_Use or OldSeq is S_Use and we are tracking an; // imprecise release, clear our reverse insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:22,Deployability,release,releases,22,// Check for possible releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:19,Deployability,release,release,19,"// Don't do retain+release tracking for ARCInstKind::RetainRV, because; // it's; // better to let it remain as the first instruction after a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:290,Deployability,release,release,290,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:378,Safety,avoid,avoids,378,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:367,Usability,simpl,simple,367,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:22,Deployability,release,releases,22,// Check for possible releases. Treat clang.arc.use as a releasing instruction; // to prevent sinking a retain past it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:621,Performance,optimiz,optimization,621,"//===- PtrState.h - ARC State for a Ptr -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains declarations for the ARC state associated with a ptr. It; // is only used by the ARC Sequence Dataflow computation. By separating this; // from the actual dataflow, it is easier to consider the mechanics of the ARC; // optimization separate from the actual predicates being used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:72,Deployability,release,release,72,/// Unidirectional information about either a; /// retain-decrement-use-release sequence or release-use-decrement-retain; /// reverse sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:92,Deployability,release,release-use-decrement-retain,92,/// Unidirectional information about either a; /// retain-decrement-use-release sequence or release-use-decrement-retain; /// reverse sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:236,Deployability,release,release,236,"/// After an objc_retain, the reference count of the referenced; /// object is known to be positive. Similarly, before an objc_release, the; /// reference count of the referenced object is known to be positive. If; /// there are retain-release pairs in code regions where the retain count; /// is known to be positive, they can be eliminated, regardless of any side; /// effects between them.; ///; /// Also, a retain+release pair nested within another retain+release; /// pair all on the known same pointer value can be eliminated, regardless; /// of any intervening side effects.; ///; /// KnownSafe is true when either of these conditions is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:418,Deployability,release,release,418,"/// After an objc_retain, the reference count of the referenced; /// object is known to be positive. Similarly, before an objc_release, the; /// reference count of the referenced object is known to be positive. If; /// there are retain-release pairs in code regions where the retain count; /// is known to be positive, they can be eliminated, regardless of any side; /// effects between them.; ///; /// Also, a retain+release pair nested within another retain+release; /// pair all on the known same pointer value can be eliminated, regardless; /// of any intervening side effects.; ///; /// KnownSafe is true when either of these conditions is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:460,Deployability,release,release,460,"/// After an objc_retain, the reference count of the referenced; /// object is known to be positive. Similarly, before an objc_release, the; /// reference count of the referenced object is known to be positive. If; /// there are retain-release pairs in code regions where the retain count; /// is known to be positive, they can be eliminated, regardless of any side; /// effects between them.; ///; /// Also, a retain+release pair nested within another retain+release; /// pair all on the known same pointer value can be eliminated, regardless; /// of any intervening side effects.; ///; /// KnownSafe is true when either of these conditions is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:14,Availability,down,down,14,"/// For a top-down sequence, the set of objc_retains or; /// objc_retainBlocks. For bottom-up, the set of objc_releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:84,Deployability,release,release,84,"/// If this is true, we cannot perform code motion but can still remove; /// retain/release pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:31,Performance,perform,perform,31,"/// If this is true, we cannot perform code motion but can still remove; /// retain/release pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:100,Deployability,release,releases,100,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:64,Safety,detect,detected,64,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:31,Deployability,release,releases,31,/// Return true if this set of releases can be paired with a release. Modifies; /// state appropriately to reflect that the matching occurred if it is; /// successful.; ///; /// It is assumed that one has already checked that the RCIdentity of the; /// retain and the RCIdentity of this ptr state are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:61,Deployability,release,release,61,/// Return true if this set of releases can be paired with a release. Modifies; /// state appropriately to reflect that the matching occurred if it is; /// successful.; ///; /// It is assumed that one has already checked that the RCIdentity of the; /// retain and the RCIdentity of this ptr state are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:100,Deployability,release,releases,100,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:64,Safety,detect,detected,64,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:73,Deployability,release,release,73,/// Return true if this set of retains can be paired with the given; /// release. Modifies state appropriately to reflect that the matching; /// occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:26,Performance,perform,perform,26,"//===- ADCE.cpp - Code to perform dead code elimination -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Aggressive Dead Code Elimination pass. This pass; // optimistically assumes that all instructions are dead until proven otherwise,; // allowing it to eliminate dead computations that other DCE passes do not; // catch, particularly involving loop computations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:50,Integrability,interface,interface,50,// This is a temporary option until we change the interface to this pass based; // on optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:86,Performance,optimiz,optimization,86,// This is a temporary option until we change the interface to this pass based; // on optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:10,Security,access,access,10,/// Quick access to information for block containing associated Instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:12,Integrability,depend,dependence,12,/// Control dependence sources need to be live for this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:10,Security,access,access,10,"/// Quick access to the LiveInfo for the terminator,; /// holds the value &InstInfo[Terminator]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:4,Performance,Cache,Cache,4,/// Cache of BB->getTerminator().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:50,Deployability,update,updates,50,"// ADCE does not use DominatorTree per se, but it updates it to preserve the; // analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:66,Integrability,depend,dependence,66,/// The set of blocks which we have determined whose control; /// dependence sources must be live and which have not had; /// those dependences analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:132,Integrability,depend,dependences,132,/// The set of blocks which we have determined whose control; /// dependence sources must be live and which have not had; /// those dependences analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:87,Integrability,depend,dependences,87,/// Analyze dead branches to find those whose branches are the sources; /// of control dependences impacting a live block. Those branches are; /// marked live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:95,Modifiability,rewrite,rewrite,95,/// Identify connected sections of the control flow graph which have; /// dead terminators and rewrite the control flow graph to remove them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:111,Performance,load,load,111,// We will have an entry in the map for each block so we grow the; // structure to twice that size to keep the load factor low in the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:134,Security,hash,hash,134,// We will have an entry in the map for each block so we grow the; // structure to twice that size to keep the load factor low in the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:104,Security,hash,hash,104,"// Iterate over blocks and initialize BlockInfoVec entries, count; // instructions to size the InstInfo hash table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:21,Testability,test,test,21,// TODO -- move this test into llvm::isInstructionTriviallyDead,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:59,Availability,Alive,AliveScopes,59,"// Even though DILocations are not scopes, shove them into AliveScopes so we; // don't revisit them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:150,Integrability,depend,dependent,150,"// If a predecessor block is not live, mark it as control-flow live; // which will trigger marking live branches upon which; // that block is control dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:126,Integrability,depend,dependent,126,// The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:250,Integrability,depend,dependence,250,// The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:101,Deployability,update,update,101,//===----------------------------------------------------------------------===//; //; // Routines to update the CFG and SSA information before removing dead code.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:89,Integrability,Rout,Routines,89,//===----------------------------------------------------------------------===//; //; // Routines to update the CFG and SSA information before removing dead code.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Deployability,Update,Updates,3,// Updates control and dataflow around dead blocks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:31,Availability,alive,alive,31,// Check if the instruction is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:51,Availability,alive,alive,51,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:30,Modifiability,variab,variable,30,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:176,Availability,alive,alive,176,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:126,Modifiability,variab,variable,126,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:77,Performance,optimiz,optimization,77,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:211,Safety,safe,safely,211,"// The inverse of the live set is the dead set. These are those instructions; // that have no side effects and do not influence the control flow or return; // value of the function, and may therefore be deleted safely.; // NOTE: We reuse the Worklist vector here for memory efficiency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:139,Availability,alive,alive,139,"// With ""RemoveDIs"" debug-info stored in DPValue objects, debug-info; // attached to this instruction, and drop any for scopes that aren't alive,; // like the rest of this loop does. Extending support to assignment tracking; // is future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:183,Modifiability,Extend,Extending,183,"// With ""RemoveDIs"" debug-info stored in DPValue objects, debug-info; // attached to this instruction, and drop any for scopes that aren't alive,; // like the rest of this loop does. Extending support to assignment tracking; // is future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Safety,Avoid,Avoid,3,// Avoid removing a DPV that is linked to instructions because it holds; // information about an existing store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:31,Availability,alive,alive,31,// Check if the instruction is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Safety,Avoid,Avoid,3,// Avoid removing a dbg.assign that is linked to instructions because it; // holds information about an existing store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:51,Availability,alive,alive,51,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:30,Modifiability,variab,variable,30,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:33,Deployability,update,update,33,// Collect removed successors to update the (Post)DominatorTrees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:314,Modifiability,extend,extend,314,"// This provides a post-order numbering of the reverse control flow graph; // Note that it is incomplete in the presence of infinite loops but we don't; // need numbers blocks which don't reach the end of the functions since; // all branches in those blocks are forced live.; // For each block without successors, extend the DFS from the block; // backward through the graph",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:102,Deployability,integrat,integration,102,//===----------------------------------------------------------------------===//; //; // Pass Manager integration code; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:102,Integrability,integrat,integration,102,//===----------------------------------------------------------------------===//; //; // Pass Manager integration code; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:108,Availability,avail,available,108,"// ADCE does not need DominatorTree, but require DominatorTree here; // to update analysis if it is already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:75,Deployability,update,update,75,"// ADCE does not need DominatorTree, but require DominatorTree here; // to update analysis if it is already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:89,Performance,Load,Load,89,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:519,Performance,load,load,519,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:702,Performance,load,loads,702,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:224,Energy Efficiency,reduce,reduced,224,"// Given an expression for the (constant) alignment, AlignSCEV, and an; // expression for the displacement between a pointer and the aligned address,; // DiffSCEV, compute the alignment of the displaced pointer if it can be reduced; // to a constant. Using SCEV to compute alignment handles the case where; // DiffSCEV is a recurrence with constant start such that the aligned offset; // is constant. e.g. {16,+,32} % 32 -> 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:134,Energy Efficiency,power,power,134,"// If the displacement is not an exact multiple, but the remainder is a; // constant, then return this remainder (but only if it is a power of 2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:82,Modifiability,extend,extended,82,"// On 32-bit platforms, DiffSCEV might now have type i32 -- we've always; // sign-extended OffSCEV to i64, so make sure they agree again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:215,Performance,load,loads,215,"// The relative offset to the alignment assumption did not yield a constant,; // but we should try harder: if we assume that a is 32-byte aligned, then in; // for (i = 0; i < 1024; i += 4) r += a[i]; not all of the loads from a are; // 32-byte aligned, but instead alternate between 32 and 16-byte alignment.; // As a result, the new alignment will not be a constant, but can still; // be improved over the default (of 4) to 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:8,Energy Efficiency,power,power,8,// Only power of two alignments are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:18,Deployability,update,updated,18,"// Now that we've updated that use of the pointer, look for other uses of; // the pointer to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:93,Deployability,update,update,93,"// Now that we've updated that use of the pointer, look for other uses of; // the pointer to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:633,Usability,simpl,simplify,633,"//===---- BDCE.cpp - Bit-tracking dead code elimination -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Bit-Tracking Dead Code Elimination pass. Some; // instructions (shifts, some ands, ors, etc.) kill some of their input bits.; // We track these dead bits and remove instructions that compute only these; // dead bits. We also simplify sext that generates unused extension bits,; // converting it to a zext.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:109,Usability,clear,cleared,109,"/// If an instruction is trivialized (dead), then the chain of users of that; /// instruction may need to be cleared of assumptions that can no longer be; /// guaranteed correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:349,Safety,avoid,avoid,349,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:566,Safety,avoid,avoid,566,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:572,Testability,assert,asserting,572,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:57,Safety,avoid,avoid,57,// DFS through subsequent users while tracking visits to avoid cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:182,Security,access,accesses,182,"// We do not have to worry about llvm.assume or range metadata:; // 1. llvm.assume demands its operand, so trivializing can't change it.; // 2. range metadata only applies to memory accesses which demand all bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:85,Safety,avoid,avoid,85,"// If the instruction has side effects and no non-dbg uses,; // skip it. This way we avoid computing known bits on an instruction; // that will not help us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:21,Safety,detect,detects,21,// DemandedBits only detects dead integer uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:561,Security,expose,expose,561,"//===- CallSiteSplitting.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a transformation that tries to split a call-site to pass; // more constrained arguments if its argument is predicated in the control flow; // so that we can expose better context to the later passes (e.g, inliner, jump; // threading, or IPA-CP based function cloning, etc.).; // As of now we support two cases :; //; // 1) Try to a split call-site with constrained arguments, if any constraints; // on any argument can be found by following the single predecessors of the; // all site's predecessors. Currently this pass only handles call-sites with 2; // predecessors. For example, in the code below, we try to split the call-site; // since we can predicate the argument(ptr) based on the OR condition.; //; // Split from :; // if (!ptr || c); // callee(ptr);; // to :; // if (!ptr); // callee(null) // set the known constant value; // else if (c); // callee(nonnull ptr) // set non-null attribute in the argument; //; // 2) We can also split a call-site based on constant incoming values of a PHI; // For example,; // from :; // Header:; // %c = icmp eq i32 %i1, %i2; // br i1 %c, label %Tail, label %TBB; // TBB:; // br label Tail%; // Tail:; // %p = phi i32 [ 0, %Header], [ 1, %TBB]; // call void @bar(i32 %p); // to; // Header:; // %c = icmp eq i32 %i1, %i2; // br i1 %c, label %Tail-split0, label %TBB; // TBB:; // br label %Tail-split1; // Tail-split0:; // call void @bar(i32 0); // br label %Tail; // Tail-split1:; // call void @bar(i32 1); // br label %Tail; // Tail:; // %p = phi i32 [ 0, %Tail-split0 ], [ 1, %Tail-split1 ]; //; //===---------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:245,Deployability,update,updated,245,// Allow splitting a call-site only when the CodeSize cost of the; // instructions before the call is less then DuplicationThreshold. The; // instructions before the call will be duplicated in the split blocks and; // corresponding uses will be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:63,Usability,simpl,simple,63,"// ValueToValueMapTy is neither copy nor moveable, so we use a simple array; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:48,Deployability,patch,patching,48,// Erase the tail block once done with musttail patching,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1189,Energy Efficiency,reduce,reduce,1189,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1553,Performance,perform,perform,1553,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1656,Performance,optimiz,optimization,1656,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1810,Performance,load,load,1810,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:785,Usability,simpl,simple,785,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1730,Usability,simpl,simple,1730,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Performance,Perform,Perform,4,/// Perform the constant hoisting optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:34,Performance,optimiz,optimization,34,/// Perform the constant hoisting optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:7,Usability,simpl,simple,7,// The simple and common case. This also includes constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:39,Availability,down,down,39,// Sort the nodes in Candidates in top-down order and save the nodes; // in Orders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:84,Deployability,update,update,84,"// Initially, ParentInsertPts is empty and ParentPtsFreq is 0. Every child; // will update its parent's ParentInsertPts and ParentPtsFreq.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:299,Energy Efficiency,reduce,reduce,299,"// Choose to insert in Node or in subtree of Node.; // Don't hoist to EHPad because we may not find a proper place to insert; // in EHPad.; // If the total frequency of InsertPts is the same as the frequency of the; // target Node, and InsertPts contains more than one nodes, choose hoisting; // to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:99,Performance,load,load,99,"// A constant GEP expression that has a GlobalVariable as base pointer is; // usually lowered to a load from constant pool. Such operation is unlikely; // to be cheaper than compute it by <Base + Offset>, which can be lowered to; // an ADD instruction or folded into Load/Store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:267,Performance,Load,Load,267,"// A constant GEP expression that has a GlobalVariable as base pointer is; // usually lowered to a load from constant pool. Such operation is unlikely; // to be cheaper than compute it by <Base + Offset>, which can be lowered to; // an ADD instruction or folded into Load/Store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:147,Modifiability,variab,variables,147,// The cost of materializing the constants (defined in; // `TargetTransformInfo::getIntImmCostInst`) for instructions which only; // take constant variables is lower than `TargetTransformInfo::TCC_Basic`.; // So it's safe for us to collect constant candidates from all; // IntrinsicInsts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:217,Safety,safe,safe,217,// The cost of materializing the constants (defined in; // `TargetTransformInfo::getIntImmCostInst`) for instructions which only; // take constant variables is lower than `TargetTransformInfo::TCC_Basic`.; // So it's safe for us to collect constant candidates from all; // IntrinsicInsts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:3,Usability,Simpl,Simple,3,// Simple linear scan through the sorted constant candidate vector for viable; // merge candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Deployability,Update,Updates,4,"/// Updates the operand at Idx in instruction Inst with the result of; /// instruction Mat. If the instruction is a PHI node then special; /// handling for duplicate values from the same incoming basic block is; /// required.; /// \return The update will always succeed, but the return value indicated if; /// Mat was used for the update or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:243,Deployability,update,update,243,"/// Updates the operand at Idx in instruction Inst with the result of; /// instruction Mat. If the instruction is a PHI node then special; /// handling for duplicate values from the same incoming basic block is; /// required.; /// \return The update will always succeed, but the return value indicated if; /// Mat was used for the update or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:331,Deployability,update,update,331,"/// Updates the operand at Idx in instruction Inst with the result of; /// instruction Mat. If the instruction is a PHI node then special; /// handling for duplicate values from the same incoming basic block is; /// required.; /// \return The update will always succeed, but the return value indicated if; /// Mat was used for the update or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:354,Modifiability,variab,variable,354,"// Check if any previous operand of the PHI node has the same incoming basic; // block. This is a very odd case that happens when the incoming basic block; // has a switch statement. In this case use the same value as the previous; // operand(s), otherwise we will fail verification due to different values.; // The values are actually the same, but the variable names are different; // and the verifier doesn't like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:60,Deployability,update,update,60,/// Emit materialization code for all rebased constants and update their; /// users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:68,Safety,avoid,avoid,68,// Check if we already have visited this cast instruction before to avoid; // unnecessary cloning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:66,Deployability,update,update,66,// Use the same debug location as the instruction we are about to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:28,Integrability,depend,depending,28,"// First, collect constants depending on this IP of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:25,Integrability,depend,depend,25,"// If only few constants depend on this IP of base, skip rebasing,; // assuming the base and the rebased have the same materialization cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:51,Integrability,depend,depending,51,// Emit materialization code for rebased constants depending on this IP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize expensive integer constants in the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:69,Integrability,depend,dependent,69,// Finally hoist the base constant and emit materialization code for dependent; // constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:163,Usability,simpl,simplify,163,/// Represents either; /// * a condition that holds on entry to a block (=condition fact); /// * an assume (=assume fact); /// * a use of a compare instruction to simplify.; /// It also tracks the Dominator DFS in and out numbers for each entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:22,Usability,simpl,simplify,22,/// An instruction to simplify (e.g. an overflow math; /// intrinsics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:39,Usability,simpl,simplify,39,/// An use of a compare instruction to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:25,Usability,simpl,simplified,25,// The use may have been simplified to a constant already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:4,Modifiability,Variab,Variables,4,/// Variables that can be removed from the system once the stack entry gets; /// removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper encapsulating separate constraint systems and corresponding value; /// mappings for both unsigned and signed information. Facts are added to and; /// conditions are checked against the corresponding system depending on the; /// signed-ness of their predicates. While the information is kept separate; /// based on signed-ness, certain conditions can be transferred between the two; /// systems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:218,Integrability,depend,depending,218,"/// Wrapper encapsulating separate constraint systems and corresponding value; /// mappings for both unsigned and signed information. Facts are added to and; /// conditions are checked against the corresponding system depending on the; /// signed-ness of their predicates. While the information is kept separate; /// based on signed-ness, certain conditions can be transferred between the two; /// systems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:156,Modifiability,variab,variables,156,"/// Turn a comparison of the form \p Op0 \p Pred \p Op1 into a vector of; /// constraints, using indices from the corresponding constraint system.; /// New variables that need to be added to the system are collected in; /// \p NewVariables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:261,Modifiability,variab,variables,261,"/// Turns a comparison of the form \p Op0 \p Pred \p Op1 into a vector of; /// constraints using getConstraint. Returns an empty constraint if the result; /// cannot be used to query the existing constraint system, e.g. because it; /// would require adding new variables. Also tries to convert signed; /// predicates to unsigned ones if possible to allow using the unsigned system; /// which increases the effectiveness of the signed <-> unsigned transfer; /// logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:461,Testability,log,logic,461,"/// Turns a comparison of the form \p Op0 \p Pred \p Op1 into a vector of; /// constraints using getConstraint. Returns an empty constraint if the result; /// cannot be used to query the existing constraint system, e.g. because it; /// would require adding new variables. Also tries to convert signed; /// predicates to unsigned ones if possible to allow using the unsigned system; /// which increases the effectiveness of the signed <-> unsigned transfer; /// logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:32,Modifiability,Variab,Variable,32,/// Represents a (Coefficient * Variable) entry after IR decomposition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:16,Modifiability,variab,variable,16,/// True if the variable is known positive in the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:3,Modifiability,Variab,Variable,3,"// Variable and constant offsets for a chain of GEPs, with base pointer BasePtr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:32,Modifiability,variab,variable,32,"// namespace; // Try to collect variable and constant offsets for \p GEP, partly traversing; // nested GEPs. Returns an OffsetResult with nullptr as BasePtr of collecting; // the offset fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:40,Modifiability,variab,variable,40,// TODO: Support cases with more than 1 variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:15,Modifiability,variab,variable,15,"// More than 1 variable index, use outer result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:77,Modifiability,Variab,Variable,77,"// Decomposes \p V into a constant offset + list of pairs { Coefficient,; // Variable } where Coefficient * Variable. The sum of the constant offset and; // pairs equals \p V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:108,Modifiability,Variab,Variable,108,"// Decomposes \p V into a constant offset + list of pairs { Coefficient,; // Variable } where Coefficient * Variable. The sum of the constant offset and; // pairs equals \p V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:101,Integrability,wrap,wrap,101,"// Don't handle integers > 64 bit. Our coefficients are 64-bit large, so; // coefficient add/mul may wrap, while the operation in the full bit width; // would not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:17,Modifiability,variab,variables,17,// Make sure all variables have entries in Value2Index or NewVariables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:11,Modifiability,variab,variables,11,// Collect variables that are known to be positive in all uses in the; // constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:28,Modifiability,Variab,Variable,28,"// Remove any (Coefficient, Variable) entry where the Coefficient is 0 for new; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:83,Modifiability,variab,variables,83,"// Remove any (Coefficient, Variable) entry where the Coefficient is 0 for new; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:29,Modifiability,variab,variables,29,// Add extra constraints for variables that are known positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:91,Modifiability,variab,variables,91,// Handle trivially true compares directly to avoid adding V UGE 0 constraints; // for all variables in the unsigned system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:46,Safety,avoid,avoid,46,// Handle trivially true compares directly to avoid adding V UGE 0 constraints; // for all variables in the unsigned system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:197,Testability,log,logic,197,"// If both operands are known to be non-negative, change signed predicates to; // unsigned ones. This increases the reasoning effectiveness in combination; // with the signed <-> unsigned transfer logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:25,Integrability,depend,depends,25,// FIXME: This currently depends on the order we add facts. Ideally we; // would first add all known facts and only then try to add additional; // facts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:39,Integrability,wrap,wrap,39,"// If SCEV guarantees that AR does not wrap, PN >= StartValue can be added; // unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:9,Modifiability,Extend,Extend,9,// TODO: Extend to allow steps > -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:10,Integrability,wrap,wrap,10,// AR may wrap.; // Add StartValue >= PN conditional on B <= StartValue which guarantees that; // the loop exits before wrapping with a step of -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:120,Integrability,wrap,wrapping,120,// AR may wrap.; // Add StartValue >= PN conditional on B <= StartValue which guarantees that; // the loop exits before wrapping with a step of -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:10,Integrability,wrap,wrap,10,// AR may wrap. Add PN >= StartValue conditional on StartValue <= B which; // guarantees that the loop exits before wrapping in combination with the; // restrictions on B and the step above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:116,Integrability,wrap,wrapping,116,// AR may wrap. Add PN >= StartValue conditional on StartValue <= B which; // guarantees that the loop exits before wrapping in combination with the; // restrictions on B and the step above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:3,Performance,Queue,Queue,3,// Queue conditions and assumes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:34,Usability,simpl,simplification,34,// Enqueue ssub_with_overflow for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:82,Usability,simpl,simplifying,82,// TODO: Check if it is possible to instead only added the min/max facts; // when simplifying uses of the min/max intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:107,Performance,queue,queue,107,"// If the condition is a chain of ORs/AND and the successor only has the; // current block as predecessor, queue conditions for the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:72,Usability,simpl,simplifying,72,"// namespace; /// Helper function to generate a reproducer function for simplifying \p Cond.; /// The reproducer function contains a series of @llvm.assume calls, one for; /// each condition in \p Stack. For each condition, the operand instruction are; /// cloned until we reach operands that have an entry in \p Value2Index. Those; /// will then be added as function arguments. \p DT is used to order cloned; /// instructions. The reproducer function will get added to \p M, if it is; /// non-null. Otherwise no reproducer function is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:142,Deployability,Update,Update,142,"// Clone instructions in \p Ops and their operands recursively until reaching; // an value in Value2Index (external input to the reproducer). Update Old2New; // mapping for the original and cloned instructions. Sort instructions to; // clone by dominance, then insert the cloned instructions in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:344,Testability,assert,assert,344,"// Materialize the assumptions for the reproducer using the entries in Stack.; // That is, first clone the operands of the condition recursively until we; // reach an external input to the reproducer and add them to the reproducer; // function. Then add an ICmp for the condition (with the inverse predicate if; // the entry is negated) and an assert using the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:104,Availability,avail,available,104,// Conditions in an assume trivially simplify to true. Skip uses; // in assume calls to not destroy the available information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:37,Usability,simpl,simplify,37,// Conditions in an assume trivially simplify to true. Skip uses; // in assume calls to not destroy the available information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:10,Modifiability,variab,variables,10,// Remove variables in the system that went out of scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:16,Usability,simpl,simplify,16,"// Don't try to simplify the first condition of a select by the second, as; // this may make the select more poisonous than the original one.; // TODO: check if the first operand may be poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:40,Usability,simpl,simplified,40,// Check if the second condition can be simplified now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:50,Modifiability,variab,variables,50,"// If R has been added to the system, add the new variables and queue it for; // removal once it goes out-of-scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:64,Performance,queue,queue,64,"// If R has been added to the system, add the new variables and queue it for; // removal once it goes out-of-scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:86,Usability,simpl,simplified,86,"// If A s>= B && B s>= 0, ssub.with.overflow(a, b) should not overflow and; // can be simplified to a regular sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:536,Testability,log,logic,536,"// Next, sort worklist by dominance, so that dominating conditions to check; // and facts come before conditions and facts dominated by them. If a; // condition to check and a fact have the same numbers, conditional facts come; // first. Assume facts and checks are ordered according to their relative; // order in the containing basic block. Also make sure conditions with; // constant operands come before conditions without constant operands. This; // increases the effectiveness of the current signed <-> unsigned fact; // transfer logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a phi with constant incoming values that match the edge; /// values of a non-constant value on all other edges:; /// bb0:; /// %isnull = icmp eq i8* %x, null; /// br i1 %isnull, label %bb2, label %bb1; /// bb1:; /// br label %bb2; /// bb2:; /// %r = phi i8* [ %x, %bb1 ], [ null, %bb0 ]; /// -->; /// %r = %x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:32,Modifiability,variab,variable,32,// We have a phi with exactly 1 variable incoming value and 1 or more constant; // incoming values. See if all constant incoming values can be mapped back to; // the same incoming variable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:180,Modifiability,variab,variable,180,// We have a phi with exactly 1 variable incoming value and 1 or more constant; // incoming values. See if all constant incoming values can be mapped back to; // the same incoming variable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:48,Modifiability,variab,variable,48,// All constant incoming values map to the same variable along the incoming; // edges of the phi. The phi is unnecessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:12,Usability,learn,learns,12,"// Once LVI learns to handle vector types, we could also add support; // for vector type constants that are not all zeroes or all ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:289,Availability,avail,available,289,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:378,Safety,safe,safely,378,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:4,Usability,Simpl,Simplify,4,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:79,Testability,log,logic,79,// The condition can be modified by removePredecessor's PHI simplification; // logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:60,Usability,simpl,simplification,60,// The condition can be modified by removePredecessor's PHI simplification; // logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:26,Usability,simpl,simplified,26,// If the switch has been simplified to the point where it can be replaced; // by a branch then do so now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:61,Usability,simpl,simplify,61,"// See if @llvm.abs argument is alays positive/negative, and simplify.; // Notably, INT_MIN can belong to either range, regardless of the NSW,; // because it is negation-invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:31,Integrability,wrap,wrap,31,// See if we can infer some no-wrap flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite this with.overflow intrinsic as non-overflowing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:36,Integrability,wrap,wrap,36,// See if we can infer the other no-wrap too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:36,Integrability,wrap,wrap,36,// See if we can infer the other no-wrap too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:253,Performance,optimiz,optimization,253,"// Deopt bundle operands are intended to capture state with minimal; // perturbance of the code otherwise. If we can find a constant value for; // any such operand and remove a use of the original value, that's; // desireable since it may allow further optimization of that value (e.g. via; // single use rules in instcombine). Since deopt uses tend to,; // idiomatically, appear along rare conditional paths, it's reasonable likely; // we may have a conditional fact with which LVI can fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:38,Availability,down,down,38,/// Try to shrink a sdiv/srem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:59,Energy Efficiency,power,power,59,/// Try to shrink a sdiv/srem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:21,Energy Efficiency,power,power,21,// Find the smallest power of two bitwidth that's sufficient to hold Instr's; // operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:66,Energy Efficiency,power,power,66,// NewWidth might be greater than OrigWidth if OrigWidth is not a power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:470,Modifiability,rewrite,rewrite,470,"// Given; // R = X u% Y; // We can represent the modulo operation as a loop/self-recursion:; // urem_rec(X, Y):; // Z = X - Y; // if X u< Y; // ret X; // else; // ret urem_rec(Z, Y); // which isn't better, but if we only need a single iteration; // to compute the answer, this becomes quite good:; // R = X < Y ? X : X - Y iff X u< 2*Y (w/ unsigned saturation); // Now, we do not care about all full multiples of Y in X, they do not change; // the answer, thus we could rewrite the expression as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y; // so we don't need the *first* iteration to return, we just need to; // know *which* iteration will always return, so we could also rewrite it as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y iff X* u< 2*Y (w/ unsigned saturation); // but that does not seem profitable here.; // Even if we don't know X's range, the divisor may be so large, X can't ever; // be 2x larger than that. I.e. if divisor is always negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:677,Modifiability,rewrite,rewrite,677,"// Given; // R = X u% Y; // We can represent the modulo operation as a loop/self-recursion:; // urem_rec(X, Y):; // Z = X - Y; // if X u< Y; // ret X; // else; // ret urem_rec(Z, Y); // which isn't better, but if we only need a single iteration; // to compute the answer, this becomes quite good:; // R = X < Y ? X : X - Y iff X u< 2*Y (w/ unsigned saturation); // Now, we do not care about all full multiples of Y in X, they do not change; // the answer, thus we could rewrite the expression as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y; // so we don't need the *first* iteration to return, we just need to; // know *which* iteration will always return, so we could also rewrite it as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y iff X* u< 2*Y (w/ unsigned saturation); // but that does not seem profitable here.; // Even if we don't know X's range, the divisor may be so large, X can't ever; // be 2x larger than that. I.e. if divisor is always negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:38,Availability,down,down,38,/// Try to shrink a udiv/urem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:59,Energy Efficiency,power,power,59,/// Try to shrink a udiv/urem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:21,Energy Efficiency,power,power,21,// Find the smallest power of two bitwidth that's sufficient to hold Instr's; // operands.; // What is the smallest bit width that can accommodate the entire value ranges; // of both of the operands?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:66,Energy Efficiency,power,power,66,// NewWidth might be greater than OrigWidth if OrigWidth is not a power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:10,Usability,simpl,simplify,10,// Try to simplify our new urem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:10,Usability,simpl,simplify,10,// Try to simplify our new udiv.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:62,Usability,simpl,simplify,62,// Visiting in a pre-order depth-first traversal causes us to simplify early; // blocks before querying later blocks (which require us to analyze early; // blocks). Eagerly simplifying shallow blocks means there is strictly less; // work to do for deep blocks. This also means we don't visit unreachable; // blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:173,Usability,simpl,simplifying,173,// Visiting in a pre-order depth-first traversal causes us to simplify early; // blocks before querying later blocks (which require us to analyze early; // blocks). Eagerly simplifying shallow blocks means there is strictly less; // work to do for deep blocks. This also means we don't visit unreachable; // blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:104,Testability,test,tests,104,"// Try to determine the return value if we can. This is mainly here to; // simplify the writing of unit tests, but also helps to enable IPO by; // constant folding the return values of callees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:75,Usability,simpl,simplify,75,"// Try to determine the return value if we can. This is mainly here to; // simplify the writing of unit tests, but also helps to enable IPO by; // constant folding the return values of callees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:15,Availability,alive,alive,15,"// Keeping LVI alive is expensive, both because it uses a lot of memory, and; // because invalidating values in LVI is expensive. While CVP does preserve; // LVI, we know that passes after JumpThreading+CVP will not need the result; // of this analysis, so we forcefully discard it early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:25,Performance,perform,perform,25,"//===- DCE.cpp - Code to perform dead code elimination --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead inst elimination and dead code elimination.; //; // Dead Inst Elimination performs a single pass over the function removing; // instructions that are obviously dead. Dead Code Elimination is similar, but; // it rechecks instructions that were used by removed instructions to see if; // they are newly dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:483,Performance,perform,performs,483,"//===- DCE.cpp - Code to perform dead code elimination --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead inst elimination and dead code elimination.; //; // Dead Inst Elimination performs a single pass over the function removing; // instructions that are obviously dead. Dead Code Elimination is similar, but; // it rechecks instructions that were used by removed instructions to see if; // they are newly dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:121,Safety,avoid,avoids,121,"// Iterate over the original function, only adding insts to the worklist; // if they actually need to be revisited. This avoids having to pre-init; // the worklist with the entire function's worth of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:149,Availability,down,downstream,149,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:41,Performance,optimiz,optimize,41,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:100,Performance,optimiz,optimizing,100,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:359,Performance,optimiz,optimizations,359,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:55,Safety,safe,safely,55,/// Returns true if the end of this instruction can be safely shortened in; /// length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:69,Safety,safe,safe,69,// Do shorten memory intrinsics.; // FIXME: Add memmove if it's also safe to transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:61,Safety,safe,safely,61,/// Returns true if the beginning of this instruction can be safely shortened; /// in length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:61,Availability,mask,masked,61,"// end anonymous namespace; /// Check if two instruction are masked stores that completely; /// overwrite one another. More specifically, \p KillingI has to; /// overwrite \p DeadI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Availability,Mask,Masks,3,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:43,Availability,mask,mask,43,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:78,Availability,mask,mask,78,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:212,Integrability,depend,depends,212,"// We may now overlap, although the overlap is not complete. There might also; // be other incomplete overlaps, and together, they might cover the complete; // dead store.; // Note: The correctness of this logic depends on the fact that this function; // is not even called providing DepWrite when there are any intervening reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:206,Testability,log,logic,206,"// We may now overlap, although the overlap is not complete. There might also; // be other incomplete overlaps, and together, they might cover the complete; // dead store.; // Note: The correctness of this logic depends on the fact that this function; // is not even called providing DepWrite when there are any intervening reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:200,Safety,avoid,avoid,200,// Another interesting case is if the killing store overwrites the end of the; // dead store.; //; // |--dead--|; // |-- killing --|; //; // In this case we may want to trim the size of dead store to avoid; // generating stores to addresses which will definitely be overwritten killing; // store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:246,Safety,avoid,avoid,246,"// Finally, we also need to check if the killing store overwrites the; // beginning of the dead store.; //; // |--dead--|; // |-- killing --|; //; // In this case we may want to move the destination address and trim the size; // of dead store to avoid generating stores to addresses which will definitely; // be overwritten killing store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:40,Security,access,accessed,40,/// Returns true if the memory which is accessed by the second instruction is not; /// modified between the first and the second instruction.; /// Precondition: Second instruction must be dominated by the first; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,Security,access,accessed,126,// Do a backwards scan through the CFG from SecondI to FirstI. Look for; // instructions which can modify the memory location accessed by SecondI.; //; // While doing the walk keep track of the address to check. It might be; // different in different basic blocks due to PHI translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:278,Energy Efficiency,reduce,reduce,278,"// We assume that memet/memcpy operates in chunks of the ""largest"" native; // type size and aligned on the same value. That means optimal start and size; // of memset/memcpy should be modulo of preferred alignment of that type. That; // is it there is no any sense in trying to reduce store size any further; // since any ""extra"" stores comes for free anyway.; // On the other hand, maximum alignment we can achieve is limited by alignment; // of initial store.; // TODO: Limit maximum alignment by preferred (or abi?) alignment of the; // ""largest"" native type.; // Note: What is the proper way to get that value?; // Should TargetTransformInfo::getRegisterBitWidth be used or anything else?; // PrefAlign = std::min(DL.getPrefTypeAlign(LargestType), PrefAlign);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Deployability,Update,Update,3,// Update attached dbg.assign intrinsics. Assume 8-bit byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:11,Deployability,update,update,11,// Finally update start and size of dead access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:41,Security,access,access,41,// Finally update start and size of dead access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Usability,Clear,Clear,3,"// Clear the bits we'll be replacing, then OR with the smaller; // store, shifted appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:19,Security,access,access,19,// Calls that only access inaccessible memory cannot read or write any memory; // locations we consider for elimination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:82,Deployability,release,release,82,"// We can remove the dead stores, irrespective of the fence and its ordering; // (release/acquire/seq_cst). Fences only constraints the ordering of; // already visible stores, it does not make a store visible to other; // threads. So, skipping over a fence does not change a store from being; // dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:48,Performance,cache,cache,48,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:194,Performance,cache,cache,194,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:311,Performance,cache,cached,311,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,Safety,safe,safe,126,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:365,Security,access,accessed,365,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:103,Safety,detect,detect,103,"// Whether the function contains any irreducible control flow, useful for; // being accurately able to detect loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:77,Security,access,accesses,77,// Post-order numbers for each basic block. Used to figure out if memory; // accesses are executed before another access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:114,Security,access,access,114,// Post-order numbers for each basic block. Used to figure out if memory; // accesses are executed before another access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:253,Safety,abort,abort,253,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:417,Safety,avoid,avoid,417,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:341,Security,access,access,341,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:82,Integrability,depend,dependencies,82,// AliasAnalysis does not always account for loops. Limit overwrite checks; // to dependencies for which we can guarantee they are independent of any; // loops they are in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Availability,Mask,Masked,3,"// Masked stores have imprecise locations, but we can reason about them; // to some extent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:39,Integrability,depend,depends,39,// Bail on doing Size comparison which depends on AA for now; // TODO: Remove AnyScalable once Alias Analysis deal with scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:120,Performance,scalab,scalable,120,// Bail on doing Size comparison which depends on AA for now; // TODO: Remove AnyScalable once Alias Analysis deal with scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:148,Security,access,access,148,// Non aliasing stores to different objects don't overlap. Note that; // if the killing store is known to overwrite whole object (out of; // bounds access overwrites whole object as well) then it is assumed to; // completely overwrite any store to the same object even if they don't; // actually alias (see next check).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:15,Security,access,access,15,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:192,Security,Access,Accesses,192,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:502,Security,access,access,502,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:15,Security,access,access,15,"// If the dead access ends ""not after"" the killing access then the; // dead one is completely overwritten by the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:51,Security,access,access,51,"// If the dead access ends ""not after"" the killing access then the; // dead one is completely overwritten by the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:24,Security,access,access,24,"// If start of the dead access is ""before"" end of the killing access; // then accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:62,Security,access,access,62,"// If start of the dead access is ""before"" end of the killing access; // then accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:78,Security,access,accesses,78,"// If start of the dead access is ""before"" end of the killing access; // then accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:27,Security,access,access,27,"// If start of the killing access is ""before"" end of the dead access then; // accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:62,Security,access,access,62,"// If start of the killing access is ""before"" end of the dead access then; // accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:78,Security,access,accesses,78,"// If start of the killing access is ""before"" end of the dead access then; // accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:26,Security,access,accesses,26,// Can reach here only if accesses are known not to overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:249,Testability,test,test,249,// NOTE: This could be made more precise by PointerMayBeCapturedBefore; // with the killing MemoryDef. But we refrain from doing so for now to; // limit compile-time and this does not cause any changes to the number; // of stores removed on a large test set in practice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,Performance,load,load,126,"// UseInst has a MemoryDef associated in MemorySSA. It's possible for a; // MemoryDef to not write to memory, e.g. a volatile load is modeled as a; // MemoryDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:92,Security,Access,AccessI,92,/// Returns true if \p MaybeTerm is a memory terminator for \p Loc from; /// instruction \p AccessI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:46,Security,access,accesses,46,"// If the terminator is a free-like call, all accesses to the underlying; // object can be considered terminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:22,Integrability,depend,dependency,22,"/// Returns true if a dependency between \p Current and \p KillingDef is; /// guaranteed to be loop invariant for the loops that they are in. Either; /// because they are known to be in the same block, in the same loop level or; /// by guaranteeing that \p CurrentLoc only references a single MemoryLocation; /// during execution of the containing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:10,Integrability,depend,dependency,10,"// If the dependency is within the same block or loop level (being careful; // of irreducible loops), we know that AA will return a valid result for the; // memory dependency. (Both at the function level, outside of any loop,; // would also be valid but we currently disable that to limit compile time).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:164,Integrability,depend,dependency,164,"// If the dependency is within the same block or loop level (being careful; // of irreducible loops), we know that AA will return a valid result for the; // memory dependency. (Both at the function level, outside of any loop,; // would also be valid but we currently disable that to limit compile time).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:93,Security,access,access,93,"// Find a MemoryDef writing to \p KillingLoc and dominating \p StartAccess,; // with no read access between them or on any other path to a function exit; // block if \p KillingLoc is not accessible after the function returns. If; // there is no such MemoryDef, return std::nullopt. The returned value may not; // (completely) overwrite \p KillingLoc. Currently we bail out when we; // encounter an aliasing MemoryUse (read).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:187,Security,access,accessible,187,"// Find a MemoryDef writing to \p KillingLoc and dominating \p StartAccess,; // with no read access between them or on any other path to a function exit; // block if \p KillingLoc is not accessible after the function returns. If; // there is no such MemoryDef, return std::nullopt. The returned value may not; // (completely) overwrite \p KillingLoc. Currently we bail out when we; // encounter an aliasing MemoryUse (read).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:8,Performance,optimiz,optimize,8,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:271,Performance,optimiz,optimizations,271,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:26,Security,access,access,26,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:90,Security,access,access,90,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:111,Security,access,access,111,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:133,Security,access,access,133,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:32,Security,access,access,32,"// Find the next clobbering Mod access for DefLoc, starting at StartAccess.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:19,Security,Access,Accesses,19,"// Cost of a step. Accesses in the same block are more likely to be valid; // candidates for elimination, hence consider them cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:73,Performance,optimiz,optimized,73,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:98,Performance,optimiz,optimize,98,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:83,Security,access,access,83,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:149,Security,access,access,149,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:56,Performance,optimiz,optimized,56,// Once a may-aliasing def is encountered do not set an optimized; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:70,Security,access,access,70,// Once a may-aliasing def is encountered do not set an optimized; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Security,Access,Accesses,3,// Accesses to objects accessible after the function returns can only be; // eliminated if the access is dead along all paths to the exit. Collect; // the blocks with killing (=completely overwriting MemoryDefs) and check if; // they cover all paths from MaybeDeadAccess to any function exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:23,Security,access,accessible,23,// Accesses to objects accessible after the function returns can only be; // eliminated if the access is dead along all paths to the exit. Collect; // the blocks with killing (=completely overwriting MemoryDefs) and check if; // they cover all paths from MaybeDeadAccess to any function exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:95,Security,access,access,95,// Accesses to objects accessible after the function returns can only be; // eliminated if the access is dead along all paths to the exit. Collect; // the blocks with killing (=completely overwriting MemoryDefs) and check if; // they cover all paths from MaybeDeadAccess to any function exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:29,Security,access,accesses,29,// Bail out if the number of accesses to check exceeds the scan limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:54,Security,access,access,54,// If this worklist walks back to the original memory access (and the; // pointer is not guarenteed loop invariant) then we cannot assume that a; // store kills itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:379,Performance,load,loads,379,"// Check all uses for MemoryDefs, except for defs completely overwriting; // the original location. Otherwise we have to check uses of *all*; // MemoryDefs we discover, including non-aliasing ones. Otherwise we might; // miss cases like the following; // 1 = Def(LoE) ; <----- DeadDef stores [0,1]; // 2 = Def(1) ; (2, 1) = NoAlias, stores [2,3]; // Use(2) ; MayAlias 2 *and* 1, loads [0, 3].; // (The Use points to the *first* Def it may alias); // 3 = Def(1) ; <---- Current (3, 2) = NoAlias, (3,1) = MayAlias,; // stores [0,1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:7,Security,access,accesses,7,"// For accesses to locations visible after the function returns, make sure; // that the location is dead (=overwritten) along all paths from; // MaybeDeadAccess to the exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:274,Energy Efficiency,allocate,allocated,274,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:75,Performance,queue,queue,75,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:187,Performance,cache,cached,187,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:324,Performance,cache,cache,324,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:166,Security,access,accesses,166,// Check if \p DeadI acts as a DSE barrier for \p KillingI. The following; // instructions act as barriers:; // * A memory instruction that may throw and \p KillingI accesses a non-stack; // object.; // * Atomic stores stronger that monotonic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:25,Performance,load,load,25,"// If DeadI is an atomic load/store stronger than monotonic, do not try to; // eliminate/reorder it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:84,Security,access,accessed,84,/// Eliminate writes to objects that are not visible in the caller and are not; /// accessed before returning from the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:92,Performance,load,loaded,92,"/// \returns true if \p Def is a no-op store, either because it; /// directly stores back a loaded value or stores zero to a calloced object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:21,Security,access,access,21,"// If the clobbering access is LiveOnEntry, no instructions between them; // can modify the memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:35,Performance,load,load,35,// Get the defining access for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:20,Security,access,access,20,// Get the defining access for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:27,Security,access,accesses,27,// Fast path: the defining accesses are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:157,Performance,Load,LoadAccess,157,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:20,Security,access,accesses,20,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:55,Security,access,accesses,55,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:81,Security,access,access,81,"// We don't want to bail when we run into the store memory def. But,; // the phi access may point to it. So, pretend like we've already; // checked it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:177,Performance,load,load,177,"// TODO: Skip no alias MemoryDefs that have no aliasing reads.; // We are searching for the definition of the store's destination.; // So, if that is the same definition as the load, then this is a; // noop. Otherwise, fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:110,Performance,optimiz,optimized,110,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:162,Performance,optimiz,optimize,162,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:32,Safety,avoid,avoid,32,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:120,Security,access,access,120,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Deployability,Update,Update,3,// Update stored value of earlier store to merged constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:81,Deployability,update,updated,81,// Remove killing store and remove any outstanding overlap; // intervals for the updated store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1155,Modifiability,variab,variable,1155,"atement inside a loop ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1241,Modifiability,variab,variable,1241,"atement inside a loop ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1731,Modifiability,variab,variable,1731,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1402,Performance,optimiz,optimization,1402,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1120,Safety,Predict,Predictable,1120,"atement inside a loop ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1556,Safety,predict,predictable,1556,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:269,Performance,optimiz,optimizeSelectInst,269,/// Unfold the select instruction held in \p SIToUnfold by replacing it with; /// control flow.; ///; /// Put newly discovered select instructions into \p NewSIsToUnfold. Put newly; /// created basic blocks into \p NewBBs.; ///; /// TODO: merge it with CodeGenPrepare::optimizeSelectInst() if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update the phi node of SI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update any other PHI nodes in EndBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update the phi node of SI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update any other PHI nodes in EndBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:157,Performance,cache,cached,157,// This block could now be visited again from a different predecessor. Note; // that this will result in exponential runtime. Subpaths could possibly be; // cached but it takes a lot of memory to store them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:18,Performance,perform,performs,18,"/// This function performs both a legality check and profitability check at; /// the same time since it is convenient to do so. It iterates through all; /// blocks that will be cloned, and keeps track of the duplication cost. It; /// also returns false if it is illegal to clone some required block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,"// Update Metrics for the Switch block, this is always cloned",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:13,Deployability,update,update,13,"// Otherwise update Metrics for all blocks that will be cloned. If any; // block is already cloned and would be reused, don't double count it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:48,Energy Efficiency,reduce,reduced,48,"// Factor in the number of conditional branches reduced from jump; // threading. Assume that lowering the switch block is implemented by; // using binary search, hence the LogBase2().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:38,Performance,optimiz,optimizer,38,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:301,Performance,optimiz,optimizer,301,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:122,Safety,predict,prediction,122,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:227,Safety,predict,predictor,227,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:35,Deployability,update,update,35,"// After all paths are cloned, now update the last successor of the cloned; // path so it skips over the switch statement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:58,Deployability,update,update,58,"// For each instruction that was cloned and used outside, update its uses",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:219,Deployability,update,update,219,"/// For a specific ThreadingPath \p Path, create an exit path starting from; /// the determinator block.; ///; /// To remember the correct destination, we have to duplicate blocks; /// corresponding to each state. Also update the terminating instruction of; /// the predecessors, and phis in the successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:53,Deployability,update,update,53,"// We already cloned BB for this NextState, now just update the branch; // and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:20,Deployability,update,update,20,// Clone the BB and update the successor of Prev to jump to the new block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:133,Deployability,update,updated,133,"/// Restore SSA form after cloning blocks.; ///; /// Each cloned block creates new defs for a variable, and the uses need to be; /// updated to reflect this. The uses may be replaced with a cloned value, or; /// some derived phi instruction. Note that all uses of a value defined in the; /// same block were already remapped when cloning the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:94,Modifiability,variab,variable,94,"/// Restore SSA form after cloning blocks.; ///; /// Each cloned block creates new defs for a variable, and the uses need to be; /// updated to reflect this. The uses may be replaced with a cloned value, or; /// some derived phi instruction. Note that all uses of a value defined in the; /// same block were already remapped when cloning the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:4,Deployability,Update,Update,4,/// Update the phi nodes in BB's successors.; ///; /// This means creating a new incoming value from NewBB with the new; /// instruction wherever there is an incoming value from BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:54,Deployability,update,update,54,"// If BB is the last block in the path, we can simply update the one case; // successor that will be reached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:47,Usability,simpl,simply,47,"// If BB is the last block in the path, we can simply update the one case; // successor that will be reached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:13,Deployability,update,update,13,// Otherwise update phis in all successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:179,Deployability,update,updated,179,"// Check if a successor has already been cloned for the particular exit; // value. In this case if a successor was already cloned, the phi nodes; // in the cloned block should be updated directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:79,Deployability,update,updated,79,"// When a path is reused, there is a chance that predecessors were already; // updated before. Check if the predecessor needs to be updated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:132,Deployability,update,updated,132,"// When a path is reused, there is a chance that predecessors were already; // updated before. Check if the predecessor needs to be updated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:4,Deployability,Update,Update,4,"/// Update the last branch of a particular cloned path to point to the correct; /// case successor.; ///; /// Note that this is an optional step and would have been done in later; /// optimizations, but it makes the CFG significantly easier to work with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:184,Performance,optimiz,optimizations,184,"/// Update the last branch of a particular cloned path to point to the correct; /// case successor.; ///; /// Note that this is an optional step and would have been done in later; /// optimizations, but it makes the CFG significantly easier to work with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:77,Deployability,update,updated,77,// Note multiple paths can end at the same block so check that it is not; // updated yet,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:33,Performance,optimiz,optimization,33,// For the time being limit this optimization to occurring once in a; // function since it can change the CFG significantly. This is not a; // strict requirement but it can cause buggy behavior if there is an; // overlap of blocks in different opportunities. There is a lot of room to; // experiment with catching more opportunities here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:32,Deployability,Integrat,Integrate,32,// end anonymous namespace; /// Integrate with the new Pass Manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:32,Integrability,Integrat,Integrate,32,// end anonymous namespace; /// Integrate with the new Pass Manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:11,Integrability,wrap,wrapper,11,/// A thin wrapper to store two values that we matched as div-rem pair.; /// We want this extra indirection to avoid dealing with RAUW'ing the map keys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:111,Safety,avoid,avoid,111,/// A thin wrapper to store two values that we matched as div-rem pair.; /// We want this extra indirection to avoid dealing with RAUW'ing the map keys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:632,Modifiability,enhance,enhancement,632,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:350,Safety,safe,safety,350,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:670,Usability,Simpl,SimplifyCFG,670,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:89,Safety,avoid,avoid,89,// Get the matching pairs of div-rem instructions. We want this extra; // indirection to avoid dealing with having to RAUW the keys of the maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:19,Modifiability,variab,variable,19,// suppress unused variable warning,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:3,Deployability,Update,Update,3,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:10,Testability,Assert,AssertingVH,10,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:59,Testability,assert,assert,59,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:82,Modifiability,rewrite,rewrite,82,// Note that we have left ((X / Y) * Y) around.; // If it had other uses we could rewrite it as X - X % Y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:13,Safety,safe,safe,13,// It's only safe to hoist if every instruction before the Div/Rem in the; // basic block is guaranteed to transfer execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:400,Modifiability,rewrite,rewrite,400,"// Look for something like this; // PredBB; // | \; // | Rem; // | /; // Div; //; // If the Rem block has a single predecessor and successor, and all paths; // from PredBB go to either RemBB or DivBB, and execution of RemBB and; // DivBB will always reach the Div/Rem, we can hoist Div to PredBB. If; // we have a DivRem operation we can also hoist Rem. Otherwise we'll leave; // Rem where it is and rewrite it to mul/sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:384,Energy Efficiency,reduce,reduce,384,"// Look for something like this; // PredBB; // / \; // Div Rem; //; // If the Rem and Din blocks share a unique predecessor, and all; // paths from PredBB go to either RemBB or DivBB, and execution of RemBB; // and DivBB will always reach the Div/Rem, we can hoist Div to PredBB.; // If we have a DivRem operation we can also hoist Rem. By hoisting both; // ops to the same block, we reduce code size and allow the DivRem to; // issue sooner. Without a DivRem op, this transformation is; // unprofitable because we would end up performing an extra Mul+Sub on; // the Rem path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:528,Performance,perform,performing,528,"// Look for something like this; // PredBB; // / \; // Div Rem; //; // If the Rem and Din blocks share a unique predecessor, and all; // paths from PredBB go to either RemBB or DivBB, and execution of RemBB; // and DivBB will always reach the Div/Rem, we can hoist Div to PredBB.; // If we have a DivRem operation we can also hoist Rem. By hoisting both; // ops to the same block, we reduce code size and allow the DivRem to; // issue sooner. Without a DivRem op, this transformation is; // unprofitable because we would end up performing an extra Mul+Sub on; // the Rem path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:60,Performance,optimiz,optimization,60,"// If DivInst has the exact flag, remove it. Otherwise this optimization; // may replace a well-defined value 'X % Y' with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:3,Deployability,Update,Update,3,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:10,Testability,Assert,AssertingVH,10,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:59,Testability,assert,assert,59,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:461,Availability,redundant,redundant,461,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:393,Performance,perform,performs,393,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:461,Safety,redund,redundant,461,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:22,Usability,Simpl,Simple,22,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:404,Usability,simpl,simple,404,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:85,Usability,Simpl,SimpleValue,85,//===----------------------------------------------------------------------===//; // SimpleValue; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:28,Availability,avail,available,28,/// Struct representing the available values in the scoped hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:59,Security,hash,hash,59,/// Struct representing the available values in the scoped hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:61,Deployability,A/B,A/B,61,// Look through a 'not' of the condition operand by swapping A/B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:79,Energy Efficiency,power,powerful,79,"// Match canonical forms of min/max. We are not using ValueTracking's; // more powerful matchSelectPattern() because it may rely on instruction flags; // such as ""nsw"". That would be incompatible with the current hashing; // mechanism that may remove flags to increase the likelihood of CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:213,Security,hash,hashing,213,"// Match canonical forms of min/max. We are not using ValueTracking's; // more powerful matchSelectPattern() because it may rely on instruction flags; // such as ""nsw"". That would be incompatible with the current hashing; // mechanism that may remove flags to increase the likelihood of CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:85,Integrability,depend,depend,85,"// Don't CSE convergent calls in different basic blocks, because they; // implicitly depend on the set of threads that is currently executing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,// Hash in all of the operands as pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,// Hash general selects to allow matching commuted true/false operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:257,Safety,detect,detect,257,"// Hash min/max (cmp + select) to allow for commuted operands.; // Min/max may also have non-canonical compare predicate (eg, the compare for; // smin may use 'sgt' rather than 'slt'), and non-canonical operands in the; // compare.; // TODO: We should also detect FP min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,"// Hash min/max (cmp + select) to allow for commuted operands.; // Min/max may also have non-canonical compare predicate (eg, the compare for; // smin may use 'sgt' rather than 'slt'), and non-canonical operands in the; // compare.; // TODO: We should also detect FP min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,"// Hash general selects to allow matching commuted true/false operands.; // If we do not have a compare as the condition, just hash in the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:127,Security,hash,hash,127,"// Hash general selects to allow matching commuted true/false operands.; // If we do not have a compare as the condition, just hash in the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:85,Integrability,depend,depend,85,"// Don't CSE convergent calls in different basic blocks, because they; // implicitly depend on the set of threads that is currently executing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:22,Security,hash,hash,22,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:87,Security,hash,hashing,87,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:245,Security,hash,hash,245,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:171,Testability,assert,assertion,171,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Integrability,depend,depend,31,"// Convergent calls implicitly depend on the set of threads that is; // currently executing, so conservatively return false if they are in; // different basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:24,Safety,detect,detect,24,// TODO: We should also detect FP min/max.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:369,Deployability,A/B,A/B,369,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:630,Security,hash,hash,630,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:759,Security,hash,hashes,759,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:785,Security,hash,hash,785,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:927,Security,hash,hashing,927,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:891,Usability,simpl,simplify,891,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,Security,hash,hash,73,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:40,Testability,assert,assert,40,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:28,Availability,avail,available,28,/// Struct representing the available call values in the scoped hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:64,Security,hash,hash,64,/// Struct representing the available call values in the scoped hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,// Hash all of the operands as pointers and mix in the opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Integrability,depend,depend,31,"// Convergent calls implicitly depend on the set of threads that is; // currently executing, so conservatively return false if they are in; // different basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Availability,redundant,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Safety,redund,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:6,Usability,simpl,simple,6,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,Usability,simpl,simple,73,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:113,Availability,down,down,113,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Security,hash,hash,13,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:60,Usability,simpl,simple,60,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:200,Availability,redundant,redundant,200,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:127,Energy Efficiency,efficient,efficient,127,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:158,Performance,load,loads,158,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:210,Performance,load,load,210,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:247,Performance,load,load,247,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:500,Performance,load,loads,500,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:517,Performance,load,loads,517,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:764,Performance,load,loads,764,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:200,Safety,redund,redundant,200,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Security,hash,hash,13,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:137,Security,access,access,137,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:12,Security,hash,hash,12,// A scoped hash table mapping memory locations (represented as typed; // addresses) to generation numbers at which that memory location became; // (henceforth indefinitely) invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:124,Performance,load,loads,124,/// A scoped hash table of the current values of read-only call; /// values.; ///; /// It uses the same generation count as loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Security,hash,hash,13,/// A scoped hash table of the current values of read-only call; /// values.; ///; /// It uses the same generation count as loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:67,Security,hash,hash,67,"// Almost a POD, but needs to call the constructors for the scoped hash; // tables so that a new scope gets pushed on. These are RAII so that the; // scope gets popped when the NodeScope is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:141,Performance,load,loads,141,"// Contains all the needed information to create a stack for doing a depth; // first traversal of the tree. This includes scopes for values, loads, and; // calls as well as the generation. There is a child iterator so that the; // children do not need to be store separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:59,Performance,load,loads,59,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:92,Performance,load,loads,92,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,Availability,mask,masked,17,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:86,Availability,mask,masked,86,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:111,Availability,mask,masked,111,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:285,Availability,mask,masked,285,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:24,Performance,load,load,24,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:93,Performance,load,loads,93,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Performance,load,loads,31,"// For regular (non-intrinsic) loads/stores, this is set to -1. For; // intrinsic loads/stores, the id is retrieved from the corresponding; // field in the MemIntrinsicInfo structure. That field contains; // non-negative values only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:82,Performance,load,loads,82,"// For regular (non-intrinsic) loads/stores, this is set to -1. For; // intrinsic loads/stores, the id is retrieved from the corresponding; // field in the MemIntrinsicInfo structure. That field contains; // non-negative values only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:54,Availability,mask,masked,54,// We could really use specific intrinsic classes for masked loads; // and stores in IntrinsicInst.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:61,Performance,load,loads,61,// We could really use specific intrinsic classes for masked loads; // and stores in IntrinsicInst.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:27,Availability,mask,masked,27,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:113,Availability,mask,masks,113,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:210,Availability,mask,mask,210,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:252,Availability,mask,mask,252,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:34,Performance,load,load,34,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:129,Availability,mask,mask,129,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:157,Availability,mask,mask,157,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:23,Performance,load,load,23,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,Performance,load,load,122,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:173,Performance,load,load,173,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:109,Availability,mask,mask,109,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:140,Availability,mask,mask,140,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:35,Performance,load,loaded,35,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:133,Performance,load,load,133,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:118,Availability,mask,mask,118,"// Trying to remove a dead store (earlier).; // Check that the pointers are the same,; // - the to-be-removed store's mask is a subset of the other store's; // mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:160,Availability,mask,mask,160,"// Trying to remove a dead store (earlier).; // Check that the pointers are the same,; // - the to-be-removed store's mask is a subset of the other store's; // mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:349,Deployability,update,updated,349,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:259,Performance,Optimiz,OptimizePhis,259,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:314,Performance,optimiz,optimized,314,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:172,Security,access,access,172,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:189,Performance,load,load,189,"// end anonymous namespace; /// Determine if the memory referenced by LaterInst is from the same heap; /// version as EarlierInst.; /// This is currently called in two scenarios:; ///; /// load p; /// ...; /// load p; ///; /// and; ///; /// x = load p; /// ...; /// store x, p; ///; /// in both cases we want to verify that there are no possible writes to the; /// memory referenced by p between the earlier and later instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:210,Performance,load,load,210,"// end anonymous namespace; /// Determine if the memory referenced by LaterInst is from the same heap; /// version as EarlierInst.; /// This is currently called in two scenarios:; ///; /// load p; /// ...; /// load p; ///; /// and; ///; /// x = load p; /// ...; /// store x, p; ///; /// in both cases we want to verify that there are no possible writes to the; /// memory referenced by p between the earlier and later instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:245,Performance,load,load,245,"// end anonymous namespace; /// Determine if the memory referenced by LaterInst is from the same heap; /// version as EarlierInst.; /// This is currently called in two scenarios:; ///; /// load p; /// ...; /// load p; ///; /// and; ///; /// x = load p; /// ...; /// store x, p; ///; /// in both cases we want to verify that there are no possible writes to the; /// memory referenced by p between the earlier and later instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Usability,simpl,simple,13,// Check the simple memory generation tracking first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:483,Deployability,pipeline,pipeline,483,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:470,Performance,optimiz,optimization,470,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:112,Safety,safe,safely,112,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:14,Performance,load,loaded,14,// A location loaded from with an invariant_load is assumed to *never* change; // within the visible scope of the compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Performance,load,loads,31,"// ""target"" intrinsic forms of loads aren't currently known to; // MemoryLocation::get. TODO",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:32,Performance,load,loads,32,// We don't yet handle removing loads with ordering of any kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:30,Performance,load,load,30,// We can't replace an atomic load with one which isn't also atomic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,Availability,avail,available,229,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:63,Integrability,depend,depending,63,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:101,Performance,load,load,101,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:128,Performance,load,load,128,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:349,Security,hash,hash,349,"// If this node has a single predecessor which ends in a conditional branch,; // we can infer the value of the branch condition given that we took this; // path. We need the single predecessor to ensure there's not another path; // which reaches this block where the condition might hold a different; // value. Since we're adding this to the scoped hash table (like any other; // def), it will have been popped if we encounter a future merge block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:97,Availability,Avail,AvailableValues,97,"// See if any instructions in the block can be eliminated. If so, do it. If; // not, add them to AvailableValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:134,Integrability,depend,dependencies,134,"// Skip assume intrinsics, they don't really have side effects (although; // they're marked as such to ensure preservation of control dependencies),; // and this pass will not bother with its removal. However, we should mark; // its condition as true for all dominated blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:411,Performance,perform,perform,411,"// We can skip all invariant.start intrinsics since they only read memory,; // and we can forward values across it. For invariant starts without; // invariant ends, we can use the fact that the invariantness never ends to; // start a scope in the current generaton which is true for all future; // generations. Also, we dont need to consume the last store since the; // semantics of invariant.start allow us to perform DSE of the last; // store, if there was a store following invariant.start. Consider:; //; // store 30, i8* p; // invariant.start(p); // store 40, i8* p; // We can DSE the store to 30, since the store 40 to invariant location p; // causes undefined behaviour.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:88,Deployability,update,update,88,"// Guard intrinsics read all memory, but don't write any memory.; // Accordingly, don't update the generation but consume the last store (to; // avoid an incorrect DSE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:145,Safety,avoid,avoid,145,"// Guard intrinsics read all memory, but don't write any memory.; // Accordingly, don't update the generation but consume the last store (to; // avoid an incorrect DSE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:29,Usability,simpl,simplified,29,// If the instruction can be simplified (e.g. X+0 = X) then replace it with; // its simpler value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:84,Usability,simpl,simpler,84,// If the instruction can be simplified (e.g. X+0 = X) then replace it with; // its simpler value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:16,Usability,simpl,simple,16,"// If this is a simple instruction that we can value number, process it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:33,Availability,avail,available,33,"// See if the instruction has an available value. If so, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:47,Availability,avail,available,47,"// Otherwise, just remember that this value is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:29,Performance,load,load,29,"// If this is a non-volatile load, process it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,Availability,avail,available,122,"// (conservatively) we can't peak past the ordering implied by this; // operation, but we can add this load to our set of available values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:103,Performance,load,load,103,"// (conservatively) we can't peak past the ordering implied by this; // operation, but we can add this load to our set of available values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:27,Performance,load,load,27,"// If we pass an invariant load, we know that memory location is; // indefinitely constant from the moment of first dereferenceability.; // We conservatively treat the invariant_load as that moment. If we; // pass a invariant load after already establishing a scope, don't; // restart it since we want to preserve the earliest point seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:226,Performance,load,load,226,"// If we pass an invariant load, we know that memory location is; // indefinitely constant from the moment of first dereferenceability.; // We conservatively treat the invariant_load as that moment. If we; // pass a invariant load after already establishing a scope, don't; // restart it since we want to preserve the earliest point seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,Availability,avail,available,17,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:43,Performance,load,load,43,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:94,Performance,load,load,94,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:205,Performance,load,load,205,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:225,Performance,load,load,225,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:280,Performance,load,load,280,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:285,Performance,load,loads,285,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:328,Performance,load,load,328,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:136,Performance,Load,Load,136,"// If this instruction may read from memory or throw (and potentially read; // from memory in the exception handler), forget LastStore. Load/store; // intrinsics will indicate both a read and a write to memory. The target; // may override this (e.g. so that a store intrinsic does not read from; // memory, and thus will be treated the same as a regular store for; // commoning purposes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,Availability,avail,available,17,"// If we have an available version of this call, and if it is the right; // generation, replace this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:5,Deployability,release,release,5,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads 'before' the fence. As a; // result, we don't need to consider it as writing to memory and don't need; // to advance the generation. We do need to prevent DSE across the fence,; // but that's handled above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:117,Performance,load,loads,117,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads 'before' the fence. As a; // result, we don't need to consider it as writing to memory and don't need; // to advance the generation. We do need to prevent DSE across the fence,; // but that's handled above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:232,Availability,avail,available,232,"// write back DSE - If we write back the same value we just loaded from; // the same location and haven't passed any intervening writes or ordering; // operations, we can remove the write. The primary benefit is in allowing; // the available load table to remain valid and value forward past where; // the store originally was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:60,Performance,load,loaded,60,"// write back DSE - If we write back the same value we just loaded from; // the same location and haven't passed any intervening writes or ordering; // operations, we can remove the write. The primary benefit is in allowing; // the available load table to remain valid and value forward past where; // the store originally was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:242,Performance,load,load,242,"// write back DSE - If we write back the same value we just loaded from; // the same location and haven't passed any intervening writes or ordering; // operations, we can remove the write. The primary benefit is in allowing; // the available load table to remain valid and value forward past where; // the store originally was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:97,Performance,load,load,97,"// It is okay to have a LastStore to a different pointer here if MemorySSA; // tells us that the load and store are from the same memory generation.; // In that case, LastStore should keep its present value since we're; // removing the current store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:10,Safety,avoid,avoid,10,// We can avoid incrementing the generation count since we were able; // to eliminate this store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,Availability,avail,available,122,"// Okay, this isn't something we can CSE at all. Check to see if it is; // something that could modify memory. If so, our available memory values; // cannot be used so bump the generation count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:100,Performance,load,loads,100,// We do a trivial form of DSE if there are two stores to the same; // location with no intervening loads. Delete the earlier store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:52,Performance,load,loaded,52,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:236,Performance,load,loads,236,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:179,Safety,safe,safe,179,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:358,Usability,clear,clear,358,"// Remember that this was the last unordered store we saw for DSE. We; // don't yet handle DSE on ordered or volatile stores since we don't; // have a good way to model the ordering requirement for following; // passes once the store is removed. We could insert a fence, but; // since fences are slightly stronger than stores in their ordering,; // it's not clear this is a profitable transform. Another option would; // be to merge the ordering with that of the post dominating store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:63,Performance,perform,performance,63,"// Note, deque is being used here because there is significant performance; // gains over vector when the container becomes very large due to the; // specific access patterns. For more information see the mailing list; // discussion on this:; // http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20120116/135228.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:159,Security,access,access,159,"// Note, deque is being used here because there is significant performance; // gains over vector when the container becomes very large due to the; // specific access patterns. For more information see the mailing list; // discussion on this:; // http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20120116/135228.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Availability,redundant,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Safety,redund,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:6,Usability,simpl,simple,6,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,Usability,simpl,simple,73,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp:79,Safety,avoid,avoid,79,// Use block handles instead of iterating over function blocks directly; // to avoid using iterators invalidated by erasing blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp:10,Integrability,interface,interface,10,// Public interface to the FlattenCFG pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:20,Usability,simpl,simple,20,"// The algorithm is simple. Start at instructions that convert from the; // float to the int domain: fptoui, fptosi and fcmp. Walk up the def-use; // graph, using an equivalence datastructure to unify graphs that interfere.; //; // Mappable instructions are those with an integer corrollary that, given; // integer domain inputs, produce an integer output; fadd, for example.; //; // If a non-mappable instruction is seen, this entire def-use graph is marked; // as non-transformable. If we see an instruction that converts from the; // integer domain to FP domain (uitofp,sitofp), we terminate our walk.; /// The largest integer type worth dealing with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:17,Availability,down,down,17,"// Walk forwards down the list of seen instructions, so we visit defs before; // uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:3,Performance,Perform,Perform,3,// Perform dead code elimination on the instructions we just modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:3,Usability,Clear,Clear,3,// Clear out all state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:583,Performance,optimiz,optimization,583,"//===- GuardWidening.cpp - ---- Guard widening ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the guard widening pass. The semantics of the; // @llvm.experimental.guard intrinsic lets LLVM transform it so that it fails; // more often that it did before the transform. This optimization is called; // ""widening"" and can be used hoist and common runtime checks in situations like; // these:; //; // %cmp0 = 7 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // %cmp1 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp1) [ ""deopt""(...) ]; // ...; //; // =>; //; // %cmp0 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // ...; //; // If %cmp0 is false, @llvm.experimental.guard will ""deoptimize"" back to a; // generic implementation of the same function, which will have the correct; // semantics from that point onward. It is always _legal_ to deoptimize (so; // replacing %cmp0 with false is ""correct""), though it may not always be; // profitable to do so.; //; // NB! This pass is a work in progress. It hasn't been tuned to be ""production; // ready"" yet. It is known to have quadriatic running time and will not scale; // to large numbers of guards; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:1448,Performance,tune,tuned,1448,"//===- GuardWidening.cpp - ---- Guard widening ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the guard widening pass. The semantics of the; // @llvm.experimental.guard intrinsic lets LLVM transform it so that it fails; // more often that it did before the transform. This optimization is called; // ""widening"" and can be used hoist and common runtime checks in situations like; // these:; //; // %cmp0 = 7 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // %cmp1 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp1) [ ""deopt""(...) ]; // ...; //; // =>; //; // %cmp0 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // ...; //; // If %cmp0 is false, @llvm.experimental.guard will ""deoptimize"" back to a; // generic implementation of the same function, which will have the correct; // semantics from that point onward. It is always _legal_ to deoptimize (so; // replacing %cmp0 with false is ""correct""), though it may not always be; // profitable to do so.; //; // NB! This pass is a work in progress. It hasn't been tuned to be ""production; // ready"" yet. It is known to have quadriatic running time and will not scale; // to large numbers of guards; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:620,Safety,safe,safest,620,"/// Find a point at which the widened condition of \p Guard should be inserted.; /// When it is represented as intrinsic call, we can do it right before the call; /// instruction. However, when we are dealing with widenable branch, we must; /// account for the following situation: widening should not turn a; /// loop-invariant condition into a loop-variant. It means that if; /// widenable.condition() call is invariant (w.r.t. any loop), the new wide; /// condition should stay invariant. Otherwise there can be a miscompile, like; /// the one described at https://github.com/llvm/llvm-project/issues/60234. The; /// safest way to do it is to expand the new condition at WC's block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:16,Performance,perform,performance,16,"/// Widening is performance neutral as far as the cycles spent in check; /// conditions goes (but can still help, e.g., code layout, having less; /// deopt state).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:389,Availability,avail,available,389,"/// Common helper used by \c widenGuard and \c isWideningCondProfitable. Try; /// to generate an expression computing the logical AND of \p ChecksToHoist; /// and \p ChecksToWiden. Return true if the expression computing the AND is; /// only as expensive as computing one of the set of expressions. If \p; /// InsertPt is true then actually generate the resulting expression, make it; /// available at \p InsertPt and return it in \p Result (else no change to the; /// IR is made).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:122,Testability,log,logical,122,"/// Common helper used by \c widenGuard and \c isWideningCondProfitable. Try; /// to generate an expression computing the logical AND of \p ChecksToHoist; /// and \p ChecksToWiden. Return true if the expression computing the AND is; /// only as expensive as computing one of the set of expressions. If \p; /// InsertPt is true then actually generate the resulting expression, make it; /// available at \p InsertPt and return it in \p Result (else no change to the; /// IR is made).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:86,Availability,avail,available,86,/// Generate the logical AND of \p ChecksToHoist and \p OldCondition and make; /// it available at InsertPt,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:17,Testability,log,logical,17,/// Generate the logical AND of \p ChecksToHoist and \p OldCondition and make; /// it available at InsertPt,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:161,Availability,failure,failure,161,"/// Parse \p ToParse into a conjunction (logical-and) of range checks; and; /// append them to \p Checks. Returns true on success, may clobber \c Checks; /// on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:41,Testability,log,logical-and,41,"/// Parse \p ToParse into a conjunction (logical-and) of range checks; and; /// append them to \p Checks. Returns true on success, may clobber \c Checks; /// on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:274,Availability,failure,failure,274,/// Combine the checks in \p Checks into a smaller set of checks and append; /// them into \p CombinedChecks. Return true on success (i.e. all of checks; /// in \p Checks were combined into \p CombinedChecks). Clobbers \p Checks; /// and \p CombinedChecks on success and on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:23,Testability,log,logical,23,/// Can we compute the logical AND of \p ChecksToHoist and \p ChecksToWiden; /// for the price of computing only one of the set of expressions?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:107,Availability,down,downsides,107,"// If the guard was conditional executed, it may never be reached; // dynamically. There are two potential downsides to hoisting it out of the; // conditionally executed region: 1) we may spuriously deopt without need and; // 2) we have the extra cost of computing the guard condition in the common; // case. At the moment, we really only consider the second in our heuristic; // here. TODO: evaluate cost model for spurious deopt; // NOTE: As written, this also lets us hoist right over another guard which; // is essentially just another spelling for control flow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:11,Availability,down,down,11,// Only go down the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:105,Performance,Cache,CacheOfFreezes,105,// A bit overloaded data structures. Visited contains constant/GV; // if we already met it. In this case CacheOfFreezes has a freeze if it is; // required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:431,Integrability,wrap,wrap,431,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:823,Integrability,wrap,wrapping,823,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:1002,Integrability,wrap,wrapping,1002,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:3,Safety,Avoid,Avoid,3,// Avoid requesting analyses if there are no guards or widenable conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Availability,redundant,redundant,27,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:444,Availability,redundant,redundant,444,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:48,Performance,load,loads,48,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:393,Performance,perform,performs,393,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:480,Performance,perform,performs,480,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:501,Performance,load,load,501,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Safety,redund,redundant,27,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:444,Safety,redund,redundant,444,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:489,Usability,simpl,simple,489,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:51,Availability,avail,available,51,// end namespace llvm; /// Represents a particular available value that we know how to materialize.; /// Materialization of an AvailableValue never fails. An AvailableValue is; /// implicitly associated with a rematerialization point which is the; /// location of the instruction from which it was formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,Availability,Avail,AvailableValue,127,// end namespace llvm; /// Represents a particular available value that we know how to materialize.; /// Materialization of an AvailableValue never fails. An AvailableValue is; /// implicitly associated with a rematerialization point which is the; /// location of the instruction from which it was formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:158,Availability,Avail,AvailableValue,158,// end namespace llvm; /// Represents a particular available value that we know how to materialize.; /// Materialization of an AvailableValue never fails. An AvailableValue is; /// implicitly associated with a rematerialization point which is the; /// location of the instruction from which it was formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Security,access,accessed,36,// A simple offsetted value that is accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:5,Usability,simpl,simple,5,// A simple offsetted value that is accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Performance,load,load,25,// A value produced by a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Performance,load,loaded,31,// A memory intrinsic which is loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Performance,load,loaded,29,// A pointer select which is loaded from and for which the load; // can be replace by a value select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:59,Performance,load,load,59,// A pointer select which is loaded from and for which the load; // can be replace by a value select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,Performance,load,load,64,/// Offset - The byte offset in Val that is interesting for the load query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:18,Availability,Avail,AvailableValue,18,/// Represents an AvailableValue which can be rematerialized at the end of; /// the associated BasicBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:20,Availability,avail,available,20,/// AV - The actual available value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:231,Energy Efficiency,efficient,efficient,231,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since commutative operands are the 1st two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:53,Performance,scalab,scalable,53,"// If converting to offset representation fails (for scalable vectors),; // fall back to type-based implementation:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:57,Integrability,depend,depend,57,"// Do not combine convergent calls since they implicitly depend on the set of; // threads that is currently executing, and they might be in different basic; // blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,Availability,mask,masked,7,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,Performance,load,load,14,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,Performance,load,load,80,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,Testability,log,logic,28,// FIXME: Move the checking logic to MemDep!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:86,Integrability,depend,dependencies,86,"// We don't handle non-definitions. If we already have a call, reject; // instruction dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:104,Modifiability,variab,variables,104,"// FIXME: The order of evaluation of these 'getResult' calls is very; // significant! Re-ordering these variables will cause GVN when run alone to; // be less effective! We should fix memdep and basic-aa to not exhibit this; // behavior, but until then don't change the order here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:37,Availability,avail,available,37,/// We know the block *is not* fully available. This is a fixpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:33,Availability,avail,available,33,/// We know the block *is* fully available. This is a fixpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Availability,avail,available,46,"/// We do not know whether the block is fully available or not,; /// but we are currently speculating that it will be.; /// If it would have turned out that the block was, in fact, not fully; /// available, this would have been cleaned up into an Unavailable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:196,Availability,avail,available,196,"/// We do not know whether the block is fully available or not,; /// but we are currently speculating that it will be.; /// If it would have turned out that the block was, in fact, not fully; /// available, this would have been cleaned up into an Unavailable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:77,Availability,avail,available,77,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:171,Availability,alive,alive,171,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:312,Availability,avail,available,312,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,Availability,avail,available,360,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:421,Availability,avail,available,421,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:140,Availability,avail,available,140,// The number of times we didn't find an entry for a block in a map and; // optimistically inserted an entry marking block as speculatively available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:83,Availability,Avail,Available,83,// LoadFO - depth-first!; // Optimistically assume that the block is Speculatively Available and check; // to see if we already know about this block in one lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Load,LoadFO,3,// LoadFO - depth-first!; // Optimistically assume that the block is Speculatively Available and check; // to see if we already know about this block in one lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:52,Availability,avail,available,52,// Tentatively consider this block as speculatively available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:70,Availability,Avail,Available,70,// If the block isn't marked as fixpoint yet; // (the Unavailable and Available states are fixpoints),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Queue,Queue,3,// Queue successors for further processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:74,Availability,avail,available,74,"// Okay, we have encountered an unavailable block.; // Mark speculatively available blocks reachable from UnavailableBB as; // unavailable as well. Paths are terminated when they reach blocks not in; // FullyAvailableBlocks or they are not marked as speculatively available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:264,Availability,avail,available,264,"// Okay, we have encountered an unavailable block.; // Mark speculatively available blocks reachable from UnavailableBB as; // unavailable as well. Paths are terminated when they reach blocks not in; // FullyAvailableBlocks or they are not marked as speculatively available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,Performance,load,loads,19,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:104,Performance,Load,Load,104,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:161,Performance,Load,Load,161,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Availability,redundant,redundant,23,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:45,Performance,load,load,45,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Safety,redund,redundant,23,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,Availability,avail,available,80,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Performance,load,load,23,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:115,Performance,load,load,115,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:227,Safety,avoid,avoid,227,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:37,Performance,load,load,37,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:115,Performance,load,load,115,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:320,Performance,load,load,320,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:502,Performance,load,load,502,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:38,Performance,load,load,38,// Introduce a new value select for a load from an eligible pointer select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:66,Performance,load,load-elimination,66,/// Try to locate the three instruction involved in a missed; /// load-elimination case that is due to an intervening store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Availability,avail,available,125,"// There is no dominating use, check if we can find a closest non-dominating; // use that lies between any other potentially available use and Load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:143,Performance,Load,Load,143,"// There is no dominating use, check if we can find a closest non-dominating; // use that lies between any other potentially available use and Load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:33,Availability,avail,available,33,"// These uses are both partially available at Load were it not for; // the clobber, but neither lies strictly after the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Performance,Load,Load,46,"// These uses are both partially available at Load were it not for; // the clobber, but neither lies strictly after the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:62,Performance,Load,Load,62,// else: keep current OtherAccess since it lies between U and Load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:55,Modifiability,extend,extended,55,// Find non-clobbered value for Loc memory location in extended basic block; // (chain of basic blocks with single predecessors) starting From instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:10,Integrability,depend,dependence,10,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:89,Performance,load,load,89,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:135,Performance,load,load,135,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:52,Performance,load,load,52,"// Check to see if we have something like this:; // load i32* P; // load i8* (P+1); // if we have this, replace the later with an extraction from the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,Performance,load,load,68,"// Check to see if we have something like this:; // load i32* P; // load i8* (P+1); // if we have this, replace the later with an extraction from the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Load,Loading,3,// Loading the alloca -> undef.; // Loading immediately after lifetime begin -> undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Performance,Load,Loading,36,// Loading the alloca -> undef.; // Loading immediately after lifetime begin -> undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:10,Performance,load,loads,10,"// Reject loads and stores that are to the same address but are of; // different types if we have to. If the stored value is convertable to; // the loaded value, we can reuse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:148,Performance,load,loaded,148,"// Reject loads and stores that are to the same address but are of; // different types if we have to. If the stored value is convertable to; // the loaded value, we can reuse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:69,Performance,load,load,69,"// If the types mismatch and we can't handle it, reject reuse of the load.; // If the stored value is larger or equal to the loaded value, we can reuse; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Performance,load,loaded,125,"// If the types mismatch and we can't handle it, reject reuse of the load.; // If the stored value is larger or equal to the loaded value, we can reuse; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Integrability,depend,dependent,27,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:12,Performance,load,load,12,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:88,Performance,load,load,88,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:153,Performance,load,loads,153,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:192,Performance,load,loads,192,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:100,Availability,avail,available,100,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:157,Integrability,depend,dependencies,157,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:208,Performance,load,load,208,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:268,Performance,load,load,268,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:8,Integrability,depend,dependent,8,// Dead dependent mem-op disguise as a load evaluating the same value; // as the load in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:39,Performance,load,load,39,// Dead dependent mem-op disguise as a load evaluating the same value; // as the load in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,Performance,load,load,81,// Dead dependent mem-op disguise as a load evaluating the same value; // as the load in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:21,Performance,load,loaded,21,// The address being loaded in this non-local block may not be the same as; // the pointer operand of the load if PHI translation occurs. Make sure; // to consider the right address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:106,Performance,load,load,106,// The address being loaded in this non-local block may not be the same as; // the pointer operand of the load if PHI translation occurs. Make sure; // to consider the right address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:50,Integrability,depend,dependency,50,"// subtlety: because we know this was a non-local dependency, we know; // it's safe to materialize anywhere between the instruction within; // DepInfo and the end of it's block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:79,Safety,safe,safe,79,"// subtlety: because we know this was a non-local dependency, we know; // it's safe to materialize anywhere between the instruction within; // DepInfo and the end of it's block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Availability,avail,available,46,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:84,Availability,avail,available,84,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,Performance,load,load,182,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:236,Performance,load,load,236,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:256,Performance,Load,LoadBB,256,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:273,Performance,Load,LoadBB,273,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:291,Performance,load,load,291,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,Performance,Load,LoadBB,360,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:410,Performance,load,load,410,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,Usability,simpl,simplicity,7,// For simplicity we handle a Pred has 2 successors only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:32,Integrability,depend,depends,32,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,Performance,load,load,19,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:188,Performance,Perform,PerformLoadPRE,188,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,Safety,safe,safely,81,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:101,Performance,load,load,101,"// Otherwise there is something in the same BB clobbers the memory, we can't; // move this and later load to PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:20,Performance,load,load,20,// Transfer the old load's AA tags to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Performance,load,load,46,// Transfer the old load's AA tags to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Performance,load,load,31,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:74,Performance,load,load,74,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:269,Performance,load,load,269,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:123,Safety,avoid,avoid,123,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,Performance,load,load,80,// For PredBB in CriticalEdgePredAndLoad we need to replace the uses of old; // load instruction with the new created load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:118,Performance,load,load,118,// For PredBB in CriticalEdgePredAndLoad we need to replace the uses of old; // load instruction with the new created load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:83,Availability,avail,available,83,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:258,Availability,avail,available,258,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:174,Performance,load,load,174,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:214,Performance,load,load,214,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:416,Performance,load,load,416,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:465,Performance,load,load,465,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:71,Performance,load,load,71,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:404,Security,access,access,404,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:520,Security,access,access,520,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:175,Performance,load,load,175,"// If any of these blocks has more than one successor (i.e. if the edge we; // just traversed was critical), then there are other paths through this; // block along which the load may not be anticipated. Hoisting the load; // above this block would be adding the load to execution paths along; // which it was not previously executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:217,Performance,load,load,217,"// If any of these blocks has more than one successor (i.e. if the edge we; // just traversed was critical), then there are other paths through this; // block along which the load may not be anticipated. Hoisting the load; // above this block would be adding the load to execution paths along; // which it was not previously executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:263,Performance,load,load,263,"// If any of these blocks has more than one successor (i.e. if the edge we; // just traversed was critical), then there are other paths through this; // block along which the load may not be anticipated. Hoisting the load; // above this block would be adding the load to execution paths along; // which it was not previously executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:70,Availability,avail,available,70,// Check to see how many predecessors have the loaded value fully; // available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:47,Performance,load,loaded,47,// Check to see how many predecessors have the loaded value fully; // available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Performance,Load,LoadBB,25,// The edge from Pred to LoadBB is a critical edge will be splitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Performance,Load,LoadBB,25,"// The edge from Pred to LoadBB is a critical edge, another successor of Pred; // contains a load can be moved to Pred. This data structure maps the Pred to; // the movable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:93,Performance,load,load,93,"// The edge from Pred to LoadBB is a critical edge, another successor of Pred; // contains a load can be moved to Pred. This data structure maps the Pred to; // the movable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:173,Performance,load,load,173,"// The edge from Pred to LoadBB is a critical edge, another successor of Pred; // contains a load can be moved to Pred. This data structure maps the Pred to; // the movable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:126,Performance,load,load,126,"// If any predecessor block is an EH pad that does not allow non-PHI; // instructions before the terminator, we can't PRE the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:45,Performance,load,load,45,// Decide whether PRE is profitable for this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:184,Availability,avail,available,184,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,Performance,load,load,28,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:194,Performance,Load,Load,194,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:216,Performance,load,load,216,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Performance,load,load,36,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:106,Performance,load,load,106,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,Safety,safe,safe,68,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Deployability,update,update,29,"// Split critical edges, and update the unavailable predecessors accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:16,Performance,load,load,16,// Check if the load can safely be moved to all the unavailable predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Safety,safe,safely,25,// Check if the load can safely be moved to all the unavailable predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:473,Availability,avail,available,473,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:219,Performance,Load,Load,219,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:239,Performance,Load,LoadBB,239,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:383,Performance,load,load,383,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,Safety,safe,safe,360,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Performance,load,load,31,"// Okay, we can eliminate this load by inserting a reload in the predecessor; // and using PHI construction to get the value in the other predecessors, do; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,Performance,load,load,81,// Instructions that have been inserted in predecessor(s) to materialize; // the load address do not retain their original debug locations. Doing; // so could lead to confusing (but correct) source attributions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:82,Availability,avail,availability,82,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:237,Availability,AVAIL,AVAIL-IN,237,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Safety,risk,risk,125,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:11,Availability,avail,available,11,// Must be available in preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,Availability,fault,fault,68,"// We plan to hoist the load to preheader without introducing a new fault.; // In order to do it, we need to prove that we cannot side-exit the loop; // once loop header is first entered before execution of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:24,Performance,load,load,24,"// We plan to hoist the load to preheader without introducing a new fault.; // In order to do it, we need to prove that we cannot side-exit the loop; // once loop header is first entered before execution of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:211,Performance,load,load,211,"// We plan to hoist the load to preheader without introducing a new fault.; // In order to do it, we need to prove that we cannot side-exit the loop; // once loop header is first entered before execution of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:78,Safety,safe,safely,78,"// Make sure the memory at this pointer cannot be freed, therefore we can; // safely reload from it after clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:38,Integrability,depend,dependencies,38,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Performance,load,load,27,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:73,Performance,perform,performing,73,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:30,Integrability,depend,dependencies,30,// Step 1: Find the non-local dependencies of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:50,Performance,load,load,50,// Step 1: Find the non-local dependencies of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:69,Integrability,depend,dependencies,69,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:88,Performance,load,load,88,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:121,Performance,Optimiz,Optimizing,121,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Availability,failure,failure,31,"// If we had a phi translation failure, we'll have a single entry which is a; // clobber in the current block. Reject this early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:11,Performance,load,load,11,"// If this load follows a GEP, see if we can PRE the indices before analyzing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Availability,avail,availability,23,// Step 2: Analyze the availability of the load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:43,Performance,load,load,43,// Step 2: Analyze the availability of the load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:66,Performance,load,load,66,"// If we have no predecessors that produce a known value for this load, exit; // early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:145,Availability,redundant,redundant,145,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:243,Availability,redundant,redundant,243,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:77,Integrability,depend,depend,77,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:122,Performance,load,load,122,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Safety,redund,redundancy,27,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:145,Safety,redund,redundant,145,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:243,Safety,redund,redundant,243,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:55,Deployability,update,update,55,"// If instruction I has debug info, then we should not update it.; // Also, if I has a null DebugLoc, then it is still potentially incorrect; // to propagate Load's DebugLoc because Load may not post-dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:158,Performance,Load,Load,158,"// If instruction I has debug info, then we should not update it.; // Also, if I has a null DebugLoc, then it is still potentially incorrect; // to propagate Load's DebugLoc because Load may not post-dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,Performance,Load,Load,182,"// If instruction I has debug info, then we should not update it.; // Also, if I has a null DebugLoc, then it is still potentially incorrect; // to propagate Load's DebugLoc because Load may not post-dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Safety,redund,redundancy,29,// Step 4: Eliminate partial redundancy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:112,Performance,optimiz,optimization,112,"// If we can prove either side non-zero, then equality must imply; // equivalence.; // FIXME: We should do this optimization if 'no signed zeros' is; // applicable via an instruction-level fast-math-flag or some other; // indicator that relaxed FP semantics are being used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:112,Performance,optimiz,optimization,112,"// If we can prove either side non-zero, then equality must imply; // equivalence.; // FIXME: We should do this optimization if 'no signed zeros' is; // applicable via an instruction-level fast-math-flag or some other; // indicator that relaxed FP semantics are being used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:53,Performance,load,load,53,// Insert a new store to null instruction before the load to indicate that; // this code is not reachable. FIXME: We could insert unreachable; // instruction directly because we can modify the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:16,Security,access,accesses,16,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:123,Security,access,access,123,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:162,Security,access,access,162,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:205,Security,access,access,205,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:488,Performance,load,load,488,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:495,Performance,load,load,495,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:547,Performance,load,load,547,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:607,Performance,load,load,607,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:290,Testability,log,logic,290,"// Heuristically pick the better replacement -- the choice of heuristic; // isn't terribly important here, but the fact we canonicalize on some; // replacement is for exposing other simplifications.; // TODO: pull this out as a helper function and reuse w/existing; // (slightly different) logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,Usability,simpl,simplifications,182,"// Heuristically pick the better replacement -- the choice of heuristic; // isn't terribly important here, but the fact we canonicalize on some; // replacement is for exposing other simplifications.; // TODO: pull this out as a helper function and reuse w/existing; // (slightly different) logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:177,Testability,log,logic,177,"// NOTE: The non-block local cases are handled by the call to; // propagateEquality above; this block is just about handling the block; // local cases. TODO: There's a bunch of logic in propagateEqualiy which; // isn't duplicated for the block local case, can we share it somehow?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Performance,load,load,27,"/// Attempt to eliminate a load, first by eliminating it; /// locally, and then attempting non-local elimination if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Security,audit,audited,25,// This code hasn't been audited for ordered or volatile memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,Security,access,access,64,// This code hasn't been audited for ordered or volatile memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:34,Performance,load,loaded,34,// ... to a pointer that has been loaded from before...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:4,Integrability,Wrap,Wrap,4,/// Wrap phiTranslateImpl to provide caching functionality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:96,Integrability,depend,depend,96,"// If there is any value related with Num is defined in a BB other than; // PhiBlock, it cannot depend on a phi in PhiBlock without going through; // a backedge. We can do an early exit in that case to save compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:40,Performance,cache,cache,40,/// Erase stale entry from phiTranslate cache so phiTranslate can be computed; /// again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:237,Security,expose,expose,237,"// If there is no obvious reason to prefer the left-hand side over the; // right-hand side, ensure the longest lived term is on the right-hand side,; // so the shortest lived term will be replaced by the longest lived.; // This tends to expose more simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:249,Usability,simpl,simplifications,249,"// If there is no obvious reason to prefer the left-hand side over the; // right-hand side, ensure the longest lived term is on the right-hand side,; // so the shortest lived term will be replaced by the longest lived.; // This tends to expose more simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:517,Performance,optimiz,optimizing,517,"// If value numbering later sees that an instruction in the scope is equal; // to 'LHS' then ensure it will be turned into 'RHS'. In order to preserve; // the invariant that instructions only occur in the leader table for their; // own value number (this is used by removeFromLeaderTable), do not do this; // if RHS is an instruction (if an instruction in the scope is morphed into; // LHS then it will be turned into RHS by the next GVN iteration anyway, so; // using the leader table is about compiling faster, not optimizing better).; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:626,Usability,simpl,simple,626,"// If value numbering later sees that an instruction in the scope is equal; // to 'LHS' then ensure it will be turned into 'RHS'. In order to preserve; // the invariant that instructions only occur in the leader table for their; // own value number (this is used by removeFromLeaderTable), do not do this; // if RHS is an instruction (if an instruction in the scope is morphed into; // LHS then it will be turned into RHS by the next GVN iteration anyway, so; // using the leader table is about compiling faster, not optimizing better).; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Cache,Cached,3,// Cached information for anything that uses LHS will be invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Cache,Cached,3,// Cached information for anything that uses NotCmp will be invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:192,Usability,simpl,simple,192,"// Ensure that any instruction in scope that gets the ""A < B"" value number; // is replaced with false.; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:21,Availability,avail,availability,21,"/// When calculating availability, handle an instruction; /// by inserting it into the appropriate sets",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:133,Safety,redund,redundancies,133,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Security,expose,exposes,125,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Usability,simpl,simplified,36,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:293,Usability,simpl,simplify,293,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Usability,Simpl,Simplification,3,"// Simplification can cause a special instruction to become not special.; // For example, devirtualization to a willreturn function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Performance,perform,perform,36,"// For conditional branches, we can perform simple conditional propagation on; // the condition value itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:44,Usability,simpl,simple,44,"// For conditional branches, we can perform simple conditional propagation on; // the condition value itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiple edges early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:95,Safety,redund,redundancies,95,"// Instructions with void type don't return a value, so there's; // no point in trying to find redundancies in them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:62,Modifiability,inherit,inherited,62,// Perform fast-path value-number based elimination of values inherited from; // dominators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform fast-path value-number based elimination of values inherited from; // dominators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Availability,Failure,Failure,3,"// Failure, just remember this instance for future use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,Performance,optimiz,optimization,64,"// Merge unconditional branches, allowing PRE to catch more; // optimization opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:73,Performance,perform,performPRE,73,// Fabricate val-num for dead-code in order to suppress assertion in; // performPRE().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:56,Testability,assert,assertion,56,// Fabricate val-num for dead-code in order to suppress assertion in; // performPRE().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,Availability,redundant,redundant,127,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:205,Deployability,update,updates,205,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:275,Deployability,integrat,integrate,275,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:275,Integrability,integrat,integrate,275,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:17,Performance,perform,perform,17,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,Safety,redund,redundant,127,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Usability,Clear,Clearing,3,// Clearing map before every BB because it can be used only for single BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:91,Security,hash,hash,91,"// Since we may not have visited the input blocks of the phis, we can't; // use our normal hash approach for phis. Instead, simply look for; // obvious duplicates. The first pass of GVN will tend to create; // identical phis, and the second or later passes can eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:124,Usability,simpl,simply,124,"// Since we may not have visited the input blocks of the phis, we can't; // use our normal hash approach for phis. Instead, simply look for; // obvious duplicates. The first pass of GVN will tend to create; // identical phis, and the second or later passes can eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Safety,Avoid,Avoid,3,// Avoid iterator invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,Availability,down,down,28,"// Because we are going top-down through the block, all value numbers; // will be available in the predecessor by the time we need them. Any; // that weren't originally present will have been instantiated earlier; // in this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:82,Availability,avail,available,82,"// Because we are going top-down through the block, all value numbers; // will be available in the predecessor by the time we need them. Any; // that weren't originally present will have been instantiated earlier; // in this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:152,Modifiability,Rewrite,Rewrite,152,"// This could be a newly inserted instruction, in which case, we won't; // find a value number, and should give up before we hurt ourselves.; // FIXME: Rewrite the infrastructure to let it easier to value number; // and process newly inserted instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:51,Availability,avail,available,51,// Fail out if we encounter an operand that is not available in; // the PRE predecessor. This is typically because of loads which; // are not value numbered precisely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:118,Performance,load,loads,118,// Fail out if we encounter an operand that is not available in; // the PRE predecessor. This is typically because of loads which; // are not value numbered precisely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,Availability,avail,availability,14,// Update the availability map to include the new instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Deployability,Update,Update,3,// Update the availability map to include the new instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:334,Availability,avail,available,334,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:138,Modifiability,Extend,Extending,138,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:290,Performance,Load,Load,290,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:355,Performance,load,load,355,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Deployability,Update,Update,3,// Update the RPO numbers for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:13,Safety,safe,safe,13,// It is not safe to do PRE when P->CurrentBlock is a loop backedge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:121,Performance,perform,perform,121,"// We may have a case where all predecessors have the instruction,; // and we just need to insert a phi node. Otherwise, perform; // insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:60,Energy Efficiency,schedul,schedule,60,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:98,Performance,perform,perform,98,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,Safety,safe,safely,19,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:34,Availability,avail,available,34,// Create a PHI to make the value available in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:55,Deployability,patch,patch,55,"// If we use an existing value in this phi, we have to patch the original; // value because the phi will be used to replace a later value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:147,Performance,cache,cache,147,"// After creating a new PHI for ValNo, the phi translate result for ValNo will; // be changed, so erase the related stale entries in phi translate cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:4,Performance,Perform,Perform,4,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:105,Performance,perform,perform,105,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:113,Usability,simpl,simple,113,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:9,Performance,perform,perform,9,// Don't perform PRE on an EH pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Usability,simpl,simplify,29,"// GVN does not require loop-simplify, do not try to preserve it if it is not; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:90,Performance,optimiz,optimization,90,/// Split critical edges found during the previous; /// iteration that may enable further optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,Availability,down,down,7,// Top-down walk of the dominator tree,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:179,Deployability,update,update,179,"/// BB is declared dead, which implied other blocks become dead as well. This; /// function is to add all these blocks to ""DeadBlocks"". For the dead blocks'; /// live successors, update their phi nodes by replacing the operands; /// corresponding to dead blocks with UndefVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:57,Deployability,update,update,57,// S could be proved dead later on. That is why we don't update phi; // operands at this moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:41,Deployability,update,update,41,"// For the dead blocks' live successors, update their phi nodes by replacing; // the operands corresponding to dead blocks with UndefVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:573,Deployability,Update,Update,573,"// If the given branch is recognized as a foldable branch (i.e. conditional; // branch with constant condition), it will perform following analyses and; // transformation.; // 1) If the dead out-coming edge is a critical-edge, split it. Let; // R be the target of the dead out-coming edge.; // 1) Identify the set of dead blocks implied by the branch's dead outcoming; // edge. The result of this step will be {X| X is dominated by R}; // 2) Identify those blocks which haves at least one dead predecessor. The; // result of this step will be dominance-frontier(R).; // 3) Update the PHIs in DF(R) by replacing the operands corresponding to; // dead blocks with ""UndefVal"" in an hope these PHIs will optimized away.; //; // Return true iff *NEW* dead code are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:121,Performance,perform,perform,121,"// If the given branch is recognized as a foldable branch (i.e. conditional; // branch with constant condition), it will perform following analyses and; // transformation.; // 1) If the dead out-coming edge is a critical-edge, split it. Let; // R be the target of the dead out-coming edge.; // 1) Identify the set of dead blocks implied by the branch's dead outcoming; // edge. The result of this step will be {X| X is dominated by R}; // 2) Identify those blocks which haves at least one dead predecessor. The; // result of this step will be dominance-frontier(R).; // 3) Update the PHIs in DF(R) by replacing the operands corresponding to; // dead blocks with ""UndefVal"" in an hope these PHIs will optimized away.; //; // Return true iff *NEW* dead code are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:700,Performance,optimiz,optimized,700,"// If the given branch is recognized as a foldable branch (i.e. conditional; // branch with constant condition), it will perform following analyses and; // transformation.; // 1) If the dead out-coming edge is a critical-edge, split it. Let; // R be the target of the dead out-coming edge.; // 1) Identify the set of dead blocks implied by the branch's dead outcoming; // edge. The result of this step will be {X| X is dominated by R}; // 2) Identify those blocks which haves at least one dead predecessor. The; // result of this step will be dominance-frontier(R).; // 3) Update the PHIs in DF(R) by replacing the operands corresponding to; // dead blocks with ""UndefVal"" in an hope these PHIs will optimized away.; //; // Return true iff *NEW* dead code are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,perform,performPRE,3,"// performPRE() will trigger assert if it comes across an instruction without; // associated val-num. As it normally has far more live instructions than dead; // instructions, it makes more sense just to ""fabricate"" a val-number for the; // dead code than checking if instruction involved is dead or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Testability,assert,assert,29,"// performPRE() will trigger assert if it comes across an instruction without; // associated val-num. As it normally has far more live instructions than dead; // instructions, it makes more sense just to ""fabricate"" a val-number for the; // dead code than checking if instruction involved is dead or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,Integrability,interface,interface,14,// The public interface to this file...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1427,Availability,redundant,redundant,1427,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:595,Energy Efficiency,reduce,reduce,595,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:638,Energy Efficiency,reduce,reduce,638,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:39,Performance,load,load,39,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1671,Performance,perform,performance,1671,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1825,Performance,load,load,1825,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1427,Safety,redund,redundant,1427,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:15,Performance,load,load,15,// Records all load instructions candidate for code hoisting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:10,Performance,Load,Load,10,// Insert Load and the value number of its memory address in VNtoLoads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:36,Performance,load,loads,36,"// With opaque pointers we may have loads from the same pointer with; // different result types, which should be disambiguated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Security,hash,hash,26,// Insert the Store and a hash number of the store address and the stored; // value in VNtoStores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:3,Security,Hash,Hash,3,// Hash the store address and the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:100,Performance,Load,Load,100,"// A call that doesNotAccessMemory is handled as a Scalar,; // onlyReadsMemory will be handled as a Load instruction,; // all other calls will be handled as stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:109,Energy Efficiency,reduce,reduce,109,"// This pass hoists common computations across branches sharing common; // dominator. The primary goal is to reduce the code size, and in some; // cases reduce critical path (by exposing more ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:153,Energy Efficiency,reduce,reduce,153,"// This pass hoists common computations across branches sharing common; // dominator. The primary goal is to reduce the code size, and in some; // cases reduce critical path (by exposing more ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:279,Usability,simpl,simplify,279,"// Copied from NewGVN.cpp; // This function provides global ranking of operations so that we can place; // them in a canonical order. Note that rank alone is not necessarily enough; // for a complete ordering, as constants all have the same rank. However,; // generally, we will simplify an operation with all constants so that it; // doesn't matter what order they appear in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:52,Performance,load,loads,52,"// Return true when there are exception handling or loads of memory Def; // between Def and NewPt. This function is only called for stores: Def is; // the MemoryDef of the store to be hoisted.; // Decrement by 1 NBBsOnAllPaths for each block between HoistPt and BB, and; // return true when the counter NBBsOnAllPaths reaces 0, except when it is; // initialized to -1 which is unlimited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:49,Performance,load,load,49,// Return true when it is safe to hoist a memory load or store U from OldPt; // to NewPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Safety,safe,safe,26,// Return true when it is safe to hoist a memory load or store U from OldPt; // to NewPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Safety,safe,safe,26,// Return true when it is safe to hoist scalar instructions from all blocks in; // WL to HoistBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:480,Availability,redundant,redundant,480,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:508,Availability,redundant,redundant,508,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:304,Safety,Redund,Redundancy,304,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:480,Safety,redund,redundant,480,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:508,Safety,redund,redundant,508,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:18,Safety,safe,safe,18,"// Check if it is safe to hoist values tracked by CHI in the range; // [Begin, End) and accumulate them in Safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:107,Safety,Safe,Safe,107,"// Check if it is safe to hoist values tracked by CHI in the range; // [Begin, End) and accumulate them in Safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:36,Availability,down,down,36,"// Walk the post-dominator tree top-down and use a stack for each value to; // store the last value you see. When you hit a CHI from a given edge, the; // value to use as the argument is at the top of the stack, add the value to; // CHI and pop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:128,Safety,safe,safe,128,// Walk all the CHI-nodes to find ones which have a empty-entry and remove; // them Then collect all the instructions which are safe to hoist and see if; // they form a list of anticipable values. OutValues contains CHIs; // corresponding to each basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:22,Availability,redundant,redundant,22,"// TODO: Remove fully-redundant expressions.; // Get instruction from the Map, assume that all the Instructions; // with same VNs have same rank (this is an approximation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:22,Safety,redund,redundant,22,"// TODO: Remove fully-redundant expressions.; // Get instruction from the Map, assume that all the Instructions; // with same VNs have same rank (this is an approximation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:187,Integrability,depend,dependent,187,// Compute the Post Dominance Frontiers of each basic block; // The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:311,Integrability,depend,dependence,311,// Compute the Post Dominance Frontiers of each basic block; // The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:75,Integrability,depend,dependence,75,// Insert CHI args at each PDF to iterate on factored graph of; // control dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:46,Availability,avail,available,46,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:277,Availability,avail,available,277,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:159,Performance,load,load,159,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:185,Security,access,access,185,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:32,Availability,avail,available,32,// Make all operands of the GEP available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:69,Availability,avail,available,69,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:25,Performance,load,load,25,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:187,Performance,load,load,187,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:115,Safety,avoid,avoid,115,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:3,Performance,Perform,Perform,3,// Perform DFS Numbering of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:39,Safety,avoid,avoid,39,// FIXME: use lazy evaluation of VN to avoid the fix-point computation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:159,Integrability,depend,dependent,159,"// To address a limitation of the current GVN, we need to rerun the; // hoisting after we hoisted loads or stores in order to be able to; // hoist all scalars dependent on the hoisted ld/st.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:98,Performance,load,loads,98,"// To address a limitation of the current GVN, we need to rerun the; // hoisting after we hoisted loads or stores in order to be able to; // hoist all scalars dependent on the hoisted ld/st.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:262,Safety,safe,safe,262,// Walk all basic blocks reachable in depth-first iteration on the inverse; // CFG from OldBB to NewBB. These blocks are all the blocks that may be; // executed between the execution of NewBB and OldBB. Hoisting an expression; // from OldBB into NewBB has to be safe on all execution paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:42,Performance,load,loads,42,// Check that we do not move a store past loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:280,Safety,safe,safe,280,// Walk all basic blocks reachable in depth-first iteration on; // the inverse CFG from BBInsn to NewHoistPt. These blocks are all the; // blocks that may be executed between the execution of NewHoistPt and; // BBInsn. Hoisting an expression from BBInsn into NewHoistPt has to be safe; // on all execution paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:24,Safety,safe,safe,24,// In place hoisting is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:13,Integrability,depend,dependences,13,// Check for dependences on the Memory SSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:19,Performance,load,load,19,// Cannot move the load or store to NewBB above its definition in DBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:19,Performance,load,load,19,// Cannot move the load or store to NewPt above its definition in D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:13,Safety,unsafe,unsafe,13,// Check for unsafe hoistings due to side effects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Safety,safe,safe,26,// No side effects: it is safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:170,Safety,safe,safe,170,"// If the Terminator is some kind of ""exotic terminator"" that produces a; // value (such as InvokeInst, CallBrInst, or CatchSwitchInst) which the CHI; // uses, it is not safe to hoist the use above the def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:164,Integrability,depend,dependent,164,"// The Basic Block where CHI is must dominate the value we want to; // track in a CHI. In the PDom walk, there can be values in the; // stack which are not control dependent e.g., nested loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:32,Safety,safe,safety,32,// Collect values which satisfy safety checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:16,Safety,safe,safety,16,"// We check for safety first because there might be multiple values in; // the same path, some of which are not safe to be hoisted, but overall; // each edge has at least one value which can be hoisted, making the; // value anticipable along that path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:112,Safety,safe,safe,112,"// We check for safety first because there might be multiple values in; // the same path, some of which are not safe to be hoisted, but overall; // each edge has at least one value which can be hoisted, making the; // value anticipable along that path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:11,Safety,safe,safe,11,// List of safe values should be anticipable at TI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:10,Availability,avail,available,10,// Gep is available if all operands of GepOp are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:49,Availability,avail,available,49,// Gep is available if all operands of GepOp are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:14,Availability,avail,available,14,// Gep is not available if it has operands other than GEPs that are; // defined in blocks not dominating HoistPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:40,Availability,avail,available,40,// Check whether the operand is already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:87,Availability,avail,available,87,"// As a GEP can refer to other GEPs, recursively make all the operands; // of this GEP available at HoistPt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:30,Performance,optimiz,optimization,30,"// Conservatively discard any optimization hints, they may differ on the; // other paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:14,Performance,optimiz,optimization,14,"// If we have optimization hints which agree with each other along different; // paths, preserve them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:3,Deployability,Update,Update,3,// Update the uses of the old MSSA access with NewMemAcc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:35,Security,access,access,35,// Update the uses of the old MSSA access with NewMemAcc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:38,Performance,cache,cache,38,// Also invalidate the Alias Analysis cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:56,Security,access,access,56,// Replace all other instructions with Repl with memory access NewMemAcc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:34,Availability,avail,available,34,// Check that the stored value is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:72,Deployability,update,update,72,"// If there are two instructions in HoistPt to be hoisted in place:; // update Repl to be the first one, such that we can rename the uses; // of the second based on the first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:58,Availability,avail,available,58,// We can move Repl in HoistPt only when all operands are available.; // The order in which hoistings are done may influence the availability; // of operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:129,Availability,avail,availability,129,// We can move Repl in HoistPt only when all operands are available.; // The order in which hoistings are done may influence the availability; // of operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:78,Availability,avail,available,78,// When HoistingGeps there is nothing more we can do to make the; // operands available: just continue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:41,Deployability,update,update,41,// Drop debug location as per debug info update guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:48,Usability,guid,guide,48,// Drop debug location as per debug info update guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:298,Usability,simpl,simply,298,// Note: This needs to return a SmallSetVector as the elements of; // ActiveBlocks will be later copied to Blocks using std::copy. The; // resultant order of elements in Blocks needs to be deterministic.; // Using SmallPtrSet instead causes non-deterministic order while; // copying. And we cannot simply sort Blocks as they need to match the; // corresponding Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:257,Energy Efficiency,efficient,efficient,257,//===----------------------------------------------------------------------===//; /// Describes a PHI node that may or may not exist. These track the PHIs; /// that must be created if we sunk a sequence of instructions. It provides; /// a hash function for efficient equality comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:239,Security,hash,hash,239,//===----------------------------------------------------------------------===//; /// Describes a PHI node that may or may not exist. These track the PHIs; /// that must be created if we sunk a sequence of instructions. It provides; /// a hash function for efficient equality comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:32,Availability,down,down,32,/// Restrict the PHI's contents down to only \c NewBlocks.; /// \c NewBlocks must be a subset of \c this->Blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:3,Security,Hash,Hash,3,// Hash functor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:70,Performance,Load,LoadInst,70,"/// Helper to compute the value number for a memory instruction; /// (LoadInst/StoreInst), including checking the memory ordering and; /// volatility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:559,Usability,simpl,simply,559,"/// \c Inst uses or touches memory. Return an ID describing the memory state; /// at \c Inst such that if getMemoryUseOrder(I1) == getMemoryUseOrder(I2),; /// the exact same memory operations happen after I1 and I2.; ///; /// This is a very hard problem in general, so we use domain-specific; /// knowledge that we only ever check for equivalence between blocks sharing a; /// single immediate successor that is common, and when determining if I1 ==; /// I2 we will have already determined that next(I1) == next(I2). This; /// inductive property allows us to simply return the value number of the next; /// instruction that defines memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:4,Performance,Perform,Perform,4,"/// Perform the actual mechanics of sinking an instruction from Blocks into; /// BBEnd, which is their only successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:46,Availability,down,down,46,// Now restrict the number of incoming blocks down to only those with; // VNumToSink.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:54,Availability,redundant,redundant,54,// Does sinking this instruction render previous PHIs redundant?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:54,Safety,redund,redundant,54,// Does sinking this instruction render previous PHIs redundant?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:3,Deployability,Update,Update,3,// Update metadata and IR flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:974,Availability,redundant,redundant,974,"//===- InductiveRangeCheckElimination.cpp - -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The InductiveRangeCheckElimination pass splits a loop's iteration space into; // three disjoint ranges. It does that in a way such that the loop running in; // the middle loop provably does not need range checks. As an example, it will; // convert; //; // len = < known positive >; // for (i = 0; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; // to; //; // len = < known positive >; // limit = smin(n, len); // // no first segment; // for (i = 0; i < limit; i++) {; // if (0 <= i && i < len) { // this check is fully redundant; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; // for (i = limit; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:974,Safety,redund,redundant,974,"//===- InductiveRangeCheckElimination.cpp - -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The InductiveRangeCheckElimination pass splits a loop's iteration space into; // three disjoint ranges. It does that in a way such that the loop running in; // the middle loop provably does not need range checks. As an example, it will; // convert; //; // len = < known positive >; // for (i = 0; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; // to; //; // len = < known positive >; // limit = smin(n, len); // // no first segment; // for (i = 0; i < limit; i++) {; // if (0 <= i && i < len) { // this check is fully redundant; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; // for (i = limit; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:303,Modifiability,variab,variable,303,/// An inductive range check is conditional branch in a loop with; ///; /// 1. a very cold successor (i.e. the branch jumps to that successor very; /// rarely); ///; /// and; ///; /// 2. a condition that is provably true for some contiguous range of values; /// taken by the containing loop's induction variable.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:90,Availability,redundant,redundant,90,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:39,Modifiability,variab,variable,39,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:152,Modifiability,variab,variable,152,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:215,Modifiability,variab,variable,215,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:90,Safety,redund,redundant,90,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:265,Safety,avoid,avoid,265,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:377,Safety,safe,safe,377,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:620,Safety,Safe,Safe,620,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:1090,Safety,Safe,Safe,1090,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:13,Safety,safe,safe,13,// Compute a safe set of limits for the main loop to run in -- effectively the; // intersection of `Range' and the iteration space of the original loop.; // Return std::nullopt if unable to compute the set of subranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:179,Integrability,wrap,wrapping,179,"// I think we can be more aggressive here and make this nuw / nsw if the; // addition that feeds into the icmp for the latch's terminating branch is nuw; // / nsw. In any case, a wrapping 2's complement addition is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:215,Safety,safe,safe,215,"// I think we can be more aggressive here and make this nuw / nsw if the; // addition that feeds into the icmp for the latch's terminating branch is nuw; // / nsw. In any case, a wrapping 2's complement addition is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:141,Modifiability,variab,variable,141,"// We compute `Smallest` and `Greatest` such that [Smallest, Greatest), or; // [Smallest, GreatestSeen] is the range of values the induction variable; // takes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:106,Modifiability,variab,variable,106,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:352,Modifiability,variab,variable,352,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:749,Safety,safe,safe,749,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:61,Modifiability,variab,variable,61,"/// Computes and returns a range of values for the induction variable (IndVar); /// in which the range check can be safely elided. If it cannot compute such a; /// range, returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:116,Safety,safe,safely,116,"/// Computes and returns a range of values for the induction variable (IndVar); /// in which the range check can be safely elided. If it cannot compute such a; /// range, returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:688,Integrability,depend,depending,688,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:79,Modifiability,variab,variable,79,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:270,Modifiability,rewrite,rewrite,270,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:538,Safety,safe,safe,538,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:627,Safety,avoid,avoid,627,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:924,Safety,safe,safe,924,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:987,Safety,safe,safe,987,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:488,Integrability,depend,depending,488,"// Subtract Y from X so that it does not go through border of the IV; // iteration space. Mathematically, it is equivalent to:; //; // ClampedSubtract(X, Y) = min(max(X - Y, INT_MIN), INT_MAX). [1]; //; // In [1], 'X - Y' is a mathematical subtraction (result is not bounded to; // any width of bit grid). But after we take min/max, the result is; // guaranteed to be within [INT_MIN, INT_MAX].; //; // In [1], INT_MAX and INT_MIN are respectively signed and unsigned max/min; // values, depending on type of latch condition that defines IV iteration; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:241,Safety,safe,safely,241,"// X is a number from signed range, Y is interpreted as signed.; // Even if Y is SINT_MAX, (X - Y) does not reach SINT_MIN. So the only; // thing we should care about is that we didn't cross SINT_MAX.; // So, if Y is positive, we subtract Y safely.; // Rule 1: Y > 0 ---> Y.; // If 0 <= -Y <= (SINT_MAX - X), we subtract Y safely.; // Rule 2: Y >=s (X - SINT_MAX) ---> Y.; // If 0 <= (SINT_MAX - X) < -Y, we can only subtract (X - SINT_MAX).; // Rule 3: Y <s (X - SINT_MAX) ---> (X - SINT_MAX).; // It gives us smax(Y, X - SINT_MAX) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:323,Safety,safe,safely,323,"// X is a number from signed range, Y is interpreted as signed.; // Even if Y is SINT_MAX, (X - Y) does not reach SINT_MIN. So the only; // thing we should care about is that we didn't cross SINT_MAX.; // So, if Y is positive, we subtract Y safely.; // Rule 1: Y > 0 ---> Y.; // If 0 <= -Y <= (SINT_MAX - X), we subtract Y safely.; // Rule 2: Y >=s (X - SINT_MAX) ---> Y.; // If 0 <= (SINT_MAX - X) < -Y, we can only subtract (X - SINT_MAX).; // Rule 3: Y <s (X - SINT_MAX) ---> (X - SINT_MAX).; // It gives us smax(Y, X - SINT_MAX) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:239,Safety,safe,safely,239,"// X is a number from unsigned range, Y is interpreted as signed.; // Even if Y is SINT_MIN, (X - Y) does not reach UINT_MAX. So the only; // thing we should care about is that we didn't cross zero.; // So, if Y is negative, we subtract Y safely.; // Rule 1: Y <s 0 ---> Y.; // If 0 <= Y <= X, we subtract Y safely.; // Rule 2: Y <=s X ---> Y.; // If 0 <= X < Y, we should stop at 0 and can only subtract X.; // Rule 3: Y >s X ---> X.; // It gives us smin(X, Y) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:308,Safety,safe,safely,308,"// X is a number from unsigned range, Y is interpreted as signed.; // Even if Y is SINT_MIN, (X - Y) does not reach UINT_MAX. So the only; // thing we should care about is that we didn't cross zero.; // So, if Y is negative, we subtract Y safely.; // Rule 1: Y <s 0 ---> Y.; // If 0 <= Y <= X, we subtract Y safely.; // Rule 2: Y <=s X ---> Y.; // If 0 <= X < Y, we should stop at 0 and can only subtract X.; // Rule 3: Y >s X ---> X.; // It gives us smin(X, Y) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:442,Safety,safe,safe,442,"// FIXME: Current implementation of ClampedSubtract implicitly assumes that; // X is non-negative (in sense of a signed value). We need to re-implement; // this function in a way that it will correctly handle negative X as well.; // We use it twice: for X = 0 everything is fine, but for X = getEnd() we can; // end up with a negative X and produce wrong results. So currently we ensure; // that if getEnd() is negative then both ends of the safe range are zero.; // Note that this may pessimize elimination of unsigned range checks against; // negative values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:24,Modifiability,extend,extended,24,// End is computed with extended type but will be truncated to a narrow one; // type of range check. Therefore we need a check that the result will not; // overflow in terms of narrow type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:105,Usability,simpl,simple,105,// TODO: we could widen the smaller range and have this work; but for now we; // bail out to keep things simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:105,Usability,simpl,simple,105,// TODO: we could widen the smaller range and have this work; but for now we; // bail out to keep things simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:205,Safety,safe,safe,205,"// Basing on the type of latch predicate, we interpret the IV iteration range; // as signed or unsigned range. We use different min/max functions (signed or; // unsigned) when intersecting this range with safe iteration ranges implied; // by range checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:25,Availability,redundant,redundant,25,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:25,Safety,redund,redundant,25,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:1034,Integrability,depend,dependence,1034,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:38,Modifiability,Variab,Variable,38,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:441,Modifiability,variab,variables,441,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:1080,Modifiability,variab,variable,1080,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:497,Usability,simpl,simpler,497,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:192,Usability,simpl,simplifyAndExtend,192,/// Try to improve our exit conditions by converting condition from signed; /// to unsigned or rotating computation out of the loop.; /// (See inline comment about why this is duplicated from simplifyAndExtend),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:31,Testability,test,tests,31,/// Try to form loop invariant tests for loop exits by changing how many; /// iterations of the loop run when that is unobservable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:113,Modifiability,rewrite,rewriteNonIntegerIVs,113,"// end anonymous namespace; //===----------------------------------------------------------------------===//; // rewriteNonIntegerIVs and helpers. Prefer integer IVs.; //===----------------------------------------------------------------------===//; /// Convert APF to an integer, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:39,Modifiability,variab,variable,39,"/// If the loop has floating induction variable then insert corresponding; /// integer induction variable if possible.; /// For example,; /// for(double i = 0; i < 10000; ++i); /// bar(i); /// is converted into; /// for(int i = 0; i < 10000; ++i); /// bar((double)i);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:97,Modifiability,variab,variable,97,"/// If the loop has floating induction variable then insert corresponding; /// integer induction variable if possible.; /// For example,; /// for(double i = 0; i < 10000; ++i); /// bar(i); /// is converted into; /// for(int i = 0; i < 10000; ++i); /// bar((double)i);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:43,Modifiability,variab,variable,43,// We convert the floating point induction variable to a signed i32 value if; // we can. This is only safe if the comparison will not overflow in a way; // that won't be trapped by the integer equivalent operations. Check for this; // now.; // TODO: We could use i64 if it is native and the range requires it.; // The start/stride/exit values must all fit in signed i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:102,Safety,safe,safe,102,// We convert the floating point induction variable to a signed i32 value if; // we can. This is only safe if the comparison will not overflow in a way; // that won't be trapped by the integer equivalent operations. Check for this; // now.; // TODO: We could use i64 if it is native and the range requires it.; // The start/stride/exit values must all fit in signed i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:42,Safety,avoid,avoid,42,"// If not actually striding (add x, 0.0), avoid touching the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:48,Safety,safe,safety,48,// Positive and negative strides have different safety conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:140,Integrability,wrap,wrap,140,"// If this is an equality comparison, we require that the strided value; // exactly land on the exit value, otherwise the IV condition will wrap; // around and do things the fp IV wouldn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,Integrability,wrap,wrap,23,"// If the stride would wrap around the i32 before exiting, we can't; // transform the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:140,Integrability,wrap,wrap,140,"// If this is an equality comparison, we require that the strided value; // exactly land on the exit value, otherwise the IV condition will wrap; // around and do things the fp IV wouldn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,Integrability,wrap,wrap,23,"// If the stride would wrap around the i32 before exiting, we can't; // transform the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:32,Modifiability,variab,variable,32,// Insert new integer induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,Modifiability,variab,variable,23,"// If the FP induction variable still has uses, this is because something else; // in the loop uses its value. In order to canonicalize the induction; // variable, we chose to eliminate the IV and rewrite it in terms of an; // int->fp cast.; //; // We give preference to sitofp over uitofp because it is faster on most; // platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:154,Modifiability,variab,variable,154,"// If the FP induction variable still has uses, this is because something else; // in the loop uses its value. In order to canonicalize the induction; // variable, we chose to eliminate the IV and rewrite it in terms of an; // int->fp cast.; //; // We give preference to sitofp over uitofp because it is faster on most; // platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:197,Modifiability,rewrite,rewrite,197,"// If the FP induction variable still has uses, this is because something else; // in the loop uses its value. In order to canonicalize the induction; // variable, we chose to eliminate the IV and rewrite it in terms of an; // int->fp cast.; //; // We give preference to sitofp over uitofp because it is faster on most; // platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:165,Integrability,rout,routines,165,"// First step. Check to see if there are any floating-point recurrences.; // If there are, change them into integer recurrences, permitting analysis by; // the SCEV routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:84,Modifiability,rewrite,rewriteFirstIterationLoopExitValues,84,"//===---------------------------------------------------------------------===//; // rewriteFirstIterationLoopExitValues: Rewrite loop exit values if we know; // they will exit at the first iteration.; //===---------------------------------------------------------------------===//; /// Check to see if this loop has loop invariant conditions which lead to loop; /// exits. If so, we know that if the exit path is taken, it is at the first; /// loop iteration. This lets us predict exit values of PHI nodes that live in; /// loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:121,Modifiability,Rewrite,Rewrite,121,"//===---------------------------------------------------------------------===//; // rewriteFirstIterationLoopExitValues: Rewrite loop exit values if we know; // they will exit at the first iteration.; //===---------------------------------------------------------------------===//; /// Check to see if this loop has loop invariant conditions which lead to loop; /// exits. If so, we know that if the exit path is taken, it is at the first; /// loop iteration. This lets us predict exit values of PHI nodes that live in; /// loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:473,Safety,predict,predict,473,"//===---------------------------------------------------------------------===//; // rewriteFirstIterationLoopExitValues: Rewrite loop exit values if we know; // they will exit at the first iteration.; //===---------------------------------------------------------------------===//; /// Check to see if this loop has loop invariant conditions which lead to loop; /// exits. If so, we know that if the exit path is taken, it is at the first; /// loop iteration. This lets us predict exit values of PHI nodes that live in; /// loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:238,Deployability,Update,Update,238,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:99,Modifiability,Extend,Extend,99,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:277,Modifiability,variab,variable,277,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:294,Modifiability,extend,extended,294,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:329,Modifiability,extend,extend,329,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:30,Modifiability,extend,extends,30,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:52,Modifiability,variab,variable,52,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:131,Modifiability,extend,extending,131,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:182,Modifiability,variab,variable,182,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:259,Modifiability,variab,variable,259,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:276,Modifiability,variab,variable,276,// Cast is either an sext or zext up to this point.; // We should not widen an indvar if arithmetics on the wider indvar are more; // expensive than those on the narrower indvar. We check only the cost of ADD; // because at least an ADD is required to increment the induction variable. We; // could compute more comprehensively the cost of all instructions on the; // induction variable when necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:378,Modifiability,variab,variable,378,// Cast is either an sext or zext up to this point.; // We should not widen an indvar if arithmetics on the wider indvar are more; // expensive than those on the narrower indvar. We check only the cost of ADD; // because at least an ADD is required to increment the induction variable. We; // could compute more comprehensively the cost of all instructions on the; // induction variable when necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:6,Modifiability,extend,extend,6,"// We extend the IV to satisfy the sign of its user(s), or 'signed'; // if there are multiple users with both sign- and zero extensions,; // in order not to introduce nondeterministic behaviour based on the; // unspecified order of a PHI nodes' users-iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:308,Usability,Simpl,Simplification,308,//===----------------------------------------------------------------------===//; // Live IV Reduction - Minimize IVs live across the loop.; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Simplification of IV users based on SCEV evaluation.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:17,Integrability,interface,interface,17,// Implement the interface used by simplifyUsersOfIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:35,Usability,simpl,simplifyUsersOfIV,35,// Implement the interface used by simplifyUsersOfIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:230,Modifiability,extend,extend,230,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:44,Performance,perform,perform,44,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:52,Usability,simpl,simplification,52,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:115,Usability,simpl,simplification,115,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:194,Usability,simpl,simplification,194,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:272,Usability,simpl,simplification,272,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:17,Usability,simpl,simplification,17,"// Each round of simplification iterates through the SimplifyIVUsers worklist; // for all current phis, then determines whether any IVs can be; // widened. Widening adds new phis to LoopPhis, inducing another round of; // simplification on the wide IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:53,Usability,Simpl,SimplifyIVUsers,53,"// Each round of simplification iterates through the SimplifyIVUsers worklist; // for all current phis, then determines whether any IVs can be; // widened. Widening adds new phis to LoopPhis, inducing another round of; // simplification on the wide IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:222,Usability,simpl,simplification,222,"// Each round of simplification iterates through the SimplifyIVUsers worklist; // for all current phis, then determines whether any IVs can be; // widened. Widening adds new phis to LoopPhis, inducing another round of; // simplification on the wide IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:103,Integrability,wrap,wrap,103,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:324,Modifiability,extend,extend,324,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:266,Safety,predict,predictable,266,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:360,Safety,avoid,avoid,360,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:413,Usability,simpl,simplifyAndExtend,413,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:124,Modifiability,Rewrite,Rewrite,124,"//===----------------------------------------------------------------------===//; // linearFunctionTestReplace and its kin. Rewrite the loop exit condition.; //===----------------------------------------------------------------------===//; /// Given an Value which is hoped to be part of an add recurance in the given; /// loop, return the associated Phi node if so. Otherwise, return null. Note; /// that this is less general than SCEVs AddRec checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:34,Testability,test,test,34,/// Whether the current loop exit test is based on this value. Currently this; /// is limited to a direct use in the loop condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:29,Testability,test,test,29,// TODO: Allow non-icmp loop test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:96,Testability,test,test,96,/// linearFunctionTestReplace policy. Return true unless we can show that the; /// current exit test is already sufficiently canonical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:115,Performance,cache,cached,115,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,Testability,test,test,49,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:76,Testability,test,test,76,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,Usability,simpl,simplify,14,// Do LFTR to simplify the exit condition to an ICMP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,Usability,simpl,simplify,14,// Do LFTR to simplify the exit ICMP to EQ/NE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,Usability,simpl,simple,14,// Look for a simple IV counter LHS,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,Usability,simpl,simple,49,// Do LFTR if the exit condition's IV is *not* a simple counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:84,Availability,down,down,84,"/// Recursive helper for hasConcreteDef(). Unfortunately, this currently boils; /// down to checking that all operands are constant and listing instructions; /// that may hide undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Performance,Load,Load,3,// Load and return values may be undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:128,Availability,avail,available,128,"/// Search the loop header for a loop counter (anadd rec w/step of one); /// suitable for use by LFTR. If multiple counters are available, select the; /// ""best"" one based profitable heuristics.; ///; /// BECount may be an i8* pointer type. The pointer difference is already; /// valid count without scaling the address stride, so it remains a pointer; /// expression as far as SCEV is concerned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,Usability,simpl,simple,49,"// Loop over all of the PHI nodes, looking for a simple counter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:108,Testability,test,tests,108,"// AR may be a pointer type, while BECount is an integer type.; // AR may be wider than BECount. With eq/ne tests overflow is immaterial.; // AR may not be a narrower type, or we may never exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,// Avoid reusing a potentially undef value to compute other values that may; // have originally had a concrete definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,Performance,perform,performing,116,// We explicitly allow unknown phis as long as they are already used by; // the loop exit test. This is legal since performing LFTR could not; // increase the number of undef users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:90,Testability,test,test,90,// We explicitly allow unknown phis as long as they are already used by; // the loop exit test. This is legal since performing LFTR could not; // increase the number of undef users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,"// Avoid introducing undefined behavior due to poison which didn't exist in; // the original program. (Annoyingly, the rules for poison and undef; // propagation are distinct, so this does NOT cover the undef case above.); // We have to ensure that we don't introduce UB by introducing a use on an; // iteration where said IV produces poison. Our strategy here differs for; // pointers and integer IVs. For integers, we strip and reinfer as needed,; // see code in linearFunctionTestReplace. For pointers, we restrict; // transforms as there is no good way to reinfer inbounds once lost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:16,Modifiability,rewrite,rewrites,16,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:132,Modifiability,variab,variable,132,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:168,Modifiability,rewrite,rewrite,168,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:185,Testability,test,tests,185,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:348,Testability,test,tests,348,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:157,Testability,test,test,157,"// For pointer IVs, we chose to not strip inbounds which requires us not; // to add a potentially UB introducing use. We need to either a) show; // the loop test we're modifying is already in post-inc form, or b) show; // that adding a use must not introduce UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:721,Integrability,wrap,wraps,721,"// It may be necessary to drop nowrap flags on the incrementing instruction; // if either LFTR moves from a pre-inc check to a post-inc check (in which; // case the increment might have previously been poison on the last iteration; // only) or if LFTR switches to a different IV that was previously dynamically; // dead (and as such may be arbitrarily poison). We remove any nowrap flags; // that SCEV didn't infer for the post-inc addrec (even if we use a pre-inc; // check), because the pre-inc addrec flags may be adopted from the original; // instruction, while SCEV has to explicitly prove the post-inc nowrap flags.; // TODO: This handling is inaccurate for one case: If we switch to a; // dynamically dead IV that wraps on the first loop iteration only, which is; // not covered by the post-inc addrec. (If the new IV was not dynamically; // dead, it could not be poison on the first iteration in the first place.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:293,Integrability,wrap,wrap,293,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:78,Safety,avoid,avoid,78,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:219,Safety,safe,safe,219,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:139,Modifiability,extend,extend,139,"// Before resorting to actually inserting the truncate, use the same; // reasoning as from SimplifyIndvar::eliminateTrunc to see if we can extend; // the other side of the comparison instead. We still evaluate the limit; // in the narrower bitwidth, we just prefer a zext/sext outside the loop to; // a truncate within in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:91,Usability,Simpl,SimplifyIndvar,91,"// Before resorting to actually inserting the truncate, use the same; // reasoning as from SimplifyIndvar::eliminateTrunc to see if we can extend; // the other side of the comparison instead. We still evaluate the limit; // in the narrower bitwidth, we just prefer a zext/sext outside the loop to; // a truncate within in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:222,Deployability,update,update,222,"// It's tempting to use replaceAllUsesWith here to fully replace the old; // comparison, but that's not immediately safe, since users of the old; // comparison may not be dominated by the new comparison. Instead, just; // update the branch to use the new comparison; in the common case this; // will make old comparison dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,Safety,safe,safe,116,"// It's tempting to use replaceAllUsesWith here to fully replace the old; // comparison, but that's not immediately safe, since users of the old; // comparison may not be dominated by the new comparison. Instead, just; // update the branch to use the new comparison; in the common case this; // will make old comparison dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:397,Energy Efficiency,reduce,reduce,397,"//===----------------------------------------------------------------------===//; // sinkUnusedInvariants. A late subpass to cleanup loop preheaders.; //===----------------------------------------------------------------------===//; /// If there's a single exit block, sink any loop-invariant values that; /// were defined in the preheader but not used inside the loop into the; /// exit block to reduce register pressure in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:197,Modifiability,Refactor,Refactor,197,"// Don't sink alloca: we never want to sink static alloca's out of the; // entry block, and correctly sinking dynamic alloca's requires; // checks for stacksave/stackrestore intrinsics.; // FIXME: Refactor this check somehow?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:67,Usability,simpl,simplify,67,// Replacing with the preheader value will often allow IV users to simplify; // (especially if the preheader value is a constant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Usability,simpl,simplify,9,// Don't simplify instructions outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:80,Integrability,wrap,wrap,80,"// Semantically skip last iter is ""subtract 1, do not bother about unsigned; // wrap"". getLoopInvariantExitCondDuringFirstIterations knows how to deal; // with umin in a smart way, but umin(a, b) - 1 will likely not simplify.; // So we manually construct umin(a - 1, b - 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:216,Usability,simpl,simplify,216,"// Semantically skip last iter is ""subtract 1, do not bother about unsigned; // wrap"". getLoopInvariantExitCondDuringFirstIterations knows how to deal; // with umin in a smart way, but umin(a, b) - 1 will likely not simplify.; // So we manually construct umin(a - 1, b - 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:164,Testability,log,logic,164,"// For branch that stays in loop by TRUE condition, go through AND. For branch; // that stays in loop by FALSE condition, go through OR. Both gives the; // similar logic: ""stay in loop iff all conditions are true(false)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:99,Safety,avoid,avoid,99,"// Go through AND/OR conditions. Collect leaf ICMPs. We only care about; // those with one use, to avoid instruction duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:288,Modifiability,extend,extending,288,"// Note: This is duplicating a particular part on SimplifyIndVars reasoning.; // We need to duplicate it because given icmp zext(small-iv), C, IVUsers; // never reaches the icmp since the zext doesn't fold to an AddRec unless; // it already has flags. The alternative to this would be to extending the; // set of ""interesting"" IV users to include the icmp, but doing that; // regresses results in practice by querying SCEVs before trip counts which; // rely on them which results in SCEV caching sub-optimal answers. The; // concern about caching sub-optimal results is why we only query SCEVs of; // the loop invariant RHS here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:50,Usability,Simpl,SimplifyIndVars,50,"// Note: This is duplicating a particular part on SimplifyIndVars reasoning.; // We need to duplicate it because given icmp zext(small-iv), C, IVUsers; // never reaches the icmp since the zext doesn't fold to an AddRec unless; // it already has flags. The alternative to this would be to extending the; // set of ""interesting"" IV users to include the icmp, but doing that; // regresses results in practice by querying SCEVs before trip counts which; // rely on them which results in SCEV caching sub-optimal answers. The; // concern about caching sub-optimal results is why we only query SCEVs of; // the loop invariant RHS here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:85,Performance,cache,cache,85,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:28,Safety,avoid,avoid,28,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:65,Safety,avoid,avoid,65,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:8,Testability,log,logic,8,// Same logic applies for the inverse case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:59,Modifiability,extend,extend,59,"// Now that we've canonicalized the condition to match the extend,; // see if we can rotate the extend out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:96,Modifiability,extend,extend,96,"// Now that we've canonicalized the condition to match the extend,; // see if we can rotate the extend out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:102,Deployability,update,update,102,// Same logic applies for the inverse case until we actually pick; // which operand of the compare to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:8,Testability,log,logic,8,// Same logic applies for the inverse case until we actually pick; // which operand of the compare to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:50,Modifiability,Extend,Extend,50,"// Match (icmp unsigned-cond zext, RHS); // TODO: Extend to handle corresponding sext/signed-cmp case; // TODO: Extend to other invertible functions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:112,Modifiability,Extend,Extend,112,"// Match (icmp unsigned-cond zext, RHS); // TODO: Extend to handle corresponding sext/signed-cmp case; // TODO: Extend to other invertible functions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:38,Modifiability,rewrite,rewriteable,38,// Remove all exits which aren't both rewriteable and execute on every; // iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:59,Modifiability,rewrite,rewrite,59,"// If our exitting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:441,Performance,Optimiz,OptimizeCond,441,"// TODO: We might have proved that we can skip the last iteration for; // this check. In this case, we only want to check the condition on the; // pre-last iteration (MaxBECount - 1). However, there is a nasty; // corner case:; //; // for (i = len; i != 0; i--) { ... check (i ult X) ... }; //; // If we could not prove that len != 0, then we also could not prove that; // (len - 1) is not a UINT_MAX. If we simply query (len - 1), then; // OptimizeCond will likely not prove anything for it, even if it could; // prove the same fact for len.; //; // As a temporary solution, we query both last and pre-last iterations in; // hope that we will be able to prove triviality for at least one of; // them. We can stop querying MaxBECount for this case once SCEV; // understands that (MaxBECount - 1) will not overflow here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:408,Usability,simpl,simply,408,"// TODO: We might have proved that we can skip the last iteration for; // this check. In this case, we only want to check the condition on the; // pre-last iteration (MaxBECount - 1). However, there is a nasty; // corner case:; //; // for (i = len; i != 0; i--) { ... check (i ult X) ... }; //; // If we could not prove that len != 0, then we also could not prove that; // (len - 1) is not a UINT_MAX. If we simply query (len - 1), then; // OptimizeCond will likely not prove anything for it, even if it could; // prove the same fact for len.; //; // As a temporary solution, we query both last and pre-last iterations in; // hope that we will be able to prove triviality for at least one of; // them. We can stop querying MaxBECount for this case once SCEV; // understands that (MaxBECount - 1) will not overflow here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:48,Modifiability,rewrite,rewrite,48,"// If we know we'd exit on the first iteration, rewrite the exit to; // reflect this. This does not imply the loop must exit through this; // exit; there may be an earlier one taken on the first iteration.; // We know that the backedge can't be taken, so we replace all; // the header PHIs with values coming from the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:199,Energy Efficiency,power,powerful,199,"// TODO: There might be another oppurtunity to leverage SCEV's reasoning; // here. If we kept track of the min of dominanting exits so far, we could; // discharge exits with EC >= MDEC. This is less powerful than the existing; // transform (since later exits aren't considered), but potentially more; // powerful for any case where SCEV can prove a >=u b, but neither a == b; // or a >u b. Such a case is not currently known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:304,Energy Efficiency,power,powerful,304,"// TODO: There might be another oppurtunity to leverage SCEV's reasoning; // here. If we kept track of the min of dominanting exits so far, we could; // discharge exits with EC >= MDEC. This is less powerful than the existing; // transform (since later exits aren't considered), but potentially more; // powerful for any case where SCEV can prove a >=u b, but neither a == b; // or a >u b. Such a case is not currently known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:149,Availability,down,down,149,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:26,Modifiability,rewrite,rewrite,26,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:240,Modifiability,rewrite,rewrite,240,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:58,Modifiability,rewrite,rewrite,58,"// If our exiting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:193,Testability,assert,assert,193,"// We rely on not being able to reach an exiting block on a later iteration; // then it's statically compute exit count. The implementaton of; // getExitCount currently has this invariant, but assert it here so that; // breakage is obvious if this ever changes..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:532,Energy Efficiency,reduce,reduce,532,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:408,Testability,log,logic,408,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:190,Usability,simpl,simply,190,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:139,Usability,simpl,simplification,139,//===----------------------------------------------------------------------===//; // IndVarSimplify driver. Manage several subpasses of IV simplification.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:31,Availability,avail,available,31,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:238,Integrability,depend,depend,238,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:416,Modifiability,variab,variable,416,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:12,Modifiability,rewrite,rewriter,12,// Create a rewriter object which we'll use to transform the code with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:276,Integrability,wrap,wrap,276,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:163,Modifiability,extend,extend,163,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Safety,redund,redundant,13,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:126,Safety,avoid,avoid,126,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:41,Usability,Simpl,Simplification,41,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant IV cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Safety,redund,redundant,13,// Eliminate redundant IV cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:30,Testability,test,tests,30,// Try to form loop invariant tests for loop exits by changing how many; // iterations of the loop run when that is unobservable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:39,Modifiability,rewrite,rewrite,39,"// If we have a trip count expression, rewrite the loop's exit condition; // using it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:59,Modifiability,rewrite,rewrite,59,"// If our exitting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:160,Performance,optimiz,optimizeLoopExits,160,"// This was handled above, but as we form SCEVs, we can sometimes refine; // existing ones; this allows exit counts to be folded to zero which; // weren't when optimizeLoopExits saw them. Arguably, we should iterate; // until stable to handle cases like this better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,"// Avoid high cost expansions. Note: This heuristic is questionable in; // that our definition of ""high cost"" is not exactly principled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Modifiability,rewrite,rewriter,13,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:60,Modifiability,rewrite,rewriter,60,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:22,Performance,cache,cache,22,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:71,Performance,cache,cache,71,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:146,Performance,cache,cache,146,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:127,Testability,Assert,AssertingVH,127,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Usability,Clear,Clear,3,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:164,Energy Efficiency,reduce,reduce,164,// The Rewriter may not be used from this point on.; // Loop-invariant instructions in the preheader that aren't used in the; // loop may be sunk below the loop to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:7,Modifiability,Rewrite,Rewriter,7,// The Rewriter may not be used from this point on.; // Loop-invariant instructions in the preheader that aren't used in the; // loop may be sunk below the loop to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Modifiability,rewrite,rewriteFirstIterationLoopExitValues,3,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:156,Modifiability,rewrite,rewriteLoopExitValues,156,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,Usability,simpl,simplify,116,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3669,Availability,down,down,3669,"ble generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the converted %y. To address this complication,; // we break these cycles using ""poison"" placeholders. When converting an; // instruction `I` to a new address space, if its operand `Op` is not converted; // yet, we let `I` temporarily use `poison` and fix all the uses later.; // For instance, our algorithm first converts %y to; // %y' = phi float addrspace(3)* [ %input, poison ]; // Then, it converts %y2 to; // %y2' = getelementptr %y', 1; // Finally, it fixes the poison in %y' so that; // %y' = phi float addrspace(3)* [ %input, %y2' ]; //; //===-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3829,Availability,down,down,3829,"jor challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the converted %y. To address this complication,; // we break these cycles using ""poison"" placeholders. When converting an; // instruction `I` to a new address space, if its operand `Op` is not converted; // yet, we let `I` temporarily use `poison` and fix all the uses later.; // For instance, our algorithm first converts %y to; // %y' = phi float addrspace(3)* [ %input, poison ]; // Then, it converts %y2 to; // %y2' = getelementptr %y', 1; // Finally, it fixes the poison in %y' so that; // %y' = phi float addrspace(3)* [ %input, %y2' ]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:431,Modifiability,variab,variable,431,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:802,Modifiability,variab,variable,802,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:924,Modifiability,variab,variables,924,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1123,Modifiability,variab,variables,1123,"SE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1226,Modifiability,variab,variable,1226,"SE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1855,Modifiability,variab,variable,1855,"ations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:578,Performance,load,loads,578,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:611,Performance,load,load,611,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1583,Performance,load,load,1583,"_global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1758,Performance,optimiz,optimization,1758,"ations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1911,Performance,optimiz,optimizes,1911,"so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. F",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2004,Performance,load,load,2004,"so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. F",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2496,Performance,optimiz,optimizing,2496,"oad float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized ad",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2779,Performance,optimiz,optimization,2779,"propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific addre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3137,Performance,load,load,3137,"e NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:526,Security,access,access,526,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:10,Deployability,update,update,10,"// Try to update the address space of V. If V is updated, returns true and; // false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:49,Deployability,update,updated,49,"// Try to update the address space of V. If V is updated, returns true and; // false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:21,Safety,safe,safe,21,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:442,Usability,clear,clear,442,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:495,Usability,clear,clear,495,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:124,Performance,load,loads,124,"// Look at operations that may be interesting accelerate by moving to a known; // address space. We aim at generating after loads and stores, but pure; // addressing calculations may also be faster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:97,Integrability,wrap,wrapped,97,"// If !IsNew, we will replace the Value with itself. However, replaced values; // are assumed to wrapped in an addrspacecast cast later so drop it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:102,Integrability,wrap,wrap,102,"// Constants need to be tracked through RAUW to handle cases with nested; // constant expressions, so wrap values in WeakTrackingVH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:10,Deployability,update,update,10,// Try to update the address space of the stack top according to the; // address spaces of its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:22,Deployability,update,updates,22,"// Our algorithm only updates the address spaces of flat address; // expressions, which are those in InferredAddrSpace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:55,Availability,down,down,55,"// Function updateAddressSpace moves the address space down a lattice; // path. Therefore, nothing to do if User is already inferred as flat (the; // bottom element in the lattice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:12,Deployability,update,updateAddressSpace,12,"// Function updateAddressSpace moves the address space down a lattice; // path. Therefore, nothing to do if User is already inferred as flat (the; // bottom element in the lattice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:10,Deployability,update,updates,10,"// If any updates are made, grabs its users to the worklist because; // their address spaces can also be possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:114,Deployability,update,updated,114,"// If any updates are made, grabs its users to the worklist because; // their address spaces can also be possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:153,Usability,simpl,simply,153,"/// \p returns true if \p U is the pointer operand of a memory instruction with; /// a single pointer operand that can have its address space changed by simply; /// mutating the use to a new value. If the memory instruction is volatile,; /// return true only if the target allows the memory instruction to be volatile; /// in the new address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:4,Deployability,Update,Update,4,/// Update memory intrinsic uses that require more complex processing than; /// simple memory instructions. These require re-mangling and may have multiple; /// pointer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:80,Usability,simpl,simple,80,/// Update memory intrinsic uses that require more complex processing than; /// simple memory instructions. These require re-mangling and may have multiple; /// pointer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:61,Safety,safe,safe,61,"// If we already have a constant addrspacecast, it should be safe to cast it; // off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:183,Performance,load,load,183,"// If V is used as the pointer operand of a compatible memory operation,; // sets the pointer operand to NewV. This replacement does not change; // the element type, so the resultant load/store is still valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp:403,Performance,load,load,403,"//===- InferAlignment.cpp -------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Infer alignment for load, stores and other memory operations based on; // trailing zero known bits information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:74,Usability,simpl,simplify,74,"// The first time through the loop, ToSimplify is empty and we try to; // simplify all instructions. On later iterations, ToSimplify is not; // empty and we only bother simplifying instructions that are in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:169,Usability,simpl,simplifying,169,"// The first time through the loop, ToSimplify is empty and we try to; // simplify all instructions. On later iterations, ToSimplify is not; // empty and we only bother simplifying instructions that are in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:20,Usability,simpl,simplifying,20,// Don't waste time simplifying dead/unused instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:18,Usability,simpl,simplified,18,"// A call can get simplified, but it may not be trivially dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:37,Usability,simpl,simplify,37,// Place the list of instructions to simplify on the next loop iteration; // into ToSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:29,Usability,simpl,simplify,29,/// Remove instructions that simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:10,Integrability,interface,interface,10,// Public interface to the simplify instructions pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:27,Usability,simpl,simplify,27,// Public interface to the simplify instructions pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IVUsersPrinter.cpp:38,Modifiability,Variab,Variable,38,"//===- IVUsersPrinter.cpp - Induction Variable Users Printer ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IVUsersPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IVUsersPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update branch probability information according to conditional; // branch probability. This is usually made possible for cloned branches; // in inline instances by the context specific profile in the caller.; // For instance,; //; // [Block PredBB]; // [Branch PredBr]; // if (t) {; // Block A;; // } else {; // Block B;; // }; //; // [Block BB]; // cond = PN([true, %A], [..., %B]); // PHI node; // [Branch CondBr]; // if (cond) {; // ... // P(cond == true) = 1%; // }; //; // Here we know that when block A is taken, cond must be true, which means; // P(cond == true | A) = 1; //; // Given that P(cond == true) = P(cond == true | A) * P(A) +; // P(cond == true | B) * P(B); // we get:; // P(cond == true ) = P(A) + P(cond == true | B) * P(B); //; // which gives us:; // P(A) is less than P(cond == true), i.e.; // P(t == true) <= P(cond == true); //; // In other words, if we know P(cond == true) is unlikely, we know; // that P(t == true) is also unlikely.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:200,Performance,perform,performance,200,"// FIXME: We currently only set the profile data when it is missing.; // With PGO, this can be used to refine even existing profile data with; // context information. This needs to be done after more performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:216,Testability,test,testing,216,"// FIXME: We currently only set the profile data when it is missing.; // With PGO, this can be used to refine even existing profile data with; // context information. This needs to be done after more performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of instructions duplicated when optimizing strictly for; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:53,Performance,optimiz,optimizing,53,// Reduce the number of instructions duplicated when optimizing strictly for; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,Availability,redundant,redundant,38,// Jump threading may have introduced redundant debug values into BB; // which should be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,Safety,redund,redundant,38,// Jump threading may have introduced redundant debug values into BB; // which should be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Integrability,rout,routines,77,// Stop processing BB if it's the entry or is now deleted. The following; // routines attempt to eliminate BB and locating a suitable replacement; // for the entry is non-trivial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:71,Safety,detect,detect,71,// Don't alter Loop headers and latches to ensure another pass can; // detect and transform nested loops later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:40,Safety,safe,safe,40,"// Replace uses of Cond with ToVal when safe to do so. If all uses are; // replaced, we can remove Cond. We cannot blindly replace all uses of Cond; // because we may incorrectly replace uses when guards/assumes are uses of; // of `Cond` and we used the guards/assume to reason about the `Cond` value; // at the end of block. RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:811,Usability,simpl,simple,811,"/// findLoopHeaders - We do not want jump threading to turn proper loop; /// structures into irreducible loops. Doing this breaks up the loop nesting; /// hierarchy and pessimizes later transformations. To prevent this from; /// happening, we first have to find the loop headers. Here we approximate this; /// by finding targets of backedges in the CFG.; ///; /// Note that there definitely are cases when we want to allow threading of; /// edges across a loop header. For example, threading a jump from outside the; /// loop (the preheader) to an exit block of the loop is definitely profitable.; /// It is also almost always profitable to thread backedges from within the loop; /// to exit blocks, and is often profitable to thread backedges to other blocks; /// within the loop (forming a nested loop). This simple analysis is not rich; /// enough to track all of these properties and keep it up-to-date as the CFG; /// mutates, so we don't allow any of these transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:199,Integrability,depend,depends,199,"/// getKnownConstant - Helper method to determine if we can thread over a; /// terminator with the given value as its condition, and if so what value to; /// use for that. What kind of value this is depends on whether we want an; /// integer or a block address, but an undef is always accepted.; /// Returns null if Val is null or not an appropriate constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:259,Availability,avail,available,259,"// If I is a non-local compare-with-constant instruction, use more-rich; // 'getPredicateOnEdge' method. This would be able to handle value; // inequalities better, for example if the compare is ""X < 4"" and ""X < 3""; // is known true but ""X < 4"" itself is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Usability,simpl,simplify,10,// Try to simplify some other binary operator values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:34,Usability,simpl,simplify,34,// Try to use constant folding to simplify the binary operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,perform,perform,10,"// Do not perform phi translation across a loop header phi, because this; // may result in comparison of values from two different loop iterations.; // FIXME: This check is broken if LoopHeaders is not populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:18,Usability,simpl,simplification,18,// We can do this simplification if any comparisons fold to true or false.; // See if any do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:273,Energy Efficiency,reduce,reduce,273,"/// GetBestDestForBranchOnUndef - If we determine that the specified block ends; /// in an undefined jump, decide which block is best to revector to.; ///; /// Since we can pick an arbitrary destination, we pick the successor with the; /// fewest predecessors. This should reduce the in-degree of the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:128,Availability,alive,alive,128,"// If the block has its address taken, it may be a tree of dead constants; // hanging off of it. These shouldn't keep the block alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:84,Usability,simpl,simplifies,84,"// If the block is trivially dead, just return and let the caller nuke it.; // This simplifies other transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:41,Energy Efficiency,reduce,reduce,41,// Run constant folding to see if we can reduce the condition to a simple; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:67,Usability,simpl,simple,67,// Run constant folding to see if we can reduce the condition to a simple; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:63,Usability,simpl,simplify,63,"// If the terminator of this block is branching on a constant, simplify the; // terminator to an unconditional branch. This can occur due to threading in; // other blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:30,Integrability,depend,depend,30,// All the rest of our checks depend on the condition being an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,Performance,optimiz,optimization,25,// Some of the following optimization can safely work on the unfrozen cond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:42,Safety,safe,safely,42,// Some of the following optimization can safely work on the unfrozen cond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Safety,safe,safely,10,"// We can safely replace *some* uses of the CondInst if it has; // exactly one value as returned by LVI. RAUW is incorrect in the; // presence of guards and assumes, that have the `Cond` as the use. This; // is because we use the guards/assume to reason about the `Cond` value; // at the end of block, but RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Integrability,depend,depends,77,"// We did not manage to simplify this branch, try to see whether; // CondCmp depends on a known phi-select pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:24,Usability,simpl,simplify,24,"// We did not manage to simplify this branch, try to see whether; // CondCmp depends on a known phi-select pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:204,Availability,redundant,redundant,204,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:86,Performance,load,loads,86,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:204,Safety,redund,redundant,204,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,Usability,simpl,simplifying,39,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,Performance,load,load,38,"// TODO: There are other places where load PRE would be profitable, such as; // more complex comparisons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:167,Safety,predict,predictable,167,"// Handle a variety of cases where we are branching on something derived from; // a PHI node in the current block. If we can prove that any predecessors; // compute a predictable value based on a PHI node, thread those predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:114,Usability,simpl,simplify,114,"// If this is an otherwise-unfoldable branch on a phi node or freeze(phi) in; // the current block, see if we can simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:69,Usability,simpl,simplify,69,"// If this is an otherwise-unfoldable branch on a XOR, see if we can simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:66,Usability,simpl,simplify,66,// Search for a stronger dominating condition that can be used to simplify a; // conditional branch leaving BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Availability,redundant,redundant,77,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:40,Performance,Load,LoadI,40,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:87,Performance,load,load,87,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:177,Performance,optimiz,optimization,177,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Safety,redund,redundant,77,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:4,Usability,simpl,simplifyPartiallyRedundantLoad,4,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:35,Performance,load,loads,35,// Don't hack volatile and ordered loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:93,Availability,redundant,redundant,93,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,load,10,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:93,Safety,redund,redundant,93,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:62,Availability,redundant,redundant,62,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,load,10,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:62,Safety,redund,redundant,62,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:85,Availability,avail,available,85,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,loaded,10,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,Performance,Load,LoadBB,43,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,Performance,load,load,39,"// Scan a few instructions up from the load, to see if it is obviously live at; // the entry to its block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,Deployability,update,updated,25,// The dominator tree is updated lazily and may not be valid at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,Availability,avail,available,39,"// If the value of the load is locally available within the block, just use; // it. This frequently occurs for reg2mem'd allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:23,Performance,load,load,23,"// If the value of the load is locally available within the block, just use; // it. This frequently occurs for reg2mem'd allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:32,Performance,load,load,32,"// If the returned value is the load itself, replace with poison. This can; // only happen in dead loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:129,Performance,load,load,129,"// Otherwise, if we scanned the whole block and got to the top of the block,; // we know the block is locally transparent to the load. If not, something; // might clobber its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,Performance,load,loads,17,"// If all of the loads and stores that feed the value have the same AA tags,; // then we can propagate them onto any newly inserted loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:132,Performance,load,loads,132,"// If all of the loads and stores that feed the value have the same AA tags,; // then we can propagate them onto any newly inserted loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:112,Availability,avail,available,112,"// If we got here, the loaded value is transparent through to the start of the; // block. Check to see if it is available in any of the predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:23,Performance,load,loaded,23,"// If we got here, the loaded value is transparent through to the start of the; // block. Check to see if it is available in any of the predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:22,Performance,load,load,22,"// NOTE: We don't CSE load that is volatile or anything stronger than; // unordered, that should have been checked when we entered the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:75,Availability,avail,available,75,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:16,Performance,load,load,16,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:85,Performance,load,load,85,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,Availability,redundant,redundant,33,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:15,Performance,load,load,15,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,Safety,redund,redundant,33,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:29,Availability,avail,available,29,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:82,Availability,redundant,redundant,82,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,loaded,10,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:82,Safety,redund,redundant,82,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:29,Availability,avail,available,29,"// Okay, the loaded value is available in at least one (and maybe all!); // predecessors. If the value is unavailable in more than one unique; // predecessor, we want to insert a merge block for those common predecessors.; // This ensures that we only have to insert one reload, thus not increasing; // code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:13,Performance,load,loaded,13,"// Okay, the loaded value is available in at least one (and maybe all!); // predecessors. If the value is unavailable in more than one unique; // predecessor, we want to insert a merge block for those common predecessors.; // This ensures that we only have to insert one reload, thus not increasing; // code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:165,Performance,Load,LoadI,165,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:232,Performance,Load,LoadI,232,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:318,Performance,perform,perform,318,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:241,Safety,safe,safe,241,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:278,Testability,log,logic,278,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:471,Usability,simpl,simple,471,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:22,Availability,avail,available,22,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:103,Availability,avail,available,103,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:163,Availability,Avail,AvailablePreds,163,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:123,Performance,load,load,123,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:70,Availability,Avail,AvailablePreds,70,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:100,Energy Efficiency,efficient,efficient,100,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:110,Security,access,access,110,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:61,Performance,load,load,61,// Create a PHI node at the start of the block for the PRE'd load value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,Availability,avail,available,17,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:157,Availability,Avail,AvailablePreds,157,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:142,Deployability,update,update,142,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:11,Deployability,update,update,11,// Finally update the terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Safety,safe,safely,10,"// We can safely replace *some* uses of the CondInst if it has; // exactly one value as returned by LVI. RAUW is incorrect in the; // presence of guards and assumes, that have the `Cond` as the use. This; // is because we use the guards/assume to reason about the `Cond` value; // at the end of block, but RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:275,Safety,avoid,avoid,275,"// Determine which is the most common successor. If we have many inputs and; // this block is a switch, we want to start by threading the batch that goes; // to the most popular destination first. If we only know about one; // threadable destination (the common case) we can avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:161,Usability,simpl,simplifications,161,/// processBranchOnPHI - We have an otherwise unthreadable conditional branch on; /// a PHI node (or freeze PHI) in the current block. See if there are any; /// simplifications we can do based on inputs to the phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:152,Usability,simpl,simplifications,152,/// processBranchOnXOR - We have an otherwise unthreadable conditional branch on; /// a xor instruction in the current block. See if there are any; /// simplifications we can do based on inputs to the xor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:72,Performance,optimiz,optimization,72,"// If either the LHS or RHS of the xor is a constant, don't do this; // optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:237,Testability,log,logical,237,"// If we have a xor as the branch input to this block, and we know that the; // LHS or RHS of the xor in any predecessor is true/false, then we can clone; // the condition into the predecessor and fix that value to true, saving some; // logical ops on that path and encouraging other paths to simplify.; //; // This copies something like this:; //; // BB:; // %X = phi i1 [1], [%X']; // %Y = icmp eq i32 %A, %B; // %Z = xor i1 %X, %Y; // br i1 %Z, ...; //; // Into:; // BB':; // %Y = icmp ne i32 %A, %B; // br i1 %Y, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:293,Usability,simpl,simplify,293,"// If we have a xor as the branch input to this block, and we know that the; // LHS or RHS of the xor in any predecessor is true/false, then we can clone; // the condition into the predecessor and fix that value to true, saving some; // logical ops on that path and encouraging other paths to simplify.; //; // This copies something like this:; //; // BB:; // %X = phi i1 [1], [%X']; // %Y = icmp eq i32 %A, %B; // %Z = xor i1 %X, %Y; // br i1 %Z, ...; //; // Into:; // BB':; // %Y = icmp ne i32 %A, %B; // br i1 %Y, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:4,Deployability,Update,Update,4,/// Update the SSA form. NewBB contains instructions that are copied from BB.; /// ValueMapping maps old values in BB to new ones in NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:95,Deployability,update,update,95,"// If there were values defined in BB that are used outside the block, then we; // now have to update all uses of the value to use either the original value,; // the cloned value, or some PHI derived value. This can require arbitrary; // PHI insertion, of which we are prepared to do, clean these up now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:142,Modifiability,variab,variables,142,"/// Clone instructions in range [BI, BE) to NewBB. For PHI nodes, we only clone; /// arguments that come from PredBB. Return the map from the variables in the; /// source basic block to the variables in the newly created basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:190,Modifiability,variab,variables,190,"/// Clone instructions in range [BI, BE) to NewBB. For PHI nodes, we only clone; /// arguments that come from PredBB. Return the map from the variables in the; /// source basic block to the variables in the newly created basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,Modifiability,variab,variables,43,// Retargets llvm.dbg.value to any renamed variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:172,Modifiability,rewrite,rewrite,172,"// Clone the phi nodes of the source basic block into NewBB. The resulting; // phi nodes are trivial since NewBB only has one predecessor, but SSAUpdater; // might need to rewrite the operand of the cloned phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:21,Deployability,patch,patch,21,// Remap operands to patch up intra-block references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:596,Usability,simpl,simplicity,596,"// Consider:; //; // PredBB:; // %var = phi i32* [ null, %bb1 ], [ @a, %bb2 ]; // %tobool = icmp eq i32 %cond, 0; // br i1 %tobool, label %BB, label ...; //; // BB:; // %cmp = icmp eq i32* %var, null; // br i1 %cmp, label ..., label ...; //; // We don't know the value of %var at BB even if we know which incoming edge; // we take to BB. However, once we duplicate PredBB for each of its incoming; // edges (say, PredBB1 and PredBB2), we know the value of %var in each copy of; // PredBB. Then we can thread edges PredBB1->BB and PredBB2->BB through BB.; // Require that BB end with a Branch for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:155,Usability,simpl,simplicity,155,"// Require that PredBB end with a conditional Branch. If PredBB ends with an; // unconditional branch, we should be merging PredBB and BB instead. For; // simplicity, we don't deal with a switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Safety,Avoid,Avoid,3,// Avoid complication with duplicating EH pads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:46,Usability,simpl,simplicity,46,"// Find a predecessor that we can thread. For simplicity, we only consider a; // successor edge out of BB to which we thread exactly one incoming edge into; // PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the terminator of PredPredBB to jump to NewBB instead of PredBB.; // This eliminates predecessors from PredPredBB, which requires us to simplify; // any PHI nodes in PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:146,Usability,simpl,simplify,146,"// Update the terminator of PredPredBB to jump to NewBB instead of PredBB.; // This eliminates predecessors from PredPredBB, which requires us to simplify; // any PHI nodes in PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,Safety,safe,safe,43,/// tryThreadEdge - Thread an edge if it's safe and profitable to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:44,Safety,safe,safe,44,"/// threadEdge - We have decided that it is safe and profitable to factor the; /// blocks in PredBBs to one predecessor, then thread an edge from it to SuccBB; /// across BB. Transform the IR to reflect this change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the terminator of PredBB to jump to NewBB instead of BB. This; // eliminates predecessors from BB, which requires us to simplify any PHI; // nodes in BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:130,Usability,simpl,simplify,130,"// Update the terminator of PredBB to jump to NewBB instead of BB. This; // eliminates predecessors from BB, which requires us to simplify any PHI; // nodes in BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:23,Deployability,update,updates,23,// Enqueue required DT updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the edge weight from BB to SuccBB, which should be less than before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:128,Availability,avail,available,128,"/// Create a new basic block that will be the predecessor of BB and successor of; /// all blocks in Preds. When profile data is available, update the frequency of; /// this new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:139,Deployability,update,update,139,"/// Create a new basic block that will be the predecessor of BB and successor of; /// all blocks in Preds. When profile data is available, update the frequency of; /// this new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:80,Deployability,update,update,80,"// Collect the frequencies of all predecessors of BB, which will be used to; // update the edge weight of the result of splitting predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update frequencies between Pred -> NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:4,Deployability,Update,Update,4,/// Update the block frequency of BB and branch weight and the metadata on the; /// edge BB->SuccBB. This is done by scaling the weight of BB->SuccBB by 1 -; /// Freq(PredBB->BB) / Freq(BB->SuccBB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:56,Deployability,update,update,56,"// As the edge from PredBB to BB is deleted, we have to update the block; // frequency of BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:11,Deployability,update,updated,11,// Collect updated outgoing edges' frequencies from BB and use them to update; // edge probabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:71,Deployability,update,update,71,// Collect updated outgoing edges' frequencies from BB and use them to update; // edge probabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update edge probabilities in BPI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the profile metadata as well.; //; // Don't do this if the profile of the transformed blocks was statically; // estimated. (This could occur despite the function having an entry; // frequency in completely cold parts of the CFG.); //; // In this case we don't want to suggest to subsequent passes that the; // calculated weights are fully consistent. Consider this graph:; //; // check_1; // 50% / |; // eq_1 | 50%; // \ |; // check_2; // 50% / |; // eq_2 | 50%; // \ |; // check_3; // 50% / |; // eq_3 | 50%; // \ |; //; // Assuming the blocks check_* all compare the same value against 1, 2 and 3,; // the overall probabilities are inconsistent; the total probability that the; // value is either 1, 2 or 3 is 150%.; //; // As a consequence if we thread eq_1 -> check_2 to check_3, check_2->check_3; // becomes 0%. This is even worse if the edge whose probability becomes 0% is; // the loop exit edge. Then based solely on static estimation we would assume; // the loop was extremely hot.; //; // FIXME this locally as well so that BPI and BFI are consistent as well. We; // shouldn't make edges extremely likely or unlikely based solely on static; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:21,Deployability,patch,patch,21,// Remap operands to patch up intra-block references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:64,Deployability,update,updated,64,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:30,Usability,simpl,simplified,30,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:90,Usability,simpl,simplified,90,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update Dominance from simplified New instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,Usability,simpl,simplified,25,// Update Dominance from simplified New instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:35,Deployability,update,update,35,// Create a conditional branch and update PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update BPI if exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update any other PHI nodes in BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:99,Usability,simpl,simplify,99,"// The second and third condition can be potentially relaxed. Currently; // the conditions help to simplify the code and allow us to reuse existing; // code, developed for tryToUnfoldSelect(CmpInst *, BasicBlock *)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:728,Performance,optimiz,optimizations,728,"/// tryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the; /// same BB in the form; /// bb:; /// %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ...; /// %s = select %p, trueval, falseval; ///; /// or; ///; /// bb:; /// %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ...; /// %c = cmp %p, 0; /// %s = select %c, trueval, falseval; ///; /// And expand the select into a branch structure. This later enables; /// jump-threading over bb in this pass.; ///; /// Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold; /// select if the associated PHI has at least one constant. If the unfolded; /// select is not jump-threaded, it will be folded again in the later; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:532,Usability,Simpl,SimplifyCFG,532,"/// tryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the; /// same BB in the form; /// bb:; /// %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ...; /// %s = select %p, trueval, falseval; ///; /// or; ///; /// bb:; /// %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ...; /// %c = cmp %p, 0; /// %s = select %c, trueval, falseval; ///; /// And expand the select into a branch structure. This later enables; /// jump-threading over bb in this pass.; ///; /// Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold; /// select if the associated PHI has at least one constant. If the unfolded; /// select is not jump-threaded, it will be folded again in the later; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:24,Energy Efficiency,reduce,reduce,24,// This transform would reduce the quality of msan diagnostics.; // Disable this transform under MemorySanitizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:42,Deployability,update,update,42,"// BB's successors were moved to SplitBB, update DTU accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:214,Usability,simpl,simplest,214,"/// Try to propagate a guard from the current BB into one of its predecessors; /// in case if another branch of execution implies that the condition of this; /// guard is always true. Currently we only process the simplest case that; /// looks like:; ///; /// Start:; /// %cond = ...; /// br i1 %cond, label %T1, label %F1; /// T1:; /// br label %Merge; /// F1:; /// br label %Merge; /// Merge:; /// %condGuard = ...; /// call void(i1, ...) @llvm.experimental.guard( i1 %condGuard )[ ""deopt""() ]; ///; /// And cond either implies condGuard or !condGuard. In this case all the; /// instructions before the guard can be duplicated in both branches, and the; /// guard is then threaded to one of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:16,Safety,safe,safe,16,// True dest is safe if BranchCond => GuardCond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,Safety,safe,safe,17,// False dest is safe if !BranchCond => GuardCond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:66,Deployability,update,update,66,// TODO: We would like to preserve BPI/BFI. Enable once all paths update them.; // TODO: Would be nice to verify BPI/BFI consistency as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update DT/PDT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update analysis JumpThreading depends on and not explicitly preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,Integrability,depend,depends,33,// Update analysis JumpThreading depends on and not explicitly preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:140,Deployability,update,updated,140,"// Important note on validity of BPI/BFI. JumpThreading tries to preserve; // BPI/BFI as it goes. Thus if cached instance exists it will be updated.; // Otherwise, new instance of BPI/BFI is created (up to date by definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:106,Performance,cache,cached,106,"// Important note on validity of BPI/BFI. JumpThreading tries to preserve; // BPI/BFI as it goes. Thus if cached instance exists it will be updated.; // Otherwise, new instance of BPI/BFI is created (up to date by definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:974,Energy Efficiency,reduce,reduce,974,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to con",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:2007,Modifiability,variab,variable,2007,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:393,Performance,perform,performs,393,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:759,Performance,load,loads,759,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:892,Performance,optimiz,optimizations,892,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1129,Performance,optimiz,optimizations,1129,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to con",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1273,Performance,load,loads,1273,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1334,Performance,load,load,1334,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1767,Performance,load,loads,1767,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1931,Performance,load,loads,1931,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:623,Safety,safe,safe,623,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:870,Usability,simpl,simplifies,870,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:401,Performance,optimiz,optimizeUses,401,"// Experimental option to allow imprecision in LICM in pathological cases, in; // exchange for faster compile. This is to be removed if MemorySSA starts to; // address the same issue. LICM calls MemorySSAWalker's; // getClobberingMemoryAccess, up to the value of the Cap, getting perfect; // accuracy. Afterwards, LICM will call into MemorySSA's getDefiningAccess,; // which may not be precise, since optimizeUses is capped. The result is; // correct, but we may not get as ""far up"" as possible to get which access is; // clobbering the one queried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:508,Security,access,access,508,"// Experimental option to allow imprecision in LICM in pathological cases, in; // exchange for faster compile. This is to be removed if MemorySSA starts to; // address the same issue. LICM calls MemorySSAWalker's; // getClobberingMemoryAccess, up to the value of the Cap, getting perfect; // accuracy. Afterwards, LICM will call into MemorySSA's getDefiningAccess,; // which may not be precise, since optimizeUses is capped. The result is; // correct, but we may not get as ""far up"" as possible to get which access is; // clobbering the one queried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the old PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:37,Performance,Optimiz,OptimizationRemarkEmitter,37,"// For the new PM, we also can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:37,Performance,Optimiz,OptimizationRemarkEmitter,37,"// For the new PM, we also can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:63,Performance,perform,performed,63,// If this loop has metadata indicating that LICM is not to be performed then; // just exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:401,Performance,perform,performance,401,"// Don't sink stores from loops with coroutine suspend instructions.; // LICM would sink instructions into the default destination of; // the coroutine switch. The default destination of the switch is to; // handle the case where the coroutine is suspended, by which point the; // coroutine frame may have been destroyed. No instruction can be sunk there.; // FIXME: This would unfortunately hurt the performance of coroutines, however; // there is currently no general solution for this. Similar issues could also; // potentially happen in other passes where instructions are being moved; // across that edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:16,Safety,safe,safety,16,// Compute loop safety information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:507,Performance,perform,perform,507,"// We want to visit all of the instructions in this loop... that are not parts; // of our subloops (they have already had their invariants hoisted out of; // their loop, into this loop, so there is no need to process the BODIES of; // the subloops).; //; // Traverse the body of the loop in depth first order on the dominator tree so; // that we are guaranteed to see definitions before we see uses. This allows; // us to sink instructions in one pass, without iteration. After sinking; // instructions, we perform another pass to hoist them out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:414,Availability,avail,available,414,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:358,Deployability,update,updater,358,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:307,Performance,load,load,307,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:375,Safety,avoid,avoid,375,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:254,Usability,simpl,simplify,254,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Security,access,accesses,24,"// Promoting one set of accesses may make the pointers for another set; // loop invariant, so run this in a loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:262,Safety,avoid,avoiding,262,"// The common successor has to be dominated by the branch, as otherwise; // there will be some other path to the successor that will not be; // controlled by this branch so any phi we hoist would be controlled by the; // wrong condition. This also takes care of avoiding hoisting of loop back; // edges.; // TODO: In some cases this could be relaxed if the successor is dominated; // by another block that's been hoisted and we can guarantee that the; // control flow has been replicated exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:49,Integrability,depend,depends,49,// Which blocks are predecessors via this branch depends on if the; // branch is triangle-like or diamond-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:156,Safety,safe,safe,156,// Try hoisting the instruction out to the preheader. We can only do; // this if all of the operands of the instruction are loop invariant and; // if it is safe to hoist the instruction. We also check block frequency; // to make sure instruction only gets hoisted into colder blocks.; // TODO: It may be safe to hoist if we are hoisting to a conditional block; // and we have accurately duplicated the control flow from the loop header; // to that block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:304,Safety,safe,safe,304,// Try hoisting the instruction out to the preheader. We can only do; // this if all of the operands of the instruction are loop invariant and; // if it is safe to hoist the instruction. We also check block frequency; // to make sure instruction only gets hoisted into colder blocks.; // TODO: It may be safe to hoist if we are hoisting to a conditional block; // and we have accurately duplicated the control flow from the loop header; // to that block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:203,Performance,load,loads,203,"// Return true if LI is invariant within scope of the loop. LI is invariant if; // CurLoop is dominated by an invariant.start representing the same memory; // location and size as the memory location LI loads from, and also the; // invariant.start has no uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:351,Modifiability,variab,variable,351,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,Performance,scalab,scalable,92,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:583,Usability,clear,clearly,583,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,Performance,load,load,28,"// Traverse all uses of the load operand value, to see if invariant.start is; // one of the uses, and whether it dominates the load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:127,Performance,load,load,127,"// Traverse all uses of the load operand value, to see if invariant.start is; // one of the uses, and whether it dominates the load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Performance,Load,Load,24,// Avoid traversing for Load operand with high number of users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Safety,Avoid,Avoid,3,// Avoid traversing for Load operand with high number of users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:66,Performance,load,load,66,"// If there are escaping uses of invariant.start instruction, the load maybe; // non-invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:51,Modifiability,variab,variable,51,// The intrinsic supports having a -1 argument for variable sized objects; // so we should check for that here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:58,Performance,load,load,58,"// Confirm the invariant.start location size contains the load operand size; // in bits. Also, the invariant.start should dominate the load, and we; // should not hoist the load out of a loop that contains this dominating; // invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:135,Performance,load,load,135,"// Confirm the invariant.start location size contains the load operand size; // in bits. Also, the invariant.start should dominate the load, and we; // should not hoist the load out of a loop that contains this dominating; // invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:173,Performance,load,load,173,"// Confirm the invariant.start location size contains the load operand size; // in bits. Also, the invariant.start should dominate the load, and we; // should not hoist the load out of a loop that contains this dominating; // invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:193,Safety,safe,safety,193,/// Return true if-and-only-if we know how to (mechanically) both hoist and; /// sink a given instruction out of a loop. Does not address legality; /// concerns such as aliasing or speculation safety.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Performance,Load,Loads,3,// Loads have extra constraints we have to verify before we can hoist them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:47,Performance,load,loads,47,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:58,Performance,Load,Loads,58,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:96,Safety,safe,safe,96,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:36,Performance,load,loads,36,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:96,Performance,load,load,96,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:9,Safety,risk,risk,9,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:68,Performance,load,load,68,// Check loop-invariant address because this may also be a sinkable load; // whose address is not necessarily loop-invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:180,Safety,safe,safe,180,// Convergent attribute has been used on operations that involve; // inter-thread communication which results are implicitly affected by the; // enclosing control flows. It is not safe to hoist or sink such operations; // across control flow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:10,Usability,simpl,simple,10,// Handle simple cases by querying alias analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:268,Security,access,access,268,// FIXME: we don't handle the semantics of thread local well. So that the; // address of thread locals are fake constants in coroutines. So We forbid; // to treat onlyReadsMemory call in coroutines as constants now. Note that; // it is possible to hide a thread local access in a onlyReadsMemory call.; // Remove this check after we handle the semantics of thread locals well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:250,Modifiability,extend,extend,250,"// Don't sink/hoist volatile or ordered atomic store!; // We can only hoist a store that we can prove writes a value which is not; // read or overwritten within the loop. For those cases, we fallback to; // load store promotion instead. TODO: We can extend this to cases where; // there is exactly one write to the location and that write dominates an; // arbitrary number of reads in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:207,Performance,load,load,207,"// Don't sink/hoist volatile or ordered atomic store!; // We can only hoist a store that we can prove writes a value which is not; // read or overwritten within the loop. For those cases, we fallback to; // load store promotion instead. TODO: We can extend this to cases where; // there is exactly one write to the location and that write dominates an; // arbitrary number of reads in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:21,Security,access,accesses,21,"// If there are more accesses than the Promotion cap, then give up as we're; // not walking a list that long.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:263,Deployability,update,update,263,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:305,Modifiability,extend,extend,305,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:93,Performance,load,loads,93,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:213,Performance,Cache,Cache,213,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:54,Security,access,access,54,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:286,Security,access,accesses,286,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:49,Performance,load,loads,49,"// Disable hoisting past potentially interfering loads. Optimized; // Uses may point to an access outside the loop, as getClobbering; // checks the previous iteration when walking the backedge.; // FIXME: More precise: no Uses that alias SI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:56,Performance,Optimiz,Optimized,56,"// Disable hoisting past potentially interfering loads. Optimized; // Uses may point to an access outside the loop, as getClobbering; // checks the previous iteration when walking the backedge.; // FIXME: More precise: no Uses that alias SI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:91,Security,access,access,91,"// Disable hoisting past potentially interfering loads. Optimized; // Uses may point to an access outside the loop, as getClobbering; // checks the previous iteration when walking the backedge.; // FIXME: More precise: no Uses that alias SI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:144,Performance,perform,performed,144,// Check if the call may read from the memory location written; // to by SI. Check CI's attributes and arguments; the number of; // such checks performed is limited above by NoOfMemAccTooLarge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:89,Availability,fault,fault,89,"// We've established mechanical ability and aliasing, it's up to the caller; // to check fault safety",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:95,Safety,safe,safety,95,"// We've established mechanical ability and aliasing, it's up to the caller; // to check fault safety",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Usability,simpl,simply,24,"// For a GEP, we cannot simply use getInstructionCost because currently; // it optimistically assumes that a GEP will fold into addressing mode; // regardless of its users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:288,Performance,load,load,288,"/// Return true if the only users of this instruction are outside of; /// the loop. If this is true, we can sink the instruction to the exit; /// blocks of the loop.; ///; /// We also return true if the instruction could be folded away in lowering.; /// (e.g., a GEP can be folded into a load as an addressing mode in the loop).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:51,Safety,Avoid,Avoid,51,// We need to sink a callsite to a unique funclet. Avoid sinking if the; // phi use is too muddled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:64,Security,access,access,64,// Create a new MemoryAccess and let MemorySSA set its defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:259,Usability,simpl,simple,259,"// It's not impossible to split EHPad blocks, but if BlockColors already exist; // it require updating BlockColors for all offspring blocks accordingly. By; // skipping such corner case, we can make updating BlockColors after splitting; // predecessor fairly simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:80,Security,expose,exposed,80,"// Split predecessors of the loop exit to make instructions in the loop are; // exposed to exit blocks through trivially replaceable PHIs while keeping the; // loop in the canonical form where each predecessor of each exit block should; // be contained within the loop. For example, this will convert the loop below; // from; //; // LB1:; // %v1 =; // br %LE, %LB2; // LB2:; // %v2 =; // br %LE, %LB1; // LE:; // %p = phi [%v1, %LB1], [%v2, %LB2] <-- non-trivially replaceable; //; // to; //; // LB1:; // %v1 =; // br %LE.split, %LB2; // LB2:; // %v2 =; // br %LE.split2, %LB1; // LE.split:; // %p1 = phi [%v1, %LB1] <-- trivially replaceable; // br %LE; // LE.split2:; // %p2 = phi [%v2, %LB2] <-- trivially replaceable; // br %LE; // LE:; // %p = phi [%p1, %LE.split], [%p2, %LE.split2]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:99,Usability,simpl,simply,99,"// Since we do not allow splitting EH-block with BlockColors in; // canSplitPredecessors(), we can simply assign predecessor's color to; // the new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:121,Deployability,patch,patches,121,"/// When an instruction is found to only be used outside of the loop, this; /// function moves it to the exit blocks and patches up SSA form as needed.; /// This method is guaranteed to remove the original instruction from its; /// position, and may either delete it or move it to outside of the loop.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:82,Safety,safe,safe,82,"/// When an instruction is found to only use loop invariant operands that; /// is safe to hoist, this instruction is called to do the dirty work.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,Integrability,depend,dependent,19,"// Metadata can be dependent on conditions we are hoisting above.; // Conservatively strip all metadata on the instruction unless we were; // guaranteed to execute I if we entered the loop, in which case the metadata; // is valid in the loop preheader.; // Similarly, If I is a call and it is not guaranteed to execute in the loop,; // then moving to the preheader means we should strip attributes on the call; // that can cause UB since we may be hoisting above conditions that allowed; // inferring those attributes. They may not be valid at the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:178,Performance,optimiz,optimization,178,"// The check on hasMetadataOtherThanDebugLoc is to prevent us from burning; // time in isGuaranteedToExecute if we don't actually have anything to; // drop. It is a compile time optimization, not required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:157,Deployability,update,updater,157,"// Insert stores after in the loop exit blocks. Each exit block gets a; // store of the live-out values that feed them. Since we've already told; // the SSA updater about the defs in the loop and the preheader; // definition, it is all set and we can start using it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,Safety,safe,safety,19,"// FIXME: true for safety, false may still be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:10,Performance,perform,perform,10,"// We can perform the captured-before check against any instruction in the; // loop header, as the loop header is reachable from any instruction inside; // the loop.; // TODO: ReturnCaptures=true shouldn't be necessary here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:108,Performance,load,loads,108,"// namespace; /// Try to promote memory values to scalars by sinking stores out of the; /// loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:31,Performance,load,load,31,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:63,Performance,load,load,63,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:463,Performance,load,load,463,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:794,Performance,load,load,794,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:925,Performance,load,load,925,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:13,Safety,safe,safe,13,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:235,Safety,safe,safe,235,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:308,Safety,safe,safety,308,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:956,Safety,safe,safe,956,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1299,Safety,safe,safe,1299,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1525,Safety,safe,safe,1525,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:273,Security,access,access,273,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1045,Security,access,access,1045,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:31,Safety,Safe,Safe,31,"// Goes from Unknown to either Safe or Unsafe, but can't switch between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:39,Safety,Unsafe,Unsafe,39,"// Goes from Unknown to either Safe or Unsafe, but can't switch between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,Security,access,access,32,// Keep track of which types of access we see,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,Safety,safe,safe,92,"// If there are reads outside the promoted set, then promoting stores is; // definitely not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:336,Performance,load,load,336,"// If a loop can throw, we have to insert a store along each unwind edge.; // That said, we can't actually make the unwind edge explicit. Therefore,; // we have to prove that the store is dead along the unwind edge. We do; // this by proving that the caller can't have a reference to the object; // after return and thus can't possibly load from the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:129,Performance,load,loaded,129,"// Check that all accesses to pointers in the alias set use the same type.; // We cannot (yet) promote a memory location that is loaded and stored in; // different sizes. While we are at it, collect alignment and AA info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:18,Security,access,accesses,18,"// Check that all accesses to pointers in the alias set use the same type.; // We cannot (yet) promote a memory location that is loaded and stored in; // different sizes. While we are at it, collect alignment and AA info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:22,Performance,load,load,22,"// If there is an non-load/store instruction in the loop, we can't promote; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:23,Performance,load,load,23,// Note that proving a load safe to speculate requires proving; // sufficient alignment at the target location. Proving it guaranteed; // to execute does as well. Thus we can increase our guaranteed; // alignment as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,Safety,safe,safe,28,// Note that proving a load safe to speculate requires proving; // sufficient alignment at the target location. Proving it guaranteed; // to execute does as well. Thus we can increase our guaranteed; // alignment as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:180,Safety,safe,safe,180,"// If the store is guaranteed to execute, both properties are satisfied.; // We may want to check if a store is guaranteed to execute even if we; // already know that promotion is safe, since it may have higher; // alignment than any other guaranteed stores, in which case we can; // raise the alignment on the promoted store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:47,Safety,safe,safe,47,"// If a store dominates all exit blocks, it is safe to sink.; // As explained above, if an exit block was executed, a dominating; // store must have been executed at least once, so we are not; // introducing stores on paths that did not have them.; // Note that this only looks at explicit exit blocks. If we ever; // start sinking stores into unwind edges (see above), this will break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:9,Performance,load,load,9,// Not a load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:16,Performance,load,load,16,"// On the first load/store, just take its AA tags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:201,Availability,down,downgrade,201,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:274,Availability,error,error,274,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:80,Security,access,access,80,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,Performance,load,load,32,"// If we're inserting an atomic load in the preheader, we must be able to; // lower it. We're only guaranteed to be able to lower naturally aligned; // atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:41,Performance,load,load,41,"// If we couldn't prove we can hoist the load, bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,Performance,load,load,28,"// We know we can hoist the load, but don't have a guaranteed store.; // Check whether the location is writable and thread-local. If it is, then we; // can insert stores along paths which originally didn't have them without; // violating the memory model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:67,Performance,load,load,67,"// If we've still failed to prove we can sink the store, hoist the load; // only, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:26,Performance,load,load,26,"// If we cannot hoist the load either, give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:25,Integrability,interface,interface,25,// We use the SSAUpdater interface to insert phi nodes as required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all the loads in the loop and remember all the definitions from; // stores in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,Performance,load,loads,19,// Rewrite all the loads in the loop and remember all the definitions from; // stores in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:36,Performance,load,load,36,"// If the SSAUpdater didn't use the load in the preheader, just zap it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:91,Performance,load,loads,91,"// The bool indicates whether there might be reads outside the set, in which; // case only loads may be promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:44,Security,access,accesses,44,// Populate AST with potentially promotable accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,Security,access,access,92,// Nothing to promote...; // Discard any sets for which there is an aliasing non-promotable access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:45,Safety,safe,safety,45,"// For hoisting, use the walker to determine safety",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:91,Performance,load,loaded,91,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:149,Performance,load,load,149,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:349,Performance,load,loaded,349,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:301,Security,access,access,301,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:241,Performance,load,load,241,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:337,Performance,load,load,337,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:502,Performance,load,load,502,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:712,Safety,Safe,Safe,712,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify things like (A < INV_1 AND icmp A < INV_2) into (A <; /// min(INV_1, INV_2)), if INV_1 and INV_2 are both loop invariants and their; /// minimun can be computed outside of loop, and X is not a loop-invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:121,Testability,log,logical,121,"// We are about to create a new guaranteed use for RHS2 which might not exist; // before (if it was a non-taken input of logical and/or instruction). If it; // was poison, we need to freeze it. Note that no new use for LHS and RHS1 are; // introduced, so they don't need this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:117,Usability,simpl,simplicity,117,"// The swapped GEPs are inbounds if both original GEPs are inbounds; // and the sign of the offsets is the same. For simplicity, only; // handle both offsets being non-negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:251,Safety,avoid,avoid,251,"// In order to turn ""LV + C1 < C2"" into ""LV < C2 - C1"", we need to be able to; // freely move values from left side of inequality to right side (just as in; // normal linear arithmetics). Overflows make things much more complicated, so; // we want to avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:251,Safety,avoid,avoid,251,"// In order to turn ""LV - C1 < C2"" into ""LV < C2 + C1"", we need to be able to; // freely move values from left side of inequality to right side (just as in; // normal linear arithmetics). Overflows make things much more complicated, so; // we want to avoid this. Likewise, for ""C1 - LV < C2"" we need to prove that; // ""C1 - C2"" does not overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize complex patterns, such as (x < INV1 && x < INV2), turning them; // into (x < min(INV1, INV2)), and hoisting the invariant part of this; // expression out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopAccessAnalysisPrinter.cpp:44,Security,Access,Access,44,"//===- LoopAccessAnalysisPrinter.cpp - Loop Access Analysis Printer --------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopAccessAnalysisPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopAccessAnalysisPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:40,Deployability,update,update,40,"// If the Cond.AddRecValue is PHI node, update Cond.NonPHIAddRecValue with; // value from backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:31,Modifiability,variab,variable,31,// Allowed AddRec as induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:20,Usability,simpl,simplified,20,// Check loop is in simplified form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update phi nodes in header of post-loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:65,Deployability,update,update,65,"// If the exiting block is loop latch, the phi does not have the update at; // last iteration. In this case, update lcssa phi with value from backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:109,Deployability,update,update,109,"// If the exiting block is loop latch, the phi does not have the update at; // last iteration. In this case, update lcssa phi with value from backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update the start value of phi node in post-loop with the LCSSA phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update phi node in exit block of post-loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:14,Performance,cache,cached,14,// Invalidate cached SE information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:31,Security,access,accesses,31,/// Check if the stride of the accesses is large enough to; /// warrant a prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:184,Performance,Cache,CacheLineSize,184,"// If PrefetchDistance is not set, don't run the pass. This gives an; // opportunity for targets to run this pass for selected subtargets only; // (whose TTI sets PrefetchDistance and CacheLineSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:146,Security,access,accesses,146,/// A record for a potential prefetch made during the initial scan of the; /// loop. This is used to let a single prefetch target multiple memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:37,Security,access,access,37,/// True if targeting a write memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:115,Deployability,update,updated,115,"/// Add the instruction \param I to this prefetch. If it's not the first; /// one, 'InsertPt' and 'Writes' will be updated as required.; /// \param PtrDiff the known constant address difference to the first added; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:47,Performance,cache,cache,47,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:105,Performance,cache,cache,105,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:72,Security,access,access,72,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:30,Security,access,accesses,30,// Check if the stride of the accesses is large enough to warrant a; // prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:139,Performance,load,loads,139,"// Make sure that no instructions in the block have potential side-effects.; // This includes instructions that could write to memory, and loads that are; // marked volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:28,Performance,cache,cache,28,// Quick hack: do not flood cache with non-instruction values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:22,Performance,cache,cached,22,// Do we already know cached result?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:11,Performance,optimiz,optimization,11,"// For the optimization to be correct, we need RPOT to have a property that; // each block is processed after all its predecessors, which may only be; // violated for headers of the current loop and all nested loops. Irreducible; // CFG provides multiple ways to break this assumption, so we do not want to; // deal with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:13,Usability,simpl,simplify,13,// Failed to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:503,Safety,safe,safety,503,"/// Remove a loop if it is dead.; ///; /// A loop is considered dead either if it does not impact the observable; /// behavior of the program other than finite running time, or if it is; /// required to make progress by an attribute such as 'mustprogress' or; /// 'llvm.loop.mustprogress' and does not make any. This may remove; /// infinite loops that have been required to make progress.; ///; /// This entire process relies pretty heavily on LoopSimplify form and LCSSA in; /// order to make various safety checks work.; ///; /// \returns true if any changes were made. This may mutate the loop even if it; /// is unable to delete it due to hoisting trivially loop invariant; /// instructions out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:136,Availability,avail,available,136,"// We can only remove the loop if there is a preheader that we can branch from; // after removing it. Also, if LoopSimplify form is not available, stay out; // of trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:216,Testability,log,logic,216,"// We require that the loop has at most one exit block. Otherwise, we'd be in; // the situation of needing to be able to solve statically which exit block; // will be branched to, or trying to preserve the branching logic in a loop; // invariant manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the new PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:507,Integrability,depend,dependence,507,"//===- LoopDistribute.cpp - Loop Distribution Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; // For dependence analysis, the pass uses the LoopVectorizer's; // LoopAccessAnalysis. Because this analysis presumes no change in the order of; // memory operations, special care is taken to preserve the lexical order of; // these operations.; //; // Similarly to the Vectorizer, the pass also supports loop versioning to; // run-time disambiguate potentially overlapping arrays.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:564,Integrability,depend,dependences,564,"//===- LoopDistribute.cpp - Loop Distribution Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; // For dependence analysis, the pass uses the LoopVectorizer's; // LoopAccessAnalysis. Because this analysis presumes no change in the order of; // memory operations, special care is taken to preserve the lexical order of; // these operations.; //; // Similarly to the Vectorizer, the pass also supports loop versioning to; // run-time disambiguate potentially overlapping arrays.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:655,Integrability,depend,dependence,655,"//===- LoopDistribute.cpp - Loop Distribution Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; // For dependence analysis, the pass uses the LoopVectorizer's; // LoopAccessAnalysis. Because this analysis presumes no change in the order of; // memory operations, special care is taken to preserve the lexical order of; // these operations.; //; // Similarly to the Vectorizer, the pass also supports loop versioning to; // run-time disambiguate potentially overlapping arrays.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:46,Integrability,depend,dependence,46,/// Returns whether this partition contains a dependence cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:15,Security,access,accessors,15,/// Collection accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:112,Integrability,depend,dependent,112,/// Populates the partition with a transitive closure of all the; /// instructions that the seeded instructions dependent on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:41,Integrability,depend,dependence,41,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:56,Usability,simpl,simply,56,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:122,Usability,simpl,simplifycfg,122,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:126,Integrability,depend,depend,126,// Follow the use-def chains to form a transitive closure of all the; // instructions that the originally seeded instructions depend on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:45,Integrability,depend,depend,45,// Insert instructions from the loop that we depend on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:40,Deployability,Update,Updates,40,/// Clones the original loop.; ///; /// Updates LoopInfo and DominatorTree using the information that block \p; /// LoopDomBB dominates the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:38,Integrability,depend,dependence,38,/// Whether this partition contains a dependence cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:69,Integrability,depend,dependence,69,"/// Adds \p Inst into a partition that is not marked to contain; /// dependence cycles.; ///; // Initially we isolate memory instructions into as many partitions as; // possible, then later we may merge them back together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:184,Integrability,depend,dependency,184,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:49,Performance,load,loads,49,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:100,Performance,load,loads,100,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:99,Performance,load,load,99,// Step through the partitions and create equivalence between partitions; // that contain the same load. Also put partitions in between them in the; // same equivalence class to avoid reordering of memory operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:178,Safety,avoid,avoid,178,// Step through the partitions and create equivalence between partitions; // that contain the same load. Also put partitions in between them in the; // same equivalence class to avoid reordering of memory operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:8,Performance,load,load,8,"// If a load occurs in two partitions PartI and PartJ, merge all; // partitions (PartI, PartJ] into PartI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:9,Performance,perform,performs,9,/// This performs the main chunk of the work of cloning the loops for; /// the partitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:151,Deployability,update,update,151,// Create a loop for each partition except the last. Clone the original; // loop before PH along with adding a preheader for the cloned loop. Then; // update PH to point to the newly added preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:31,Deployability,update,update,31,// Now go in forward order and update the immediate dominator for the; // preheaders with the exiting block of the previous loop. Dominance; // within the loop is updated in cloneLoopWithPreheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:163,Deployability,update,updated,163,// Now go in forward order and update the immediate dominator for the; // preheaders with the exiting block of the previous loop. Dominance; // within the loop is updated in cloneLoopWithPreheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:94,Integrability,depend,dependences,94,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:302,Integrability,depend,dependence,302,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:87,Safety,unsafe,unsafe,87,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:295,Safety,unsafe,unsafe,295,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:21,Performance,perform,performing,21,/// The actual class performing the per-loop work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:74,Integrability,depend,dependence,74,"// Currently, we only distribute to isolate the part of the loop with; // dependence cycles to enable partial vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:164,Integrability,depend,dependences,164,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:388,Integrability,depend,dependence,388,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:489,Integrability,depend,dependent,489,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:157,Safety,unsafe,unsafe,157,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:381,Safety,unsafe,unsafe,381,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:687,Safety,Unsafe,Unsafe,687,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:6,Deployability,update,update,6,"// We update NumUnsafeDependencesActive post-instruction, catch the; // start of a dependence directly via NumUnsafeDependencesStartOrEnd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:83,Integrability,depend,dependence,83,"// We update NumUnsafeDependencesActive post-instruction, catch the; // start of a dependence directly via NumUnsafeDependencesStartOrEnd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:164,Performance,load,load,164,// Add partitions for values used outside. These partitions can be out of; // order from the original program order. This is OK because if the; // partition uses a load we will merge this partition with the original; // partition of the load that we set up in the previous loop (see; // mergeToAvoidDuplicatedLoads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:237,Performance,load,load,237,// Add partitions for values used outside. These partitions can be out of; // order from the original program order. This is OK because if the; // partition uses a load we will merge this partition with the original; // partition of the load that we set up in the previous loop (see; // mergeToAvoidDuplicatedLoads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:51,Performance,load,loads,51,"// In order to preserve original lexical order for loads, keep them in the; // partition that we set up in the MemoryInstructionDependences loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:18,Usability,simpl,simple,18,"// To keep things simple have an empty preheader before we version or clone; // the loop. (Also split if this has no predecessor, i.e. entry, because we; // rely on PH having a predecessor.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:51,Modifiability,inherit,inherit,51,"// The unversioned loop will not be changed, so we inherit all attributes; // from the original loop, but remove the loop distribution metadata to; // avoid to distribute it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:151,Safety,avoid,avoid,151,"// The unversioned loop will not be changed, so we inherit all attributes; // from the original loop, but remove the loop distribution metadata to; // avoid to distribute it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:243,Safety,safe,safely,243,/// Filter out checks between pointers from the same partition.; ///; /// \p PtrToPartition contains the partition number for pointers. Partition; /// number -1 means that the pointer is used in multiple partitions. In this; /// case we can't safely omit the check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:760,Modifiability,variab,variables,760,"//===- LoopFlatten.cpp - Loop flattening pass------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:842,Modifiability,variab,variables,842,"//===- LoopFlatten.cpp - Loop flattening pass------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1476,Modifiability,variab,variables,1476,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1614,Modifiability,variab,variable,1614,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1848,Modifiability,variab,variable,1848,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1144,Safety,avoid,avoids,1144,"v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1870,Safety,safe,safe,1870,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:2188,Safety,sanity check,sanity check,2188,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:515,Security,access,access,515,"//===- LoopFlatten.cpp - Loop flattening pass------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:41,Modifiability,variab,variables,41,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // I.e., it needs to be a linear expression of the induction variables and the; // inner loop trip count. We keep track of all different expressions on which; // checks will be performed in this bookkeeping struct.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:187,Modifiability,variab,variables,187,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // I.e., it needs to be a linear expression of the induction variables and the; // inner loop trip count. We keep track of all different expressions on which; // checks will be performed in this bookkeeping struct.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:303,Performance,perform,performed,303,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // I.e., it needs to be a linear expression of the induction variables and the; // inner loop trip count. We keep track of all different expressions on which; // checks will be performed in this bookkeeping struct.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:13,Modifiability,variab,variables,13,"// induction variables, which are; // expected to start at zero and; // increment by one on each loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:21,Modifiability,variab,variables,21,// Uses of induction variables in,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:7,Safety,safe,safe,7,// are safe to ignore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:40,Deployability,update,updated,40,// The instruction that needs to be; // updated with new tripcount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:136,Modifiability,variab,variables,136,"// Matches the same pattern as above, except it also looks for truncs; // on the phi, which can be the result of widening the induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:16,Modifiability,extend,extends,16,// Look through extends if the IV has been widened. Don't look through; // extends if we already looked through a trunc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:75,Modifiability,extend,extends,75,// Look through extends if the IV has been widened. Don't look through; // extends if we already looked through a trunc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:92,Performance,perform,performed,92,"// Evaluating in the trip count's type can not overflow here as the overflow; // checks are performed in checkOverflow, but are first tried to avoid by; // widening the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:143,Safety,avoid,avoid,143,"// Evaluating in the trip count's type can not overflow here as the overflow; // checks are performed in checkOverflow, but are first tried to avoid by; // widening the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:12,Modifiability,extend,extended,12,// Find the extended backedge taken count and extended trip count using; // SCEV. One of these should now match the RHS of the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:46,Modifiability,extend,extended,46,// Find the extended backedge taken count and extended trip count using; // SCEV. One of these should now match the RHS of the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:23,Modifiability,variab,variable,23,"// Finds the induction variable, increment and trip count for a simple loop that; // we can flatten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:64,Usability,simpl,simple,64,"// Finds the induction variable, increment and trip count for a simple loop that; // we can flatten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:65,Modifiability,variab,variable,65,"// Currently, to simplify the implementation, the Loop induction variable must; // start at zero and increment with a step size of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:17,Usability,simpl,simplify,17,"// Currently, to simplify the implementation, the Loop induction variable must; // start at zero and increment with a step size of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:111,Modifiability,variab,variables,111,"// Find the induction PHI. If there is no induction PHI, we can't do the; // transformation. TODO: could other variables trigger this? Do we have to; // search for the best one?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:194,Modifiability,variab,variable,194,// Find increment and trip count.; // There are exactly 2 incoming values to the induction phi; one from the; // pre-header and one from the latch. The incoming latch value is the; // increment variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:139,Modifiability,variab,variable,139,"// The trip count is the RHS of the compare. If this doesn't match the trip; // count computed by SCEV then this is because the trip count variable; // has been widened so the types don't match, or because it is a constant and; // another transformation has changed the compare (e.g. icmp ult %inc,; // tripcount -> icmp ult %j, tripcount-1), or both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:457,Integrability,depend,dependency,457,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:106,Modifiability,rewrite,rewrite,106,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:532,Modifiability,variab,variable,532,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:771,Modifiability,variab,variable,771,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:828,Safety,unsafe,unsafe,828,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:37,Modifiability,variab,variable,37,// Multiplies of the outer iteration variable and inner iteration; // count will be optimised out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:41,Modifiability,variab,variables,41,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // Any uses of the induction variables not matching that pattern would; // require a div/mod to reconstruct in the flattened loop, so the; // transformation wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:155,Modifiability,variab,variables,155,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // Any uses of the induction variables not matching that pattern would; // require a div/mod to reconstruct in the flattened loop, so the; // transformation wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:53,Modifiability,variab,variable,53,"// Check that all uses of the inner loop's induction variable match the; // expected pattern, recording the uses of the outer IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:28,Integrability,depend,dependant,28,// Return an OverflowResult dependant on if overflow of the multiplication of; // InnerTripCount and OuterTripCount can be assumed not to happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:17,Testability,test,testing,17,// For debugging/testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:174,Integrability,wrap,wrap,174,"// The IV is used as the operand of a GEP which dominates the loop; // latch, and the IV is at least as wide as the address space of the; // GEP. In this case, the GEP would wrap around the address space; // before the IV increment wraps, which would be UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:232,Integrability,wrap,wraps,232,"// The IV is used as the operand of a GEP which dominates the loop; // latch, and the IV is at least as wide as the address space of the; // GEP. In this case, the GEP would wrap around the address space; // before the IV increment wraps, which would be UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:86,Modifiability,variab,variable,86,"// Find the values in the loop that can be replaced with the linearized; // induction variable, and check that there are no other uses of the inner; // or outer induction variable. If there were, we could still do this; // transformation, but we'd have to insert a div/mod to calculate the; // original IVs, so it wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:171,Modifiability,variab,variable,171,"// Find the values in the loop that can be replaced with the linearized; // induction variable, and check that there are no other uses of the inner; // or outer induction variable. If there were, we could still do this; // transformation, but we'd have to insert a div/mod to calculate the; // original IVs, so it wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:3,Deployability,Update,Update,3,// Update the DomTree and MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:76,Modifiability,variab,variables,76,// Replace all uses of the polynomial calculated from the two induction; // variables with the one new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:110,Availability,avail,available,110,"// If both induction types are less than the maximum legal integer width,; // promote both to the widest type available so we know calculating; // (OuterTripCount * InnerTripCount) as the new trip count is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:206,Safety,safe,safe,206,"// If both induction types are less than the maximum legal integer width,; // promote both to the widest type available so we know calculating; // (OuterTripCount * InnerTripCount) as the new trip count is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:100,Performance,perform,performed,100,"// Add the narrow phi to list, so that it will be adjusted later when the; // the transformation is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:39,Modifiability,variab,variables,39,// Check if we can widen the induction variables to avoid overflow checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:52,Safety,avoid,avoid,52,// Check if we can widen the induction variables to avoid overflow checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:199,Performance,perform,performing,199,"// It can happen that after widening of the IV, flattening may not be; // possible/happening, e.g. when it is deemed unprofitable. So bail here if; // that is the case.; // TODO: IV widening without performing the actual flattening transformation; // is not ideal. While this codegen change should not matter much, it is an; // unnecessary change which is better to avoid. It's unlikely this happens; // often, because if it's unprofitibale after widening, it should be; // unprofitabe before widening as checked in the first round of checks. But; // 'RepeatedInstructionThreshold' is set to only 2, which can probably be; // relaxed. Because this is making a code change (the IV widening, but not; // the flattening), we return true here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:366,Safety,avoid,avoid,366,"// It can happen that after widening of the IV, flattening may not be; // possible/happening, e.g. when it is deemed unprofitable. So bail here if; // that is the case.; // TODO: IV widening without performing the actual flattening transformation; // is not ideal. While this codegen change should not matter much, it is an; // unnecessary change which is better to avoid. It's unlikely this happens; // often, because if it's unprofitibale after widening, it should be; // unprofitabe before widening as checked in the first round of checks. But; // 'RepeatedInstructionThreshold' is set to only 2, which can probably be; // relaxed. Because this is making a code change (the IV widening, but not; // the flattening), we return true here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:30,Performance,perform,perform,30,"// If we have widened and can perform the transformation, do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:75,Modifiability,variab,variable,75,"// Otherwise, if we haven't widened the IV, check if the new iteration; // variable might overflow. In this case, we need to version the loop, and; // select the original version at runtime if the iteration space is too; // large.; // TODO: We currently don't version the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:56,Usability,simpl,simplified,56,"// The loop flattening pass requires loops to be; // in simplified form, and also needs LCSSA. Running; // this pass will simplify all loops that contain inner loops,; // regardless of whether anything ends up being flattened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:122,Usability,simpl,simplify,122,"// The loop flattening pass requires loops to be; // in simplified form, and also needs LCSSA. Running; // this pass will simplify all loops that contain inner loops,; // regardless of whether anything ends up being flattened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1251,Integrability,depend,dependencies,1251,"dentifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// additional fusion.; ///; /// This implementation currently does not make any modifications to remove; /// conditions for fusion. Code transformations to make loops conform to each of; /// the conditions for fusion are discussed in more detail in t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1336,Safety,safe,safe,1336,"-------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// additional fusion.; ///; /// This implementation currently does not make any modifications to remove; /// conditions for fusion. Code transformations to make loops conform to each of; /// the conditions for fusion are discussed in more detail in the document; /// above. These can be added to the current implementation i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:823,Testability,test,test,823,"//===- LoopFuse.cpp - Loop Fusion Pass ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:191,Performance,cache,caches,191,"/// This class is used to represent a candidate for loop fusion. When it is; /// constructed, it checks the conditions for loop fusion to ensure that it; /// represents a valid candidate. It caches several parts of a loop that are; /// used throughout loop fusion (e.g., loop preheader, loop header, etc) instead; /// of continually querying the underlying Loop to retrieve these values. It is; /// assumed these will not change throughout loop fusion.; ///; /// The invalidate method should be used to indicate that the FusionCandidate is; /// no longer a valid candidate for fusion. Similarly, the isValid() method can; /// be used to ensure that the FusionCandidate is still valid for fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Performance,Cache,Cache,4,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:162,Performance,cache,cached,162,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:172,Safety,avoid,avoid,172,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:92,Deployability,update,updated,92,"/// After Peeling the loop is modified quite a bit, hence all of the Blocks; /// need to be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:286,Deployability,update,update,286,"// This is only used internally for now, to clear the MemWrites and MemReads; // list and setting Valid to false. I can't envision other uses of this right; // now, since once FusionCandidates are put into the FusionCandidateSet they; // are immutable. Thus, any time we need to change/update a FusionCandidate,; // we must create a new one and insert it into the FusionCandidateSet to; // ensure the FusionCandidateSet remains ordered correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:44,Usability,clear,clear,44,"// This is only used internally for now, to clear the MemWrites and MemReads; // list and setting Valid to false. I can't envision other uses of this right; // now, since once FusionCandidates are put into the FusionCandidateSet they; // are immutable. Thus, any time we need to change/update a FusionCandidate,; // we must create a new one and insert it into the FusionCandidateSet to; // ensure the FusionCandidateSet remains ordered correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:28,Modifiability,variab,variable,28,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:103,Modifiability,variab,variable,103,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:59,Testability,assert,asserts,59,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:140,Testability,assert,asserts,140,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:306,Deployability,patch,patch,306,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:653,Energy Efficiency,efficient,efficient,653,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:625,Testability,log,logic,625,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:612,Usability,simpl,simplify,612,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:725,Usability,simpl,simplify,725,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Testability,Test,Test,4,"/// Test whether a given loop has been removed from the function, and thus is; /// no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:82,Usability,clear,clear,82,// Finished analyzing candidates at this level.; // Descend to the next level and clear all of the candidates currently; // collected. Note that it will not be possible to fuse any of the; // existing candidates with new candidates because the new candidates will; // be at a different nest level and thus not be control flow equivalent; // with all of the candidates collected so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:200,Modifiability,evolve,evolve,200,"/// Determine if it is beneficial to fuse two loops.; ///; /// For now, this method simply returns true because we want to fuse as much; /// as possible (primarily to test the pass). This method will evolve, over; /// time, to add heuristics for profitability of fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:167,Testability,test,test,167,"/// Determine if it is beneficial to fuse two loops.; ///; /// For now, this method simply returns true because we want to fuse as much; /// as possible (primarily to test the pass). This method will evolve, over; /// time, to add heuristics for profitability of fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:84,Usability,simpl,simply,84,"/// Determine if it is beneficial to fuse two loops.; ///; /// For now, this method simply returns true because we want to fuse as much; /// as possible (primarily to test the pass). This method will evolve, over; /// time, to add heuristics for profitability of fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:445,Performance,perform,performed,445,"/// Determine if two fusion candidates have the same trip count (i.e., they; /// execute the same number of iterations).; ///; /// This function will return a pair of values. The first is a boolean,; /// stating whether or not the two candidates are known at compile time to; /// have the same TripCount. The second is the difference in the two; /// TripCounts. This information can be used later to determine whether or not; /// peeling can be performed on either one of the candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:20,Deployability,update,update,20,// Peeling does not update the PDT,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:457,Deployability,update,update,457,"// In this case the iterations of the loop are constant, so the first; // loop will execute completely (will not jump from one of; // the peeled blocks to the second loop). Here we are updating the; // branch conditions of each of the peeled blocks, such that it will; // branch to its successor which is not the preheader of the second loop; // in the case of unguarded loops, or the succesors of the exit block of; // the first loop otherwise. Doing this update will ensure that the entry; // block of the first loop dominates the entry block of the second loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:122,Availability,error,errors,122,"// Cannot modify the predecessors inside the above loop as it will cause; // the iterators to be nullptrs, causing memory errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependent,3,"// Dependent on peeling being performed on the first loop, and; // assuming all other conditions for fusion return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:30,Performance,perform,performed,30,"// Dependent on peeling being performed on the first loop, and; // assuming all other conditions for fusion return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:13,Integrability,depend,dependencies,13,// Check the dependencies across the loops and do not fuse if it would; // violate them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:16,Safety,safe,safe,16,"// If it is not safe to hoist/sink all instructions in the; // pre-header, we cannot fuse these loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:141,Performance,perform,perform,141,"// All analysis has completed and has determined that fusion is legal; // and profitable. At this point, start transforming the code and; // perform fusion.; // Execute the hoist/sink operations on preheader instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:119,Performance,perform,performed,119,// Peel the loop after determining that fusion is legal. The Loops; // will still be safe to fuse after the peeling is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:85,Safety,safe,safe,85,// Peel the loop after determining that fusion is legal. The Loops; // will still be safe to fuse after the peeling is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:24,Performance,Optimiz,Optimization,24,"// Report fusion to the Optimization Remarks.; // Note this needs to be done *before* performFusion because; // performFusion will change the original loops, making it not; // possible to identify them after fusion is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:86,Performance,perform,performFusion,86,"// Report fusion to the Optimization Remarks.; // Note this needs to be done *before* performFusion because; // performFusion will change the original loops, making it not; // possible to identify them after fusion is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:112,Performance,perform,performFusion,112,"// Report fusion to the Optimization Remarks.; // Note this needs to be done *before* performFusion because; // performFusion will change the original loops, making it not; // possible to identify them after fusion is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:101,Safety,Safe,SafeToHoist,101,// Returns true if the instruction \p I can be hoisted to the end of the; // preheader of \p FC0. \p SafeToHoist contains the instructions that are; // known to be safe to hoist. The instructions encountered that cannot be; // hoisted are in \p NotHoisting.; // TODO: Move functionality into CodeMoverUtils,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:164,Safety,safe,safe,164,// Returns true if the instruction \p I can be hoisted to the end of the; // preheader of \p FC0. \p SafeToHoist contains the instructions that are; // known to be safe to hoist. The instructions encountered that cannot be; // hoisted are in \p NotHoisting.; // TODO: Move functionality into CodeMoverUtils,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:44,Safety,safe,safe,44,"// If this isn't a memory inst, hoisting is safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,"// Dependency is not read-before-write, write-before-read or; // write-before-write",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not read-before-write,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not write-before-read or write-before-write,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:43,Safety,safe,safe,43,"// If this isn't a memory inst, sinking is safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not write-before-read,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not write-before-write or read-before-write,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:143,Integrability,depend,dependence,143,"// If the instruction has side-effects, give up.; // TODO: The case of mayReadFromMemory we can handle but requires; // additional work with a dependence analysis so for now we give; // up on memory reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite all additive recurrences in a SCEV to use a new loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:88,Integrability,depend,dependence,88,/// Return false if the access functions of \p I0 and \p I1 could cause; /// a negative dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:24,Security,access,access,24,/// Return false if the access functions of \p I0 and \p I1 could cause; /// a negative dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:144,Testability,test,test,144,// TODO: isKnownPredicate doesnt work well when one SCEV is loop carried (by; // L0) and the other is not. We could check if it is monotone and test; // the beginning and end value instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:23,Integrability,depend,dependences,23,/// Return true if the dependences between @p I0 (in @p L0) and @p I1 (in; /// @p L1) allow loop fusion of @p L0 and @p L1. The dependence analyses; /// specified by @p DepChoice are used to determine this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:128,Integrability,depend,dependence,128,/// Return true if the dependences between @p I0 (in @p L0) and @p I1 (in; /// @p L1) allow loop fusion of @p L0 and @p L1. The dependence analyses; /// specified by @p DepChoice are used to determine this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:33,Integrability,depend,dependence,33,// TODO: Can we actually use the dependence info analysis here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:14,Integrability,depend,dependence,14,/// Perform a dependence check and return if @p FC0 and @p FC1 can be fused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Performance,Perform,Perform,4,/// Perform a dependence check and return if @p FC0 and @p FC1 can be fused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:118,Safety,safe,safe,118,"// Walk through all uses in FC1. For each use, find the reaching def. If the; // def is located in FC0 then it is not safe to fuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:592,Deployability,update,update,592,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1118,Deployability,update,updates,1118,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:419,Integrability,depend,dependencies,419,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:559,Performance,perform,performed,559,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1612,Safety,safe,safe,1612,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:171,Testability,log,logic,171,// Fusing guarded loops is handled slightly differently than non-guarded; // loops and has been broken out into a separate method instead of trying to; // intersperse the logic within a single method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:229,Testability,test,test,229,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:258,Usability,simpl,simply,258,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:36,Deployability,update,update,36,// Then modify the control flow and update DT and PDT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:955,Usability,simpl,simpler,955,"// The old exiting block of the first loop (FC0) has to jump to the header; // of the second as we need to execute the code in the second header block; // regardless of the trip count. That is, if the trip count is 0, so the; // back edge is never taken, we still have to execute both loop headers,; // especially (but not only!) if the second is a do-while style loop.; // However, doing so might invalidate the phi nodes of the first loop as; // the new values do only need to dominate their latch and not the exiting; // predicate. To remedy this potential problem we always introduce phi; // nodes in the header of the second loop later that select the loop carried; // value, if the second header was reached through an old latch of the; // first, or undef otherwise. This is sound as exiting the first implies the; // second will exit too, __without__ taking the back-edge. [Their; // trip-counts are equal after all.; // KB: Would this sequence be simpler to just make FC0.ExitingBlock go; // to FC1.Header? I think this is basically what the three sequences are; // trying to accomplish; however, doing this directly in the CFG may mean; // the DT/PDT becomes invalid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:89,Deployability,update,updates,89,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:75,Performance,perform,performed,75,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Deployability,Update,Update,3,// Update DT/PDT,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:83,Deployability,update,updated,83,// Move instructions from FC0.Latch to FC1.Latch.; // Note: mergeLatch requires an updated DT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:233,Performance,Optimiz,OptimizationRemarkMissed,233,"/// Report details on loop fusion opportunities.; ///; /// This template function can be used to report both successful and missed; /// loop fusion opportunities, based on the RemarkKind. The RemarkKind should; /// be one of:; /// - OptimizationRemarkMissed to report when loop fusion is unsuccessful; /// given two valid fusion candidates.; /// - OptimizationRemark to report successful fusion of two fusion; /// candidates.; /// The remarks will be printed using the form:; /// <path/filename>:<line number>:<column number>: [<function name>]:; /// <Cand1 Preheader> and <Cand2 Preheader>: <Stat Description>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:348,Performance,Optimiz,OptimizationRemark,348,"/// Report details on loop fusion opportunities.; ///; /// This template function can be used to report both successful and missed; /// loop fusion opportunities, based on the RemarkKind. The RemarkKind should; /// be one of:; /// - OptimizationRemarkMissed to report when loop fusion is unsuccessful; /// given two valid fusion candidates.; /// - OptimizationRemark to report successful fusion of two fusion; /// candidates.; /// The remarks will be printed using the form:; /// <path/filename>:<line number>:<column number>: [<function name>]:; /// <Cand1 Preheader> and <Cand2 Preheader>: <Stat Description>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:692,Deployability,update,updated,692,"/// Fuse two guarded fusion candidates, creating a new fused loop.; ///; /// Fusing guarded loops is handled much the same way as fusing non-guarded; /// loops. The rewiring of the CFG is slightly different though, because of; /// the presence of the guards around the loops and the exit blocks after the; /// loop body. As such, the new loop is rewired as follows:; /// 1. Keep the guard branch from FC0 and use the non-loop block target; /// from the FC1 guard branch.; /// 2. Remove the exit block from FC0 (this exit block should be empty; /// right now).; /// 3. Remove the guard branch for FC1; /// 4. Remove the preheader for FC1.; /// The exit block successor for the latch of FC0 is updated to be the header; /// of FC1 and the non-exit block successor of the latch of FC1 is updated to; /// be the header of FC0, thus creating the fused loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:785,Deployability,update,updated,785,"/// Fuse two guarded fusion candidates, creating a new fused loop.; ///; /// Fusing guarded loops is handled much the same way as fusing non-guarded; /// loops. The rewiring of the CFG is slightly different though, because of; /// the presence of the guards around the loops and the exit blocks after the; /// loop body. As such, the new loop is rewired as follows:; /// 1. Keep the guard branch from FC0 and use the non-loop block target; /// from the FC1 guard branch.; /// 2. Remove the exit block from FC0 (this exit block should be empty; /// right now).; /// 3. Remove the guard branch for FC1; /// 4. Remove the preheader for FC1.; /// The exit block successor for the latch of FC0 is updated to be the header; /// of FC1 and the non-exit block successor of the latch of FC1 is updated to; /// be the header of FC0, thus creating the fused loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:81,Deployability,Update,Update,81,"////////////////////////////////////////////////////////////////////////////; // Update the Loop Guard; ////////////////////////////////////////////////////////////////////////////; // The guard for FC0 is updated to guard both FC0 and FC1. This is done by; // changing the NonLoopGuardBlock for FC0 to the NonLoopGuardBlock for FC1.; // Thus, one path from the guard goes to the preheader for FC0 (and thus; // executes the new fused loop) and the other path goes to the NonLoopBlock; // for FC1 (where FC1 guard would have gone if FC1 was not executed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:206,Deployability,update,updated,206,"////////////////////////////////////////////////////////////////////////////; // Update the Loop Guard; ////////////////////////////////////////////////////////////////////////////; // The guard for FC0 is updated to guard both FC0 and FC1. This is done by; // changing the NonLoopGuardBlock for FC0 to the NonLoopGuardBlock for FC1.; // Thus, one path from the guard goes to the preheader for FC0 (and thus; // executes the new fused loop) and the other path goes to the NonLoopBlock; // for FC1 (where FC1 guard would have gone if FC1 was not executed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:229,Testability,test,test,229,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.; // KB: This is no longer necessary because FC0.ExitingBlock == FC0.Latch; // (because the loops are rotated. Thus, nothing will ever be added to; // OriginalFC0PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:258,Usability,simpl,simply,258,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.; // KB: This is no longer necessary because FC0.ExitingBlock == FC0.Latch; // (because the loops are rotated. Thus, nothing will ever be added to; // OriginalFC0PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Deployability,Update,Update,3,// Update the latches; // Replace latch terminator destinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:89,Deployability,update,updates,89,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:75,Performance,perform,performed,75,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:26,Deployability,update,updates,26,// All done; // Apply the updates to the Dominator Tree and cleanup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Deployability,Update,Update,3,// Update DT/PDT,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:83,Deployability,update,updated,83,// Move instructions from FC0.Latch to FC1.Latch.; // Note: mergeLatch requires an updated DT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:176,Integrability,depend,dependency,176,// Ensure loops are in simplifed form which is a pre-requisite for loop fusion; // pass. Added only for new PM since the legacy PM has already added; // LoopSimplify pass as a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:23,Usability,simpl,simplifed,23,// Ensure loops are in simplifed form which is a pre-requisite for loop fusion; // pass. Added only for new PM since the legacy PM has already added; // LoopSimplify pass as a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:536,Performance,perform,performance,536,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:591,Safety,avoid,avoid,591,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:440,Usability,simpl,simple,440,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:50,Availability,error,errors,50,// Dummy retval never to be used. Allows catching errors in retval; // handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:37,Performance,Optimiz,OptimizationRemarkEmitter,37,"// For the new PM, we also can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:77,Performance,optimiz,optimized,77,"// If this loop executes exactly one time, then it should be peeled, not; // optimized by this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:73,Safety,safe,safe,73,"/// getMemSetPatternValue - If a strided store of the specified value is safe to; /// turn into a memset_pattern16, return a ConstantArray of 16 bytes that should; /// be passed in. Otherwise, return null.; ///; /// Note that we don't ever attempt to use memset_pattern8 or 4, because these; /// just replicate their input array and then pass on to memset_pattern16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:40,Energy Efficiency,power,power,40,// Only handle simple values that are a power of two bytes in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,Usability,simpl,simple,15,// Only handle simple values that are a power of two bytes in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:16,Usability,simpl,simple,16,// We only want simple or unordered-atomic stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:3,Safety,Avoid,Avoid,3,// Avoid merging nontemporal stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:88,Performance,scalab,scalable,88,"// Reject stores that are so large that they overflow an unsigned.; // When storing out scalable vectors we bail out for now, since the code; // below currently only works for constant strides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:44,Performance,load,load,44,// The store must be feeding a non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:27,Performance,load,loads,27,// Only allow non-volatile loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:41,Performance,load,loads,41,// Only allow simple or unordered-atomic loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:14,Usability,simpl,simple,14,// Only allow simple or unordered-atomic loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:17,Performance,load,load,17,// The store and load must share the same stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:45,Performance,optimiz,optimized,45,"// Look for store instructions, which may be optimized to memset/memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:82,Performance,optimiz,optimized,82,"// Look for a single store or sets of stores with a common base, which can be; // optimized into a memset (memset_pattern). The latter most commonly happens; // with structs and handunrolled loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:70,Performance,load,load,70,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:17,Performance,optimiz,optimize,17,// See if we can optimize just this store in isolation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:46,Performance,optimiz,optimized,46,"// Look for memory instructions, which may be optimized to a larger one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:14,Performance,load,load,14,"// See if the load and store pointer expressions are AddRec like {base,+,1} on; // the current loop, which indicates a strided load and store. If we have; // something else, it's a random load or store we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:127,Performance,load,load,127,"// See if the load and store pointer expressions are AddRec like {base,+,1} on; // the current loop, which indicates a strided load and store. If we have; // something else, it's a random load or store we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:188,Performance,load,load,188,"// See if the load and store pointer expressions are AddRec like {base,+,1} on; // the current loop, which indicates a strided load and store. If we have; // something else, it's a random load or store we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:16,Performance,load,load,16,// Check if the load stride matches the store stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:85,Performance,optimiz,optimization,85,"// If an expression is covered by the loop guard, compare again and; // proceed with optimization if equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:68,Security,access,access,68,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:136,Security,access,access,136,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:149,Security,Access,Access,149,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:208,Security,access,access,208,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:66,Security,access,access,66,"// Get the location that may be stored across the loop. Since the access is; // strided positively through memory, we say that the modified location starts; // at the pointer and has infinite size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:67,Security,access,access,67,"// If the loop iterates a fixed number of times, we can refine the access size; // to be exactly the size of the memset, which is (BECount+1)*StoreSize",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:107,Integrability,depend,dependencies,107,// TODO: ideally we should still be able to generate memset if SCEV expander; // is taught to generate the dependencies at the latest point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:163,Safety,unsafe,unsafe,163,"// Okay, we have a strided store ""p[i]"" of a splattable value. We can turn; // this into a memset in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write to the aliased location. Check for any overlap by generating the; // base pointer and checking the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:294,Modifiability,variab,variable,294,"// From here on out, conservatively report to the pass manager that we've; // changed the IR, even if we later clean up these added instructions. There; // may be structural differences e.g. in the order of use lists not accounted; // for in just a textual dump of the IR. This is written as a variable, even; // though statically all the places this dominates could be replaced with; // 'true', with the hope that anyone trying to be clever / ""more precise"" with; // the return value will read this comment, and leave them alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:107,Integrability,depend,dependencies,107,// TODO: ideally we should still be able to generate memset if SCEV expander; // is taught to generate the dependencies at the latest point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:37,Performance,load,load,37,/// If the stored value is a strided load in the same loop with the same stride; /// this may be transformable into a memcpy. This kicks in for stuff like; /// for (i) A[i] = B[i];,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:44,Performance,load,load,44,// The store must be feeding a non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,Performance,Load,LoadBasePtr,15,// Ensure that LoadBasePtr is after StoreBasePtr or before StoreBasePtr; // for negative stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,Performance,Load,LoadBasePtr,15,// Ensure that LoadBasePtr is after StoreBasePtr or before StoreBasePtr; // for negative stride. LoadBasePtr shouldn't overlap with StoreBasePtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:97,Performance,Load,LoadBasePtr,97,// Ensure that LoadBasePtr is after StoreBasePtr or before StoreBasePtr; // for negative stride. LoadBasePtr shouldn't overlap with StoreBasePtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:45,Performance,load,loaded,45,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:291,Performance,load,load,291,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:159,Safety,unsafe,unsafe,159,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:294,Modifiability,variab,variable,294,"// From here on out, conservatively report to the pass manager that we've; // changed the IR, even if we later clean up these added instructions. There; // may be structural differences e.g. in the order of use lists not accounted; // for in just a textual dump of the IR. This is written as a variable, even; // though statically all the places this dominates could be replaced with; // 'true', with the hope that anyone trying to be clever / ""more precise"" with; // the return value will read this comment, and leave them alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:67,Security,access,access,67,// For memmove case it's not enough to guarantee that loop doesn't access; // TheStore and TheLoad. Additionally we need to make sure that TheStore is; // the only user of TheLoad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:83,Performance,load,load,83,"// If the store is a memcpy instruction, we must check if it will write to; // the load memory locations. So remove it from the ignored stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:23,Safety,safe,safe,23,"// Okay, everything is safe, we can transform this!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:68,Performance,load,load,68,"// Check whether to generate an unordered atomic memcpy:; // If the load or store are atomic, then they must necessarily be unordered; // by previous checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:47,Performance,load,load,47,"// We cannot allow unaligned ops for unordered load/store, so reject; // anything where the alignment isn't at least the element size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:65,Performance,load,loads,65,"// If the element.atomic memcpy is not lowered into explicit; // loads/stores later, then it will be lowered into an element-size; // specific lib call. If the lib call doesn't exist for our store size, then; // we shouldn't generate the memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:51,Performance,load,loads,51,// Create the call.; // Note that unordered atomic loads/stores are *required* by the spec to; // have an alignment but non-atomic loads/stores may not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:131,Performance,load,loads,131,// Create the call.; // Note that unordered atomic loads/stores are *required* by the spec to; // have an alignment but non-atomic loads/stores may not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:34,Safety,avoid,avoid,34,// When compiling for codesize we avoid idiom recognition for a multi-block loop; // unless it is a loop_memset idiom or a memset/memcpy idiom in a nested loop.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:84,Modifiability,variab,variable,84,"/// Check if the given conditional branch is based on the comparison between; /// a variable and zero, and if the variable is non-zero or zero (JmpOnZero is; /// true), the control yields to the loop entry. If the branch matches the; /// behavior, the variable involved in the comparison is returned. This function; /// will be called to see if the precondition and postcondition of the loop are; /// in desirable form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:114,Modifiability,variab,variable,114,"/// Check if the given conditional branch is based on the comparison between; /// a variable and zero, and if the variable is non-zero or zero (JmpOnZero is; /// true), the control yields to the loop entry. If the branch matches the; /// behavior, the variable involved in the comparison is returned. This function; /// will be called to see if the precondition and postcondition of the loop are; /// in desirable form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:252,Modifiability,variab,variable,252,"/// Check if the given conditional branch is based on the comparison between; /// a variable and zero, and if the variable is non-zero or zero (JmpOnZero is; /// true), the control yields to the loop entry. If the branch matches the; /// behavior, the variable involved in the comparison is returned. This function; /// will be called to see if the precondition and postcondition of the loop are; /// in desirable form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:27,Modifiability,variab,variable,27,// Check if the recurrence variable `VarX` is in the right form to create; // the idiom. Returns the value coerced to a PHINode if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:33,Safety,detect,detected,33,"/// Return true iff the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction counting the population bit.; /// 2) \p CntPhi is set to the corresponding phi node.; /// 3) \p Var is set to the value whose population bits are being counted.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 != 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x1 = phi (x0, x2);; /// cnt1 = phi(cnt0, cnt2);; ///; /// cnt2 = cnt1 + 1;; /// ...; /// x2 = x1 & (x1 - 1);; /// ...; /// } while(x != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:327,Safety,detect,detect,327,"/// Return true iff the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction counting the population bit.; /// 2) \p CntPhi is set to the corresponding phi node.; /// 3) \p Var is set to the value whose population bits are being counted.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 != 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x1 = phi (x0, x2);; /// cnt1 = phi(cnt0, cnt2);; ///; /// cnt2 = cnt1 + 1;; /// ...; /// x2 = x1 & (x1 - 1);; /// ...; /// } while(x != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Safety,detect,detect,11,"// step 2: detect instructions corresponding to ""x2 = x1 & (x1 - 1)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:35,Modifiability,variab,variable,35,// step 3: Check the recurrence of variable X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,Safety,detect,detected,32,"/// Return true if the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction Counting Leading Zeros (CTLZ); /// or nullptr if there is no such.; /// 2) \p CntPhi is set to the corresponding phi node; /// or nullptr if there is no such.; /// 3) \p Var is set to the value whose CTLZ could be used.; /// 4) \p DefX is set to the instruction calculating Loop exit condition.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 == 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x = phi (x0, x.next); //PhiX; /// cnt = phi(cnt0, cnt.next);; ///; /// cnt.next = cnt + 1;; /// ...; /// x.next = x >> 1; // DefX; /// ...; /// } while(x.next != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:460,Safety,detect,detect,460,"/// Return true if the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction Counting Leading Zeros (CTLZ); /// or nullptr if there is no such.; /// 2) \p CntPhi is set to the corresponding phi node; /// or nullptr if there is no such.; /// 3) \p Var is set to the value whose CTLZ could be used.; /// 4) \p DefX is set to the instruction calculating Loop exit condition.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 == 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x = phi (x0, x.next); //PhiX; /// cnt = phi(cnt0, cnt.next);; ///; /// cnt.next = cnt + 1;; /// ...; /// x.next = x >> 1; // DefX; /// ...; /// } while(x.next != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Safety,detect,detect,11,"// step 2: detect instructions corresponding to ""x.next = x >> 1 or x << 1""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:35,Modifiability,variab,variable,35,// step 3: Check the recurrence of variable X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:210,Performance,optimiz,optimized,210,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:275,Performance,optimiz,optimized,275,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:317,Safety,detect,detect,317,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:9,Safety,safe,safe,9,// It is safe to assume Preheader exist as it was checked in; // parent function RunOnLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:78,Safety,detect,detected,78,"/// Recognizes a population count idiom in a non-countable loop.; ///; /// If detected, transforms the relevant code to issue the popcount intrinsic; /// function call, and returns true; otherwise, returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:189,Availability,down,downstream,189,"// Step 2: Replace the precondition from ""if (x == 0) goto loop-exit"" to; // ""if (NewCount == 0) loop-exit"". Without this change, the intrinsic; // function would be partial dead code, and downstream passes will drag; // it back from the precondition block to the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:639,Availability,alive,alive,639,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:603,Performance,perform,performs,603,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:720,Performance,optimiz,optimized,720,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:738,Performance,optimiz,optimizations,738,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:557,Safety,safe,safely,557,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,Safety,detect,detected,32,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:96,Safety,detect,detect,96,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:687,Availability,mask,mask,687,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:731,Availability,mask,masked,731,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:753,Availability,mask,mask,753,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:766,Availability,mask,masked,766,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:822,Availability,mask,masked,822,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:852,Availability,mask,masked,852,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:890,Availability,mask,masked,890,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:921,Availability,mask,masked,921,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:955,Availability,mask,masked,955,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:1027,Availability,mask,masked,1027,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:7,Modifiability,rewrite,rewrite,7,"// The rewrite is considered to be unprofitable iff and only iff the; // intrinsic/shift we'll use are not cheap. Note that we are okay with *just*; // making the loop countable, even if nothing else changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:104,Safety,safe,safe,104,"// We know loop's backedge-taken count, but what's loop's trip count?; // Note that while NUW is always safe, while NSW is only for bitwidths != 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:83,Safety,safe,safe,83,"// Step 2: Compute the recurrence's final value without a loop.; // NewX is always safe to compute, because `LoopBackedgeTakenCount`; // will always be smaller than `bitwidth(X)`, i.e. we never get poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:284,Safety,safe,safe,284,"// Rewriting XNext is more complicated, however, because `X << LoopTripCount`; // will be poison iff `LoopTripCount == bitwidth(X)` (which will happen; // iff `BitPos` is `bitwidth(x) - 1` and `X` is `1`). So unless we know; // that isn't the case, we'll need to emit an alternative, safe IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Modifiability,Rewrite,Rewrite,11,"// Step 4: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:102,Modifiability,variab,variable,102,"// Step 4: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:59,Safety,safe,safe,59,"// The induction itself.; // Note that while NUW is always safe, while NSW is only for bitwidths != 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,Safety,detect,detected,32,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %start = <...>; /// %extraoffset = <...>; /// <...>; /// br label %for.cond; ///; /// loop:; /// %iv = phi i8 [ %start, %entry ], [ %iv.next, %for.cond ]; /// %nbits = add nsw i8 %iv, %extraoffset; /// %val.shifted = {{l,a}shr,shl} i8 %val, %nbits; /// %val.shifted.iszero = icmp eq i8 %val.shifted, 0; /// %iv.next = add i8 %iv, 1; /// <...>; /// br i1 %val.shifted.iszero, label %end, label %loop; ///; /// end:; /// %iv.res = phi i8 [ %iv, %loop ] <...>; /// %nbits.res = phi i8 [ %nbits, %loop ] <...>; /// %val.shifted.res = phi i8 [ %val.shifted, %loop ] <...>; /// %val.shifted.iszero.res = phi i1 [ %val.shifted.iszero, %loop ] <...>; /// %iv.next.res = phi i8 [ %iv.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:96,Safety,detect,detect,96,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %start = <...>; /// %extraoffset = <...>; /// <...>; /// br label %for.cond; ///; /// loop:; /// %iv = phi i8 [ %start, %entry ], [ %iv.next, %for.cond ]; /// %nbits = add nsw i8 %iv, %extraoffset; /// %val.shifted = {{l,a}shr,shl} i8 %val, %nbits; /// %val.shifted.iszero = icmp eq i8 %val.shifted, 0; /// %iv.next = add i8 %iv, 1; /// <...>; /// br i1 %val.shifted.iszero, label %end, label %loop; ///; /// end:; /// %iv.res = phi i8 [ %iv, %loop ] <...>; /// %nbits.res = phi i8 [ %nbits, %loop ] <...>; /// %val.shifted.res = phi i8 [ %val.shifted, %loop ] <...>; /// %val.shifted.iszero.res = phi i1 [ %val.shifted.iszero, %loop ] <...>; /// %iv.next.res = phi i8 [ %iv.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:177,Testability,log,logical,177,"// The new, countable, loop will certainly only run a known number of; // iterations, It won't be infinite. But the old loop might be infinite; // under certain conditions. For logical shifts, the value will become zero; // after at most bitwidth(%Val) loop iterations. However, for arithmetic; // right-shift, iff the sign bit was set, the value will never become zero,; // and the loop may never finish.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:7,Modifiability,rewrite,rewrite,7,"// The rewrite is considered to be unprofitable iff and only iff the; // intrinsic we'll use are not cheap. Note that we are okay with *just*; // making the loop countable, even if nothing else changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:82,Modifiability,variab,variable,82,// Step 2: Adjust the successor basic block to recieve the original; // induction variable's final value instead of the orig. IV itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Modifiability,Rewrite,Rewrite,11,"// Step 3: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:102,Modifiability,variab,variable,102,"// Step 3: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:393,Performance,perform,performs,393,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:47,Usability,Simpl,Simplification,47,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:426,Usability,simpl,simplification,426,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:189,Deployability,update,updated,189,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:429,Energy Efficiency,allocate,allocated,429,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:50,Usability,simpl,simplify,50,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:133,Usability,simpl,simplifying,133,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:269,Usability,simpl,simplifying,269,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:346,Usability,simpl,simplify,346,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:9,Usability,simpl,simplifying,9,// While simplifying we may discover dead code or cause code to become dead.; // Keep track of all such instructions and we will delete them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:212,Usability,simpl,simplifications,212,// First we want to create an RPO traversal of the loop body. By processing in; // RPO we can ensure that definitions are processed prior to uses (for non PHI; // uses) in all cases. This ensures we maximize the simplifications in each; // iteration over the loop and minimizes the possible causes for continuing to; // iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:52,Safety,detect,detect,52,// We special case the first iteration which we can detect due to the; // empty `ToSimplify` set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:18,Usability,simpl,simplifying,18,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:297,Usability,simpl,simplified,297,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:397,Usability,simpl,simplify,397,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:44,Usability,simpl,simplified,44,"// If we never found a PHI that needs to be simplified in the next; // iteration, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:480,Performance,cache,cache-friendly,480,"//===- LoopInterchange.cpp - Loop interchange pass-------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This Pass handles loop interchange transform.; // This pass interchanges loops to provide a more cache-friendly memory access; // patterns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:502,Security,access,access,502,"//===- LoopInterchange.cpp - Loop interchange pass-------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This Pass handles loop interchange transform.; // This pass interchanges loops to provide a more cache-friendly memory access; // patterns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Integrability,depend,dependencies,49,// end anonymous namespace; // Maximum number of dependencies that can be handled in the dependency matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:89,Integrability,depend,dependency,89,// end anonymous namespace; // Maximum number of dependencies that can be handled in the dependency matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:33,Performance,load,loads,33,// Scan the BB and collect legal loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:16,Integrability,depend,dependencies,16,// Ignore Input dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:32,Integrability,depend,dependencies,32,"// Track Output, Flow, and Anti dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:55,Deployability,Update,Update,55,// A loop is moved from index 'from' to an index 'to'. Update the Dependence; // matrix by exchanging the two columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:66,Integrability,Depend,Dependence,66,// A loop is moved from index 'from' to an index 'to'. Update the Dependence; // matrix by exchanging the two columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:87,Integrability,depend,dependence,87,// TODO: Add a better heuristic to select the loop to be interchanged based; // on the dependence matrix. Currently we select the innermost loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:45,Performance,cache,cache,45,"// Obtain the loop vector returned from loop cache analysis beforehand,; // and put each <Loop, index> pair into a map for constant time query; // later. Indices in loop vector reprsent the optimal order of the; // corresponding loop, e.g., given a loopnest with depth N, index 0; // indicates the loop should be placed as the outermost loop and index N; // indicates the loop should be placed as the innermost loop.; //; // For the old pass manager CacheCost would be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:450,Performance,Cache,CacheCost,450,"// Obtain the loop vector returned from loop cache analysis beforehand,; // and put each <Loop, index> pair into a map for constant time query; // later. Indices in loop vector reprsent the optimal order of the; // corresponding loop, e.g., given a loopnest with depth N, index 0; // indicates the loop should be placed as the outermost loop and index N; // indicates the loop should be placed as the innermost loop.; //; // For the old pass manager CacheCost would be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Security,access,access,49,"// We try to achieve the globally optimal memory access for the loopnest,; // and do interchange based on a bubble-sort fasion. We start from; // the innermost loop, move it outwards to the best possible position; // and repeat this process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:23,Deployability,update,update,23,"// Loops interchanged, update LoopList accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Deployability,Update,Update,3,// Update the DependencyMatrix,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:14,Integrability,Depend,DependencyMatrix,14,// Update the DependencyMatrix,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:9,Safety,abort,abort,9,// Early abort if there was no interchange during an entire round of; // moving loops outwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:121,Safety,unsafe,unsafe,121,// We do not have any basic block in between now make sure the outer header; // and outer loop latch doesn't contain any unsafe instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:64,Safety,unsafe,unsafe,64,// Also make sure the inner loop preheader does not contain any unsafe; // instructions. Note that all instructions in the preheader will be moved to; // the outer loop header when interchanging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:117,Safety,safe,safe,117,"// The inner loop exit block does flow to the outer loop latch and not some; // other BBs, now make sure it contains safe instructions, since it will be; // moved into the (new) inner loop after interchange.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Modifiability,variab,variable,49,"// Check if V only involves inner loop induction variable.; // Return true if V is InnerInduction, or a cast from; // InnerInduction, or a binary operator that involves; // InnerInduction and a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:103,Modifiability,variab,variables,103,"// In case of multiple inner loop indvars, it is okay if LHS and RHS; // are both inner indvar related variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:82,Modifiability,variab,variable,82,// Otherwise we check if the cmp instruction compares an inner indvar; // related variable (Left) with a outer loop invariant (Right).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:13,Modifiability,variab,variables,13,// Reduction variables cannot be constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Safety,Detect,Detect,3,// Detect floating point reduction only when it can be reordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:224,Availability,avail,available,224,"// We currently support LCSSA PHI nodes in the outer loop exit, if their; // incoming values do not come from the outer loop latch or if the; // outer loop latch has a single predecessor. In that case, the value will; // be available if both the inner and outer loop conditions are true, which; // will still be true after interchanging. If we have multiple predecessor,; // that may not be the case, e.g. because the outer loop latch may be executed; // if the inner loop is not executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:545,Deployability,update,update,545,"// The incoming value is defined in the outer loop latch. Currently we; // only support that in case the outer loop latch has a single predecessor.; // This guarantees that the outer loop latch is executed if and only if; // the inner loop is executed (because tightlyNested() guarantees that the; // outer loop header only branches to the inner loop or the outer loop; // latch).; // FIXME: We could weaken this logic and allow multiple predecessors,; // if the values are produced outside the loop latch. We would need; // additional logic to update the PHI nodes in the exit block as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:413,Testability,log,logic,413,"// The incoming value is defined in the outer loop latch. Currently we; // only support that in case the outer loop latch has a single predecessor.; // This guarantees that the outer loop latch is executed if and only if; // the inner loop is executed (because tightlyNested() guarantees that the; // outer loop header only branches to the inner loop or the outer loop; // latch).; // FIXME: We could weaken this logic and allow multiple predecessors,; // if the values are produced outside the loop latch. We would need; // additional logic to update the PHI nodes in the exit block as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:536,Testability,log,logic,536,"// The incoming value is defined in the outer loop latch. Currently we; // only support that in case the outer loop latch has a single predecessor.; // This guarantees that the outer loop latch is executed if and only if; // the inner loop is executed (because tightlyNested() guarantees that the; // outer loop header only branches to the inner loop or the outer loop; // latch).; // FIXME: We could weaken this logic and allow multiple predecessors,; // if the values are produced outside the loop latch. We would need; // additional logic to update the PHI nodes in the exit block as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:222,Availability,avail,available,222,"// In case of multi-level nested loops, it may occur that lcssa phis exist in; // the latch of InnerLoop, i.e., when defs of the incoming values are further; // inside the loopnest. Sometimes those incoming values are not available; // after interchange, since the original inner latch will become the new outer; // latch which may have predecessor paths that do not include those incoming; // values.; // TODO: Handle transformation of lcssa phis in the InnerLoop latch in case of; // multi-level loop nests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:147,Availability,avail,available,147,"// If the original outer latch has only one predecessor, then values defined; // further inside the looploop, e.g., in the innermost loop, will be available; // at the new outer latch after interchange.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:356,Availability,avail,available,356,"// The outer latch has more than one predecessors, i.e., the inner; // exit and the inner header.; // PHI nodes in the inner latch are lcssa phis where the incoming values; // are defined further inside the loopnest. Check if those phis are used; // in the original inner latch. If that is the case then bail out since; // those incoming values may not be available at the new outer latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Performance,cache,cache,49,"// This is the new cost model returned from loop cache analysis.; // A smaller index means the loop should be placed an outer loop, and vice; // versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:113,Modifiability,variab,variables,113,// Legacy cost model: this is rough cost estimation algorithm. It counts the; // good and bad order of induction variables in the instruction and allows; // reordering if number of bad orders is more than good.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:62,Integrability,depend,dependency,62,"// If the inner loop is loop independent or doesn't carry any dependency; // it is not profitable to move this to outer position, since we are; // likely able to do inner loop vectorization already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:21,Integrability,depend,dependence,21,"// If inner loop has dependence and outer loop is loop independent then it; // is/ profitable to interchange to enable inner loop parallelism.; // If there are no dependences, interchanging will not improve anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:163,Integrability,depend,dependences,163,"// If inner loop has dependence and outer loop is loop independent then it; // is/ profitable to interchange to enable inner loop parallelism.; // If there are no dependences, interchanging will not improve anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:79,Performance,cache,cache,79,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:204,Performance,cache,cache,204,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:35,Safety,avoid,avoid,35,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Deployability,Update,Update,4,"/// Update LoopInfo, after interchanging. NewInner and NewOuter refer to the; /// new inner and outer loop after interchanging: NewInner is the original; /// outer loop and NewOuter is the original inner loop.; ///; /// Before interchanging, we have the following structure; /// Outer preheader; // Outer header; // Inner preheader; // Inner header; // Inner body; // Inner latch; // outer bbs; // Outer latch; //; // After interchanging:; // Inner preheader; // Inner header; // Outer preheader; // Outer header; // Inner body; // outer bbs; // Outer latch; // Inner latch",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:52,Deployability,Update,Update,52,// Duplicate instruction and move it the new latch. Update uses that; // have been moved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:57,Integrability,depend,depend,57,"// Instructions in the original inner loop preheader may depend on values; // defined in the outer loop header. Move them there, because the original; // inner loop preheader will become the entry into the interchanged loop nest.; // Currently we move all instructions and rely on LICM to move invariant; // instructions outside the loop nest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Deployability,Update,Update,3,"// Update BI to jump to NewBB instead of OldBB. Records updates to the; // dominator tree in DTUpdates. If \p MustUpdateOnce is true, assert that; // \p OldBB is exactly once in BI's successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:56,Deployability,update,updates,56,"// Update BI to jump to NewBB instead of OldBB. Records updates to the; // dominator tree in DTUpdates. If \p MustUpdateOnce is true, assert that; // \p OldBB is exactly once in BI's successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:134,Testability,assert,assert,134,"// Update BI to jump to NewBB instead of OldBB. Records updates to the; // dominator tree in DTUpdates. If \p MustUpdateOnce is true, assert that; // \p OldBB is exactly once in BI's successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:96,Deployability,update,updated,96,// Skip Phis with incoming values defined in the inner loop. Those should; // already have been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:7,Deployability,update,update,7,// Now update the reduction PHIs in the inner and outer loop headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Deployability,Update,Update,3,// Update the incoming blocks for moved PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:499,Integrability,depend,dependences,499,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:38,Performance,Load,Load,38,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:416,Performance,load,load,416,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:557,Performance,load,loads,557,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:702,Performance,load,load,702,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:723,Performance,load,load,723,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:903,Performance,load,load,903,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:23,Integrability,depend,dependence,23,/// Return true if the dependence from the store to the load has an; /// absolute distance of one.; /// E.g. A[i+1] = A[i] (or A[i-1] = A[i] for descending loop),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:56,Performance,load,load,56,/// Return true if the dependence from the store to the load has an; /// absolute distance of one.; /// E.g. A[i+1] = A[i] (or A[i-1] = A[i] for descending loop),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:454,Energy Efficiency,efficient,efficiently,454,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:179,Integrability,wrap,wrap,179,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:238,Performance,load,load,238,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:259,Safety,safe,safely,259,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:30,Integrability,wrap,wrapping,30,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:73,Integrability,depend,dependence,73,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:129,Security,access,accesses,129,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:142,Performance,load,loaded,142,"// end anonymous namespace; /// Check if the store dominates all latches, so as long as there is no; /// intervening store this value will be loaded in the next iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:23,Performance,load,load,23,/// Return true if the load is not executed on all paths in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:55,Integrability,depend,dependences,55,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:106,Integrability,depend,dependences,106,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:101,Performance,load,load,101,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:232,Testability,test,tested,232,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:20,Integrability,depend,dependences,20,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:97,Integrability,depend,dependences,97,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:163,Integrability,depend,dependences,163,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:15,Performance,load,load,15,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:129,Performance,load,loads,129,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:142,Integrability,depend,depending,142,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:266,Integrability,depend,dependences,266,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:557,Integrability,depend,dependences,557,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:666,Integrability,depend,dependece,666,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:815,Integrability,depend,dependence,815,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:9,Performance,load,load,9,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:807,Performance,perform,perform,807,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:323,Usability,simpl,simple,323,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:43,Performance,load,load,43,// Already multiple stores forward to this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:171,Integrability,depend,dependence,171,// Handle the very basic case when the two stores are in the same block; // so deciding which one forwards is easy. The later one forwards as; // long as they both have a dependence distance of one to the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:205,Performance,load,load,205,// Handle the very basic case when the two stores are in the same block; // so deciding which one forwards is easy. The later one forwards as; // long as they both have a dependence distance of one to the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:65,Performance,load,load,65,"// They are in the same block, the later one will forward to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:186,Performance,load,load,186,"/// Given two pointers operations by their RuntimePointerChecking; /// indices, return true if they require an alias check.; ///; /// We need a check if one is a pointer for a candidate load and the other is; /// a pointer for a possibly intervening store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:95,Performance,load,load,95,/// Return pointers that are possibly written to on the path from a; /// forwarding store to a load.; ///; /// These pointers need to be alias-checked against the forwarding candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:68,Performance,load,loads,68,"// From FirstStore to LastLoad neither of the elimination candidate loads; // should overlap with any of the stores.; //; // E.g.:; //; // st1 C[i]; // ld1 B[i] <-------,; // ld0 A[i] <----, | * LastLoad; // ... | |; // st2 E[i] | |; // st3 B[i+1] -- | -' * FirstStore; // st0 A[i+1] ---'; // st4 D[i]; //; // st0 forwards to ld0 if the accesses in st4 and st1 don't overlap with; // ld0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:337,Security,access,accesses,337,"// From FirstStore to LastLoad neither of the elimination candidate loads; // should overlap with any of the stores.; //; // E.g.:; //; // st1 C[i]; // ld1 B[i] <-------,; // ld0 A[i] <----, | * LastLoad; // ... | |; // st2 E[i] | |; // st3 B[i+1] -- | -' * FirstStore; // st0 A[i+1] ---'; // st4 D[i]; //; // st0 forwards to ld0 if the accesses in st4 and st1 don't overlap with; // ld0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:160,Performance,load,load,160,"// We're looking for stores after the first forwarding store until the end; // of the loop, then from the beginning of the loop until the last; // forwarded-to load. Collect the pointer for the stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:41,Performance,load,loads,41,// Collect the pointers of the candidate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:4,Performance,Perform,Perform,4,/// Perform the transformation for a candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:18,Performance,load,load,18,"// loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:111,Performance,load,load,111,"// loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:198,Performance,load,load,198,"// loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:48,Performance,load,load,48,"/// Top-level driver for each loop: find store->load forwarding; /// candidates, add run-time checks and perform transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:105,Performance,perform,perform,105,"/// Top-level driver for each loop: find store->load forwarding; /// candidates, add run-time checks and perform transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:391,Integrability,depend,dependences,391,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:21,Performance,load,load,21,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:97,Performance,load,load,97,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:190,Performance,load,load,190,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:277,Performance,load,load,277,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:386,Performance,load,load,386,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:30,Performance,load,load,30,// Generate an index for each load and store according to the original; // program order. This will be used later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:57,Performance,load,load,57,"// To keep things simple for now, remove those where the load is potentially; // fed by multiple stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:18,Usability,simpl,simple,18,"// To keep things simple for now, remove those where the load is potentially; // fed by multiple stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:39,Availability,avail,available,39,// Make sure that the stored values is available everywhere in the loop in; // the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:10,Performance,load,load,10,// If the load is conditional we can't hoist its 0-iteration instance to; // the preheader because that would make it unconditional. Thus we would; // access a memory location that the original loop did not access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:151,Security,access,access,151,// If the load is conditional we can't hoist its 0-iteration instance to; // the preheader because that would make it unconditional. Thus we would; // access a memory location that the original loop did not access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:207,Security,access,access,207,// If the load is conditional we can't hoist its 0-iteration instance to; // the preheader because that would make it unconditional. Thus we would; // access a memory location that the original loop did not access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:84,Performance,load,load,84,"// Check whether the SCEV difference is the same as the induction step,; // thus we load the value in the next iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:69,Performance,load,load,69,"// Next, propagate the value stored by the store to the users of the load.; // Also for the first iteration, generate the initial value of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:143,Performance,load,load,143,"// Next, propagate the value stored by the store to the users of the load.; // Also for the first iteration, generate the initial value of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:13,Performance,load,load,13,/// Maps the load/store instructions to their index according to; /// program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:256,Performance,optimiz,optimizes,256,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:277,Performance,load,loads,277,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:54,Safety,avoid,avoid,54,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:103,Testability,log,logic,103,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:192,Usability,clear,clear,192,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:22,Performance,perform,performed,22,// The actual work is performed by LoadEliminationForLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:35,Performance,Load,LoadEliminationForLoop,35,// The actual work is performed by LoadEliminationForLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:91,Deployability,update,updates,91,/// Explicitly specialize the pass manager's run method to handle loop nest; /// structure updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:28,Safety,abort,abort,28,"// If the loop was deleted, abort the run and return to the outer walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager as each pass runs and potentially; // invalidates analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:167,Availability,failure,failures,167,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:91,Deployability,update,updater,91,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:157,Testability,assert,assertion,157,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:114,Usability,simpl,simply,114,// Run all loop passes on loop \p L. Loop-nest passes don't run either because; // \p L is not a top-level one or simply because there are no loop-nest passes; // in the pass manager at all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:28,Safety,abort,abort,28,"// If the loop was deleted, abort the run and return to the outer walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager as each pass runs and potentially; // invalidates analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:167,Availability,failure,failures,167,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:91,Deployability,update,updater,91,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:157,Testability,assert,assertion,157,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:85,Deployability,pipeline,pipeline,85,"// Before we even compute any loop analyses, first run a miniature function; // pass pipeline to put loops into their canonical form. Note that we can; // directly build up function analyses after this as the function pass; // manager handles all the invalidation at that layer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:96,Deployability,pipeline,pipeline,96,// Check the PassInstrumentation's BeforePass callbacks before running the; // canonicalization pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:206,Performance,cache,cached,206,// Setup the loop analysis manager from its proxy. It is important that; // this is only done when there are loops to process and we have built the; // LoopStandardAnalysisResults object. The loop analyses cached in this; // manager have access to those analysis results and so it must invalidate; // itself when they go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:238,Security,access,access,238,// Setup the loop analysis manager from its proxy. It is important that; // this is only done when there are loops to process and we have built the; // LoopStandardAnalysisResults object. The loop analyses cached in this; // manager have access to those analysis results and so it must invalidate; // itself when they go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:79,Deployability,update,update,79,// Register the worklist and loop analysis manager so that loop passes can; // update them when they mutate the loop nest structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:13,Deployability,update,update,13,// Reset the update structure for this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:34,Testability,assert,asserts,34,// Save a parent loop pointer for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:98,Integrability,contract,contract,98,"// We know that the loop pass couldn't have invalidated any other; // loop's analyses (that's the contract of a loop pass), so directly; // handle the loop analysis manager's invalidation here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1478,Modifiability,variab,variable,1478,"dening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1673,Modifiability,variab,variable,1673,"ard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step); //; // Informal proof that the transformation above is correct:; //; // By the definition of guards we can rewrite the guard condition to:; // G(I) && G(0) && M; //; // Let's prove that for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:2587,Modifiability,rewrite,rewrite,2587,"onic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step); //; // Informal proof that the transformation above is correct:; //; // By the definition of guards we can rewrite the guard condition to:; // G(I) && G(0) && M; //; // Let's prove that for each iteration of the loop:; // G(0) && M => G(I); // And the condition above can be simplified to G(Start) && M.; //; // Induction base.; // G(0) && M => G(0); //; // Induction step. Assuming G(0) && M => G(I) on the subsequent; // iteration:; //; // B(I) is true because it's the backedge condition.; // G(I) is true because the backedge is guarded by this condition.; //; // So M = forall X . (G(X) && B(X)) => G(X + Step) implies G(I + Step).; //; // Note that we can use anything stronger than M, i.e. any condition which; // implies M.; //; // When S = 1 (i.e. forward iterating loop), the transformation is supported; // when:; // * The loop has a single latch with the condition of the form:; // B(X) = latchStart + X <pred> latchLimit,; // where <pred> is u<, u<=, s<, or s<=.; // * The guard condition is of the form; // G(X) = guardStart + X u< guardLimit; //; // For the ult latch comparison case M is:; // forall X . guardStart + X u",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1299,Performance,optimiz,optimize,1299,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1369,Performance,optimiz,optimized,1369,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1344,Testability,log,logic,1344,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:2755,Usability,simpl,simplified,2755,"onic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step); //; // Informal proof that the transformation above is correct:; //; // By the definition of guards we can rewrite the guard condition to:; // G(I) && G(0) && M; //; // Let's prove that for each iteration of the loop:; // G(0) && M => G(I); // And the condition above can be simplified to G(Start) && M.; //; // Induction base.; // G(0) && M => G(0); //; // Induction step. Assuming G(0) && M => G(I) on the subsequent; // iteration:; //; // B(I) is true because it's the backedge condition.; // G(I) is true because the backedge is guarded by this condition.; //; // So M = forall X . (G(X) && B(X)) => G(X + Step) implies G(I + Step).; //; // Note that we can use anything stronger than M, i.e. any condition which; // implies M.; //; // When S = 1 (i.e. forward iterating loop), the transformation is supported; // when:; // * The loop has a single latch with the condition of the form:; // B(X) = latchStart + X <pred> latchLimit,; // where <pred> is u<, u<=, s<, or s<=.; // * The guard condition is of the form; // G(X) = guardStart + X u< guardLimit; //; // For the ult latch comparison case M is:; // forall X . guardStart + X u",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:28,Modifiability,variab,variable,28,"/// Represents an induction variable check:; /// icmp Pred, <induction variable>, <loop invariant limit>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:71,Modifiability,variab,variable,71,"/// Represents an induction variable check:; /// icmp Pred, <induction variable>, <loop invariant limit>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:55,Safety,safe,safe,55,"/// Return an insertion point suitable for inserting a safe to speculate; /// instruction whose only user will be 'User' which has operands 'Ops'. A; /// trivial result would be the at the User itself, but we try to return a; /// loop invariant location if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
