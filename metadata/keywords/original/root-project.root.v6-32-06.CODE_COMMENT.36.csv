id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:311,Performance,load,load,311,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:280,Usability,guid,guide,280,/// This function is called when we have proved that a SETCC node can be replaced; /// by subtraction (and other supporting instructions) so that the result of; /// comparison is kept in a GPR instead of CR. This function is purely for; /// codegen purposes and has some flags to guide the codegen process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Modifiability,extend,extend,8,"// Zero extend the operands to the largest legal integer. Originally, they; // must be of a strictly smaller size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Integrability,Depend,Depends,19,// Swap if needed. Depends on the condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,Modifiability,extend,extended,12,// Subtract extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Modifiability,extend,extend,25,// If all users of SETCC extend its value to a legal integer type; // then we replace SETCC with a subtraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Safety,abort,abort,84,// We have an input that is not an extension or another binary; // operation; we'll abort this transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:112,Security,validat,validate,112,"// Replace all operations (these are all the same, but have a different; // (i1) return type). DAG.getNode will validate that the types of; // a binary operator match, so go through the list in reverse so that; // we've likely promoted both operands first. Any intermediate truncations or; // extensions disappear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:413,Availability,mask,masking,413,"// If we're tracking CR bits, we need to be careful that we don't have:; // zext(binary-ops(trunc(x), trunc(y))); // or; // zext(binary-ops(binary-ops(trunc(x), trunc(y)), ...); // such that we're unnecessarily moving things into CR bits that can more; // efficiently stay in GPRs. Note that if we're not certain that the high; // bits are set as required by the final extension, we still may need to do; // some masking to get the proper behavior.; // This same functionality is important on PPC64 when dealing with; // 32-to-64-bit extensions; these occur often when 32-bit values are used as; // the return values of functions. Because it is so similar, it is handled; // here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:256,Energy Efficiency,efficient,efficiently,256,"// If we're tracking CR bits, we need to be careful that we don't have:; // zext(binary-ops(trunc(x), trunc(y))); // or; // zext(binary-ops(binary-ops(trunc(x), trunc(y)), ...); // such that we're unnecessarily moving things into CR bits that can more; // efficiently stay in GPRs. Note that if we're not certain that the high; // bits are set as required by the final extension, we still may need to do; // some masking to get the proper behavior.; // This same functionality is important on PPC64 when dealing with; // 32-to-64-bit extensions; these occur often when 32-bit values are used as; // the return values of functions. Because it is so similar, it is handled; // here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Safety,abort,abort,84,// We have an input that is not a truncation or another binary; // operation; we'll abort this transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:50,Modifiability,extend,extended,50,"// If all of the inputs are not already sign/zero extended, then; // we'll still need to do that at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Security,validat,validate,118,"// Replace all operations (these are all the same, but have a different; // (promoted) return type). DAG.getNode will validate that the types of; // a binary operator match, so go through the list in reverse so that; // we've likely promoted both operands first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Availability,mask,mask,24,"// To zero extend, just mask off everything except for the first bit (in the; // i1 case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Modifiability,extend,extend,11,"// To zero extend, just mask off everything except for the first bit (in the; // i1 case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Modifiability,extend,extending,14,// Is this an extending load from an f32 to an f64?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Performance,load,load,24,// Is this an extending load from an f32 to an f64?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:4,Energy Efficiency,Reduce,Reduces,4,"/// Reduces the number of fp-to-int conversion when building a vector.; ///; /// If this vector is built out of floating to integer conversions,; /// transform it to a vector built out of floating point values followed by a; /// single floating to integer conversion of the vector.; /// Namely (build_vector (fptosi $A), (fptosi $B), ...); /// becomes (fptosi (build_vector ($A, $B, ...)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:194,Modifiability,extend,extending,194,"// If we are converting to 32-bit integers, we need to add an FP_ROUND.; // This is not valid if the input was originally double precision. It is; // also not profitable to do unless this is an extending load in which; // case doing this combine will allow us to combine consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,Performance,load,load,204,"// If we are converting to 32-bit integers, we need to add an FP_ROUND.; // This is not valid if the input was originally double precision. It is; // also not profitable to do unless this is an extending load in which; // case doing this combine will allow us to combine consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:283,Performance,load,loads,283,"// If we are converting to 32-bit integers, we need to add an FP_ROUND.; // This is not valid if the input was originally double precision. It is; // also not profitable to do unless this is an extending load in which; // case doing this combine will allow us to combine consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Modifiability,extend,extending,107,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,Performance,load,loads,117,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Safety,safe,safe,134,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:4,Energy Efficiency,Reduce,Reduce,4,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,load,loads,25,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,Performance,load,loads,99,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,load,load,127,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:163,Performance,load,loads,163,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:193,Performance,load,loads,193,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Performance,load,loads,47,// Not a build vector of (possibly fp_rounded) loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Performance,load,loads,30,// We only care about regular loads. The PPC-specific load intrinsics; // will not lead to a merge opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:54,Performance,load,load,54,// We only care about regular loads. The PPC-specific load intrinsics; // will not lead to a merge opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Performance,load,loads,21,// Exit early if the loads are neither consecutive nor reverse consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:74,Modifiability,extend,extended,74,"// Look for build vector patterns where input operands come from sign; // extended vector_extract elements of specific indices. If the correct indices; // aren't used, add a vector shuffle to fix up the indices and create; // SIGN_EXTEND_INREG node which selects the vector sign extend instructions; // during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:279,Modifiability,extend,extend,279,"// Look for build vector patterns where input operands come from sign; // extended vector_extract elements of specific indices. If the correct indices; // aren't used, add a vector shuffle to fix up the indices and create; // SIGN_EXTEND_INREG node which selects the vector sign extend instructions; // during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:55,Modifiability,extend,extend,55,"// This array encodes the indices that the vector sign extend instructions; // extract from when extending from one type to another for both BE and LE.; // The right nibble of each byte corresponds to the LE incides.; // and the left nibble of each byte corresponds to the BE incides.; // For example: 0x3074B8FC byte->word; // For LE: the allowed indices are: 0x0,0x4,0x8,0xC; // For BE: the allowed indices are: 0x3,0x7,0xB,0xF; // For example: 0x000070F8 byte->double word; // For LE: the allowed indices are: 0x0,0x8; // For BE: the allowed indices are: 0x7,0xF",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Modifiability,extend,extending,97,"// This array encodes the indices that the vector sign extend instructions; // extract from when extending from one type to another for both BE and LE.; // The right nibble of each byte corresponds to the LE incides.; // and the left nibble of each byte corresponds to the BE incides.; // For example: 0x3074B8FC byte->word; // For LE: the allowed indices are: 0x0,0x4,0x8,0xC; // For BE: the allowed indices are: 0x3,0x7,0xB,0xF; // For example: 0x000070F8 byte->double word; // For LE: the allowed indices are: 0x0,0x8; // For BE: the allowed indices are: 0x7,0xF",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Modifiability,extend,extended,44,"// If the build vector operands aren't sign extended vector extracts,; // of the same input vector, then return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:189,Modifiability,extend,extending,189,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,load,load,29,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:199,Performance,load,load,199,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:236,Performance,Load,Load,236,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:79,Performance,load,load,79,// Proceed with the transformation if the operand to the BUILD_VECTOR; // is a load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:51,Performance,load,loading,51,"// This transformation is only valid if the we are loading either a byte,; // halfword, word, or doubleword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:60,Modifiability,extend,extended,60,// Ensure that the load from the narrow width is being zero extended to i128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Performance,load,load,19,// Ensure that the load from the narrow width is being zero extended to i128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Performance,load,loads,49,"// If we're building a vector out of consecutive loads, just load that; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:61,Performance,load,load,61,"// If we're building a vector out of consecutive loads, just load that; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Modifiability,extend,extended,37,// If we're building a vector out of extended elements from another vector; // we have P9 vector integer extend instructions. The code assumes legal; // input types (i.e. it can't handle things like v4i16) so do not run before; // legalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Modifiability,extend,extend,105,// If we're building a vector out of extended elements from another vector; // we have P9 vector integer extend instructions. The code assumes legal; // input types (i.e. it can't handle things like v4i16) so do not run before; // legalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Performance,Load,Load,19,"// On Power10, the Load VSX Vector Rightmost instructions can be utilized; // if this is a BUILD_VECTOR of v1i128, and if the operand to the BUILD_VECTOR; // is a load from <valid narrow width> to i128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:163,Performance,load,load,163,"// On Power10, the Load VSX Vector Rightmost instructions can be utilized; // if this is a BUILD_VECTOR of v1i128, and if the operand to the BUILD_VECTOR; // is a load from <valid narrow width> to i128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Modifiability,extend,extend,42,"// For signed conversion, we need to sign-extend the value in the VSR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:207,Modifiability,extend,extending,207,"// For i32 intermediate values, unfortunately, the conversion functions; // leave the upper 32 bits of the value are undefined. Within the set of; // scalar instructions, we have no method for zero- or sign-extending the; // value. Thus, we cannot handle i32 intermediate values here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:108,Performance,load,load,108,"// If we're converting from a float, to an int, and back to a float again,; // then we don't need the store/load pair at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,loads,36,// expandVSXLoadForLE - Convert VSX loads (which may be intrinsics for; // builtins) into loads with swaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,Performance,load,loads,90,// expandVSXLoadForLE - Convert VSX loads (which may be intrinsics for; // builtins) into loads with swaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Performance,load,load,13,// Delay VSX load for LE combine until after LegalizeOps to prioritize other; // load combines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:81,Performance,load,load,81,// Delay VSX load for LE combine until after LegalizeOps to prioritize other; // load combines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,load,36,"// If the MMO suggests this isn't a load of a full vector, leave; // things alone. For a built-in, we have to make the change for; // correctness, so if there is a size problem that will be a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,load,34,// Add a bitcast if the resulting load type doesn't match v2f64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:50,Performance,Load,Load,50,"// Package {bitcast value, swap's chain} to match Load's shape.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,perform,perform,8,// Only perform combine for conversion to i64/i32 or power9 i16/i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:65,Availability,Mask,Mask,65,// Check that the source of the element keeps flipping; // (i.e. Mask[i] < NumElts -> Mask[i+i] >= NumElts).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:86,Availability,Mask,Mask,86,// Check that the source of the element keeps flipping; // (i.e. Mask[i] < NumElts -> Mask[i+i] >= NumElts).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,"// Fix up the shuffle mask to account for the fact that the result of; // scalar_to_vector is not in lane zero. This just takes all values in; // the ranges specified by the min/max indices and adds the number of; // elements required to ensure each element comes from the respective; // position in the valid lane.; // On little endian, that's just the corresponding element in the other; // half of the vector. On big endian, it is in the same half but right; // justified rather than left justified in that half.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:206,Availability,mask,mask,206,"// Replace a SCALAR_TO_VECTOR with a SCALAR_TO_VECTOR_PERMUTED except if; // the original is:; // (<n x Ty> (scalar_to_vector (Ty (extract_elt <n x Ty> %a, C)))); // In such a case, just change the shuffle mask to extract the element; // from the permuted index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:420,Availability,mask,mask,420,"// On little endian subtargets, combine shuffles such as:; // vector_shuffle<16,1,17,3,18,5,19,7,20,9,21,11,22,13,23,15>, <zero>, %b; // into:; // vector_shuffle<16,0,17,1,18,2,19,3,20,4,21,5,22,6,23,7>, <zero>, %b; // because the latter can be matched to a single instruction merge.; // Furthermore, SCALAR_TO_VECTOR on little endian always involves a permute; // to put the value into element zero. Adjust the shuffle mask so that the; // vector can remain in permuted form (to prevent a swap prior to a shuffle).; // On big endian targets, this is still useful for SCALAR_TO_VECTOR; // nodes with elements smaller than doubleword because all the ways; // of getting scalar data into a vector register put the value in the; // rightmost element of the left half of the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,// Adjust the shuffle mask if either input vector comes from a; // SCALAR_TO_VECTOR and keep the respective input vector in permuted; // form (to prevent the need for a swap).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:299,Deployability,update,updated,299,"// FIXME: If both LHS and RHS are SCALAR_TO_VECTOR, but are not the; // same type and have differing element sizes, then do not perform; // the following transformation. The current transformation for; // SCALAR_TO_VECTOR assumes that both input vectors have the same; // element size. This will be updated in the future to account for; // differing sizes of the LHS and RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:128,Performance,perform,perform,128,"// FIXME: If both LHS and RHS are SCALAR_TO_VECTOR, but are not the; // same type and have differing element sizes, then do not perform; // the following transformation. The current transformation for; // SCALAR_TO_VECTOR assumes that both input vectors have the same; // element size. This will be updated in the future to account for; // differing sizes of the LHS and RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:218,Availability,mask,mask,218,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:303,Availability,mask,mask,303,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Usability,simpl,simplified,15,// We may have simplified away the shuffle. We won't be able to do anything; // further with it here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Availability,mask,mask,24,// We are looking for a mask such that all even elements are from; // one vector and all odd elements from the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Availability,mask,mask,14,// Adjust the mask so we are pulling in the same index from the splat; // as the index from the interesting vector in consecutive elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load,10,"// If the load return value 0 has more than one user except the; // shufflevector instruction, it is not profitable to replace the; // shufflevector with a reverse load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:164,Performance,load,load,164,"// If the load return value 0 has more than one user except the; // shufflevector instruction, it is not profitable to replace the; // shufflevector with a reverse load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Safety,avoid,avoided,62,"// If there are other uses of the shuffle, the swap cannot be avoided.; // Forcing the use of an X-Form (since swapped stores only have; // X-Forms) without removing the swap is unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Modifiability,extend,extend,191,"// We don't want (and (zext (shift...)), C) if C fits in the width of the; // original input as that will prevent us from selecting optimal rotates.; // This only matters if the input to the extend is i32 widened to i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Usability,simpl,simple,25,// STBRX can only handle simple types and it makes no sense to store less; // two bytes in byte-reversed order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Modifiability,extend,extend,13,// Do an any-extend to 32-bits if this is a half-word input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Modifiability,extend,extended,16,// Need to sign-extended to 64-bits to handle negative values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,Deployability,Update,UpdateNodeOperands,131,// DAG.getTruncStore() can't be used here because it doesn't accept; // the general (base + offset) addressing mode.; // So we use UpdateNodeOperands and setTruncatingStore instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Performance,load,loads,26,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,load,134,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:45,Performance,load,load,45,"// We sometimes end up with a 64-bit integer load, from which we extract; // two single-precision floating-point numbers. This happens with; // std::complex<float>, and other similar structures, because of the way we; // canonicalize structure copies. However, if we lack direct moves,; // then the final bitcasts from the extracted integer values to the; // floating-point numbers turn into store/load pairs. Even with direct moves,; // just loading the two floating-point numbers is likely better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:398,Performance,load,load,398,"// We sometimes end up with a 64-bit integer load, from which we extract; // two single-precision floating-point numbers. This happens with; // std::complex<float>, and other similar structures, because of the way we; // canonicalize structure copies. However, if we lack direct moves,; // then the final bitcasts from the extracted integer values to the; // floating-point numbers turn into store/load pairs. Even with direct moves,; // just loading the two floating-point numbers is likely better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:443,Performance,load,loading,443,"// We sometimes end up with a 64-bit integer load, from which we extract; // two single-precision floating-point numbers. This happens with; // std::complex<float>, and other similar structures, because of the way we; // canonicalize structure copies. However, if we lack direct moves,; // then the final bitcasts from the extracted integer values to the; // floating-point numbers turn into store/load pairs. Even with direct moves,; // just loading the two floating-point numbers is likely better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:61,Performance,load,load,61,"// We're looking for a sequence like this:; // t13: i64,ch = load<LD8[%ref.tmp]> t0, t6, undef:i64; // t16: i64 = srl t13, Constant:i32<32>; // t17: i32 = truncate t16; // t18: f32 = bitcast t17; // t19: i32 = truncate t13; // t20: f32 = bitcast t19",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Performance,load,load,57,// Note that DAGCombine should re-form any pre-increment load(s) from; // what is produced here if that makes sense.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,Performance,LOAD,LOAD,41,// P8 and later hardware should just use LOAD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Performance,load,load,42,// This is a type-legal unaligned Altivec load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:901,Availability,fault,fault,901,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,loading,23,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:350,Performance,load,loads,350,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:459,Performance,load,loads,459,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:626,Performance,load,loaded,626,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:676,Performance,load,load,676,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:784,Performance,load,load,784,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1110,Performance,load,loaded,1110,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1394,Performance,perform,perform,1394,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1411,Performance,optimiz,optimization,1411,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:888,Safety,avoid,avoid,888,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Performance,load,load,39,"// Create the new MMO for the new base load. It is like the original MMO,; // but represents an area in memory almost twice the vector size centered; // on the original address. If the address is unaligned, we might start; // reading up to (sizeof(vector)-1) bytes below the address of the; // original unaligned load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:313,Performance,load,load,313,"// Create the new MMO for the new base load. It is like the original MMO,; // but represents an area in memory almost twice the vector size centered; // on the original address. If the address is unaligned, we might start; // reading up to (sizeof(vector)-1) bytes below the address of the; // original unaligned load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,// Create the new base load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Performance,load,load,71,"// Note that the value of IncOffset (which is provided to the next; // load's pointer info offset value, and thus used to calculate the; // alignment), and the value of IncValue (which is actually used to; // increment the pointer value) are different! This is because we; // require the next load to appear to be aligned, even though it; // is actually offset from the base pointer by a lesser amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:293,Performance,load,load,293,"// Note that the value of IncOffset (which is provided to the next; // load's pointer info offset value, and thus used to calculate the; // alignment), and the value of IncValue (which is actually used to; // increment the pointer value) are different! This is because we; // require the next load to appear to be aligned, even though it; // is actually offset from the base pointer by a lesser amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Availability,down,down,21,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Performance,load,load,57,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:123,Performance,load,load,123,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:246,Performance,load,loads,246,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:108,Performance,load,loaded,108,"// second argument is 1 because this rounding; // is always exact.; // The output of the permutation is our loaded result, the TokenFactor is; // our new chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,Availability,down,down,92,"// Combine vmaxsw/h/b(a, a's negation) to abs(a); // Expose the vabsduw/h/b opportunity for down stream",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,Security,Expose,Expose,53,"// Combine vmaxsw/h/b(a, a's negation) to abs(a); // Expose the vabsduw/h/b opportunity for down stream",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Performance,load,loads,26,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,load,134,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Performance,LOAD,LOAD,15,"// Turn BSWAP (LOAD) -> lhbrx/lwbrx.; // For subtargets without LDBRX, we can still do better than the default; // expansion even for 64-bit BSWAP (LOAD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Performance,LOAD,LOAD,148,"// Turn BSWAP (LOAD) -> lhbrx/lwbrx.; // For subtargets without LDBRX, we can still do better than the default; // expansion even for 64-bit BSWAP (LOAD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:28,Performance,load,load,28,// Create the byte-swapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Performance,load,load,21,"// If this is an i16 load, insert the truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,Performance,load,load,75,"// First, combine the bswap away. This makes the value produced by the; // load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Performance,load,load,21,"// Next, combine the load away, we give it a bogus result value but a real; // chain result. The result value is dead because the bswap is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,loads,36,// Convert this to two 32-bit bswap loads and a BUILD_PAIR. Do this only; // before legalization so that the BUILD_PAIR is handled correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,loads,34,// Can't split volatile or atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Safety,safe,safe,56,"// If the user is a MFOCRF instruction, we know this is safe.; // Otherwise we give up for right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:240,Availability,down,down,240,"// If this is a branch on an altivec predicate comparison, lower this so; // that we don't have to do a MFOCRF: instead, branch directly on CR6. This; // lowering is done pre-legalize, because the legalizer lowers the predicate; // compare down to code that is difficult to reassemble.; // This code also handles branches that depend on the result of a store; // conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:327,Integrability,depend,depend,327,"// If this is a branch on an altivec predicate comparison, lower this so; // that we don't have to do a MFOCRF: instead, branch directly on CR6. This; // lowering is done pre-legalize, because the legalizer lowers the predicate; // compare down to code that is difficult to reassemble.; // This code also handles branches that depend on the result of a store; // conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Usability,clear,cleared,39,// lhbrx is known to have the top bits cleared out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Usability,clear,cleared,16,// Top bits are cleared for load2r (which is the same as lhbrx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:184,Integrability,depend,depend,184,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:103,Performance,cache,cache,103,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Safety,predict,prediction,127,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:226,Testability,log,logic,226,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,Performance,cache,cache,131,"// For small loops (between 5 and 8 instructions), align to a 32-byte; // boundary so that the entire loop fits in one instruction-cache line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Deployability,upgrade,upgrade,191,"// r[0-9]+ are used, on PPC64, to refer to the corresponding 64-bit registers; // (which we call X[0-9]+). If a 64-bit value has been requested, and a; // 32-bit GPR has been selected, then 'upgrade' it to the 64-bit parent; // register.; // FIXME: If TargetLowering::getRegForInlineAsmConstraint could somehow use; // the AsmName field from *RegisterInfo.td, then this would not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Energy Efficiency,power,power,47,"// ""N"" is a positive constant that is an exact power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:116,Performance,load,load,116,"// isLegalAddressingMode - Return true if the addressing mode represented; // by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Energy Efficiency,Power,PowerPC,148,"// Vector type r+i form is supported since power9 as DQ form. We don't check; // the offset matching DQ form requirement(off % 16 == 0), because on PowerPC,; // imm form is preferred and the offset can be adjusted to use imm form later; // in pass PPCLoopInstrFormPrep. Also in LSR, for one LSRUse, it uses min and; // max offset to check legal addressing mode, we should be a little aggressive; // to contain other offsets for that LSRUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Modifiability,extend,extended,21,// PPC allows a sign-extended 16-bit immediate field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:35,Performance,optimiz,optimize,35,// Make sure the function does not optimize away the store of the RA to; // the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Performance,load,load,153,// The link register (return address) is saved in the caller's frame; // not the callee's stack frame. So we must get the caller's frame; // address and load the return address at the LR offset from there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,load,load,8,// Just load the return address off the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Security,access,access,19,// 32-bit SVR4 ABI access everything as got-indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Security,access,accesses,7,"// AIX accesses everything indirectly through the TOC, which is similar to; // the GOT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,load,loading,84,"// If it is small or large code model, module locals are accessed; // indirectly by loading their address from .toc/.got.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Security,access,accessed,57,"// If it is small or large code model, module locals are accessed; // indirectly by loading their address from .toc/.got.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Security,access,accessed,34,// JumpTable and BlockAddress are accessed as got-indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Energy Efficiency,Power,PowerPC,7,// The PowerPC target isn't yet aware of offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Testability,log,logic,97,/// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:51,Availability,avail,available,51,"// We should use Altivec/VSX loads and stores when available. For unaligned; // addresses, unaligned VSX loads are only fast starting with the P8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,load,loads,29,"// We should use Altivec/VSX loads and stores when available. For unaligned; // addresses, unaligned VSX loads are only fast starting with the P8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Performance,load,loads,105,"// We should use Altivec/VSX loads and stores when available. For unaligned; // addresses, unaligned VSX loads are only fast starting with the P8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:138,Availability,mask,mask,138,"// FIXME: Add other cases...; // - 32-bit shifts with a zext to i64; // - zext after ctlz, bswap, etc.; // - zext after and by a constant mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Modifiability,Extend,Extending,3,// Extending to float128 is not free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:126,Energy Efficiency,efficient,efficient,126,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:193,Energy Efficiency,efficient,efficient,193,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Security,access,access,37,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:86,Security,access,accessing,86,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,Security,access,accessing,139,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:48,Usability,simpl,simple,48,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Energy Efficiency,Power,PowerPC,20,"// Don't break FMA, PowerPC prefers FMA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:179,Energy Efficiency,Power,PowerPC,179,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:91,Performance,load,load,91,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:188,Performance,load,loading,188,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:237,Performance,load,loading,237,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Performance,load,loads,11,"// For the loads that combineLoadToOperationType does nothing, like; // ordered load, it should be profitable to hoist them.; // For swifterror load, it can only be used for pointer to pointer type, so; // later type check should get rid of this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:80,Performance,load,load,80,"// For the loads that combineLoadToOperationType does nothing, like; // ordered load, it should be profitable to hoist them.; // For swifterror load, it can only be used for pointer to pointer type, so; // later type check should get rid of this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:144,Performance,load,load,144,"// For the loads that combineLoadToOperationType does nothing, like; // ordered load, it should be profitable to hoist them.; // For swifterror load, it can only be used for pointer to pointer type, so; // later type check should get rid of this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:198,Deployability,patch,patchpoints,198,"// LR is a callee-save register, but we must treat it as clobbered by any call; // site. Hence we include LR in the scratch registers, which are in turn added; // as implicit-defs for stackmaps and patchpoints. The same reasoning applies; // to CTR, which is used by any indirect call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Deployability,canary,canary,71,// Override to disable global variable loading on Linux and insert AIX canary; // word declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Modifiability,variab,variable,30,// Override to disable global variable loading on Linux and insert AIX canary; // word declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Performance,load,loading,39,// Override to disable global variable loading on Linux and insert AIX canary; // word declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,Modifiability,extend,extended,59,"// We can't save an operation here if the value is already extended, and; // the existing shift is easier to combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:213,Usability,simpl,simplified,213,"// Transform (add X, (zext(setne Z, C))) -> (addze X, (addic (addi Z, -C), -1)); // Transform (add X, (zext(sete Z, C))) -> (addze X, (subfic (addi Z, -C), 0)); // When C is zero, the equation (addi Z, -C) can be simplified to Z; // Requirement: -C in [-32768, 32767], X and Z are MVT::i64 types",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:89,Deployability,update,updated,89,// The new global address is a copy of the old global address except; // that it has the updated Offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect TRUNCATE operations on bitcasts of float128 values.; // What we are looking for here is the situtation where we extract a subset; // of bits from a 128 bit float.; // This can be of two forms:; // 1) BITCAST of f128 feeding TRUNCATE; // 2) BITCAST of f128 feeding SRL (a shift) feeding TRUNCATE; // The reason this is required is because we do not have a legal i128 type; // and so we want to prevent having to store the f128 and then reload part; // of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Update,Update,3,// Update Op0 past the SRL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Modifiability,enhance,enhance,9,// TODO: enhance the condition for subtarget before pwr8,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Availability,mask,mask,10,// If the mask is suitable for andi. or andis. we should sink the and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Availability,mask,masks,20,"// For non-constant masks, we can always use the record-form and.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:155,Performance,load,load,155,/// Set alignment flags based on whether or not the Frame Index is aligned.; /// Utilized when computing flags for address computation when selecting; /// load and store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Usability,clear,clear,114,"// If this is (add $FI, $S16Imm), the alignment flags are already set; // based on the immediate. We just need to clear the alignment flags; // if the FI alignment is weaker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,Performance,load,load,90,"/// Given a node, compute flags that are used for address computation when; /// selecting load and store instructions. The flags computed are stored in; /// FlagSet. This function takes into account whether the node is a constant,; /// an ADD, OR, or a constant, and computes the address flags accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:40,Integrability,depend,depending,40,// Set the alignment flags for the node depending on if the node is; // 4-byte or 16-byte aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Performance,load,load,105,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,load,load,29,"// If the node is the paired load/store intrinsics, compute flags for; // address computation and return early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:174,Performance,load,loads,174,"// For integers, no extension is the same as zero extension.; // We set the extension mode to zero extension so we don't have; // to add separate entries in AddrModesMap for loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,Energy Efficiency,reduce,reduce,143,"// If the address is the result of an add, we will utilize the fact that the; // address calculation includes an implicit add. However, we can reduce; // register pressure if we do not materialize a constant just for use as the; // index register. We only get rid of the add if it is not an add of a; // value and a 16-bit signed constant and both have a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Modifiability,extend,extend,125,"// If we are splitting a scalar integer into f64 parts (i.e. so they; // can be placed into VFRC registers), we need to zero extend and; // bitcast the values. This will ensure the value is placed into a; // VSR using direct moves or stack operations as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:95,Performance,load,load,95,"// If the address mode is DS-Form or DQ-Form, check if the FI is aligned.; // Select an X-Form load if it is not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:33,Integrability,depend,depending,33,// Set Base and Disp accordingly depending on the address mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:76,Performance,load,load-immediate-shifted,76,// This is a constant address at most 32 bits. The base will be; // zero or load-immediate-shifted and the displacement will be; // the low 16 bits of the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Availability,down,down,25,"// Otherwise, break this down into LIS + Disp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,Load,Load,46,"// Otherwise, the PPC:MOF_NotAdd flag is set. Load/Store is Non-foldable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,Availability,avail,available,32,"// By default, X-Form is always available to be selected.; // When a frame index is not aligned, we also match by XForm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:47,Integrability,Interface,Interface,47,"//===-- PPCISelLowering.h - PPC32 DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that PPC uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- PPCISelLowering.h - PPC32 DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that PPC uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:416,Performance,LOAD,LOAD,416,"// When adding a NEW PPCISD node please add it to the correct position in; // the enum. The order of elements in this enum matters!; // Values that are added after this entry:; // STBRX = ISD::FIRST_TARGET_MEMORY_OPCODE; // are considered memory opcodes and are treated differently than entries; // that come before it. For example, ADD or MUL should be placed before; // the ISD::FIRST_TARGET_MEMORY_OPCODE while a LOAD or STORE should come; // after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:97,Modifiability,extend,extended,97,"/// VEXTS, ByteWidth - takes an input in VSFRC and produces an output in; /// VSFRC that is sign-extended from ByteWidth to a 64-byte integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:4,Testability,Test,Test,4,/// Test instruction for software square root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:40,Performance,perform,performed,40,"/// To avoid stack clash, allocation is performed by block and each block is; /// probed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:7,Safety,avoid,avoid,7,"/// To avoid stack clash, allocation is performed by block and each block is; /// probed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:59,Modifiability,extend,extend-sign,59,"/// EXTSWSLI = The PPC extswsli instruction, which does an extend-sign; /// word and shift left immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:96,Energy Efficiency,power,power,96,"/// The combination of sra[wd]i and addze used to implemented signed; /// integer division by a power of 2. The first operand is the dividend,; /// and the second is the constant shift amount (representing the; /// divisor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:4,Energy Efficiency,Power,PowerPC,4,/// PowerPC instructions that have SCALAR_TO_VECTOR semantics tend to; /// place the value into the least significant element of the most; /// significant doubleword in the vector. This is not element zero for; /// anything smaller than a doubleword on either endianness. This node has; /// the same semantics as SCALAR_TO_VECTOR except that the value remains in; /// the aforementioned location in the vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:37,Deployability,Toggle,Toggle,37,"/// ch, gl = CR6[UN]SET ch, inglue - Toggle CR bit 6 for SVR4 vararg calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:176,Modifiability,variab,variable,176,"/// GPRC = TLSGD_AIX, TOC_ENTRY, TOC_ENTRY; /// G8RC = TLSGD_AIX, TOC_ENTRY, TOC_ENTRY; /// Op that combines two register copies of TOC entries; /// (region handle into R3 and variable offset into R4) followed by a; /// GET_TLS_ADDR node which will be expanded to a call to __get_tls_addr.; /// This node is used in 64-bit mode as well (in which case the result is; /// G8RC and inputs are X3/X4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:104,Performance,optimiz,optimize,104,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:205,Performance,optimiz,optimizations,205,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:181,Safety,avoid,avoid,181,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:49,Deployability,rolling,rolling,49,/// CHAIN = CLRBHRB CHAIN - Clear branch history rolling buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:28,Usability,Clear,Clear,28,/// CHAIN = CLRBHRB CHAIN - Clear branch history rolling buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:78,Deployability,rolling,rolling,78,"/// GPRC, CHAIN = MFBHRBE CHAIN, Entry, Dummy - Move from branch; /// history rolling buffer entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:220,Performance,load,load,220,"/// VSRC, CHAIN = XXSWAPD CHAIN, VSRC - Occurs only for little; /// endian. Maps to an xxswapd instruction that corrects an lxvd2x; /// or stxvd2x instruction. The chain is necessary because the; /// sequence replaces a load and needs to provide the same number; /// of outputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:57,Performance,load,loads,57,/// An SDNode for swaps that are not associated with any loads/stores; /// and thereby have no chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:41,Modifiability,extend,extend,41,"/// FP_EXTEND_HALF(VECTOR, IDX) - Custom extend upper (IDX=0) half or; /// lower (IDX=1) half of v4f32 to v2f64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:136,Performance,load,load,136,/// MAT_PCREL_ADDR = Materialize a PC Relative address. This can be done; /// either through an add like PADDI or through a PC Relative load like; /// PLD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:114,Security,access,access,114,/// TLS_DYNAMIC_MAT_PCREL_ADDR = Materialize a PC Relative address for; /// TLS global address when using dynamic access models. This can be done; /// through an add like PADDI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:158,Availability,avail,available,158,"/// TLS_LOCAL_EXEC_MAT_ADDR = Materialize an address for TLS global address; /// when using local exec access models, and when prefixed instructions are; /// available. This is used with ADD_TLS to produce an add like PADDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:103,Security,access,access,103,"/// TLS_LOCAL_EXEC_MAT_ADDR = Materialize an address for TLS global address; /// when using local exec access models, and when prefixed instructions are; /// available. This is used with ADD_TLS to produce an add like PADDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:246,Testability,test,tests,246,"// NOTE: The nodes below may require PC-Rel specific patterns if the; // address could be PC-Relative. When adding new nodes below, consider; // whether or not the address can be PC-Relative and add the corresponding; // PC-relative patterns and tests.; /// CHAIN = STBRX CHAIN, GPRC, Ptr, Type - This is a; /// byte-swapping store instruction. It byte-swaps the low ""Type"" bits of; /// the GPRC input, then stores it through Ptr. Type can be either i16 or; /// i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:71,Performance,load,load,71,"/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a; /// byte-swapping load instruction. It loads ""Type"" bits, byte swaps it,; /// then puts it in the bottom bits of the GPRC. TYPE can be either i16; /// or i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:92,Performance,load,loads,92,"/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a; /// byte-swapping load instruction. It loads ""Type"" bits, byte swaps it,; /// then puts it in the bottom bits of the GPRC. TYPE can be either i16; /// or i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:84,Modifiability,extend,extends,84,"/// GPRC, CHAIN = LFIWAX CHAIN, Ptr - This is a floating-point; /// load which sign-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:68,Performance,load,load,68,"/// GPRC, CHAIN = LFIWAX CHAIN, Ptr - This is a floating-point; /// load which sign-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:84,Modifiability,extend,extends,84,"/// GPRC, CHAIN = LFIWZX CHAIN, Ptr - This is a floating-point; /// load which zero-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:68,Performance,load,load,68,"/// GPRC, CHAIN = LFIWZX CHAIN, Ptr - This is a floating-point; /// load which zero-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:137,Modifiability,extend,extended,137,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:60,Performance,load,load,60,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:184,Performance,load,loaded,184,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:48,Modifiability,Extend,Extend,48,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:111,Modifiability,extend,extending,111,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:13,Performance,Load,Load,13,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:121,Performance,load,load,121,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:226,Performance,Load,Load,226,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:132,Integrability,depend,depending,132,"/// VSRC, CHAIN = LOAD_VEC_BE CHAIN, Ptr - Occurs only for little endian.; /// Maps directly to one of lxvd2x/lxvw4x/lxvh8x/lxvb16x depending on; /// the vector type to load vector in big-endian element order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:169,Performance,load,load,169,"/// VSRC, CHAIN = LOAD_VEC_BE CHAIN, Ptr - Occurs only for little endian.; /// Maps directly to one of lxvd2x/lxvw4x/lxvh8x/lxvb16x depending on; /// the vector type to load vector in big-endian element order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:66,Performance,load,load,66,"/// VSRC, CHAIN = LD_VSX_LH CHAIN, Ptr - This is a floating-point load of a; /// v2f32 value into the lower half of a VSR register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:53,Performance,load,load,53,"/// VSRC, CHAIN = LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// instructions such as LXVDSX, LXVWSX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:85,Modifiability,extend,extends,85,"/// VSRC, CHAIN = ZEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that zero-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Performance,load,load,58,"/// VSRC, CHAIN = ZEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that zero-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:85,Modifiability,extend,extends,85,"/// VSRC, CHAIN = SEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that sign-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Performance,load,load,58,"/// VSRC, CHAIN = SEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that sign-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:137,Integrability,depend,depending,137,"/// CHAIN = STORE_VEC_BE CHAIN, VSRC, Ptr - Occurs only for little endian.; /// Maps directly to one of stxvd2x/stxvw4x/stxvh8x/stxvb16x depending on; /// the vector type to store vector in big-endian element order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:124,Modifiability,extend,extended,124,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:190,Modifiability,extend,extend,190,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:179,Performance,load,loads,179,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:34,Performance,Load,Loads,34,"/// GPRC = TOC_ENTRY GA, TOC; /// Loads the entry for GA from the TOC, where the TOC base is given by; /// the last operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,Availability,mask,mask,62,/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUHUM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,Availability,mask,mask,62,/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUWUM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,Availability,mask,mask,62,/// isVPKUDUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUDUM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,"/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for; /// a VRGL* instruction with the specified unit size (1,2 or 4 bytes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,"/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for; /// a VRGH* instruction with the specified unit size (1,2 or 4 bytes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:59,Availability,mask,mask,59,/// isVMRGEOShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGEW or VMRGOW instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:60,Availability,mask,mask,60,/// isXXSLDWIShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXSLDWI instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRHShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRH instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRWShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRW instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRDShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRD instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRQShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRQ instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:61,Availability,mask,mask,61,/// isXXPERMDIShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXPERMDI instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:54,Availability,mask,mask,54,"/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the; /// shift amount, otherwise return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:55,Performance,load,loads,55,// Flags for computing the optimal addressing mode for loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:30,Performance,load,loads,30,// Extension mode for integer loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:14,Modifiability,variab,variables,14,// Sum of two variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:5,Usability,simpl,simple,5,// A simple 32-bit constant.; // The in-memory type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:28,Performance,load,loads,28,// The addressing modes for loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not support scalar condition selects on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:442,Modifiability,extend,extending,442,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:365,Performance,load,load,365,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:457,Performance,load,loads,457,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:24,Performance,scalab,scalable,24,// Default handling for scalable and single-element vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:194,Performance,load,load,194,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:96,Energy Efficiency,efficient,efficiently,96,"/// SelectAddressEVXRegReg - Given the specified addressed, check to see if; /// it can be more efficiently represented as [r+imm].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:93,Energy Efficiency,efficient,efficiently,93,"/// SelectAddressRegReg - Given the specified addressed, check to see if it; /// can be more efficiently represented as [r+imm]. If \p EncodingAlignment; /// is non-zero, only accept displacement which is not suitable for [r+imm].; /// Returns false if it can be represented by [r+imm], which are preferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:174,Testability,log,logarithm,174,"/// getByValTypeAlignment - Return the desired alignment for ByVal aggregate; /// function arguments in the caller parameter area. This is the actual; /// alignment, not its logarithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:21,Performance,load,load,21,// Only handle float load/store pair because float(fpr) load/store; // instruction has more cycles than integer(gpr) load/store in PPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:56,Performance,load,load,56,// Only handle float load/store pair because float(fpr) load/store; // instruction has more cycles than integer(gpr) load/store in PPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:117,Performance,load,load,117,// Only handle float load/store pair because float(fpr) load/store; // instruction has more cycles than integer(gpr) load/store in PPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:97,Testability,log,logic,97,/// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:24,Security,access,access,24,"/// Is unaligned memory access allowed for the given type, and is it fast; /// relative to software emulation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:214,Energy Efficiency,Power,Powerpc,214,"/// isProfitableToHoist - Check if it is profitable to hoist instruction; /// \p I to its dominator block.; /// For example, it is not profitable if \p I and it's only user can form a; /// FMA instruction, because Powerpc prefers FMADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:199,Availability,avail,available,199,"// We support any array type as ""consecutive"" block in the parameter; // save area. The element type defines the alignment requirement and; // whether the argument should go in GPRs, FPRs, or VRs if available.; //; // Note that clang uses this capability both to implement the ELFv2; // homogeneous float/vector aggregate ABI, and to avoid having to use; // ""byval"" when passing aggregates that might fully fit in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:334,Safety,avoid,avoid,334,"// We support any array type as ""consecutive"" block in the parameter; // save area. The element type defines the alignment requirement and; // whether the argument should go in GPRs, FPRs, or VRs if available.; //; // Note that clang uses this capability both to implement the ELFv2; // homogeneous float/vector aggregate ABI, and to avoid having to use; // ""byval"" when passing aggregates that might fully fit in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:47,Performance,load,loading,47,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:207,Performance,perform,performance,207,/// ConvertSETCCToSubtract - looks at SETCC that compares ints. It replaces; /// SETCC with integer subtraction when (1) there is a legal way of doing it; /// (2) keeping the result of comparison in GPR has performance benefit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Performance,optimiz,optimized,58,"// Return whether the call instruction can potentially be optimized to a; // tail call. This will cause the optimizers to attempt to move, or; // duplicate return instructions to help enable tail call optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:108,Performance,optimiz,optimizers,108,"// Return whether the call instruction can potentially be optimized to a; // tail call. This will cause the optimizers to attempt to move, or; // duplicate return instructions to help enable tail call optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:201,Performance,optimiz,optimizations,201,"// Return whether the call instruction can potentially be optimized to a; // tail call. This will cause the optimizers to attempt to move, or; // duplicate return instructions to help enable tail call optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:105,Performance,load,load,105,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.; /// The address flags are stored in a map, which is then searched; /// through to determine the optimal load/store instruction format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:256,Performance,load,load,256,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.; /// The address flags are stored in a map, which is then searched; /// through to determine the optimal load/store instruction format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:543,Deployability,update,update,543,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1278,Deployability,update,update,1278,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1357,Deployability,update,update,1357,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1723,Energy Efficiency,reduce,reduce,1723,"ated for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offset; //; // for (int i = 0; i < n; i++); // unsigned long x1 = *(unsigned long *)(A1 + i);; // unsigned long x2 = *(unsigned long *)(A2 + i); // unsigned long x3 = *(unsigned long *)(B1 + i);; // unsigned long x4 = *(unsigned long *)(B2 + i);; // }; //; // to look like this:; //; // A1_new = p + base1 // chain 1; // B1_new = p + base2 // chain 2, now inside the loop, common offset is; // // reused.; //; // for (long long i = 0; i < n; i+=count) {; // unsigned lon",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:602,Modifiability,variab,variables,602,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:620,Performance,load,load,620,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:743,Performance,load,load,743,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1310,Performance,load,load,1310,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1639,Performance,load,load,1639,"ated for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offset; //; // for (int i = 0; i < n; i++); // unsigned long x1 = *(unsigned long *)(A1 + i);; // unsigned long x2 = *(unsigned long *)(A2 + i); // unsigned long x3 = *(unsigned long *)(B1 + i);; // unsigned long x4 = *(unsigned long *)(B2 + i);; // }; //; // to look like this:; //; // A1_new = p + base1 // chain 1; // B1_new = p + base2 // chain 2, now inside the loop, common offset is; // // reused.; //; // for (long long i = 0; i < n; i+=count) {; // unsigned lon",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:24,Energy Efficiency,reduce,reduce,24,"// Commoning chain will reduce the register pressure, so we don't consider about; // the PHI nodes number.; // But commoning chain will increase the addi/add number in the loop and also; // increase loop ILP. Maximum chain number should be same with hardware; // IssueWidth, because we won't benefit from ILP if the parallel chains number; // is bigger than IssueWidth. We assume there are 2 chains in one bucket, so; // there would be 4 buckets at most on P9(IssueWidth is 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:62,Performance,load,load,62,"// If would not be profitable if the common base has only one load/store, ISEL; // should already be able to choose best load/store form based on offset for; // single load/store. Set minimal profitable value default to 2 and make it as; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:121,Performance,load,load,121,"// If would not be profitable if the common base has only one load/store, ISEL; // should already be able to choose best load/store form based on offset for; // single load/store. Set minimal profitable value default to 2 and make it as; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:168,Performance,load,load,168,"// If would not be profitable if the common base has only one load/store, ISEL; // should already be able to choose best load/store form based on offset for; // single load/store. Set minimal profitable value default to 2 and make it as; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Deployability,Update,UpdateForm,4,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:92,Deployability,update,update,92,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:76,Performance,load,load,76,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:38,Deployability,Update,Update,38,"/// Successful preparation number for Update/DS/DQ form in all inner most; /// loops. One successful preparation will put one common base out of loop,; /// this may leads to register presure like LICM does.; /// Make sure total preparation number can be controlled by option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:49,Energy Efficiency,reduce,reduce,49,/// Common chains to reuse offsets for a loop to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite load/store according to the common chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:12,Performance,load,load,12,/// Rewrite load/store according to the common chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:45,Deployability,update,update,45,/// Prepare all candidates in \p Buckets for update form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:78,Deployability,update,update,78,"/// Prepare for one chain \p BucketChain, find the best base element and; /// update all other elements in \p BucketChain accordingly.; /// \p Form is used to find the best base element.; /// If success, best base element must be stored as the first element of; /// \p BucketChain.; /// Return false if no base element found, otherwise return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:78,Deployability,update,update,78,"/// Prepare for one chain \p BucketChain, find the best base element and; /// update all other elements in \p BucketChain accordingly.; /// If success, best base element must be stored as the first element of; /// \p BucketChain.; /// Return false if no base element found, otherwise return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite load/store instructions in \p BucketChain according to; /// preparation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:12,Performance,load,load,12,/// Rewrite load/store instructions in \p BucketChain according to; /// preparation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite for the base load/store of a chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:25,Performance,load,load,25,/// Rewrite for the base load/store of a chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite for the other load/stores of a chain according to the new \p; /// Base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:26,Performance,load,load,26,/// Rewrite for the other load/stores of a chain according to the new \p; /// Base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:235,Energy Efficiency,power,powerful,235,"// Finding the minimal(chain_number + reusable_offset_number) is a complicated; // algorithmic problem.; // For now, the algorithm used here is simply adjusted to handle the case for; // manually unrolling cases.; // FIXME: use a more powerful algorithm to find minimal sum of chain_number and; // reusable_offset_number for one base with multiple offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:144,Usability,simpl,simply,144,"// Finding the minimal(chain_number + reusable_offset_number) is a complicated; // algorithmic problem.; // For now, the algorithm used here is simply adjusted to handle the case for; // manually unrolling cases.; // FIXME: use a more powerful algorithm to find minimal sum of chain_number and; // reusable_offset_number for one base with multiple offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:6,Usability,simpl,simply,6,// We simply select the FirstOffset as the first reusable offset between each; // chain element 1 and element 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:13,Modifiability,rewrite,rewriter,13,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:60,Modifiability,rewrite,rewriter,60,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:22,Performance,cache,cache,22,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:71,Performance,cache,cache,71,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:134,Performance,cache,cache,134,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:115,Testability,Assert,AssertingVH,115,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Usability,Clear,Clear,3,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:345,Modifiability,rewrite,rewrite,345,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:458,Modifiability,rewrite,rewrite,458,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:359,Performance,load,load,359,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:476,Performance,load,load,476,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:266,Performance,load,load,266,"// RemainderOffsetInfo details:; // key: value of (Offset urem DispConstraint). For DSForm, it can; // be [0, 4).; // first of pair: the index of first BucketElement whose remainder is equal; // to key. For key 0, this value must be 0.; // second of pair: number of load/stores with the same remainder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:91,Performance,load,load,91,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:182,Performance,load,load,182,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:320,Performance,load,load,320,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:369,Performance,load,load,369,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:411,Performance,load,load,411,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:525,Performance,load,load,525,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:590,Performance,load,load,590,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Safety,Abort,Abort,3,// Abort when there are too few insts with common base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:10,Performance,load,load,10,// Adjust load/store to the new chosen base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:96,Performance,load,load,96,"// FIXME: implement a more clever base choosing policy.; // Currently we always choose an exist load/store offset. This maybe lead to; // suboptimal code sequences. For example, for one DS chain with offsets; // {-32769, 2003, 2007, 2011}, we choose -32769 as base offset, and left disp; // for load/stores are {0, 34772, 34776, 34780}. Though each offset now is a; // multipler of 4, it cannot be represented by sint16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:295,Performance,load,load,295,"// FIXME: implement a more clever base choosing policy.; // Currently we always choose an exist load/store offset. This maybe lead to; // suboptimal code sequences. For example, for one DS chain with offsets; // {-32769, 2003, 2007, 2011}, we choose -32769 as base offset, and left disp; // for load/stores are {0, 34772, 34776, 34780}. Though each offset now is a; // multipler of 4, it cannot be represented by sint16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:63,Deployability,update,update,63,"// For some DS form load/store instructions, it can also be an update form,; // if the stride is constant and is a multipler of 4. Use update form if; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:135,Deployability,update,update,135,"// For some DS form load/store instructions, it can also be an update form,; // if the stride is constant and is a multipler of 4. Use update form if; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:20,Performance,load,load,20,"// For some DS form load/store instructions, it can also be an update form,; // if the stride is constant and is a multipler of 4. Use update form if; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:13,Modifiability,rewrite,rewriter,13,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:60,Modifiability,rewrite,rewriter,60,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:22,Performance,cache,cache,22,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:71,Performance,cache,cache,71,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:134,Performance,cache,cache,134,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:115,Testability,Assert,AssertingVH,115,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Usability,Clear,Clear,3,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:29,Deployability,update,update,29,// Check if a load/store has update form. This lambda is used by function; // collectCandidates which can collect candidates for types defined by lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,// Check if a load/store has update form. This lambda is used by function; // collectCandidates which can collect candidates for types defined by lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:16,Deployability,update,update,16,// There are no update forms for Altivec vector load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:48,Performance,load,load,48,// There are no update forms for Altivec vector load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:16,Deployability,update,update,16,// There are no update forms for P10 lxvp/stxvp intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:110,Performance,load,loads,110,"// See getPreIndexedAddressParts, the displacement for LDU/STDU has to; // be 4's multiple (DS-form). For i64 loads/stores when the displacement; // fits in a 16-bit signed field but isn't a multiple of 4, it will be; // useless and possible to break some original well-form addressing mode; // to make this pre-inc prep for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,// Check if a load/store has DS form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,// Check if a load/store has DQ form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:30,Performance,load,load,30,// Check if it is a P9 vector load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,"// Check if a load/store is candidate for chain commoning.; // If the SCEV is only with one ptr operand in its start, we can use that; // start as a chain separator. Mark this load/store as a candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:176,Performance,load,load,176,"// Check if a load/store is candidate for chain commoning.; // If the SCEV is only with one ptr operand in its start, we can use that; // start as a chain separator. Mark this load/store as a candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:58,Deployability,update,update,58,// Check if the diff is a constant type. This is used for update/DS/DQ form; // preparation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:72,Deployability,update,update,72,// Collect buckets of comparable addresses used by loads and stores for update; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,// Collect buckets of comparable addresses used by loads and stores for update; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:15,Deployability,update,update,15,// Prepare for update form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,// Collect buckets of comparable addresses used by loads and stores for DS; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,// Collect buckets of comparable addresses used by loads and stores for DQ; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:189,Energy Efficiency,reduce,reduced,189,"// Collect buckets of comparable addresses used by loads and stores for chain; // commoning. With chain commoning, we reuse offsets between the chains, so; // the register pressure will be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,"// Collect buckets of comparable addresses used by loads and stores for chain; // commoning. With chain commoning, we reuse offsets between the chains, so; // the register pressure will be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:450,Energy Efficiency,Power,PowerPC,450,"//===-- PPCLowerMASSVEntries.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements lowering of MASSV (SIMD) entries for specific PowerPC; // subtargets.; // Following is an example of a conversion specific to Power9 subtarget:; // __sind2_massv ---> __sind2_P9; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:63,Energy Efficiency,Power,PowerPC,63,"// FIXME:; /// Returns a string corresponding to the specified PowerPC subtarget. e.g.:; /// ""_P8"" for Power8, ""_P9"" for Power9. The string is used as a suffix while; /// generating subtarget-specific MASSV library functions. Current support; /// includes minimum subtarget Power8 for Linux and Power7 for AIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:12,Energy Efficiency,Power,PowerPC,12,"/// Creates PowerPC subtarget-specific name corresponding to the specified; /// generic MASSV function, and the PowerPC subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:112,Energy Efficiency,Power,PowerPC,112,"/// Creates PowerPC subtarget-specific name corresponding to the specified; /// generic MASSV function, and the PowerPC subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:196,Deployability,update,updated,196,/// Lowers generic MASSV entries to PowerPC subtarget-specific MASSV entries.; /// e.g.: __sind2_massv --> __sind2_P9 for a Power9 subtarget.; /// Both function prototypes and their callsites are updated during lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:36,Energy Efficiency,Power,PowerPC,36,/// Lowers generic MASSV entries to PowerPC subtarget-specific MASSV entries.; /// e.g.: __sind2_massv --> __sind2_P9 for a Power9 subtarget.; /// Both function prototypes and their callsites are updated during lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.cpp:59,Energy Efficiency,Power,PowerPC,59,"//===-- PPCMachineFunctionInfo.cpp - Private data used for PowerPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:57,Energy Efficiency,Power,PowerPC,57,"//===-- PPCMachineFunctionInfo.h - Private data used for PowerPC --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of MachineFunctionInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCMachineFunctionInfo.h - Private data used for PowerPC --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of MachineFunctionInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:78,Energy Efficiency,Power,PowerPC,78,/// PPCFunctionInfo - This class is derived from MachineFunction private; /// PowerPC target-specific information for each MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:41,Security,Hash,Hash,41,/// Frame index where the ROP Protection Hash is stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:58,Performance,perform,performed,58,/// MustSaveTOC - Indicates that the TOC save needs to be performed in the; /// prologue of the function. This is typically the case when there are; /// indirect calls in the function and it is more profitable to save the; /// TOC pointer in the prologue than in the block(s) containing the call(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:33,Integrability,wrap,wrapping,33,/// Do we have to disable shrink-wrapping? This has to be set if we emit any; /// instructions that clobber LR in the entry block because discovering this; /// in PEI is too late (happens after shrink-wrapping);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:201,Integrability,wrap,wrapping,201,/// Do we have to disable shrink-wrapping? This has to be set if we emit any; /// instructions that clobber LR in the entry block because discovering this; /// in PEI is too late (happens after shrink-wrapping);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:101,Performance,optimiz,optimization,101,/// We keep track attributes for each live-in virtual registers; /// to use SExt/ZExt flags in later optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:38,Integrability,wrap,wrap,38,"/// We certainly don't want to shrink wrap functions if we've emitted a; /// MovePCtoLR8 as that has to go into the entry, so the prologue definitely; /// has to go into the entry block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:89,Modifiability,extend,extended,89,/// This function returns true if the specified vreg is; /// a live-in register and sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:89,Modifiability,extend,extended,89,/// This function returns true if the specified vreg is; /// a live-in register and zero-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:36,Energy Efficiency,Schedul,Scheduler,36,"//===- PPCMachineScheduler.cpp - MI Scheduler for PowerPC -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:50,Energy Efficiency,Power,PowerPC,50,"//===- PPCMachineScheduler.cpp - MI Scheduler for PowerPC -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid exceeding the target's limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:53,Energy Efficiency,schedul,scheduled,53,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:118,Usability,simpl,simply,118,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:232,Usability,clear,clear,232,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:57,Energy Efficiency,schedul,schedule,57,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:74,Performance,latency,latency,74,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:46,Availability,down,downstream,46,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:94,Energy Efficiency,reduce,reduce,94,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:291,Energy Efficiency,schedul,scheduler,291,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:70,Performance,optimiz,optimizations,70,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:191,Performance,Optimiz,Optimizations,191,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:225,Performance,load,loads,225,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:323,Performance,load,loads,323,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max pressure of the entire region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:34,Integrability,depend,dependence,34,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:26,Performance,latency,latency,26,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:89,Performance,latency,latency,89,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:46,Energy Efficiency,power,powerpc,46,// GenericScheduler::tryCandidate end; // Add powerpc specific heuristic only when TryCand isn't selected or; // selected as node order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,Energy Efficiency,schedul,schedule,30,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:113,Integrability,depend,dependency,113,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:59,Performance,load,load,59,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:80,Performance,latency,latency,80,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:136,Performance,load,load,136,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:34,Integrability,depend,dependence,34,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:26,Performance,latency,latency,26,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:50,Energy Efficiency,power,powerpc,50,// PostGenericScheduler::tryCandidate end; // Add powerpc post ra specific heuristic only when TryCand isn't selected or; // selected as node order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,Energy Efficiency,schedul,schedule,30,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:233,Performance,perform,performance,233,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:84,Safety,avoid,avoid,84,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,Energy Efficiency,schedul,scheduling,30,// Custom PPC PostRA specific scheduling here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:38,Energy Efficiency,Power,PowerPC,38,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:49,Energy Efficiency,schedul,scheduler,49,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:386,Energy Efficiency,Power,PowerPC,386,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:397,Energy Efficiency,schedul,scheduler,397,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:46,Energy Efficiency,Power,PowerPC,46,/// A MachineSchedStrategy implementation for PowerPC pre RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:61,Energy Efficiency,schedul,scheduling,61,/// A MachineSchedStrategy implementation for PowerPC pre RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:46,Energy Efficiency,Power,PowerPC,46,/// A MachineSchedStrategy implementation for PowerPC post RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:62,Energy Efficiency,schedul,scheduling,62,/// A MachineSchedStrategy implementation for PowerPC post RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:28,Energy Efficiency,Power,PowerPC,28,"//===- PPCMacroFusion.cpp - PowerPC Macro Fusion --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:413,Energy Efficiency,Power,PowerPC,413,"//===- PPCMacroFusion.cpp - PowerPC Macro Fusion --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:447,Energy Efficiency,schedul,scheduling,447,"//===- PPCMacroFusion.cpp - PowerPC Macro Fusion --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:41,Integrability,depend,dependent,41,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:17,Performance,load,load,17,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:82,Performance,load,load,82,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:65,Performance,load,load,65,"// If si = 1111111111110000 and the msb of the d/ds field of the load equals; // 1, then fusion does not occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:31,Safety,avoid,avoid,31,// We use the PPC namespace to avoid the need to prefix opcodes with PPC:: in; // the def file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h:26,Energy Efficiency,Power,PowerPC,26,"//===- PPCMacroFusion.h - PowerPC Macro Fusion ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC definition of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h:413,Energy Efficiency,Power,PowerPC,413,"//===- PPCMacroFusion.h - PowerPC Macro Fusion ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC definition of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h:443,Energy Efficiency,schedul,scheduling,443,"//===- PPCMacroFusion.h - PowerPC Macro Fusion ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC definition of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:488,Energy Efficiency,reduce,reduce,488,"//===-- PPCMergeStringPool.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation tries to merge the strings in the module into one pool; // of strings. The idea is to reduce the number of TOC entries in the module so; // that instead of having one TOC entry for each string there is only one global; // TOC entry and all of the strings are referenced off of that one entry plus; // an offset.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:29,Modifiability,Variab,Variables,29,// Combine all of the Global Variables marked as used into a SmallPtrSet for; // faster lookup inside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:187,Deployability,patch,patch,187,// TODO: At this point do not allow over-aligned types. Adding a type; // with larger alignment may lose the larger alignment once it is; // added to the struct.; // Fix this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:49,Energy Efficiency,efficient,efficient,49,// Sort the global constants to make access more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:37,Security,access,access,37,// Sort the global constants to make access more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:151,Performance,perform,performance,151,"// Use an anonymous struct to pool the strings.; // TODO: This pass uses a single anonymous struct for all of the pooled; // entries. This may cause a performance issue in the situation where; // computing the offset requires two instructions (addis, addi). For the; // future we may want to split this into multiple structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:3,Security,Access,Access,3,// Access to the pooled constant strings require an offset. Add a GEP; // before every use in order to compute this offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:1106,Availability,error,errors,1106,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:1137,Integrability,contract,contract,1137,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:391,Performance,perform,performs,391,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:409,Performance,optimiz,optimizations,409,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:816,Performance,optimiz,optimization,816,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:995,Testability,Assert,Asserts,995,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,// Perform peepholes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,// Perform peepholes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:301,Usability,simpl,simply,301,"// A number of transformations will eliminate the definition of a register; // as all of its uses will be removed. However, this leaves a register; // without a definition for LiveVariables. Such transformations should; // use this function to provide a dummy definition of the register that; // will simply be removed by DCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:227,Availability,redundant,redundant,227,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:354,Integrability,depend,depending,354,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:227,Safety,redund,redundant,227,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:74,Availability,redundant,redundant,74,"// If new instruction dominates an existing one, mark existing one as; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:74,Safety,redund,redundant,74,"// If new instruction dominates an existing one, mark existing one as; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:35,Availability,redundant,redundant,35,// Check if the new instruction is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:35,Safety,redund,redundant,35,// Check if the new instruction is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,Performance,perform,perform,100,"// This function returns a list of all PHI nodes in the tree starting from; // the RootPHI node. We perform a BFS traversal to get an ordered list of nodes.; // The list initially only contains the root PHI. When we visit a PHI node, we; // add it to the list. We continue to look for other PHI node operands while; // there are nodes to visit in the list. The function returns false if the; // optimization cannot be applied on this tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:395,Performance,optimiz,optimization,395,"// This function returns a list of all PHI nodes in the tree starting from; // the RootPHI node. We perform a BFS traversal to get an ordered list of nodes.; // The list initially only contains the root PHI. When we visit a PHI node, we; // add it to the list. We continue to look for other PHI node operands while; // there are nodes to visit in the list. The function returns false if the; // optimization cannot be applied on this tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:9,Safety,detect,detect,9,"// If we detect a cycle in the PHI nodes, we exit. It would be; // possible to change cycles as well, but that would add a lot; // of complexity for a case that is unlikely to occur with MMA; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,// Perform peephole optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:20,Performance,optimiz,optimizations,20,// Perform peephole optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:57,Performance,load,load-immediate,57,"// Fixed-point conversion of reg/reg instructions fed by load-immediate; // into reg/imm instructions. FIXME: This is expensive, control it with; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:7,Deployability,update,updated,7,// The updated instruction may now have new register operands.; // Conservatively add them to recompute the flags as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:132,Deployability,update,update,132,"// Since we are deleting this instruction, we need to run LiveVariables; // on any of its definitions that are marked as needing an update since; // we can't run LiveVariables on a deleted register. This only needs; // to be done for defs since uses will have their own defining; // instructions so we won't be running LiveVariables on a deleted reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:110,Safety,safe,safely,110,"// If some transformation has introduced an additional definition of; // this register (breaking SSA), we can safely convert this def to; // a def of an invalid register as the instruction is going away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:41,Performance,optimiz,optimized,41,"// If a conditional trap instruction got optimized to an; // unconditional trap, eliminate all the instructions after; // the trap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:370,Safety,detect,detect,370,"// We are copying an unprimed accumulator to a primed accumulator.; // If the input to the copy is a PHI that is fed only by (i) copies in; // the other direction (ii) implicitly defined unprimed accumulators or; // (iii) other PHI nodes satisfying (i) and (ii), we can change; // the PHI to a PHI on primed accumulators (as long as we also change; // its operands). To detect and change such copies, we first get a list; // of all the PHI nodes starting from the root PHI node in BFS order.; // We then visit all these PHI nodes to check if they can be changed to; // primed accumulator PHI nodes and if so, we change them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:151,Availability,redundant,redundant,151,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:50,Deployability,Update,UpdateTOCSaves,50,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:151,Safety,redund,redundant,151,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,"// Perform simplifications of 2x64 vector swaps and splats.; // A swap is identified by an immediate value of 2, and a splat; // is identified by an immediate value of 0 or 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:11,Usability,simpl,simplifications,11,"// Perform simplifications of 2x64 vector swaps and splats.; // A swap is identified by an immediate value of 2, and a splat; // is identified by an immediate value of 0 or 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:21,Usability,simpl,simplifications,21,"// For each of these simplifications, we need the two source; // regs to match. Unfortunately, MachineCSE ignores COPY and; // SUBREG_TO_REG, so for example we can see; // XXPERMDI t, SUBREG_TO_REG(s), SUBREG_TO_REG(s), immed.; // We have to look through chains of COPY and SUBREG_TO_REG; // to find the real source values for comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:64,Availability,redundant,redundant,64,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:41,Performance,load,load,41,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:205,Performance,load,load,205,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:64,Safety,redund,redundant,64,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:44,Usability,simpl,simplify,44,"// If this is a splat fed by a swap, we can simplify modify; // the splat to splat the other value from the swap's input; // parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Availability,redundant,redundant,94,"// If the instruction[s] that feed this splat have already splat; // the value, this splat is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Safety,redund,redundant,94,"// If the instruction[s] that feed this splat have already splat; // the value, this splat is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:62,Availability,redundant,redundant,62,"// If this is a DP->SP conversion fed by an FRSP, the FRSP is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:62,Safety,redund,redundant,62,"// If this is a DP->SP conversion fed by an FRSP, the FRSP is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:152,Performance,perform,performs,152,"// If the input to XVCVDPSP is a vector that was built (even; // partially) out of FRSP's, the FRSP(s) can safely be removed; // since this instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:107,Safety,safe,safely,107,"// If the input to XVCVDPSP is a vector that was built (even; // partially) out of FRSP's, the FRSP(s) can safely be removed; // since this instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:24,Modifiability,extend,extending,24,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:57,Modifiability,extend,extend,57,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:84,Modifiability,extend,extending,84,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:34,Performance,load,load,34,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Performance,load,load,94,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:78,Availability,Alive,AliveBlocks,78,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:144,Availability,Alive,AliveBlocks,144,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:160,Deployability,update,updated,160,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:24,Modifiability,extend,extending,24,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:57,Modifiability,extend,extend,57,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:84,Modifiability,extend,extending,84,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:34,Performance,load,load,34,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Performance,load,load,94,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:34,Modifiability,extend,extending,34,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:59,Modifiability,extend,extending,59,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:44,Performance,load,load,44,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:73,Performance,load,load,73,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:196,Performance,perform,perform,196,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:78,Availability,Alive,AliveBlocks,78,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:144,Availability,Alive,AliveBlocks,144,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:160,Deployability,update,updated,160,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:71,Modifiability,extend,extended,71,// We can eliminate EXTSW if the input is known to be already; // sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:72,Usability,clear,clear,72,"// We can eliminate RLDICL (e.g. for zero-extension); // if all bits to clear are already zero in the input.; // This code assume following code sequence for zero-extension.; // %6 = COPY %5:sub_32; (optional); // %8 = IMPLICIT_DEF;; // %7<def,tied1> = INSERT_SUBREG %8<tied0>, %6, sub_32;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:97,Performance,load,load,97,"// TODO: Any instruction that has an immediate form fed only by a PHI; // whose operands are all load immediate can be folded away. We currently; // do this for ADD instructions, but should expand it to arithmetic and; // binary instructions with immediate forms in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:50,Usability,clear,clear,50,// We can eliminate RLDICL/RLDICR if it's used to clear bits and all; // bits cleared will be ANDed with 0 by ANDI_rec/ANDIS_rec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:78,Usability,clear,cleared,78,// We can eliminate RLDICL/RLDICR if it's used to clear bits and all; // bits cleared will be ANDed with 0 by ANDI_rec/ANDIS_rec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:22,Performance,optimiz,optimization,22,// We can only do the optimization if we can get immediates; // from both operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:53,Availability,redundant,redundant,53,// Eliminate all the TOC save instructions which are redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:53,Safety,redund,redundant,53,// Eliminate all the TOC save instructions which are redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:23,Availability,redundant,redundant,23,// We try to eliminate redundant compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:23,Safety,redund,redundant,23,// We try to eliminate redundant compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:110,Deployability,update,update,110,"// If we have made any modifications and added any registers to the set of; // registers for which we need to update the kill flags, do so by recomputing; // LiveVariables for those registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:37,Safety,avoid,avoid,37,// We track through PHI only once to avoid infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:147,Deployability,pipeline,pipeline,147,"// We optimize BBs ending with a conditional branch.; // We check only for BCC here, not BCCLR, because BCCLR; // will be formed only later in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:6,Performance,optimiz,optimize,6,"// We optimize BBs ending with a conditional branch.; // We check only for BCC here, not BCCLR, because BCCLR; // will be formed only later in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:6,Performance,optimiz,optimize,6,// We optimize only if the condition code is used only by one BCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:207,Safety,avoid,avoid,207,"// If this BB has more than one successor, we can create a new BB and; // move the compare instruction in the new BB.; // So far, we do not move compare instruction to a BB having multiple; // successors to avoid potentially increasing code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:26,Availability,redundant,redundant,26,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:26,Safety,redund,redundant,26,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:105,Safety,avoid,avoid,105,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:134,Availability,avail,available,134,"// Here, Pred2MBB is the BB to which we need to append a compare inst.; // We cannot move the compare instruction if operands are not available; // in Pred2MBB (i.e. defined in MBB by an instruction other than PHI).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:167,Availability,redundant,redundant,167,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:256,Availability,redundant,redundant,256,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:167,Safety,redund,redundant,167,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:256,Safety,redund,redundant,256,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,Availability,redundant,redundant,13,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:369,Availability,redundant,redundant,369,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:596,Availability,redundant,redundant,596,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:762,Availability,redundant,redundant,762,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:787,Availability,redundant,redundant,787,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:80,Performance,optimiz,optimization,80,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,Safety,redund,redundant,13,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:369,Safety,redund,redundant,369,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:596,Safety,redund,redundant,596,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:762,Safety,redund,redundant,762,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:787,Safety,redund,redundant,787,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,Performance,optimiz,optimize,13,// We cannot optimize an unsupported compare opcode or; // a mix of 32-bit and 64-bit comparisons,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:217,Performance,optimiz,optimize,217,"// Typically, unsigned comparison is used for equality check, but; // we replace it with a signed comparison if the comparison; // to be merged is a signed comparison.; // In other cases of opcode mismatch, we cannot optimize this.; // We cannot change opcode when comparing against an immediate; // if the most significant bit of the immediate is one; // due to the difference in sign extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:22,Safety,redund,redundancy,22,"// In case of partial redundancy, we need to swap operands; // in another compare instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,Availability,redundant,redundant,100,// We touch up the compare instruction in MBB2 and move it to; // a previous BB to handle partially redundant case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,Safety,redund,redundant,100,// We touch up the compare instruction in MBB2 and move it to; // a previous BB to handle partially redundant case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:136,Modifiability,variab,variables,136,"// We finally eliminate compare instruction in MBB2.; // We do not need to treat CMPI2 specially here in terms of re-computing; // live variables even though it is being deleted because:; // - It defines a register that has a single use (already checked in; // eligibleForCompareElimination()); // - The only user (BI2) is no longer using it so the register is dead (no; // def, no uses); // - We do not attempt to recompute live variables for dead registers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:430,Modifiability,variab,variables,430,"// We finally eliminate compare instruction in MBB2.; // We do not need to treat CMPI2 specially here in terms of re-computing; // live variables even though it is being deleted because:; // - It defines a register that has a single use (already checked in; // eligibleForCompareElimination()); // - The only user (BI2) is no longer using it so the register is dead (no; // def, no uses); // - We do not attempt to recompute live variables for dead registers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:137,Usability,clear,clear,137,"// We miss the opportunity to emit an RLDIC when lowering jump tables; // since ISEL sees only a single basic block. When selecting, the clear; // and shift left will be in different blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:12,Usability,clear,cleared,12,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:61,Usability,clear,cleared,61,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:130,Usability,clear,cleared,130,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:196,Usability,clear,cleared,196,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:39,Safety,safe,safe,39,// If SrcReg has no non-debug use it's safe to delete its def SrcMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:351,Performance,optimiz,optimization,351,"// For case in LLVM IR; // entry:; // %iconv = sext i32 %index to i64; // br i1 undef label %true, label %false; // true:; // %ptr = getelementptr inbounds i32, i32* null, i64 %iconv; // ...; // PPCISelLowering::combineSHL fails to combine, because sext and shl are in; // different BBs when conducting instruction selection. We can do a peephole; // optimization to combine these two instructions into extswsli after; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:54,Performance,optimiz,optimizations,54,"//===--------- PPCPreEmitPeephole.cpp - Late peephole optimizations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pre-emit peephole for catching opportunities introduced by late passes such; // as MachineBlockPlacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:29,Availability,redundant,redundant,29,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:340,Availability,redundant,redundant,340,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:262,Deployability,update,update,262,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:39,Performance,load,load,39,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:110,Performance,load,load,110,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:29,Safety,redund,redundant,29,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:174,Safety,redund,redundancy,174,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:247,Safety,redund,redundancy,247,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:340,Safety,redund,redundant,340,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:8,Performance,load,load,8,// Skip load immediate that is marked to be erased later because it; // cannot be used to replace any other instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:12,Performance,load,load,12,// Skip non-load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:8,Performance,load,load,8,"// Skip load immediate, where the operand is a relocation (e.g., $r3 =; // LI target-flags(ppc-lo) %const.0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,Availability,redundant,redundant,69,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:79,Performance,load,load,79,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,Safety,redund,redundant,69,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:108,Availability,redundant,redundant,108,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:118,Performance,load,load,118,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:108,Safety,redund,redundant,108,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:17,Usability,clear,clear,17,"// We can't just clear implicit kills, so if we encounter one, stop; // looking further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:55,Performance,load,load,55,// Finish scanning because Reg is overwritten by a non-load; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:59,Availability,redundant,redundant,59,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:124,Modifiability,extend,extend,124,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:6,Performance,load,loads,6,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:59,Safety,redund,redundant,59,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:176,Safety,redund,redundancy,176,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:75,Security,access,access,75,// Check if this instruction is a PLDpc that is part of a GOT indirect; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:63,Security,access,access,63,// Struct to keep track of one def/use pair for a GOT indirect access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:113,Security,access,access,113,// Run through all of the instructions in the basic block and try to; // collect potential pairs of GOT indirect access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:37,Performance,load,load,37,// Look for the initial GOT indirect load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:7,Performance,load,load,7,// The load/store instruction that uses the address from the PLD will; // either use a register (for a store) or define a register (for the; // load). That register will be added as an implicit def to the PLD; // and as an implicit use on the second memory op. This is a precaution; // to prevent future passes from using that register between the two; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:144,Performance,load,load,144,// The load/store instruction that uses the address from the PLD will; // either use a register (for a store) or define a register (for the; // load). That register will be added as an implicit def to the PLD; // and as an implicit use on the second memory op. This is a precaution; // to prevent future passes from using that register between the two; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:25,Availability,redundant,redundant,25,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:393,Availability,redundant,redundant,393,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:25,Safety,redund,redundant,25,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:393,Safety,redund,redundant,393,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,Performance,load,load,69,"// If the user wants to set the DSCR using command-line options,; // load in the specified value at the start of main.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:15,Availability,mask,mask,15,// 25-bit DSCR mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:330,Testability,log,logic,330,"// Insert Point; // Copy the 32-bit DSCRValue integer into the GPR InDSCR using LIS and; // ORI, then move to DSCR. If the requested DSCR value is contained; // in a 16-bit signed number, we can emit a single `LI`, but the; // impact of saving one instruction in one function does not warrant; // any additional complexity in the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:3,Safety,Detect,Detect,3,// Detect self copies - these can result from running AADB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:540,Deployability,pipeline,pipeline,540,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:36,Energy Efficiency,Reduce,Reduce,36,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:400,Energy Efficiency,reduce,reduce,400,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:510,Performance,latency,latency,510,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:707,Performance,latency,latency,707,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:50,Testability,Log,Logical,50,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:421,Testability,log,logical,421,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:730,Testability,log,logical,730,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:260,Deployability,update,updated,260,"/// Given a basic block \p Successor that potentially contains PHIs, this; /// function will look for any incoming values in the PHIs that are supposed to; /// be coming from \p OrigMBB but whose definition is actually in \p NewMBB.; /// Any such PHIs will be updated to reflect reality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:114,Deployability,update,updated,114,"// If any of the PHIs in the successors of NewMBB reference values that; // now come from NewMBB, they need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:15,Testability,log,logical,15,"/// Given a CR logical operation \p CROp, branch opcode \p BROp as well as; /// a flag to indicate if the first operand of \p CROp is used as the; /// SplitBefore operand, determines whether either of the branches are to be; /// inverted as well as whether the new target should be the original; /// fall-through block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:209,Usability,clear,clearer,209,"// The conditions under which each of the output operands should be [un]set; // can certainly be written much more concisely with just 3 if statements or; // ternary expressions. However, this provides a much clearer overview to the; // reader as to what is set for each <CROp, BROp, OpUsed> combination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:34,Testability,log,logical,34,// A vector to contain all the CR logical operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:46,Testability,log,logical,46,// We now know whether all the uses of the CR logical are in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:55,Testability,log,logical,55,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:105,Testability,log,logical,105,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:173,Testability,log,logical,173,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:270,Testability,log,logical,270,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:284,Usability,simpl,simply,284,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:38,Testability,log,logical,38,"/// Splits a block that contains a CR-logical operation that feeds a branch; /// and whose operands are produced within the block.; /// Example:; /// %vr5<def> = CMPDI %vr2, 0; CRRC:%vr5 G8RC:%vr2; /// %vr6<def> = COPY %vr5:sub_eq; CRBITRC:%vr6 CRRC:%vr5; /// %vr7<def> = CMPDI %vr3, 0; CRRC:%vr7 G8RC:%vr3; /// %vr8<def> = COPY %vr7:sub_eq; CRBITRC:%vr8 CRRC:%vr7; /// %vr9<def> = CROR %vr6<kill>, %vr8<kill>; CRBITRC:%vr9,%vr6,%vr8; /// BC %vr9<kill>, <BB#2>; CRBITRC:%vr9; /// Becomes:; /// %vr5<def> = CMPDI %vr2, 0; CRRC:%vr5 G8RC:%vr2; /// %vr6<def> = COPY %vr5:sub_eq; CRBITRC:%vr6 CRRC:%vr5; /// BC %vr6<kill>, <BB#2>; CRBITRC:%vr6; ///; /// %vr7<def> = CMPDI %vr3, 0; CRRC:%vr7 G8RC:%vr3; /// %vr8<def> = COPY %vr7:sub_eq; CRBITRC:%vr8 CRRC:%vr7; /// BC %vr9<kill>, <BB#2>; CRBITRC:%vr9",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:100,Testability,log,logical,100,// We want the new block to have no code in it other than the definition; // of the input to the CR logical and the CR logical itself. So we move; // those to the bottom of the block (just before the branch). Then we; // will split before the CR logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:119,Testability,log,logical,119,// We want the new block to have no code in it other than the definition; // of the input to the CR logical and the CR logical itself. So we move; // those to the bottom of the block (just before the branch). Then we; // will split before the CR logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:246,Testability,log,logical,246,// We want the new block to have no code in it other than the definition; // of the input to the CR logical and the CR logical itself. So we move; // those to the bottom of the block (just before the branch). Then we; // will split before the CR logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:26,Testability,log,logical,26,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:54,Testability,log,logical,54,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:91,Testability,log,logical,91,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:112,Usability,usab,usable,112,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:30,Energy Efficiency,Power,PowerPC,30,"//===-- PPCRegisterInfo.cpp - PowerPC Register Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCRegisterInfo.cpp - PowerPC Register Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:157,Performance,perform,performance-sensitive,157,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:85,Safety,avoid,avoided,85,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:291,Safety,detect,detect,291,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:165,Performance,load,loads,165,"// We only reserve r2 if we need to use the TOC pointer. If we have no; // explicit uses of the TOC pointer (meaning we're a leaf function with; // no constant-pool loads, etc.) and we have no potential uses inside an; // inline asm block, then we can treat r2 has an ordinary callee-saved; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:75,Energy Efficiency,allocate,allocate,75,"// System-reserved register; // On PPC64, r13 is the thread pointer. Never allocate this register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:70,Safety,safe,safety,70,// If the callee saved info is invalid we have to default to true for safety.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:119,Performance,load,load,119,// The callee saved info is valid so it can be traversed.; // Checking for registers that need saving that do not have load or store; // forms where the address offset is an immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:128,Modifiability,variab,variable,128,// Do not use virtual base registers when ROP protection is turned on.; // Virtual base registers break the layout of the local variable space and may; // push the ROP Hash location past the 512 byte range of the ROP store; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:168,Security,Hash,Hash,168,// Do not use virtual base registers when ROP protection is turned on.; // Virtual base registers break the layout of the local variable space and may; // push the ROP Hash location past the 512 byte range of the ROP store; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:245,Security,access,access,245,"// X2/R2 is guaranteed to be preserved within a function if it is reserved.; // The reason it's reserved is that it's the TOC pointer (and the function; // uses the TOC). In functions where it isn't reserved (i.e. leaf functions; // with no TOC access), we can't claim that it is preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:126,Energy Efficiency,Power,Power,126,// Don't use the allocation hints for ISAFuture.; // The WACC registers used in ISAFuture are unlike the ACC registers on; // Power 10 and so this logic to register allocation hints does not apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:147,Testability,log,logic,147,// Don't use the allocation hints for ISAFuture.; // The WACC registers used in ISAFuture are unlike the ACC registers on; // Power 10 and so this logic to register allocation hints does not apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:142,Energy Efficiency,allocate,allocate,142,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:258,Energy Efficiency,allocate,allocate,258,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:98,Usability,simpl,simply,98,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:216,Deployability,patch,patch,216,"// With VSX, we can inflate various sub-register classes to the full VSX; // register set.; // For Power9 we allow the user to enable GPR to vector spills.; // FIXME: Currently limited to spilling GP8RC. A follow on patch will add; // support to spill GPRC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:455,Deployability,update,update,455,"//===----------------------------------------------------------------------===//; // Stack Frame Processing methods; //===----------------------------------------------------------------------===//; /// lowerDynamicAlloc - Generate the code for allocating an object in the; /// current frame. The sequence of code will be in the general form; ///; /// addi R0, SP, \#frameSize ; get the address of the previous frame; /// stwxu R0, SP, Rnegsize ; add and update the SP with the negated size; /// addi Rnew, SP, \#maxCalFrameSize ; get the top of the allocation; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:22,Deployability,update,update,22,"// Grow the stack and update the stack pointer link, then determine the; // address of new allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:91,Energy Efficiency,allocate,allocated,91,"// Grow the stack and update the stack pointer link, then determine the; // address of new allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:130,Performance,load,load,130,"// Determine the previous frame's address. If FrameSize can't be; // represented as 16 bits or we need special alignment, then we load the; // previous frame's address from 0(SP). Why not do an addis of the hi?; // Because R0 is our only safe tmp register and addi/addis treat R0 as zero.; // Constructing the constant and adding would take 3 instructions.; // Fortunately, a frame greater than 32K is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:238,Safety,safe,safe,238,"// Determine the previous frame's address. If FrameSize can't be; // represented as 16 bits or we need special alignment, then we load the; // previous frame's address from 0(SP). Why not do an addis of the hi?; // Because R0 is our only safe tmp register and addi/addis treat R0 as zero.; // Constructing the constant and adding would take 3 instructions.; // Fortunately, a frame greater than 32K is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:22,Energy Efficiency,allocate,allocate,22,// RegAllocator might allocate FramePointer and NegSizeReg in the same phyreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:132,Safety,avoid,avoid,132,"// FramePointer is clobbered earlier than the use of NegSizeReg in; // prepareDynamicAlloca, save NegSizeReg in ActualNegSizeReg to avoid; // misuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:23,Deployability,update,updated,23,// NegSizeReg might be updated in prepareDynamicAlloca if MaxAlign >; // TargetAlign.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:163,Testability,log,logical,163,"// We need to move the CR field that contains the CR bit we are spilling.; // The super register may not be explicitly defined (i.e. it can be defined; // by a CR-logical that only defines the subreg) so we state that the CR; // field is undef. Also, in order to preserve the kill flag on the CR bit,; // we add it as an implicit use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:106,Availability,Mask,Mask,106,"// If the saved register wasn't CR0LT, shift the bits left so that the bit; // to store is the first one. Mask all but that bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:27,Integrability,depend,dependency,27,// Make sure we have a use dependency all the way through this; // sequence of instructions. We can't have the other bits in the CR; // modified in between the mfocrf and the mtocrf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:227,Usability,simpl,simply,227,"/// lowerACCSpilling - Generate the code for spilling the accumulator register.; /// Similarly to other spills/reloads that use pseudo-ops, we do not actually; /// eliminate the FrameIndex here nor compute the stack offset. We simply; /// create a real instruction with an FI and rely on eliminateFrameIndex to; /// handle the FI elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:14,Performance,load,loads,14,// Create two loads for the pair subregisters accounting for endianness and; // then prime the accumulator register being restored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:133,Safety,safe,safely,133,"// If we can, encode the offset directly into the instruction. If this is a; // normal PPC ""ri"" instruction, any 16-bit value can be safely encoded. If; // this is a PPC64 ""ix"" instruction, only a 16-bit value with the low two bits; // clear can be encoded. This is extremely uncommon, because normally you; // only ""std"" to a stack slot that is at least 4-byte aligned, but it can; // happen in invalid code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:236,Usability,clear,clear,236,"// If we can, encode the offset directly into the instruction. If this is a; // normal PPC ""ri"" instruction, any 16-bit value can be safely encoded. If; // this is a PPC64 ""ix"" instruction, only a 16-bit value with the low two bits; // clear can be encoded. This is extremely uncommon, because normally you; // only ""std"" to a stack slot that is at least 4-byte aligned, but it can; // happen in invalid code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:83,Security,access,access,83,"// Since these are not real X-Form instructions, we must; // add the registers and access 0(NewReg) rather than; // emitting the X-Form pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:12,Performance,load,load,12,"// It's the load/store FI references that cause issues, as it can be difficult; // to materialize the offset if it won't fit in the literal field. Estimate; // based on the size of the local frame and some conservative assumptions; // about the rest of the stack frame (note, this is pre-regalloc, so; // we don't know everything for certain yet) whether this offset is likely; // to be out of range of the immediate. Return true if so.; // We only generate virtual base registers for loads and stores that have; // an r+i form. Return false for everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:485,Performance,load,loads,485,"// It's the load/store FI references that cause issues, as it can be difficult; // to materialize the offset if it won't fit in the literal field. Estimate; // based on the size of the local frame and some conservative assumptions; // about the rest of the stack frame (note, this is pre-regalloc, so; // we don't know everything for certain yet) whether this offset is likely; // to be out of range of the immediate. Return true if so.; // We only generate virtual base registers for loads and stores that have; // an r+i form. Return false for everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:138,Security,access,access,138,"// Estimate an offset from the stack pointer.; // The incoming offset is relating to the SP at the start of the function,; // but when we access the local it'll be relative to the SP after local; // allocation, so adjust our SP-relative offset by that allocation size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:28,Energy Efficiency,Power,PowerPC,28,"//===-- PPCRegisterInfo.h - PowerPC Register Information Impl ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCRegisterInfo.h - PowerPC Register Information Impl ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:60,Performance,load,load,60,/// getMappedIdxOpcForImmOpc - Return the mapped index form load/store opcode; /// for a given imm form load/store opcode \p ImmFormOpcode.; /// FIXME: move this to PPCInstrInfo class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:104,Performance,load,load,104,/// getMappedIdxOpcForImmOpc - Return the mapped index form load/store opcode; /// for a given imm form load/store opcode \p ImmFormOpcode.; /// FIXME: move this to PPCInstrInfo class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:8,Energy Efficiency,Power,PowerPCSubtarget,8,"//===-- PowerPCSubtarget.cpp - PPC Subtarget Information ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PPC specific subclass of TargetSubtargetInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:24,Energy Efficiency,schedul,schedule,24,// Determine the CPU to schedule for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:48,Energy Efficiency,schedul,scheduling,48,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:90,Energy Efficiency,schedul,schedule,90,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:206,Energy Efficiency,schedul,scheduling,206,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:255,Energy Efficiency,schedul,schedule,255,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:282,Performance,perform,performance,282,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCSubtarget.h - Define Subtarget for the PPC ----------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of TargetSubtargetInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:65,Performance,Tune,TuneCPU,65,"/// initializeSubtargetDependencies - Initializes using a CPU, a TuneCPU, and; /// feature string so that we can use initializer lists for subtarget; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:4,Energy Efficiency,Schedul,Scheduling,4,/// Scheduling customization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:4,Deployability,Pipeline,Pipeliner,4,/// Pipeliner customization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:12,Deployability,Pipeline,Pipeliner,12,/// Machine Pipeliner customization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:27,Security,access,accessed,27,/// True if the GV will be accessed via an indirect symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:56,Energy Efficiency,Power,PowerPC,56,"//===-- PPCTargetMachine.cpp - Define TargetMachine for PowerPC -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Top-level implementation for the PowerPC target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:416,Energy Efficiency,Power,PowerPC,416,"//===-- PPCTargetMachine.cpp - Define TargetMachine for PowerPC -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Top-level implementation for the PowerPC target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:92,Integrability,depend,depends,92,"// If the target ABI uses function descriptors, then the alignment of function; // pointers depends on the alignment used to emit the descriptor. Otherwise,; // function pointers are aligned to 32 bits because the instructions must be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:33,Availability,avail,available,33,// Make sure 64-bit features are available when CPUname is generic,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:90,Deployability,Pipeline,Pipeline,90,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:99,Deployability,Configurat,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:99,Modifiability,Config,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:28,Deployability,Configurat,Configuration,28,/// PPC Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:28,Modifiability,Config,Configuration,28,/// PPC Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:58,Energy Efficiency,Schedul,Scheduler,58,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:105,Energy Efficiency,Schedul,Scheduler,105,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:10,Performance,optimiz,optimization,10,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:35,Energy Efficiency,Power,PowerPC,35,// Lower generic MASSV routines to PowerPC subtarget-specific entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:23,Integrability,rout,routines,23,// Lower generic MASSV routines to PowerPC subtarget-specific entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:83,Availability,avail,available,83,// Generate PowerPC target-specific entries for scalar math functions; // that are available in IBM MASS (scalar) library.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:12,Energy Efficiency,Power,PowerPC,12,// Generate PowerPC target-specific entries for scalar math functions; // that are available in IBM MASS (scalar) library.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of cr-logical ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:27,Testability,log,logical,27,// Reduce the number of cr-logical ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:37,Performance,perform,performed,37,// Target-specific peephole cleanups performed after instruction; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:116,Integrability,depend,dependent,116,"// FIXME: LiveVariables should not be necessary here!; // PPCTLSDynamicCallPass uses LiveIntervals which previously dependent on; // LiveVariables. This (unnecessary) dependency has been removed now,; // however a stage-2 clang build fails without LiveVariables computed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:167,Integrability,depend,dependency,167,"// FIXME: LiveVariables should not be necessary here!; // PPCTLSDynamicCallPass uses LiveIntervals which previously dependent on; // LiveVariables. This (unnecessary) dependency has been removed now,; // however a stage-2 clang build fails without LiveVariables computed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:63,Safety,avoid,avoiding,63,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:54,Energy Efficiency,Power,PowerPC,54,"//===-- PPCTargetMachine.h - Define TargetMachine for PowerPC ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of TargetMachine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCTargetMachine.h - Define TargetMachine for PowerPC ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of TargetMachine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:42,Energy Efficiency,Power,PowerPC,42,/// Common code between 32-bit and 64-bit PowerPC targets.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h:77,Energy Efficiency,Power,PowerPC,77,/// PPC64LinuxTargetObjectFile - This implementation is used for; /// 64-bit PowerPC Linux.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h:19,Modifiability,variab,variable,19,/// Describe a TLS variable address within debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:7,Performance,latency,latency,7,// The latency of mtctr is only justified if there are more than 4; // comparisons that will be removed as a result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:19,Performance,load,load,19,// Turn PPC lvx -> load if the pointer is known aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:16,Performance,load,loads,16,// Turn PPC VSX loads into normal loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:34,Performance,load,loads,34,// Turn PPC VSX loads into normal loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:20,Availability,mask,mask,20,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:43,Availability,mask,mask,43,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:52,Availability,mask,mask,52,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:303,Availability,mask,mask,303,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:219,Performance,perform,performed,219,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:191,Usability,undo,undo,191,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,Availability,mask,mask,23,// (for the rotate-and-mask instructions),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:70,Performance,perform,perform,70,// We already implement getCastInstrCost and getMemoryOpCost where we perform; // the vector adjustment there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,Performance,latency,latency,23,// 6 is an approximate latency for the mtctr instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:34,Deployability,pipeline,pipeline,34,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:137,Energy Efficiency,schedul,scheduler,137,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:89,Performance,latency,latency-hiding,89,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:82,Security,expose,expose,82,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:30,Performance,cache,cache,30,// Starting with P7 we have a cache line size of 128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,Performance,cache,cache,39,// Assume that Future CPU has the same cache line size as the others.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:83,Performance,latency,latency,83,"// The 440 has no SIMD support, but floating-point instructions; // have a 5-cycle latency, so unroll by 5x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:112,Performance,latency,latency,112,"// The 440 has no SIMD support, but floating-point instructions; // have a 5-cycle latency, so unroll by 5x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:82,Performance,latency,latency,82,"// The A2 has no SIMD support, but floating-point instructions; // have a 6-cycle latency, so unroll by 6x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:111,Performance,latency,latency,111,"// The A2 has no SIMD support, but floating-point instructions; // have a 6-cycle latency, so unroll by 6x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:201,Energy Efficiency,schedul,scheduling,201,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:279,Energy Efficiency,schedul,scheduling,279,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:61,Performance,latency,latency,61,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:129,Performance,latency,latency,129,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:186,Performance,throughput,throughput,186,"// Returns a cost adjustment factor to adjust the cost of vector instructions; // on targets which there is overlap between the vector and scalar units,; // thereby reducing the overall throughput of vector code wrt. scalar code.; // An invalid instruction cost is returned if the type is an MMA vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:249,Performance,optimiz,optimizer,249,"// If the vector type is of an MMA type (v256i1, v512i1), an invalid; // instruction cost is returned. This is to signify to other cost computing; // functions to return the maximum instruction cost in order to prevent any; // opportunities for the optimizer to produce MMA types within the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:30,Safety,predict,predicted,30,// Branches are assumed to be predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:19,Performance,throughput,throughput,19,// TODO: Allow non-throughput costs that aren't binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:44,Availability,mask,mask,44,// Computing on 1 bit values requires extra mask or compare operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:165,Energy Efficiency,schedul,schedulable,165,"// We need a vector extract (or mfvsrld). Assume vector operation cost.; // The cost of the load constant for a vector extract is disregarded; // (invariant, easily schedulable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:92,Performance,load,load,92,"// We need a vector extract (or mfvsrld). Assume vector operation cost.; // The cost of the load constant for a vector extract is disregarded; // (invariant, easily schedulable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,Performance,load,load-hit-store,23,// Estimated cost of a load-hit-store delay. This was obtained; // experimentally as a minimum needed to prevent unprofitable; // vectorization for the paq8p benchmark. It may need to be; // raised further if other unprofitable cases remain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:158,Testability,benchmark,benchmark,158,// Estimated cost of a load-hit-store delay. This was obtained; // experimentally as a minimum needed to prevent unprofitable; // vectorization for the paq8p benchmark. It may need to be; // raised further if other unprofitable cases remain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:179,Availability,avail,available,179,"// Vector element insert/extract with Altivec is very expensive,; // because they require store and reload with the attendant; // processor stall for load-hit-store. Until VSX is available,; // these need to be estimated as very costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:150,Performance,load,load-hit-store,150,"// Vector element insert/extract with Altivec is very expensive,; // because they require store and reload with the attendant; // processor stall for load-hit-store. Until VSX is available,; // these need to be estimated as very costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:19,Performance,load,load,19,// VSX has 32b/64b load instructions. Legalization can handle loading of; // 32b/64b to VSR correctly and cheaply. But BaseT::getMemoryOpCost and; // PPCTargetLowering can't compute the cost appropriately. So here we; // explicitly check this case. There are also corresponding store; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:62,Performance,load,loading,62,// VSX has 32b/64b load instructions. Legalization can handle loading of; // 32b/64b to VSR correctly and cheaply. But BaseT::getMemoryOpCost and; // PPCTargetLowering can't compute the cost appropriately. So here we; // explicitly check this case. There are also corresponding store; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:11,Performance,load,loads,11,// Aligned loads and stores are easy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,Performance,load,load,39,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:141,Performance,load,load,141,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:177,Performance,load,load,177,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:290,Performance,load,loads,290,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:409,Performance,load,load,409,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:70,Performance,load,loads,70,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:141,Performance,load,loads,141,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:197,Performance,load,load,197,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,Security,access,access,39,// Newer PPC supports unaligned memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:45,Performance,load,loads,45,// PPC in general does not support unaligned loads and stores. They'll need; // to be decomposed based on the alignment factor.; // Add the cost of each scalar load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:160,Performance,load,load,160,// PPC in general does not support unaligned loads and stores. They'll need; // to be decomposed based on the alignment factor.; // Add the cost of each scalar load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:81,Performance,load,loads,81,"// For a vector type, there is also scalarization overhead (only for; // stores, loads are expanded using the vector-load + permutation sequence,; // which is much less expensive).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:117,Performance,load,load,117,"// For a vector type, there is also scalarization overhead (only for; // stores, loads are expanded using the vector-load + permutation sequence,; // which is much less expensive).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:24,Performance,load,load,24,"// Firstly, the cost of load/store operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC default behaviour here is ""instruction number 1st priority"".; // If LsrNoInsnsCost is set, call default implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:72,Energy Efficiency,Power,Power,72,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:46,Modifiability,variab,variable,46,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:8,Performance,load,load,8,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:3,Performance,Load,Loads,3,// Loads/stores with length instructions use bits 0-7 of the GPR operand and; // therefore cannot be used in 32-bit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:108,Availability,mask,masked,108,"// On P9 but not on P10, if the op is misaligned then it will cause a; // pipeline flush. Otherwise the VSX masked memops cost the same as unmasked; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:74,Deployability,pipeline,pipeline,74,"// On P9 but not on P10, if the op is misaligned then it will cause a; // pipeline flush. Otherwise the VSX masked memops cost the same as unmasked; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:175,Performance,load,load,175,"// Since alignment may be under estimated, we try to compute the probability; // that the actual address is aligned to the desired boundary. For example; // an 8-byte aligned load is assumed to be actually 16-byte aligned half the; // time, while a 4-byte aligned load has a 25% chance of being 16-byte; // aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:264,Performance,load,load,264,"// Since alignment may be under estimated, we try to compute the probability; // that the actual address is aligned to the desired boundary. For example; // an 8-byte aligned load is assumed to be actually 16-byte aligned half the; // time, while a 4-byte aligned load has a 25% chance of being 16-byte; // aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:174,Availability,mask,mask,174,"// Usually we should not get to this point, but the following is an attempt to; // model the cost of legalization. Currently we can only lower intrinsics with; // evl but no mask, on Power 9/10. Otherwise, we must scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:183,Energy Efficiency,Power,Power,183,"// Usually we should not get to this point, but the following is an attempt to; // model the cost of legalization. Currently we can only lower intrinsics with; // evl but no mask, on Power 9/10. Otherwise, we must scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:991,Modifiability,variab,variable,991,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:813,Performance,optimiz,optimization,813,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:915,Security,access,access,915,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:1000,Security,access,accesses,1000,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:208,Availability,error,error,208,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:65,Energy Efficiency,schedul,scheduling,65,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:163,Safety,avoid,avoid,163,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:77,Energy Efficiency,schedul,scheduling,77,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:109,Energy Efficiency,schedul,scheduled,109,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:97,Safety,avoid,avoid,97,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:7,Modifiability,variab,variable,7,// The variable offset and region handle are copied in r4 and r3. The; // copies are followed by GETtlsADDR32AIX/GETtlsADDR64AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1779,Deployability,update,updated,1779,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:51,Integrability,Depend,Dependencies,51,"//===-- PPCTOCRegDeps.cpp - Add Extra TOC Register Dependencies -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When resolving an address using the ELF ABI TOC pointer, two relocations are; // generally required: one for the high part and one for the low part. Only; // the high part generally explicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencie",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:576,Integrability,depend,depends,576,"//===-- PPCTOCRegDeps.cpp - Add Extra TOC Register Dependencies -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When resolving an address using the ELF ABI TOC pointer, two relocations are; // generally required: one for the high part and one for the low part. Only; // the high part generally explicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencie",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1800,Integrability,depend,dependencies,1800,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1990,Integrability,depend,dependencies,1990,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2405,Integrability,depend,dependencies,2405,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2306,Performance,optimiz,optimizations,2306,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1630,Safety,detect,detect,1630,"plicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1871,Safety,avoid,avoid,1871,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1588,Testability,assert,asserted,1588,"plicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2209,Testability,log,logic,2209,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:124,Safety,avoid,avoid,124,"// PPCTOCRegDeps pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:28,Usability,simpl,simple,28,"// PPCTOCRegDeps pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp:46,Usability,clear,clearing,46,"// add 1, not 0, because there is no implicit clearing; // of the high bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:437,Safety,avoid,avoid,437,"//===--------------- PPCVSXFMAMutate.cpp - VSX FMA Mutation ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mutates the form of VSX FMA instructions to avoid unnecessary; // copies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:111,Deployability,update,updated,111,"// The default (A-type) VSX FMA form kills the addend (it is taken from; // the target register, which is then updated to reflect the result of; // the FMA). If the instruction, however, kills one of the registers; // used for the product, then we can use the M-form instruction (which; // will take that value from the to-be-defined register).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:143,Testability,log,logic,143,"// In theory, there could be other uses of the addend copy before this; // fma. We could deal with this, but that would require additional; // logic below and I suspect it will not occur in any relevant; // situations. Additionally, check whether the copy source is killed; // prior to the fma. In order to replace the addend here with the; // source of the copy, it must still be live here. We can't use; // interval testing for a physical register, so as long as we're; // walking the MIs we may as well test liveness here.; //; // FIXME: There is a case that occurs in practice, like this:; // %9 = COPY %f1; VSSRC:%9; // ...; // %6 = COPY %9; VSSRC:%6,%9; // %7 = COPY %9; VSSRC:%7,%9; // %9<def,tied1> = XSMADDASP %9<tied0>, %1, %4; VSSRC:; // %6<def,tied1> = XSMADDASP %6<tied0>, %1, %2; VSSRC:; // %7<def,tied1> = XSMADDASP %7<tied0>, %1, %3; VSSRC:; // which prevents an otherwise-profitable transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:418,Testability,test,testing,418,"// In theory, there could be other uses of the addend copy before this; // fma. We could deal with this, but that would require additional; // logic below and I suspect it will not occur in any relevant; // situations. Additionally, check whether the copy source is killed; // prior to the fma. In order to replace the addend here with the; // source of the copy, it must still be live here. We can't use; // interval testing for a physical register, so as long as we're; // walking the MIs we may as well test liveness here.; //; // FIXME: There is a case that occurs in practice, like this:; // %9 = COPY %f1; VSSRC:%9; // ...; // %6 = COPY %9; VSSRC:%6,%9; // %7 = COPY %9; VSSRC:%7,%9; // %9<def,tied1> = XSMADDASP %9<tied0>, %1, %4; VSSRC:; // %6<def,tied1> = XSMADDASP %6<tied0>, %1, %2; VSSRC:; // %7<def,tied1> = XSMADDASP %7<tied0>, %1, %3; VSSRC:; // which prevents an otherwise-profitable transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:506,Testability,test,test,506,"// In theory, there could be other uses of the addend copy before this; // fma. We could deal with this, but that would require additional; // logic below and I suspect it will not occur in any relevant; // situations. Additionally, check whether the copy source is killed; // prior to the fma. In order to replace the addend here with the; // source of the copy, it must still be live here. We can't use; // interval testing for a physical register, so as long as we're; // walking the MIs we may as well test liveness here.; //; // FIXME: There is a case that occurs in practice, like this:; // %9 = COPY %f1; VSSRC:%9; // ...; // %6 = COPY %9; VSSRC:%6,%9; // %7 = COPY %9; VSSRC:%7,%9; // %9<def,tied1> = XSMADDASP %9<tied0>, %1, %4; VSSRC:; // %6<def,tied1> = XSMADDASP %6<tied0>, %1, %2; VSSRC:; // %7<def,tied1> = XSMADDASP %7<tied0>, %1, %3; VSSRC:; // which prevents an otherwise-profitable transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:19,Usability,usab,usable,19,"// If there are no usable killed product operands, then this; // transformation is likely not profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:228,Modifiability,extend,extended,228,"// If the addend copy is used only by this MI, then the addend source; // register is likely not live here. This could be fixed (based on the; // legality checks above, the live range for the addend source register; // could be extended), but it seems likely that such a trivial copy can; // be coalesced away later, and thus is not worth the effort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:46,Performance,perform,perform,46,"// If there isn't a class that fits, we can't perform the transform.; // This is needed for correctness with a mixture of VSX and Altivec; // instructions to make sure that a low VSX register is not assigned to; // the Altivec instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:3,Modifiability,Extend,Extend,3,// Extend the live intervals of the killed product operand to hold the; // fma result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:3,Modifiability,Extend,Extend,3,"// Extend the live interval of the addend source (it might end at the; // copy to be removed, or somewhere in between there and here). This; // is necessary only if it is a physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:940,Energy Efficiency,reduce,reduce,940,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:995,Energy Efficiency,reduce,reduce,995,"---- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operat",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:502,Performance,perform,performed,502,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:592,Performance,load,loads,592,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:865,Performance,load,load,865,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:947,Performance,perform,performance,947,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:1544,Performance,load,loads,1544," See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operations are identified as using ""special; // handling"" within this module.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:1784,Performance,optimiz,optimized,1784," See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operations are identified as using ""special; // handling"" within this module.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:1935,Performance,optimiz,optimization,1935," See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operations are identified as using ""special; // handling"" within this module.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:20,Energy Efficiency,allocate,allocated,20,// Swap entries are allocated in a vector for better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:53,Performance,perform,performance,53,// Swap entries are allocated in a vector for better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:51,Performance,optimiz,optimized,51,// Analyze webs and determine those that cannot be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:41,Safety,safe,safely,41,// Record which swap instructions can be safely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:20,Deployability,update,update,20,// Remove swaps and update other instructions requiring special; // handling. Return true iff any changes are made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:3,Deployability,Update,Update,3,// Update instructions requiring special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:74,Energy Efficiency,Power,Power,74,"// If we don't have VSX on the subtarget, don't do anything.; // Also, on Power 9 the load and store ops preserve element order and so; // the swaps are not required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:86,Performance,load,load,86,"// If we don't have VSX on the subtarget, don't do anything.; // Also, on Power 9 the load and store ops preserve element order and so; // the swaps are not required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:90,Energy Efficiency,allocate,allocate,90,"// Initialize data structures for this pass. In particular, clear the; // swap vector and allocate the equivalence class mapping before; // processing each function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:60,Usability,clear,clear,60,"// Initialize data structures for this pass. In particular, clear the; // swap vector and allocate the equivalence class mapping before; // processing each function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:185,Testability,test,tests,185,"// An initial vector size of 256 appears to work well in practice.; // Small/medium functions with vector content tend not to incur a; // reallocation at this size. Three of the vector tests in; // projects/test-suite reallocate, which seems like a reasonable rate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:207,Testability,test,test-suite,207,"// An initial vector size of 256 appears to work well in practice.; // Small/medium functions with vector content tend not to incur a; // reallocation at this size. Three of the vector tests in; // projects/test-suite reallocate, which seems like a reasonable rate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:23,Energy Efficiency,allocate,allocate,23,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:71,Security,access,access,71,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:121,Usability,clear,clear,121,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:159,Usability,clear,clear,159,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:73,Performance,optimiz,optimization,73,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:60,Safety,safe,safe,60,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:165,Testability,log,logical,165,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:285,Performance,optimiz,optimization,285,"// This is a doubleword splat if it is of the form; // XXPERMDI t, s, s, 0 or XXPERMDI t, s, s, 3. As above we; // must look through chains of copy-likes to find the source; // register. We turn off the marking for mention of a physical; // register, because splatting it is safe; the optimization; // will not swap the value in the physical register. Whether; // or not the two input registers are identical, we can handle; // these by adjusting the form of the XXPERMDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:275,Safety,safe,safe,275,"// This is a doubleword splat if it is of the form; // XXPERMDI t, s, s, 0 or XXPERMDI t, s, s, 3. As above we; // must look through chains of copy-likes to find the source; // register. We turn off the marking for mention of a physical; // register, because splatting it is safe; the optimization; // will not swap the value in the physical register. Whether; // or not the two input registers are identical, we can handle; // these by adjusting the form of the XXPERMDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:17,Performance,load,loads,17,"// Non-permuting loads are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:37,Safety,unsafe,unsafe,37,"// Non-permuting loads are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:13,Performance,load,loads,13,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:38,Performance,load,load,38,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:74,Performance,optimiz,optimization,74,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:65,Safety,safe,safe,65,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:5,Performance,load,load,5,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:147,Performance,load,load,147,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:89,Safety,safe,safe,89,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:228,Safety,safe,safe,228,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:38,Safety,unsafe,unsafe,38,"// Non-permuting stores are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:76,Performance,optimiz,optimization,76,"// Permuting stores are marked as both store and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:67,Safety,safe,safe,67,"// Permuting stores are marked as both store and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:325,Modifiability,maintainab,maintainable,325,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:86,Performance,optimiz,optimization,86,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:159,Performance,optimiz,optimization,159,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:314,Usability,simpl,simple,314,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:343,Testability,test,test,343,"// We can handle STXSDX and STXSSPX similarly to LXSDX and LXSSPX,; // by adding special handling for narrowing copies as well as; // widening ones. However, I've experimented with this, and in; // practice we currently do not appear to use STXSDX fed by; // a narrowing copy from a full vector register. Since I can't; // generate any useful test cases, I've left this alone for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:464,Performance,optimiz,optimized,464,"// Generate equivalence classes for related computations (webs) by; // def-use relationships of virtual registers. Mention of a physical; // register terminates the generation of equivalence classes as this; // indicates a use of a parameter, definition of a return value, use; // of a value returned from a call, or definition of a parameter to a; // call. Computations with physical register mentions are flagged; // as such so their containing webs will not be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:113,Performance,optimiz,optimized,113,"// Walk the swap vector entries looking for conditions that prevent their; // containing computations from being optimized. When such conditions are; // found, mark the representative of the computation's equivalence class; // as rejected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:37,Performance,load,loads,37,// Reject webs than contain swapping loads that feed something other; // than a swap instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:117,Performance,optimiz,optimization,117,// We skip debug instructions in the analysis. (Note that debug; // location information is still maintained by this optimization; // because it remains on the LXVD2X and STXVD2X instructions after; // the XXPERMDIs are removed.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:27,Performance,load,load,27,"// It is possible that the load feeds a swap and that swap feeds a; // store. In such a case, the code is actually trying to store a swapped; // vector. We must reject such webs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:67,Performance,load,loads,67,"// Walk the swap vector entries looking for swaps fed by permuting loads; // and swaps that feed permuting stores. If the containing computation; // has not been marked rejected, mark each such swap for removal.; // (Removal is delayed in case optimization has disturbed the pattern,; // such that multiple loads feed the same swap, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:244,Performance,optimiz,optimization,244,"// Walk the swap vector entries looking for swaps fed by permuting loads; // and swaps that feed permuting stores. If the containing computation; // has not been marked rejected, mark each such swap for removal.; // (Removal is delayed in case optimization has disturbed the pattern,; // such that multiple loads feed the same swap, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:307,Performance,load,loads,307,"// Walk the swap vector entries looking for swaps fed by permuting loads; // and swaps that feed permuting stores. If the containing computation; // has not been marked rejected, mark each such swap for removal.; // (Removal is delayed in case optimization has disturbed the pattern,; // such that multiple loads feed the same swap, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:218,Deployability,patch,patches,218,// The identified swap entry requires special handling to allow its; // containing computation to be optimized. Perform that handling; // here.; // FIXME: Additional opportunities will be phased in with subsequent; // patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:101,Performance,optimiz,optimized,101,// The identified swap entry requires special handling to allow its; // containing computation to be optimized. Perform that handling; // here.; // FIXME: Additional opportunities will be phased in with subsequent; // patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:112,Performance,Perform,Perform,112,// The identified swap entry requires special handling to allow its; // containing computation to be optimized. Perform that handling; // here.; // FIXME: Additional opportunities will be phased in with subsequent; // patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:117,Safety,avoid,avoid,117,"// Note that an XXPERMDI requires a VSRC, so if the SUBREG_TO_REG; // is copying to a VRRC, we need to be careful to avoid a register; // assignment problem. In this case we must copy from VRRC to VSRC; // prior to the swap, and from VSRC to VRRC following the swap.; // Coalescing will usually remove all this mess.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:10,Testability,assert,asserts,10,// For no-asserts builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:33,Energy Efficiency,Power,PowerPC,33,"//===-- PPCAsmParser.cpp - Parse PowerPC asm to MCInst instructions -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:145,Availability,error,error,145,"// Evaluate an expression containing condition register; // or condition register field symbols. Returns positive; // value on success, or -1 on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:60,Energy Efficiency,Power,PowerPC,60,/// PPCOperand - Instances of this class represent a parsed PowerPC machine; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:3,Performance,Cache,Cached,3,// Cached result of EvaluateCRExpr(Val),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:7,Security,Hash,Hash,7,// The Hash Imm form is used for instructions that check or store a hash.; // These instructions have a small immediate range that spans between; // -8 and -512.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:68,Security,hash,hash,68,// The Hash Imm form is used for instructions that check or store a hash.; // These instructions have a small immediate range that spans between; // -8 and -512.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:43,Integrability,wrap,wrap,43,"// In 32-bit mode, large 32-bit quantities wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate extra memory for the string and copy it.; // FIXME: This is incorrect, Operands are owned by unique_ptr with a default; // deleter which will destroy them by simply using ""delete"", not correctly; // calling operator delete on this extra memory after calling the dtor; // explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:170,Usability,simpl,simply,170,"// Allocate extra memory for the string and copy it.; // FIXME: This is incorrect, Operands are owned by unique_ptr with a default; // deleter which will destroy them by simply using ""delete"", not correctly; // calling operator delete on this extra memory after calling the dtor; // explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:40,Modifiability,extend,extended,40,// Post-process instructions (typically extended mnemonics),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:136,Safety,avoid,avoid,136,/// Find all VK_TLSGD/VK_TLSLD symbol references in expression and replace; /// them by VK_PPC_TLSGD/VK_PPC_TLSLD. This is necessary to avoid having; /// _GLOBAL_OFFSET_TABLE_ created via ELFObjectWriter::RelocNeedsGOT.; /// FIXME: This is a hack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:35,Performance,load,loads,35,// Handle base mnemonic for atomic loads where the EH bit is zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:50,Availability,avail,available,50,"// FIXME: Right now, the parser always allows any available; // instruction, so the .machine directive is not useful.; // In the wild, any/push/pop/ppc64/altivec/power[4-9] are seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:162,Energy Efficiency,power,power,162,"// FIXME: Right now, the parser always allows any available; // instruction, so the .machine directive is not useful.; // In the wild, any/push/pop/ppc64/altivec/power[4-9] are seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:51,Energy Efficiency,Power,PowerPC,51,"//===------ PPCDisassembler.cpp - Disassembler for PowerPC ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:243,Modifiability,extend,extend,243,// Decode the disp field for a hash store or hash check operation.; // The field is composed of an immediate value that is 6 bits; // and covers the range -8 to -512. The immediate is always negative and 2s; // complement which is why we sign extend a 7 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:31,Security,hash,hash,31,// Decode the disp field for a hash store or hash check operation.; // The field is composed of an immediate value that is 6 bits; // and covers the range -8 to -512. The immediate is always negative and 2s; // complement which is why we sign extend a 7 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:45,Security,hash,hash,45,// Decode the disp field for a hash store or hash check operation.; // The field is composed of an immediate value that is 6 bits; // and covers the range -8 to -512. The immediate is always negative and 2s; // complement which is why we sign extend a 7 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCCallLowering.cpp:33,Performance,load,load,33,// define a lambda expression to load value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:468,Energy Efficiency,Power,PowerPC,468,"//===- PPCInstructionSelector.cpp --------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the targeting of the InstructionSelector class for; /// PowerPC.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:262,Availability,mask,mask,262,"// 2-2) Patterns : {zeros}{ones}{15-bit value}{zeros}; // {zeros}{15-bit value}{zeros}; // {zeros}{ones}{15-bit value}; // {ones}{15-bit value}{zeros}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:209,Availability,mask,mask,209,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:502,Usability,clear,clear,502,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:725,Usability,clear,clear,725,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:196,Availability,mask,mask,196,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:734,Usability,clear,clear,734,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:295,Availability,mask,mask,295,"// 2-6) Patterns : {******}{49 zeros}{******}; // {******}{49 ones}{******}; // If the Imm contains 49 consecutive zeros/ones, it means that a total of 15; // bits remain on both sides. Rotate right the Imm to construct an int<16>; // value, use LI for int<16> value and then use RLDICL without mask to rotate; // it back.; //; // 1) findContiguousZerosAtLeast(Imm, 49); // +------|--zeros-|------+ +---ones--||---15 bit--+; // |bbbbbb0000000000aaaaaa| -> |0000000000aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0; //; // 2) findContiguousZerosAtLeast(~Imm, 49); // +------|--ones--|------+ +---ones--||---15 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:362,Availability,mask,mask,362,"// Following patterns use 3 instructions to materialize the Imm.; // 3-1) Patterns : {zeros}{ones}{31-bit value}{zeros}; // {zeros}{31-bit value}{zeros}; // {zeros}{ones}{31-bit value}; // {ones}{31-bit value}{zeros}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDIC to mask off the; // ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:244,Availability,mask,mask,244,"// 3-2) Pattern : {zeros}{31-bit value}{ones}; // Shift right the Imm by (32 - LZ) bits to construct a negative 32 bits; // value, therefore we can take advantage of LIS's sign-extension semantics,; // add the remaining bits with ORI, and then mask them off after rotation.; // This is similar to Pattern 2-3, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:230,Availability,mask,mask,230,"// 3-3) Patterns : {zeros}{ones}{31-bit value}{ones}; // {ones}{31-bit value}{ones}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDICL to mask off the; // ones in left sides (if required) after rotation.; // This is similar to Pattern 2-4, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:302,Availability,mask,mask,302,"// 3-5) Patterns : {******}{33 zeros}{******}; // {******}{33 ones}{******}; // If the Imm contains 33 consecutive zeros/ones, it means that a total of 31; // bits remain on both sides. Rotate right the Imm to construct an int<32>; // value, use LIS + ORI for int<32> value and then use RLDICL without mask to; // rotate it back.; // This is similar to Pattern 2-6, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:146,Energy Efficiency,Power,PowerPC,146,"// Address stored in the TOC entry. This is related to code model and the ABI; // we are currently using. For now we only handle 64-bit Linux LE. PowerPC; // only supports small, medium and large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:34,Performance,load,load,34,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:83,Performance,optimiz,optimize,83,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:92,Performance,load,load,92,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:12,Usability,simpl,simply,12,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp:460,Energy Efficiency,Power,PowerPC,460,"//===- PPCLegalizerInfo.h ----------------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the targeting of the Machinelegalizer class for PowerPC; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp:28,Energy Efficiency,Power,PowerPC,28,// Check if this is a legal PowerPC vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h:458,Energy Efficiency,Power,PowerPC,458,"//===- PPCLegalizerInfo.h ----------------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares the targeting of the Machinelegalizer class for PowerPC; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h:48,Energy Efficiency,Power,PowerPC,48,/// This class provides the information for the PowerPC target legalizer for; /// GlobalISel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:465,Energy Efficiency,Power,PowerPC,465,"//===- PPCRegisterBankInfo.cpp --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the targeting of the RegisterBankInfo class for; /// PowerPC.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:19,Testability,log,logic,19,// Try the default logic for non-generic instructions that are either copies; // or already have some operands assigned to banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:17,Performance,load,load,17,// Check if that load feeds fp instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:96,Performance,load,load,96,"// If we have at least one direct use in a FP instruction,; // assume this was a floating point load in the IR. If it was; // not, we would have had a bitcast before reaching that; // instruction.; //; // Int->FP conversion operations are also captured in; // onlyDefinesFP().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:89,Modifiability,extend,extended,89,"// TODO: Currently, only vector and GPR register banks are handled.; // This needs to be extended to handle floating point register; // banks in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:185,Modifiability,refactor,refactor,185,"/// Returns whether opcode \p Opc is a pre-isel generic floating-point opcode,; /// having only floating-point operands.; /// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in GlobalISel/Utils.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:63,Modifiability,refactor,refactor,63,/// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in class RegisterBankInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:63,Modifiability,refactor,refactor,63,/// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in class RegisterBankInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:63,Modifiability,refactor,refactor,63,/// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in class RegisterBankInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.h:463,Energy Efficiency,Power,PowerPC,463,"//===-- PPCRegisterBankInfo.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file declares the targeting of the RegisterBankInfo class for PowerPC.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the appropriate; // bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:417,Energy Efficiency,Power,PowerPC,417,"//===-------- PPCELFStreamer.cpp - ELF Object Output ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCELFStreamer for PowerPC.; //; // The purpose of the custom ELF streamer is to allow us to intercept; // instructions as they are being emitted and align all 8 byte instructions; // to a 64 byte boundary if required (by adding a 4 byte nop). This is important; // because 8 byte instructions are not allowed to cross 64 byte boundaries; // and by aliging anything that is within 4 bytes of the boundary we can; // guarantee that the 8 byte instructions do not cross that boundary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:63,Performance,optimiz,optimization,63,"// If the instruction is a part of the GOT to PC-Rel link time optimization; // instruction pair, return a value, otherwise return std::nullopt. A true; // returned value means the instruction is the PLDpc and a false value means; // it is the user instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:58,Performance,load,load,58,"// User of the GOT-indirect address.; // For example, the load that will get the relocation as follows:; // .reloc .Lpcrel1-8,R_PPC64_PCREL_OPT,.-(.Lpcrel1-8); // lwa 3, 4(3)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:71,Performance,load,load,71,"// Producer of the GOT-indirect address.; // For example, the prefixed load from the got that will get the label as; // follows:; // pld 3, vec@got@pcrel(0), 1; // .Lpcrel1:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:36,Performance,optimiz,optimization,36,"// This linker time GOT PC Relative optimization relocation will look like this:; // pld <reg> symbol@got@pcrel; // <Label###>:; // .reloc Label###-8,R_PPC64_PCREL_OPT,.-(Label###-8); // load <loadedreg>, 0(<reg>); // The reason we place the label after the PLDpc instruction is that there; // may be an alignment nop before it since prefixed instructions must not; // cross a 64-byte boundary (please see; // PPCELFStreamer::emitPrefixedInstruction()). When referring to the; // label, we subtract the width of a prefixed instruction (8 bytes) to ensure; // we refer to the PLDpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:187,Performance,load,load,187,"// This linker time GOT PC Relative optimization relocation will look like this:; // pld <reg> symbol@got@pcrel; // <Label###>:; // .reloc Label###-8,R_PPC64_PCREL_OPT,.-(Label###-8); // load <loadedreg>, 0(<reg>); // The reason we place the label after the PLDpc instruction is that there; // may be an alignment nop before it since prefixed instructions must not; // cross a 64-byte boundary (please see; // PPCELFStreamer::emitPrefixedInstruction()). When referring to the; // label, we subtract the width of a prefixed instruction (8 bytes) to ensure; // we refer to the PLDpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:193,Performance,load,loadedreg,193,"// This linker time GOT PC Relative optimization relocation will look like this:; // pld <reg> symbol@got@pcrel; // <Label###>:; // .reloc Label###-8,R_PPC64_PCREL_OPT,.-(Label###-8); // load <loadedreg>, 0(<reg>); // The reason we place the label after the PLDpc instruction is that there; // may be an alignment nop before it since prefixed instructions must not; // cross a 64-byte boundary (please see; // PPCELFStreamer::emitPrefixedInstruction()). When referring to the; // label, we subtract the width of a prefixed instruction (8 bytes) to ensure; // we refer to the PLDpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:84,Performance,optimiz,optimization,84,// Emit the label that immediately follows the PLDpc for a link time GOT PC Rel; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:103,Performance,optimiz,optimization,103,// This function checks if the parameter Inst is part of the setup for a link; // time GOT PC Relative optimization. For example in this situation:; // <MCInst PLDpc <MCOperand Reg:282> <MCOperand Expr:(glob_double@got@pcrel)>; // <MCOperand Imm:0> <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // <MCInst SOME_LOAD <MCOperand Reg:22> <MCOperand Imm:0> <MCOperand Reg:282>; // <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // The above is a pair of such instructions and this function will not return; // std::nullopt for either one of them. In both cases we are looking for the; // last operand <MCOperand Expr:(.Lpcrel@<<invalid>>)> which needs to be an; // MCExpr and has the flag MCSymbolRefExpr::VK_PPC_PCREL_OPT. After that we just; // look at the opcode and in the case of PLDpc we will return true. For the load; // (or store) this function will return false indicating it has found the second; // instruciton in the pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:805,Performance,load,load,805,// This function checks if the parameter Inst is part of the setup for a link; // time GOT PC Relative optimization. For example in this situation:; // <MCInst PLDpc <MCOperand Reg:282> <MCOperand Expr:(glob_double@got@pcrel)>; // <MCOperand Imm:0> <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // <MCInst SOME_LOAD <MCOperand Reg:22> <MCOperand Imm:0> <MCOperand Reg:282>; // <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // The above is a pair of such instructions and this function will not return; // std::nullopt for either one of them. In both cases we are looking for the; // last operand <MCOperand Expr:(.Lpcrel@<<invalid>>)> which needs to be an; // MCExpr and has the flag MCSymbolRefExpr::VK_PPC_PCREL_OPT. After that we just; // look at the opcode and in the case of PLDpc we will return true. For the load; // (or store) this function will return false indicating it has found the second; // instruciton in the pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:417,Energy Efficiency,Power,PowerPC,417,"//===- PPCELFStreamer.h - ELF Object Output --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCELFStreamer for PowerPC.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:77,Integrability,depend,depending,77,"// We need to keep track of the last label we emitted (only one) because; // depending on whether the label is on the same line as an aligned; // instruction or not, the label may refer to the instruction or the nop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:13,Deployability,update,updates,13,// EmitLabel updates LastLabel and LastLabelLoc when a new label is emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:107,Performance,optimiz,optimization,107,// Check if the instruction Inst is part of a pair of instructions that make up; // a link time GOT PC Rel optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:19,Deployability,integrat,integrated,19,"// FIXME: Once the integrated assembler supports full register names, tie this; // to the verbose-asm setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:19,Integrability,integrat,integrated,19,"// FIXME: Once the integrated assembler supports full register names, tie this; // to the verbose-asm setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:14,Testability,test,testing,14,// Useful for testing purposes. Prints vs{31-63} as v{0-31} respectively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:147,Performance,load,load,147,"// Customize printing of the addis instruction on AIX. When an operand is a; // symbol reference, the instruction syntax is changed to look like a load; // operation, i.e:; // Transform: addis $rD, $rA, $src --> addis $rD, $src($rA).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:132,Performance,optimiz,optimization,132,// Check if the last operand is an expression with the variant kind; // VK_PPC_PCREL_OPT. If this is the case then this is a linker optimization; // relocation and the .reloc directive needs to be added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:507,Availability,avail,available,507,"// dcbt[st] is printed manually here because:; // 1. The assembly syntax is different between embedded and server targets; // 2. We must print the short mnemonics for TH == 0 because the; // embedded/server syntax default will not be stable across assemblers; // The syntax for dcbt is:; // dcbt ra, rb, th [server]; // dcbt th, ra, rb [embedded]; // where th can be omitted when it is 0. dcbtst is the same.; // On AIX, only emit the extended mnemonics for dcbt and dcbtst if; // the ""modern assembler"" is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:435,Modifiability,extend,extended,435,"// dcbt[st] is printed manually here because:; // 1. The assembly syntax is different between embedded and server targets; // 2. We must print the short mnemonics for TH == 0 because the; // embedded/server syntax default will not be stable across assemblers; // The syntax for dcbt is:; // dcbt ra, rb, th [server]; // dcbt th, ra, rb [embedded]; // where th can be omitted when it is 0. dcbtst is the same.; // On AIX, only emit the extended mnemonics for dcbt and dcbtst if; // the ""modern assembler"" is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:115,Usability,simpl,simply,115,// Operands of BUILD_VECTOR are signed and we use this to print operands; // of XXSPLTIB which are unsigned. So we simply truncate to 8 bits and; // print as unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h:426,Energy Efficiency,Power,PowerPC,426,"//===-- PPCMCAsmInfo.h - PPC asm properties --------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declarations of the PowerPC MCAsmInfo classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp:27,Performance,load,load,27,// Encode imm for the hash load/store to stack for the ROP Protection; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp:22,Security,hash,hash,22,// Encode imm for the hash load/store to stack for the ROP Protection; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp:43,Usability,simpl,simply,43,"// Add a fixup for the TLS register, which simply provides a relocation; // hint to the linker that this statement is part of a relocation sequence.; // Return the thread-pointer register's encoding. Add a one byte displacement; // if using PC relative memops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:30,Energy Efficiency,Power,PowerPC,30,"//===-- PPCMCTargetDesc.cpp - PowerPC Target Descriptions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:402,Energy Efficiency,Power,PowerPC,402,"//===-- PPCMCTargetDesc.cpp - PowerPC Target Descriptions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:162,Energy Efficiency,allocate,allocated,162,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:234,Energy Efficiency,allocate,allocated,234,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:434,Modifiability,extend,extend,434,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:113,Integrability,depend,depending,113,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:54,Modifiability,variab,variable,54,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:102,Modifiability,variab,variables,102,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:46,Availability,error,error,46,// encodePPC64LocalEntryOffset will report an error if it cannot; // encode LocalOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:45,Deployability,update,updated,45,// Clear the set of symbols that needs to be updated so the streamer can; // be reused without issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:3,Usability,Clear,Clear,3,// Clear the set of symbols that needs to be updated so the streamer can; // be reused without issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:20,Deployability,update,update,20,"// FIXME: We should update the CPUType, CPUSubType in the Object file if; // the new values are different from the defaults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:28,Energy Efficiency,Power,PowerPC,28,"//===-- PPCMCTargetDesc.h - PowerPC Target Descriptions ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:402,Energy Efficiency,Power,PowerPC,402,"//===-- PPCMCTargetDesc.h - PowerPC Target Descriptions ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:162,Energy Efficiency,allocate,allocated,162,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:234,Energy Efficiency,allocate,allocated,234,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:434,Modifiability,extend,extend,434,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:127,Integrability,wrap,wrap,127,"/// Returns true iff Val consists of one contiguous run of 1s with any number of; /// 0s on either side. The 1s are allowed to wrap from LSB to MSB, so; /// 0x000FFF0, 0x0000FFFF, and 0xFF0000FF are all runs. 0x0F0F0000 is not,; /// since all 1s are not contiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:10,Availability,mask,mask,10,// invert mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:10,Availability,mask,mask,10,// invert mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:44,Energy Efficiency,Power,PowerPC,44,/// PPCII - This namespace holds all of the PowerPC target-specific; /// per-instruction flags. These must match the corresponding definitions in; /// PPC.td and PPCInstrFormats.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:81,Energy Efficiency,Power,PowerPC,81,"// PPC970 Instruction Flags. These flags describe the characteristics of the; // PowerPC 970 (aka G5) dispatch groups and how they are formed out of; // raw machine instructions.; /// PPC970_First - This instruction starts a new dispatch group, so it will; /// always be the first one in the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:106,Availability,avail,available,106,"/// PPC970_Cracked - This instruction is cracked into two pieces, requiring; /// two dispatch pipes to be available to issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:59,Deployability,pipeline,pipeline,59,/// PPC970_Mask/Shift - This is a bitmask that selects the pipeline type that; /// an instruction is issued to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:48,Deployability,pipeline,pipelines,48,/// These are the various PPC970 execution unit pipelines. Each instruction; /// is one of these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:3,Performance,Load,Load,3,// Load Store Unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:37,Modifiability,extend,extended,37,/// This instruction produced a sign extended result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:37,Modifiability,extend,extended,37,/// This instruction produced a zero extended result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:53,Energy Efficiency,Power,PowerPC,53,// end namespace llvm; // Defines symbolic names for PowerPC registers. This defines a mapping from; // register name to register number.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:34,Energy Efficiency,Power,PowerPC,34,// Defines symbolic names for the PowerPC instructions.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp:408,Energy Efficiency,Power,PowerPC,408,"//===-- PPCPredicates.cpp - PPC Branch Predicate Information --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PowerPC branch predicates.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp:3,Usability,Simpl,Simple,3,// Simple predicates for single condition-register bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:407,Energy Efficiency,Power,PowerPC,407,"//===-- PPCPredicates.h - PPC Branch Predicate Information ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file describes the PowerPC branch predicates.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:48,Safety,avoid,avoid,48,"// Generated files will use ""namespace PPC"". To avoid symbol clash,; // undefine PPC here. PPC may be predefined on some hosts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:65,Usability,simpl,simple,65,"// When dealing with individual condition-register bits, we have simple set; // and unset predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFObjectWriter.cpp:35,Energy Efficiency,Power,PowerPC,35,"//===-- PPCXCOFFObjectWriter.cpp - PowerPC XCOFF Writer -------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.cpp:420,Energy Efficiency,Power,PowerPC,420,"//===-------- PPCXCOFFStreamer.cpp - XCOFF Object Output ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCXCOFFStreamer for PowerPC.; //; // The purpose of the custom XCOFF streamer is to allow us to intercept; // instructions as they are being emitted and align all 8 byte instructions; // to a 64 byte boundary if required (by adding a 4 byte nop). This is important; // because 8 byte instructions are not allowed to cross 64 byte boundaries; // and by aligning anything that is within 4 bytes of the boundary we can; // guarantee that the 8 byte instructions do not cross that boundary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.h:420,Energy Efficiency,Power,PowerPC,420,"//===- PPCXCOFFStreamer.h - XCOFF Object Output -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCXCOFFStreamer for PowerPC.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp:8,Energy Efficiency,Power,PowerPCTargetInfo,8,"//===-- PowerPCTargetInfo.cpp - PowerPC Target Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp:32,Energy Efficiency,Power,PowerPC,32,"//===-- PowerPCTargetInfo.cpp - PowerPC Target Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h:8,Energy Efficiency,Power,PowerPCTargetInfo,8,"//===-- PowerPCTargetInfo.h - PowerPC Target Implementation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h:30,Energy Efficiency,Power,PowerPC,30,"//===-- PowerPCTargetInfo.h - PowerPC Target Implementation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCV.h:28,Integrability,interface,interface,28,"//===-- RISCV.h - Top-level interface for RISC-V ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // RISC-V back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCV.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCV.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- RISCVAsmPrinter.cpp - RISC-V LLVM assembly writer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the RISC-V assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper needed for tblgenned pseudo lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:11,Deployability,patch,patchpoint,11,"// Lower a patchpoint of the form:; // [<def>], <id>, <numBytes>, <target>, <numArgs>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Usability,Simpl,Simple,3,// Simple pseudo-instructions have their lowering (with expansion to real; // instructions) auto-generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:22,Deployability,update,update,22,// Use module flag to update feature bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:41,Security,hash,hashes,41,"// Temporary registers for comparing the hashes. If a register is used; // for the call target, or reserved by the user, we can clobber another; // temporary register as the check is immediately followed by the; // call. The check defaults to X6/X7, but can fall back to X28-X31 if; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:53,Performance,load,load,53,"// Checking X0 makes no sense. Instead of emitting a load, zero; // ScratchRegs[0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:25,Deployability,patch,patchable-function-prefix,25,// Adjust the offset for patchable-function-prefix. This assumes that; // patchable-function-prefix is the same for all functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:74,Deployability,patch,patchable-function-prefix,74,// Adjust the offset for patchable-function-prefix. This assumes that; // patchable-function-prefix is the same for all functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Performance,Load,Load,3,// Load the target function type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:33,Security,hash,hash,33,// Load the target function type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Performance,Load,Load,3,// Load the expected 32-bit type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:33,Security,hash,hash,33,// Load the expected 32-bit type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:15,Security,hash,hashes,15,// Compare the hashes and trap if there's a mismatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Performance,load,load,3,"// load shadow tag in X6, X5 contains shadow base",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:43,Performance,load,loaded,43,// Extract tag from X5 and compare it with loaded tag from shadow,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:53,Availability,mask,mask,53,// Unmasked pseudo instructions need to append dummy mask operand to; // V instructions. All V instructions are modeled as the masked version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:127,Availability,mask,masked,127,// Unmasked pseudo instructions need to append dummy mask operand to; // V instructions. All V instructions are modeled as the masked version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:38,Performance,optimiz,optimize,38,"// end anonymous namespace; // Try to optimize (i64 (and (zext/sext (i32 X), C1))) if C1 has bit 31 set,; // but bits 63:32 are zero. If we know that bit 31 of X is 0, we can fill; // the upper 32 bits with ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:98,Modifiability,extend,extending,98,"// Look for constants that fit in 32 bits but not simm12, and can be made; // into simm12 by sign extending bit 31. This will allow use of ANDI.; // TODO: Is worth making simm32?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:8,Modifiability,extend,extend,8,// Sign extend the constant and replace the And operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:681,Energy Efficiency,reduce,reduce,681,"// LLVM vector reduction intrinsics return a scalar result, but on RISC-V vector; // reduction instructions write the result in the first element of a vector; // register. So when a reduction in a loop uses a scalar phi, we end up with; // unnecessary scalar moves:; //; // loop:; // vfmv.s.f v10, fa0; // vfredosum.vs v8, v8, v10; // vfmv.f.s fa0, v8; //; // This mainly affects ordered fadd reductions, since other types of reduction; // typically use element-wise vectorisation in the loop body. This tries to; // vectorize any scalar phis that feed into a fadd reduction:; //; // loop:; // %phi = phi <float> [ ..., %entry ], [ %acc, %loop ]; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %phi, <vscale x 2 x float> %vec); //; // ->; //; // loop:; // %phi = phi <vscale x 2 x float> [ ..., %entry ], [ %acc.vec, %loop ]; // %phi.scalar = extractelement <vscale x 2 x float> %phi, i64 0; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %x, <vscale x 2 x float> %vec); // %acc.vec = insertelement <vscale x 2 x float> poison, float %acc.next, i64 0; //; // Which eliminates the scalar -> vector -> scalar crossing during instruction; // selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:939,Energy Efficiency,reduce,reduce,939,"// LLVM vector reduction intrinsics return a scalar result, but on RISC-V vector; // reduction instructions write the result in the first element of a vector; // register. So when a reduction in a loop uses a scalar phi, we end up with; // unnecessary scalar moves:; //; // loop:; // vfmv.s.f v10, fa0; // vfredosum.vs v8, v8, v10; // vfmv.f.s fa0, v8; //; // This mainly affects ordered fadd reductions, since other types of reduction; // typically use element-wise vectorisation in the loop body. This tries to; // vectorize any scalar phis that feed into a fadd reduction:; //; // loop:; // %phi = phi <float> [ ..., %entry ], [ %acc, %loop ]; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %phi, <vscale x 2 x float> %vec); //; // ->; //; // loop:; // %phi = phi <vscale x 2 x float> [ ..., %entry ], [ %acc.vec, %loop ]; // %phi.scalar = extractelement <vscale x 2 x float> %phi, i64 0; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %x, <vscale x 2 x float> %vec); // %acc.vec = insertelement <vscale x 2 x float> poison, float %acc.next, i64 0; //; // Which eliminates the scalar -> vector -> scalar crossing during instruction; // selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVDeadRegisterDefinitions.cpp:391,Modifiability,rewrite,rewrites,391,"//===- RISCVDeadRegisterDefinitions.cpp - Replace dead defs w/ zero reg --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass rewrites Rd to x0 for instrs whose return values are unused.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVDeadRegisterDefinitions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVDeadRegisterDefinitions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:536,Safety,avoid,avoiding,536,"//===-- RISCVExpandAtomicPseudoInsts.cpp - Expand atomic pseudo instrs. ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands atomic pseudo instructions into; // target instructions. This pass should be run at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LR/SC block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:105,Availability,Mask,MaskedMerge,105,// We select bits from newval and oldval using:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // r = oldval ^ ((oldval ^ newval) & masktargetdata);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:155,Availability,mask,masktargetdata,155,// We select bits from newval and oldval using:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // r = oldval ^ ((oldval ^ newval) & masktargetdata);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:135,Availability,mask,masktargetdata,135,"// .loop:; // lr.w destreg, (alignedaddr); // binop scratch, destreg, incr; // xor scratch, destreg, scratch; // and scratch, scratch, masktargetdata; // xor scratch, destreg, scratch; // sc.w scratch, scratch, (alignedaddr); // bnez scratch, loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:77,Availability,mask,mask,77,"//; // .loophead:; // lr.w destreg, (alignedaddr); // and scratch2, destreg, mask; // mv scratch1, destreg; // [sext scratch2 if signed min/max]; // ifnochangeneeded scratch2, incr, .looptail",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:76,Availability,mask,mask,76,"// .loopifbody:; // xor scratch1, destreg, incr; // and scratch1, scratch1, mask; // xor scratch1, destreg, scratch1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:356,Availability,redundant,redundant,356,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:403,Availability,mask,masked,403,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:189,Performance,perform,performs,189,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:356,Safety,redund,redundant,356,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:16,Availability,mask,masked,16,"// If we have a masked cmpxchg, match AND dst, DestReg, MaskReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:56,Availability,Mask,MaskReg,56,"// If we have a masked cmpxchg, match AND dst, DestReg, MaskReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:22,Availability,Mask,MaskReg,22,"// Match BNE DestReg, MaskReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:59,Availability,mask,mask,59,"// .loophead:; // lr.w dest, (addr); // and scratch, dest, mask; // bne scratch, cmpval, done",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:70,Availability,mask,mask,70,"// .looptail:; // xor scratch, dest, newval; // and scratch, scratch, mask; // xor scratch, dest, scratch; // sc.w scratch, scratch, (adrr); // bnez scratch, loophead",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp:555,Energy Efficiency,schedul,scheduling,555,"//===-- RISCVExpandPseudoInsts.cpp - Expand pseudo instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp:49,Performance,load,loading,49,// This function expands PseudoRV32ZdinxLoad for loading a double-precision; // floating-point value from memory into an equivalent instruction sequence for; // RV32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp:88,Performance,load,loading,88,"// If the register of operand 1 is equal to the Lo register, then swap the; // order of loading the Lo and Hi statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:45,Availability,Mask,Mask,45,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:442,Availability,mask,masks,442,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:392,Performance,perform,performs,392,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:3,Availability,Mask,Mask,3,// Mask operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:26,Availability,mask,mask,26,"// vmv.v.v doesn't have a mask operand, so we may be able to inflate the; // register class for the destination and merge operands e.g. VRNoV0 -> VR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:23,Availability,Mask,MaskOpIdxs,23,// TODO: Increment all MaskOpIdxs in tablegen by num of explicit defs?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:3,Availability,Mask,Masked,3,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:53,Availability,mask,mask,53,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:102,Availability,mask,mask,102,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:226,Availability,mask,mask,226,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:91,Safety,risk,risk,91,"// Do not save RA to the SCS if it's not saved to the regular stack,; // i.e. RA is not at risk of being overwritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Performance,Load,Load,3,"// Load return address from shadow call stack; // l[w|d] ra, -[4|8](gp); // addi gp, gp, -[4|8]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:105,Performance,load,load,105,"// Return encoded value and register count for PUSH/POP instruction,; // representing registers to store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:215,Modifiability,variab,variable,215,"// Return true if the specified function should have a dedicated frame; // pointer register. This is true if frame pointer elimination is; // disabled, if it needs dynamic stack realignment, if the function has; // variable sized allocas, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:181,Security,access,access,181,"// If we do not reserve stack space for outgoing arguments in prologue,; // we will adjust the stack pointer before call instruction. After the; // adjustment, we can not use SP to access the stack objects for the; // arguments. Instead, use BP to access these stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:248,Security,access,access,248,"// If we do not reserve stack space for outgoing arguments in prologue,; // we will adjust the stack pointer before call instruction. After the; // adjustment, we can not use SP to access the stack objects for the; // arguments. Instead, use BP to access these stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:238,Modifiability,variab,variable,238,"// When using SP or BP to access stack objects, we may require extra padding; // to ensure the bottom of the RVV stack is correctly aligned within the main; // stack. We calculate this as the amount required to align the scalar local; // variable section up to the RVV alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:26,Security,access,access,26,"// When using SP or BP to access stack objects, we may require extra padding; // to ensure the bottom of the RVV stack is correctly aligned within the main; // stack. We calculate this as the amount required to align the scalar local; // variable section up to the RVV alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize compile time offset case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:71,Deployability,update,updates,71,// We must keep the stack pointer aligned through any intermediate; // updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Performance,Scalab,ScalableOffset,48,// Build up the expression (Reg + FixedOffset + ScalableOffset * VLENB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:701,Integrability,depend,depending,701,"// If libcalls are used to spill and restore callee-saved registers, the frame; // has two sections; the opaque section managed by the libcalls, and the; // section managed by MachineFrameInfo which can also hold callee saved; // registers in fixed stack slots, both of which have negative frame indices.; // This gets even more complicated when incoming arguments are passed via the; // stack, as these too have negative frame indices. An example is detailed; // below:; //; // | incoming arg | <- FI[-3]; // | libcallspill |; // | calleespill | <- FI[-2]; // | calleespill | <- FI[-1]; // | this_frame | <- FI[0]; //; // For negative frame indices, the offset from the frame pointer will differ; // depending on which of these groups the frame index applies to.; // The following calculates the correct offset knowing the number of callee; // saved registers spilt by the two methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:122,Energy Efficiency,allocate,allocate,122,// FIXME (note copied from Lanai): This appears to be overallocating. Needs; // investigation. Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Early exit if there is no need to allocate on the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:69,Availability,error,error,69,"// If the stack pointer has been marked as reserved, then produce an error if; // the frame requires stack allocation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:30,Energy Efficiency,reduce,reduce,30,// Split the SP adjustment to reduce the offsets of callee saved spill.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:7,Availability,avail,available,7,// Use available stack adjustment in push instruction to allocate additional; // stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:57,Energy Efficiency,allocate,allocate,57,// Use available stack adjustment in push instruction to allocate additional; // stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space on the stack if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:81,Usability,simpl,simply,81,// Offsets for objects with fixed locations (IE: those saved by libcall) are; // simply calculated from the frame index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:183,Modifiability,variab,variable,183,"// FP will be used to restore the frame in the epilogue, so we need; // another base register BP to record SP after re-alignment. SP will; // track the current stack after allocating variable sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:378,Modifiability,variab,variables,378,"// Restore the stack pointer using the value of the frame pointer. Only; // necessary if the stack pointer was modified, meaning the stack size is; // unknown.; //; // In order to make sure the stack point is right through the EH region,; // we also need to restore stack pointer from the frame pointer if we; // don't preserve stack space within prologue/epilogue for outgoing variables,; // normally it's just checking the variable sized object is present or not; // is enough, but we also don't preserve that at prologue/epilogue when; // have vector objects in stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:425,Modifiability,variab,variable,425,"// Restore the stack pointer using the value of the frame pointer. Only; // necessary if the stack pointer was modified, meaning the stack size is; // unknown.; //; // In order to make sure the stack point is right through the EH region,; // we also need to restore stack pointer from the frame pointer if we; // don't preserve stack space within prologue/epilogue for outgoing variables,; // normally it's just checking the variable sized object is present or not; // is enough, but we also don't preserve that at prologue/epilogue when; // have vector objects in stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:7,Availability,avail,available,7,// Use available stack adjustment in pop instruction to deallocate stack; // space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:229,Energy Efficiency,allocate,allocated,229,"// If the stack was realigned, the frame pointer is set in order to allow; // SP to be restored, so we need another base register to record the stack; // after realignment.; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | realignment (the size of | | |; // | this area is not counted | | |; // | in MFI.getStackSize()) | | |; // |--------------------------| -- |-- MFI.getStackSize(); // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize() or in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:1075,Modifiability,variab,variables,1075,"// If the stack was realigned, the frame pointer is set in order to allow; // SP to be restored, so we need another base register to record the stack; // after realignment.; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | realignment (the size of | | |; // | this area is not counted | | |; // | in MFI.getStackSize()) | | |; // |--------------------------| -- |-- MFI.getStackSize(); // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize() or in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:149,Energy Efficiency,allocate,allocated,149,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:344,Modifiability,variab,variables,344,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:27,Performance,scalab,scalable,27,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:20,Security,access,access,20,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:133,Energy Efficiency,allocate,allocated,133,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:791,Modifiability,variab,variables,791,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:20,Security,access,access,20,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Create a buffer of RVV objects to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate all RVV locals and spills,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the maximum alignment of the RVV stack section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:178,Availability,down,down,178,"// Ensure the alignment of the RVV stack. Since we want the most-aligned; // object right at the bottom (i.e., any padding at the top of the frame),; // readjust all RVV objects down by the alignment padding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:18,Performance,scalab,scalable,18,"// For RVV spill, scalable stack offsets computing requires up to two scratch; // registers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:22,Performance,scalab,scalable,22,"// For RVV spill, non-scalable stack offsets computing requires up to one; // scratch register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:85,Performance,Scalab,Scalable,85,// ADDI instruction's destination register can be used for computing; // offsets. So Scalable stack offsets require up to one scratch register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:164,Availability,error,errors,164,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:97,Performance,scalab,scalable,97,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:443,Security,access,access,443,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:80,Performance,scalab,scalable-vector,80,// Ensure the entire stack is aligned to at least the RVV requirement: some; // scalable-vector object alignments are not considered by the; // target-independent code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:7,Performance,load,loads,7,// RVV loads & stores have no capacity to hold the immediate address offsets; // so we must always reserve an emergency spill slot if the MachineFunction; // contains any RVV spills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:57,Modifiability,variab,variables,57,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:98,Modifiability,variab,variable,98,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:148,Security,access,accessed,148,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:281,Energy Efficiency,allocate,allocate,281,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:196,Modifiability,variab,variable,196,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:47,Energy Efficiency,reduce,reduce,47,"// We would like to split the SP adjustment to reduce prologue/epilogue; // as following instructions. In this way, the offset of the callee saved; // register could fit in a single store. Supposed that the first sp adjust; // amount is 2032.; // add sp,sp,-2032; // sw ra,2028(sp); // sw s0,2024(sp); // sw s1,2020(sp); // sw s3,2012(sp); // sw s4,2008(sp); // add sp,sp,-64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:213,Performance,load,load,213,"// FirstSPAdjustAmount is chosen at most as (2048 - StackAlign) because; // 2048 will cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment. 2048 has; // 16-byte alignment. The stack alignment for RV32 and RV64 is 16 and for; // RV32E it is 4. So (2048 - StackAlign) will satisfy the stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:104,Safety,avoid,avoid,104,"// Compared with amount (2048 - StackAlign), StackSize needs to; // satisfy the following conditions to avoid using more instructions; // to adjust the sp after adjusting the amount, such as; // StackSize meets the condition (StackSize <= 2048 + RVCompressLen),; // case1: Amount is 2048 - StackAlign: use addi + addi to adjust sp.; // case2: Amount is RVCompressLen: use addi + addi to adjust sp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Availability,recover,recover,48,"// In the epilogue, addi sp, sp, 496 is used to recover the sp and it; // can be compressed(C.ADDI16SP, offset can be [-512, 496]), but; // addi sp, sp, 512 can not be compressed. So try to use 496 first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Safety,recover,recover,48,"// In the epilogue, addi sp, sp, 496 is used to recover the sp and it; // can be compressed(C.ADDI16SP, offset can be [-512, 496]), but; // addi sp, sp, 512 can not be compressed. So try to use 496 first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:288,Performance,load,load-to-use,288,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:320,Performance,load,loading,320,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:353,Performance,load,loadRegFromStackSlot,353,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:274,Safety,avoid,avoid,274,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:305,Safety,hazard,hazard,305,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:44,Performance,optimiz,optimizing,44,// Keep the conventional code flow when not optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:31,Safety,safe,safe,31,"// Doing a tail call should be safe if there are no successors, because either; // we have a returning block or the end of the block is unreachable, so the; // restore will be eliminated regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h:63,Energy Efficiency,allocate,allocated,63,// We don't support putting RISC-V Vector objects into the pre-allocated; // local frame block at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:3,Performance,Cache,Cache,3,"// Cache of the BasePtr and Stride determined from this GEP. When a GEP is; // used by multiple gathers/scatters, this allow us to reuse the scalar; // instructions we created for the first gather/scatter for the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:32,Availability,mask,mask,32,// TODO: Should we consider the mask when looking for a stride?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:107,Deployability,update,update,107,"// Recursively, walk about the use-def chain until we find a Phi with a strided; // start value. Build and update a scalar recurrence as we unwind the recursion.; // We also update the Stride as we unwind. Our goal is to move all of the; // arithmetic out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:174,Deployability,update,update,174,"// Recursively, walk about the use-def chain until we find a Phi with a strided; // start value. Build and update a scalar recurrence as we unwind the recursion.; // We also update the Stride as we unwind. Our goal is to move all of the; // arithmetic out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:25,Performance,perform,perform,25,// A phi node we want to perform this function on should be from the; // loop header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:49,Performance,load,load,49,// A gather/scatter of a splat is a zero strided load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:37,Usability,simpl,simplify,37,// We need to find a vector index to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:136,Integrability,wrap,wrap,136,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:310,Testability,test,test,310,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:287,Usability,simpl,simplifies,287,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite gather/scatter to form strided load/store if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:42,Performance,load,load,42,// Rewrite gather/scatter to form strided load/store if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:22,Performance,load,load,22,/// Get the EEW for a load or store instruction. Return std::nullopt if MI is; /// not a load or store which ignores SEW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:89,Performance,load,load,89,/// Get the EEW for a load or store instruction. Return std::nullopt if MI is; /// not a load or store which ignores SEW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:43,Availability,mask,mask,43,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:120,Performance,load,load,120,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:104,Testability,log,logical,104,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,Availability,mask,mask,37,// A Log2SEW of 0 is an operation on mask registers only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:30,Availability,mask,mask,30,// Behavior is independent of mask policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:3,Performance,Load,Loads,3,"// Loads and stores with implicit EEW do not demand SEW or LMUL directly.; // They instead demand the ratio of the two which is used in computing; // EMUL, but which allows us the flexibility to change SEW and LMUL; // provided we don't change the ratio.; // Note: We assume that the instructions initial SEW is the EEW encoded; // in the opcode. This is asserted when constructing the VSETVLIInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:355,Testability,assert,asserted,355,"// Loads and stores with implicit EEW do not demand SEW or LMUL directly.; // They instead demand the ratio of the two which is used in computing; // EMUL, but which allows us the flexibility to change SEW and LMUL; // provided we don't change the ratio.; // Note: We assume that the instructions initial SEW is the EEW encoded; // in the opcode. This is asserted when constructing the VSETVLIInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:16,Availability,mask,mask,16,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:128,Availability,avail,available,128,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:101,Testability,log,logic,101,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:54,Performance,queue,queue,54,// Keeps track of whether the block is already in the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,Availability,mask,mask,37,// A Log2SEW of 0 is an operation on mask registers only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:102,Energy Efficiency,reduce,reduces,102,"// If we know the exact VLEN, see if we can use the constant encoding; // for the VLMAX instead. This reduces register pressure slightly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:172,Modifiability,extend,extending,172,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:131,Safety,avoid,avoid,131,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:166,Safety,avoid,avoid,166,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:38,Integrability,depend,depending,38,// Otherwise use an AVL of 1 to avoid depending on previous vl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:32,Safety,avoid,avoid,32,// Otherwise use an AVL of 1 to avoid depending on previous vl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:124,Availability,mask,masked,124,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:455,Integrability,depend,depend,455,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:443,Performance,latency,latency,443,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:139,Deployability,toggle,toggles,139,"// If we don't use LMUL or the SEW/LMUL ratio, then adjust LMUL so that we; // maintain the SEW/LMUL ratio. This allows us to eliminate VL toggles in more; // places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:359,Modifiability,extend,extending,359,"// If MI only demands that VL has the same zeroness, we only need to set the; // AVL if the zeroness differs. This removes a vsetvli entirely if the types; // match or allows use of cheaper avl preserving variant if VLMAX doesn't; // change. If VLMAX might change, we couldn't use the 'vsetvli x0, x0, vtype""; // variant, so we avoid the transform to prevent extending live range of an; // avl register operand.; // TODO: We can probably relax this for immediates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:328,Safety,avoid,avoid,328,"// If MI only demands that VL has the same zeroness, we only need to set the; // AVL if the zeroness differs. This removes a vsetvli entirely if the types; // match or allows use of cheaper avl preserving variant if VLMAX doesn't; // change. If VLMAX might change, we couldn't use the 'vsetvli x0, x0, vtype""; // variant, so we avoid the transform to prevent extending live range of an; // avl register operand.; // TODO: We can probably relax this for immediates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:15,Availability,mask,mask,15,// Prefer tail/mask agnostic since it can be relaxed to undisturbed later; // if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:34,Availability,fault,fault,34,// Update AVL to vl-output of the fault first load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:3,Deployability,Update,Update,3,// Update AVL to vl-output of the fault first load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:46,Performance,load,load,46,// Update AVL to vl-output of the fault first load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:29,Deployability,update,updates,29,"// If this is something that updates VL/VTYPE that we don't know about, set; // the state to unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:26,Performance,cache,cache,26,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:96,Performance,perform,performed,96,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:172,Performance,cache,cache,172,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:196,Testability,log,logic,196,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:93,Safety,avoid,avoid,93,// If the exit from the predecessor has the VTYPE we are looking for; // we might be able to avoid a VSETVLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:47,Deployability,update,update,47,"// If this is an explicit VSETVLI or VSETIVLI, update our state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:4,Performance,Perform,Perform,4,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:27,Safety,redund,redundancy,27,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:12,Usability,simpl,simple,12,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,Safety,redund,redundancy,37,"// Unreachable, single pred, or full redundancy. Note that FRE is handled by; // phase 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:101,Availability,avail,available,101,"// If the AVL value is a register (other than our VLMAX sentinel),; // we need to prove the value is available at the point we're going; // to insert the vsetvli at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:72,Availability,Avail,AvailableInfo,72,"// Model the effect of changing the input state of the block MBB to; // AvailableInfo. We're looking for two issues here; one legality,; // one profitability.; // 1) If the block doesn't use some of the fields from VL or VTYPE, we; // may hit the end of the block with a different end state. We can; // not make this change without reflowing later blocks as well.; // 2) If we don't actually remove a transition, inserting a vsetvli; // into the predecessor block would be correct, but unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:12,Deployability,update,update,12,"// Finally, update both data flow state and insert the actual vsetvli.; // Doing both keeps the code in sync with the dataflow results, which; // is critical for correctness of phase 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:103,Modifiability,rewrite,rewrite,103,"// If the VL values aren't equal, return false if either a) the former is; // demanded, or b) we can't rewrite the former to be the later for; // implementation reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:3,Performance,Perform,Perform,3,// Perform partial redundancy elimination of vsetvli transitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:19,Safety,redund,redundancy,19,// Perform partial redundancy elimination of vsetvli transitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:98,Safety,avoid,avoid,98,// Phase 3 - add any vsetvli instructions needed in the block. Use the; // Phase 2 information to avoid adding vsetvlis before the first vector; // instruction in the block if the VL/VTYPE is satisfied by its; // predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:603,Availability,redundant,redundant,603,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:755,Availability,avail,available,755,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:976,Availability,avail,available,976,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:1174,Energy Efficiency,reduce,reduce,1174,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:575,Performance,optimiz,optimize,575,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:597,Safety,avoid,avoid,597,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:603,Safety,redund,redundant,603,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:1074,Safety,redund,redundancy,1074,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:22,Availability,avail,available,22,// Keeps track of the available VXRM value at the start of the basic bloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:22,Availability,avail,available,22,// Keeps track of the available VXRM value at the end of the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:54,Performance,queue,queue,54,// Keeps track of whether the block is already in the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:30,Availability,avail,available,30,"// If we don't have any valid available info, wait until we do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:44,Availability,avail,available,44,// Insert VXRM write if anticipated and not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:11,Availability,avail,available,11,"// If it's available out of the predecessor, then we're ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:289,Availability,redundant,redundant,289,"// If all our successors anticipate a value, do the insert.; // NOTE: It's possible that not all predecessors of our successor provide the; // correct value. This can occur on critical edges. If we don't split the; // critical edge we'll also have a write vxrm in the succesor that is; // redundant with this one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:289,Safety,redund,redundant,289,"// If all our successors anticipate a value, do the insert.; // NOTE: It's possible that not all predecessors of our successor provide the; // correct value. This can occur on critical edges. If we don't split the; // critical edge we'll also have a write vxrm in the succesor that is; // redundant with this one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:21,Availability,avail,available,21,// Phase 2 - Compute available VXRM using a forward walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:41,Integrability,depend,depend,41,"// If the producing instruction does not depend on vsetvli, do not; // convert COPY to vmv.v.v. For example, VL1R_V or PseudoVRELOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:13,Performance,optimiz,optimizations,13,// The below optimizations narrow the load so they are only valid for little; // endian.; // TODO: Support big endian by adding an offset into the frame object?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:38,Performance,load,load,38,// The below optimizations narrow the load so they are only valid for little; // endian.; // TODO: Support big endian by adding an offset into the frame object?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:8,Performance,load,load,8,// Fold load from stack followed by sext.b/sext.h/sext.w/zext.b/zext.h/zext.w.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:15,Deployability,update,update,15,// We may also update the jump target to RestoreBB later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:302,Performance,optimiz,optimization,302,"// For two constants C0 and C1 from; // ```; // li Y, C0; // li Z, C1; // ```; // 1. if C1 = C0 + 1; // we can turn:; // (a) blt Y, X -> bge X, Z; // (b) bge Y, X -> blt X, Z; //; // 2. if C1 = C0 - 1; // we can turn:; // (a) blt X, Y -> bge Z, X; // (b) bge X, Y -> blt Z, X; //; // To make sure this optimization is really beneficial, we only; // optimize for cases where Y had only one use (i.e. only used by the branch).; // Right now we only care about LI (i.e. ADDI x0, imm)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:349,Performance,optimiz,optimize,349,"// For two constants C0 and C1 from; // ```; // li Y, C0; // li Z, C1; // ```; // 1. if C1 = C0 + 1; // we can turn:; // (a) blt Y, X -> bge X, Z; // (b) bge Y, X -> blt X, Z; //; // 2. if C1 = C0 - 1; // we can turn:; // (a) blt X, Y -> bge Z, X; // (b) bge X, Y -> blt Z, X; //; // To make sure this optimization is really beneficial, we only; // optimize for cases where Y had only one use (i.e. only used by the branch).; // Right now we only care about LI (i.e. ADDI x0, imm)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Performance,load,load,12,// Either a load from immediate instruction or X0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Modifiability,extend,extend,12,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:40,Usability,clear,clear,40,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:64,Integrability,wrap,wrap,64,"// Might be case 2.; // For unsigned cases, we don't want C1 to wrap back to UINT64_MAX; // when C0 is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Modifiability,extend,extend,12,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:40,Usability,clear,clear,40,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:3,Deployability,Update,Update,3,// Update SeenMIs set: register newly created MI and erase removed DefMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:17,Performance,load,load,17,// c.ntl.all + c.load/c.store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:15,Performance,load,load,15,// c.ntl.all + load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:13,Performance,load,load,13,// ntl.all + load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:19,Deployability,patch,patchpoint,19,// The size of the patchpoint intrinsic is the number of bytes requested,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:81,Energy Efficiency,schedul,scheduling,81,"// The option is unused. Choose Local strategy only for in-order cores. When; // scheduling model is unspecified, use MinInstrCount strategy as more; // generic one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:382,Performance,perform,performing,382,"// From RISC-V ISA spec, if both the high and low bits of the same product; // are required, then the recommended code sequence is:; //; // MULH[[S]U] rdh, rs1, rs2; // MUL rdl, rs1, rs2; // (source register specifiers must be in same order and rdh cannot be the; // same as rs1 or rs2); //; // Microarchitectures can then fuse these into a single multiply operation; // instead of performing two separate multiplies.; // MachineCombiner may reassociate MUL operands and lose the fusion; // opportunity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:73,Integrability,depend,dependency,73,"// Try combining even if fmul has more than one use as it eliminates; // dependency between fadd(fsub) and fmul. However, it can extend liveranges; // for fmul operands, so reject the transformation in register pressure; // reduction mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:129,Modifiability,extend,extend,129,"// Try combining even if fmul has more than one use as it eliminates; // dependency between fadd(fsub) and fmul. However, it can extend liveranges; // for fmul operands, so reject the transformation in register pressure; // reduction mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:47,Modifiability,extend,extending,47,"// We need to clear kill flags since we may be extending the live range past; // a kill. If the mul had kill flags, we can preserve those since we know; // where the previous range stopped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:14,Usability,clear,clear,14,"// We need to clear kill flags since we may be extending the live range past; // a kill. If the mul had kill flags, we can preserve those since we know; // where the previous range stopped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:38,Performance,load,loads,38,"// Conservatively, only handle scalar loads/stores for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:139,Security,access,access,139,"// Only examine the first ""base"" operand of each instruction, on the; // assumption that it represents the real base address of the memory access.; // Other operands are typically offsets or indices from this base address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Performance,cache,cache,12,// Assume a cache line size of 64 bytes if no size is set in RISCVSubtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:70,Performance,cache,cache,70,"// Cluster if the memory operations are on the same or a neighbouring cache; // line, but limit the maximum ClusterSize to avoid creating too much; // additional register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:123,Safety,avoid,avoid,123,"// Cluster if the memory operations are on the same or a neighbouring cache; // line, but limit the maximum ClusterSize to avoid creating too much; // additional register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:78,Security,access,accessed,78,"// Set BaseReg (the base register operand), Offset (the byte offset being; // accessed) and the access Width of the passed instruction that reads/writes; // memory. Returns false if the instruction does not read/write memory or the; // BaseReg/Offset/Width can't be determined. Is not guaranteed to always; // recognise base operands and offsets in all cases.; // TODO: Add an IsScalable bool ref argument (like the equivalent AArch64; // function) and set it as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:96,Security,access,access,96,"// Set BaseReg (the base register operand), Offset (the byte offset being; // accessed) and the access Width of the passed instruction that reads/writes; // memory. Returns false if the instruction does not read/write memory or the; // BaseReg/Offset/Width can't be determined. Is not guaranteed to always; // recognise base operands and offsets in all cases.; // TODO: Add an IsScalable bool ref argument (like the equivalent AArch64; // function) and set it as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:149,Performance,load,load,149,"// Here we assume the standard RISC-V ISA, which uses a base+offset; // addressing mode. You'll need to relax these conditions to support custom; // load/store instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:118,Performance,load,loaded,118,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:218,Security,access,access,218,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:287,Security,access,access,287,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:315,Security,access,accesses,315,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:8,Safety,safe,safe,8,// It's safe to outline from MF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:17,Safety,safe,safety,17,// More accurate safety checking is done in getOutliningCandidateInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:52,Safety,unsafe,unsafe,52,// Make sure the operands don't reference something unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:25,Deployability,toggle,toggle,25,// It only make sense to toggle these between clobbering the; // addend/subtrahend/minuend one of the multiplicands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:163,Deployability,update,update,163,"// Use operand 1 was tied to early-clobber def operand 0, so its live; // interval could have ended at an early-clobber slot. Now they are not; // tied we need to update it to the normal register slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:23,Testability,Log,Logical,23,// 11.5 Vector Bitwise Logical Instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:35,Safety,safe,safely,35,// Return true if the function can safely be outlined from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:25,Safety,safe,safe,25,"// Return true if MBB is safe to outline from, and return any target-specific; // information in Flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:3,Availability,Mask,Mask,3,// Mask assignments for floating-point,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:100,Energy Efficiency,reduce,reduce,100,// Convert integer SPLAT_VECTOR to VMV_V_X_VL and floating-point; // SPLAT_VECTOR to VFMV_V_F_VL to reduce isel burden.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:79,Performance,load,load,79,// Lower SPLAT_VECTOR_SPLIT_I64 to two scalar stores and a stride 0 vector; // load. Done after lowering and combining so that we have a chance to; // optimize this to VMV_V_X_VL when the upper bits aren't needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:151,Performance,optimiz,optimize,151,// Lower SPLAT_VECTOR_SPLIT_I64 to two scalar stores and a stride 0 vector; // load. Done after lowering and combining so that we have a chance to; // optimize this to VMV_V_X_VL when the upper bits aren't needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,Availability,mask,masked,88,"// FIXME: This is here only because the VMerge transform doesn't; // know how to handle masked true inputs. Once that has been moved; // to post-ISEL, this can be deleted as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:138,Performance,optimiz,optimization,138,"// After we're done with everything else, convert IMPLICIT_DEF; // passthru operands to NoRegister. This is required to workaround; // an optimization deficiency in MachineCSE. This really should; // be merged back into each of the patterns (i.e. there's no good; // reason not to go directly to NoReg), but is being done this way; // to allow easy backporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:141,Safety,avoid,avoids,141,"// See if we can create this constant as (ADD (SLLI X, C), X) where X is at; // worst an LUI+ADDIW. This will require an extra register, but avoids a; // constant pool.; // If we have Zba we can use (ADD_UW X, (SLLI X, 32)) to handle cases where; // low and high 32 bits are the same and bit 31 and 63 are set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask needs to be copied to V0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:28,Availability,mask,masked,28,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Performance,load,load,35,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:153,Performance,load,loads,153,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:2,Availability,Mask,MaskAgnostic,2,/*MaskAgnostic*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Performance,load,loads,35,// Target does not support indexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:87,Modifiability,extend,extending,87,"// If the upper XLen-16 bits are not used, try to convert this to a simm12; // by sign extending bit 15.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:83,Modifiability,extend,extending,83,// If the upper 32-bits are not used try to convert this into a simm32 by; // sign extending bit 32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (shl (and X, C2), C) -> (slli (srliw X, C3), C3+C) where C2 has; // 32 leading zeros and C3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (srl (and X, C2), C) -> (slli (srliw X, C3), C3-C) where C2 has; // 32 leading zeros and C3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:99,Availability,mask,mask,99,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:227,Safety,avoid,avoids,227,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:200,Usability,Simpl,SimplifyDemandedBits,200,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:10,Availability,mask,mask,10,"// If the mask has 32 trailing ones, use SRLI on RV32 or SRLIW on RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:413,Performance,optimiz,optimization,413,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:360,Security,expose,expose,360,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:208,Testability,test,tests,208,"// Keep track of whether this is a c.andi. If we can't use c.andi, the; // shift pair might offer more compression opportunities.; // TODO: We could check for C extension here, but we don't have many lit; // tests with the C extension enabled so not checking gets better; // coverage.; // TODO: What if ANDI faster than shift?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:32,Availability,mask,mask,32,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Usability,Clear,Clear,3,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:70,Availability,mask,mask,70,"// Turn (and (srl x, c2) c1) -> (srli (slli x, c3-c2), c3) if c1 is a mask; // with c3 leading zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:84,Availability,mask,mask,84,"// (and (srl (sexti32 Y), c2), c1) -> (srliw (sraiw Y, 31), c3 - 32); // if c1 is a mask with c3 leading zeros and c2 >= 32 and c3-c2==1.; //; // This pattern occurs when (i32 (srl (sra 31), c3 - 32)) is type; // legalized and goes through DAG combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:66,Availability,avail,available,66,"// Try to use an unsigned bitfield extract (e.g., th.extu) if; // available.; // Transform (and (srl x, C2), C1); // -> (<bfextract> x, msb, lsb); //; // Make sure to keep this below the SRLIW cases, as we always want to; // prefer the more common instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:68,Availability,mask,mask,68,"// Turn (and (shl x, c2), c1) -> (srli (slli c2+c3), c3) if c1 is a mask; // shifted by c2 bits with c3 leading zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:83,Availability,mask,mask,83,"// Turn (and (shr x, c2), c1) -> (slli (srli x, c2+c3), c3) if c1 is a; // shifted mask with c2 leading zeros and c3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:83,Availability,mask,mask,83,"// Turn (and (shl x, c2), c1) -> (slli (srli x, c3-c2), c3) if c1 is a; // shifted mask with no leading zeros and c3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:9,Availability,mask,masks,9,"// If C1 masks off the upper bits only (but can't be formed as an; // ANDI), use an unsigned bitfield extract (e.g., th.extu), if; // available.; // Transform (and x, C1); // -> (<bfextract> x, msb, lsb)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:134,Availability,avail,available,134,"// If C1 masks off the upper bits only (but can't be formed as an; // ANDI), use an unsigned bitfield extract (e.g., th.extu), if; // available.; // Transform (and x, C1); // -> (<bfextract> x, msb, lsb)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:310,Safety,avoid,avoid,310,"// Special case for calculating (mul (and X, C2), C1) where the full product; // fits in XLen bits. We can shift X left by the number of leading zeros in; // C2 and shift C1 left by XLen-lzcnt(C2). This will ensure the final; // product has XLen trailing zeros, putting it in the output of MULHU. This; // can avoid materializing a constant in a register for C2.; // RHS should be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:24,Availability,mask,mask,24,// Constant should be a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,Modifiability,extend,extend,33,"// If this RV32, we need to sign extend the constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask operations use the LMUL from the mask type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:41,Availability,mask,mask,41,// Mask operations use the LMUL from the mask type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:54,Availability,mask,mask,54,"// If vmsgeu_mask with 0 immediate, expand it to vmor mask, maskedoff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:60,Availability,mask,maskedoff,60,"// If vmsgeu_mask with 0 immediate, expand it to vmor mask, maskedoff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:29,Availability,Mask,MaskedOff,29,// We don't need vmor if the MaskedOff and the Mask are the same; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:47,Availability,Mask,Mask,47,// We don't need vmor if the MaskedOff and the Mask are the same; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:10,Availability,Mask,MaskedOff,10,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Availability,Mask,Mask,34,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:119,Safety,avoid,avoids,119,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask needs to be copied to V0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,Availability,mask,mask,88,"// Otherwise use; // vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0; // The result is mask undisturbed.; // We use the same instructions to emulate mask agnostic behavior, because; // the agnostic result can be either undisturbed or all 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:150,Availability,mask,mask,150,"// Otherwise use; // vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0; // The result is mask undisturbed.; // We use the same instructions to emulate mask agnostic behavior, because; // the agnostic result can be either undisturbed or all 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Deployability,update,update,34,"// vmxor.mm vd, vd, v0 is used to update active value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:72,Performance,scalab,scalable,72,// Just drop bitcasts between vectors if both are fixed or both are; // scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Performance,scalab,scalable-vector,25,// Establish the correct scalable-vector types for any fixed-length type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:43,Testability,assert,asserts,43,// Silence unused variable warning without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Performance,scalab,scalable-vector,25,// Establish the correct scalable-vector types for any fixed-length type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Performance,load,load,34,// Try to match splat of a scalar load to a strided load with stride of x0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:52,Performance,load,load,52,// Try to match splat of a scalar load to a strided load with stride of x0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:19,Deployability,update,update,19,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:82,Deployability,update,update,82,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:14,Performance,load,load,14,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:77,Performance,load,load,77,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:36,Deployability,update,update,36,// We could deal with more VL if we update the VSETVLI insert pass to; // avoid introducing more VSETVLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:74,Safety,avoid,avoid,74,// We could deal with more VL if we update the VSETVLI insert pass to; // avoid introducing more VSETVLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:47,Performance,load,load,47,"// If VL=1, then we don't need to do a strided load and can just do a; // regular load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:82,Performance,load,load,82,"// If VL=1, then we don't need to do a strided load and can just do a; // regular load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:21,Performance,load,load,21,// Only do a strided load if we have optimized zero-stride vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,Performance,optimiz,optimized,37,// Only do a strided load if we have optimized zero-stride vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:66,Performance,load,load,66,// Only do a strided load if we have optimized zero-stride vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:67,Performance,load,loads,67,// Is this ADD instruction only used as the base pointer of scalar loads and; // stores?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:44,Modifiability,variab,variable,44,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:137,Modifiability,variab,variable,137,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:228,Performance,load,load,228,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:169,Safety,safe,safety,169,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:138,Performance,load,load,138,"// Handle immediates in the range [-4096,-2049] or [2048, 4094]. We can use; // an ADDI for part of the offset and fold the rest into the load/store.; // This mirrors the AddiPair PatFrag in RISCVInstrInfo.td.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:215,Performance,load,loads,215,"// For larger immediates, we might be able to save one instruction from; // constant materialization by folding the Lo12 bits of the immediate into; // the address. We should only do this if the ADD is only used by loads and; // stores that can fold the lo12 bits. Otherwise, the ADD will get iseled; // separately with the full materialized immediate creating extra; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:78,Availability,mask,mask,78,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Energy Efficiency,power,power,35,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:47,Availability,mask,mask,47,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,Performance,optimiz,optimized,33,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Usability,Simpl,SimplifyDemandedBits,3,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:80,Safety,avoid,avoid,80,"// If we are shifting by X+N where N == 0 mod Size, then just shift by X; // to avoid the ADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// Look for (and (shl y, c2), c1) where c1 is a shifted mask with no; // leading zeros and c3 trailing zeros. We can use an SRLI by c2+c3; // followed by a SHXADD with c3 for the X amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// Look for (and (shr y, c2), c1) where c1 is a shifted mask with c2; // leading zeros and c3 trailing zeros. We can use an SRLI by C3; // followed by a SHXADD using c3 for the X amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Availability,Mask,Mask,25,"// Look for (shl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C1+C3==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:42,Availability,Mask,Mask,42,"// Look for (shl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C1+C3==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Availability,Mask,Mask,25,"// Look for (srl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C3-C1==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:42,Availability,Mask,Mask,42,"// Look for (srl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C3-C1==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// Look for (and (shl y, c2), c1) where c1 is a shifted mask with; // 32-ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2-ShAmt followed by SHXADD_UW with ShAmt for the X amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:582,Safety,detect,detect,582,"// Return true if all users of this SDNode* only consume the lower \p Bits.; // This can be used to form W instructions for add/sub/mul/shl even when the; // root isn't a sext_inreg. This can allow the ADDW/SUBW/MULW/SLLIW to CSE if; // SimplifyDemandedBits has made it so some users see a sext_inreg and some; // don't. The sext_inreg+add/sub/mul/shl will get selected, but still leave; // the add/sub/mul/shl to become non-W instructions. By checking the users we; // may be able to use a W instruction and CSE with the other instruction if; // this has happened. We could try to detect that the CSE opportunity exists; // before doing this, but that would be more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:237,Usability,Simpl,SimplifyDemandedBits,237,"// Return true if all users of this SDNode* only consume the lower \p Bits.; // This can be used to form W instructions for add/sub/mul/shl even when the; // root isn't a sext_inreg. This can allow the ADDW/SUBW/MULW/SLLIW to CSE if; // SimplifyDemandedBits has made it so some users see a sext_inreg and some; // don't. The sext_inreg+add/sub/mul/shl will get selected, but still leave; // the add/sub/mul/shl to become non-W instructions. By checking the users we; // may be able to use a W instruction and CSE with the other instruction if; // this has happened. We could try to detect that the CSE opportunity exists; // before doing this, but that would be more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:119,Safety,avoid,avoid,119,// The PatFrags that call this may run before RISCVGenDAGISel.inc has checked; // the VT. Ensure the type is scalar to avoid wasting time on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:60,Modifiability,extend,extended,60,// The first operand to add.uw/shXadd.uw is implicitly zero extended from; // 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:289,Modifiability,extend,extended,289,"// The semantics of RISCVISD::VMV_V_X_VL is that when the operand; // type is wider than the resulting vector element type: an implicit; // truncation first takes place. Therefore, perform a manual; // truncation/sign-extension in order to ignore any truncated bits and catch; // any zero-extended immediate.; // For example, we wish to match (i8 -1) -> (XLenVT 255) as a simm5 by first; // sign-extending to (XLenVT -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:396,Modifiability,extend,extending,396,"// The semantics of RISCVISD::VMV_V_X_VL is that when the operand; // type is wider than the resulting vector element type: an implicit; // truncation first takes place. Therefore, perform a manual; // truncation/sign-extension in order to ignore any truncated bits and catch; // any zero-extended immediate.; // For example, we wish to match (i8 -1) -> (XLenVT 255) as a simm5 by first; // sign-extending to (XLenVT -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:181,Performance,perform,perform,181,"// The semantics of RISCVISD::VMV_V_X_VL is that when the operand; // type is wider than the resulting vector element type: an implicit; // truncation first takes place. Therefore, perform a manual; // truncation/sign-extension in order to ignore any truncated bits and catch; // any zero-extended immediate.; // For example, we wish to match (i8 -1) -> (XLenVT 255) as a simm5 by first; // sign-extending to (XLenVT -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:121,Performance,latency,latency,121,// Convert sext.w+add/sub/mul to their W instructions. This will create; // a new independent instruction. This improves latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,Modifiability,extend,extended,26,// Result is already sign extended just remove the sext.w.; // NOTE: We only handle the nodes that are selected with hasAllWUsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Availability,mask,mask,34,// Check that we're using V0 as a mask register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,Availability,mask,mask,37,// Check that we're defining V0 as a mask register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:69,Availability,mask,mask,69,"// Sometimes the VMSET is wrapped in a COPY_TO_REGCLASS, e.g. if the mask came; // from an extract_subvector or insert_subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,Integrability,wrap,wrapped,26,"// Sometimes the VMSET is wrapped in a COPY_TO_REGCLASS, e.g. if the mask came; // from an extract_subvector or insert_subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Availability,mask,mask,35,// Return true if we can make sure mask of N is all-ones mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:57,Availability,mask,mask,57,// Return true if we can make sure mask of N is all-ones mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:12,Availability,mask,masked,12,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:65,Availability,mask,mask,65,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:129,Availability,mask,mask,129,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:12,Availability,mask,mask,12,"// Skip the mask, and the Glue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:73,Availability,Mask,Masked,73,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:162,Availability,mask,masked,162,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:257,Availability,Mask,Masked,257,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:333,Availability,mask,masked,333,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:400,Availability,mask,masked,400,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:438,Availability,mask,masked,438,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,// A vmv.v.v is equivalent to a vmerge with an all-ones mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,Availability,Mask,Mask,26,"// A vmv.v.v won't have a Mask or Glue, instead we'll construct an all-ones; // mask later below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:80,Availability,mask,mask,80,"// A vmv.v.v won't have a Mask or Glue, instead we'll construct an all-ones; // mask later below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:38,Availability,mask,mask,38,// We always have a glue node for the mask at v0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:8,Availability,Mask,Mask,8,"// When Mask is not a true mask, this transformation is illegal for some; // operations whose results are affected by mask, like viota.m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:27,Availability,mask,mask,27,"// When Mask is not a true mask, this transformation is illegal for some; // operations whose results are affected by mask, like viota.m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:118,Availability,mask,mask,118,"// When Mask is not a true mask, this transformation is illegal for some; // operations whose results are affected by mask, like viota.m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:46,Availability,mask,mask,46,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:85,Availability,mask,mask,85,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:136,Availability,mask,mask,136,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Availability,mask,masked,25,// The last operand of a masked instruction may be glued.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,Integrability,depend,depend,88,// Avoid creating cycles in the DAG. We must ensure that none of the other; // operands depend on True through it's Chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating cycles in the DAG. We must ensure that none of the other; // operands depend on True through it's Chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:48,Availability,mask,masked,48,// The vector policy operand may be present for masked intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Availability,mask,mask,35,"// If we end up changing the VL or mask of True, then we need to make sure it; // doesn't raise any observable fp exceptions, since changing the active; // elements will affect how fflags is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// From the preconditions we checked above, we know the mask and thus glue; // for the result node will be taken from True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,Availability,mask,mask,33,"// If we end up using the vmerge mask the vmerge is actually a vmv.v.v, create; // an all-ones mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:95,Availability,mask,mask,95,"// If we end up using the vmerge mask the vmerge is actually a vmv.v.v, create; // an all-ones mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:126,Availability,mask,masked,126,"// For unmasked ""VOp"" with rounding mode operand, that is interfaces like; // (..., rm, vl) or (..., rm, vl, policy).; // Its masked version is (..., vm, rm, vl, policy).; // Check the rounding mode pseudo nodes under RISCVInstrInfoVPseudos.td",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:58,Integrability,interface,interfaces,58,"// For unmasked ""VOp"" with rounding mode operand, that is interfaces like; // (..., rm, vl) or (..., rm, vl, policy).; // Its masked version is (..., vm, rm, vl, policy).; // Check the rounding mode pseudo nodes under RISCVInstrInfoVPseudos.td",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,Availability,mask,mask,37,// Add the glue for the CopyToReg of mask->v0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:283,Performance,perform,performed,283,"/// If our passthru is an implicit_def, use noreg instead. This side; /// steps issues with MachineCSE not being able to CSE expressions with; /// IMPLICIT_DEF operands while preserving the semantic intent. See; /// pr64282 for context. Note that this transform is the last one; /// performed at ISEL DAG to DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:91,Energy Efficiency,schedul,scheduling,91,"// This pass converts a legalized DAG into a RISCV-specific DAG, ready; // for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h:45,Modifiability,extend,extended,45,"// Matches the splat of a value which can be extended or truncated, such that; // only the bottom 8 bits are preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:404,Integrability,interface,interfaces,404,"//===-- RISCVISelLowering.cpp - RISC-V DAG Lowering Implementation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that RISC-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,Energy Efficiency,efficient,efficient,98,// We need the custom lowering to make sure that the resulting sequence; // for the 32bit case is efficient on 64bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Availability,Mask,Mask,3,// Mask VTs are custom-expanded into a series of standard nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Energy Efficiency,power,power-of-two,102,// RVV has native int->float & float->int conversions where the; // element type sizes are within one power-of-two of each other. Any; // wider distances between type sizes have to be lowered as sequences; // which progressively narrow the gap in stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Modifiability,extend,extending,14,"// Expand all extending loads to types larger than this, and truncating; // stores from types larger than this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Performance,load,loads,24,"// Expand all extending loads to types larger than this, and truncating; // stores from types larger than this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Availability,mask,mask,51,// Custom-lower extensions and truncations from/to mask types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Energy Efficiency,power,power-of-two,102,// RVV has native int->float & float->int conversions where the; // element type sizes are within one power-of-two of each other. Any; // wider distances between type sizes have to be lowered as sequences; // which progressively narrow the gap in stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:105,Energy Efficiency,power,power,105,"// Integer VTs are lowered as a series of ""RISCVISD::TRUNCATE_VECTOR_VL""; // nodes which truncate by one power of two at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Usability,simpl,simplify,45,// Custom-lower insert/extract operations to simplify patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:212,Performance,optimiz,optimization,212,"// Expand various CCs to best match the RVV ISA, which natively supports UNE; // but no other unordered comparisons, and supports all ordered comparisons; // except ONE. Additionally, we expand GT,OGT,GE,OGE for optimization; // purposes; they are expanded to their swapped-operand CCs (LT,OLT,LE,OLE),; // and we pattern-match those back to the ""original"", swapping operands once; // more. This way we catch both operations and both ""vf"" and ""fv"" forms with; // fewer patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:99,Energy Efficiency,power,power-of-two,99,// RVV has native FP_ROUND & FP_EXTEND conversions where the element type; // sizes are within one power-of-two of each other. Therefore conversions; // between vXf16 and vXf64 must be lowered as sequences which convert via; // vXf32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Usability,simpl,simplify,45,// Custom-lower insert/extract operations to simplify patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,load,load,3,// load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Performance,scalab,scalable,39,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Safety,avoid,avoid,65,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Performance,scalab,scalable,45,"// We use EXTRACT_SUBVECTOR as a ""cast"" from scalable to fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:46,Availability,mask,masks,46,// Operations below are different for between masks and other vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Modifiability,extend,extending,16,// There are no extending loads or truncating stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:26,Performance,load,loads,26,// There are no extending loads or truncating stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Performance,scalab,scalable,39,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Safety,avoid,avoid,65,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Performance,scalab,scalable,45,"// We use EXTRACT_SUBVECTOR as a ""cast"" from scalable to fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Energy Efficiency,power,power,82,// The maximum VF is for the smallest element width with LMUL=8.; // VF must be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Performance,load,load,36,"// Use return type. If it's segment load, return type is a struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:49,Performance,load,load,49,// Zexts are free if they can be combined with a load.; // Don't advertise i32->i64 zextload as being free for RV64. It interacts; // poorly with type legalization of compares preferring sext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:108,Availability,mask,mask,108,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:183,Availability,mask,mask,183,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Energy Efficiency,power,power,118,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Testability,test,tests,39,// FIXME: Support vectors once we have tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:68,Testability,test,test,68,"// Zbs provides BEXT[_I], which can be used with SEQZ/SNEZ as a bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Testability,test,test,38,// We can use ANDI+SEQZ/SNEZ as a bit test. Y contains the bit position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:190,Availability,down,down,190,"// A constant pool entry may be more aligned thant he load we're trying to; // replace. If we don't support unaligned scalar mem, prefer the constant; // pool.; // TODO: Can the caller pass down the alignment?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Performance,load,load,54,"// A constant pool entry may be more aligned thant he load we're trying to; // replace. If we don't support unaligned scalar mem, prefer the constant; // pool.; // TODO: Can the caller pass down the alignment?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Performance,load,load,22,// Prefer to keep the load if it would require many instructions.; // This uses the same threshold we use for constant pools but doesn't; // check useConstantPoolForLargeInts.; // TODO: Should we keep the load only when we're definitely going to emit a; // constant pool?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:205,Performance,load,load,205,// Prefer to keep the load if it would require many instructions.; // This uses the same threshold we use for constant pools but doesn't; // check useConstantPoolForLargeInts.; // TODO: Should we keep the load only when we're definitely going to emit a; // constant pool?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Usability,undo,undo,118,"// Do form the 'bit extract' pattern.; // If 'X' is a constant, and we transform, then we will immediately; // try to undo the fold, thus causing endless combine loop.; // So only do the transform if X is not a constant. This matches the default; // implementation of this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Safety,avoid,avoid,45,// All uses of the shuffle should be sunk to avoid duplicating it across gpr; // and vector registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,Availability,avail,available,73,"// Return one of the followings:; // (1) `{0-31 value, false}` if FLI is available for Imm's type and FP value.; // (2) `{0-31 value, true}` if Imm is negative and FLI is available for its; // positive counterpart, which will be materialized from the first returned; // element. The second returned element indicated that there should be a FNEG; // followed.; // (3) `{-1, _}` if there is no way FLI can be used to materialize Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:171,Availability,avail,available,171,"// Return one of the followings:; // (1) `{0-31 value, false}` if FLI is available for Imm's type and FP value.; // (2) `{0-31 value, true}` if Imm is negative and FLI is available for its; // positive counterpart, which will be materialized from the first returned; // element. The second returned element indicated that there should be a FNEG; // followed.; // (3) `{-1, _}` if there is no way FLI can be used to materialize Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,Availability,mask,mask,81,// The smallest type we can slide is i8.; // TODO: We can extract index 0 from a mask vector without a slide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Testability,test,test,127,"// TODO: We can do arbitrary slidedowns, but for now only support extracting; // the upper half of a vector until we have more test coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:109,Performance,perform,perform,109,"// If this is a single bit test that can't be handled by ANDI, shift the; // bit to be tested to the MSB and perform a signed compare with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Testability,test,test,27,"// If this is a single bit test that can't be handled by ANDI, shift the; // bit to be tested to the MSB and perform a signed compare with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:87,Testability,test,tested,87,"// If this is a single bit test that can't be handled by ANDI, shift the; // bit to be tested to the MSB and perform a signed compare with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Performance,perform,perform,150,"// Attempt to decompose a subvector insert/extract between VecVT and; // SubVecVT via subregister indices. Returns the subregister index that; // can perform the subvector insert/extract with the given element index, as; // well as the index corresponding to any leftover subvectors that must be; // further inserted/extracted within the register class for SubVecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Availability,down,down,96,"// Try to compose a subregister index that takes us from the incoming; // LMUL>1 register class down to the outgoing one. At each step we half; // the LMUL:; // nxv16i32@12 -> nxv2i32: sub_vrm4_1_then_sub_vrm2_1_then_sub_vrm1_0; // Note that this is not guaranteed to find a subregister index, such as; // when we are extracting from one VR type to another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,mask,mask,23,// Permit combining of mask vectors as BUILD_VECTOR never expands to scalar; // stores for those types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Safety,avoid,avoid,127,// We only support a set of vector types with a consistent maximum fixed size; // across all supported vector element types to avoid legalization issues.; // Therefore -- since the largest is v1024i8/v512i16/etc -- the largest; // fixed-length vector type we support is 1024 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Availability,Mask,Masks,3,// Masks can only use a single register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,scalab,scalable,28,// Return the largest legal scalable vector type that matches VT's element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Availability,mask,mask,27,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Availability,mask,masking,50,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,Performance,scalab,scalable,157,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Usability,simpl,simply,97,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Availability,mask,mask,24,/// Creates an all ones mask suitable for masking a vector of type VecTy with; /// vector length VL. .,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:42,Availability,mask,masking,42,/// Creates an all ones mask suitable for masking a vector of type VecTy with; /// vector length VL. .,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Availability,mask,mask,50,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:129,Performance,scalab,scalable,129,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:250,Performance,scalab,scalable,250,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:294,Availability,reliab,reliably,294,"// The state of RVV BUILD_VECTOR and VECTOR_SHUFFLE lowering is that very few; // of either is (currently) supported. This can get us into an infinite loop; // where we try to lower a BUILD_VECTOR as a VECTOR_SHUFFLE as a BUILD_VECTOR; // as a ..., etc.; // Until either (or both) of these can reliably lower any node, reporting that; // we don't want to expand BUILD_VECTORs via VECTOR_SHUFFLEs at least breaks; // the infinite loop. Note that this lowers BUILD_VECTOR through the stack,; // which is not desirable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Performance,throughput,throughput,32,"// TODO: Here assume reciprocal throughput is 1 for LMUL_1, it is; // implementation-defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:188,Availability,mask,mask,188,/// Return the cost of a vrgather.vv instruction for the type VT. vrgather.vv; /// is generally quadratic in the number of vreg implied by LMUL. Note that; /// operand (index and possibly mask) are handled separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:209,Integrability,depend,dependent,209,"/// Return the cost of a vrgather.vi (or vx) instruction for the type VT.; /// vrgather.vi/vx may be linear in the number of vregs implied by LMUL,; /// or may track the vrgather.vv cost. It is implementation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:276,Integrability,depend,dependent,276,"/// Return the cost of a vslidedown.vx or vslideup.vx instruction; /// for the type VT. (This does not cover the vslide1up or vslide1down; /// variants.) Slides may be linear in the number of vregs implied by LMUL,; /// or may track the vrgather.vv cost. It is implementation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:276,Integrability,depend,dependent,276,"/// Return the cost of a vslidedown.vi or vslideup.vi instruction; /// for the type VT. (This does not cover the vslide1up or vslide1down; /// variants.) Slides may be linear in the number of vregs implied by LMUL,; /// or may track the vrgather.vv cost. It is implementation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:207,Safety,avoid,avoid,207,"// Expand vector FTRUNC, FCEIL, FFLOOR, FROUND, VP_FCEIL, VP_FFLOOR, VP_FROUND; // VP_FROUNDEVEN, VP_FROUNDTOZERO, VP_FRINT and VP_FNEARBYINT by converting to; // the integer domain and back. Taking care to avoid converting values that are; // nan or already correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:445,Safety,detect,detect,445,"// Try to match an arithmetic-sequence BUILD_VECTOR [X,X+S,X+2*S,...,X+(N-1)*S]; // to the (non-zero) step S and start value X. This can be then lowered as the; // RVV sequence (VID * S) + X, for example.; // The step S is represented as an integer numerator divided by a positive; // denominator. Note that the implementation currently only identifies; // sequences in which either the numerator is +/- 1 or the denominator is 1. It; // cannot detect 2/3, for example.; // Note that this method will also match potentially unappealing index; // sequences, like <i32 0, i32 50939494>, however it is left to the caller to; // determine whether this is worth generating code for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Testability,log,logged,19,// We need to have logged a step for this to count as a legal index sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Security,validat,validate,38,"// Loop back through the sequence and validate elements we might have skipped; // while waiting for a valid step. While doing this, log any sequence addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:132,Testability,log,log,132,"// Loop back through the sequence and validate elements we might have skipped; // while waiting for a valid step. While doing this, log any sequence addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Performance,optimiz,optimization,21,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:88,Performance,perform,perform,88,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Performance,optimiz,optimization,101,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,Usability,simpl,simplicity,66,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,Performance,optimiz,optimize,12,"/// Try and optimize BUILD_VECTORs with ""dominant values"" - these are values; /// which constitute a large proportion of the elements. In such cases we can; /// splat a vector with the dominant element and make up the shortfall with; /// INSERT_VECTOR_ELTs. Returns SDValue if not profitable.; /// Note that this includes vectors of 2 elements by association. The; /// upper-most element is the ""dominant"" one, allowing us to use a splat to; /// ""insert"" the upper element, and an insert of the lower element at position; /// 0, which improves codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,Performance,load,loads,30,"// Track the number of scalar loads we know we'd be inserting, estimated as; // any non-zero floating-point constant. Other kinds of element are either; // already in registers or are materialized on demand. The threshold at which; // a vector load is more desirable than several scalar materializion and; // vector-insertion instructions is not known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:244,Performance,load,load,244,"// Track the number of scalar loads we know we'd be inserting, estimated as; // any non-zero floating-point constant. Other kinds of element are either; // already in registers or are materialized on demand. The threshold at which; // a vector load is more desirable than several scalar materializion and; // vector-insertion instructions is not known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Performance,perform,perform,9,"// Don't perform this optimization when optimizing for size, since; // materializing elements and inserting them tends to cause code bloat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Performance,optimiz,optimization,22,"// Don't perform this optimization when optimizing for size, since; // materializing elements and inserting them tends to cause code bloat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimizing,40,"// Don't perform this optimization when optimizing for size, since; // materializing elements and inserting them tends to cause code bloat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:288,Availability,mask,mask,288,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:154,Safety,avoid,avoids,154,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:249,Safety,avoid,avoids,249,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:69,Availability,mask,mask,69,"// Blend in all instances of this value using a VSELECT, using a; // mask where each bit signals whether that element is the one; // we're after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Availability,mask,mask,18,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:135,Availability,mask,mask,135,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,Integrability,depend,depends,110,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:67,Performance,optimiz,optimization,67,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,Performance,load,load,165,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:113,Safety,avoid,avoid,113,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Availability,mask,mask,96,// Now we can create our integer vector type. Note that it may be larger; // than the resulting mask type: v4i1 would use v1i8 as its integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Usability,clear,clear,118,"// Once we accumulate enough bits to fill our scalar type or process the; // last element, insert into our vector and clear our accumulated data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,Availability,mask,mask,120,"// If we're producing a smaller vector than our minimum legal integer; // type, bitcast to the equivalent (known-legal) mask type, and extract; // our final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,Availability,mask,mask,157,"// If we're producing a smaller vector than our minimum legal integer; // type, bitcast to the equivalent (known-legal) mask type, and extract; // our final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Availability,mask,mask,76,// Else we must have produced an integer type with the same size as the; // mask type; bitcast for the final result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Performance,optimiz,optimize,63,// Exclude INT64_MIN to avoid passing it to std::abs. We won't optimize it; // anyway as the shift of 63 won't fit in uimm5.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Safety,avoid,avoid,24,// Exclude INT64_MIN to avoid passing it to std::abs. We won't optimize it; // anyway as the shift of 63 won't fit in uimm5.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,scalab,scalable,28,"// Convert right out of the scalable type so we can use standard ISD; // nodes for the rest of the computation. If we used scalable types with; // these, we'd lose the fixed-length vector info and generate worse; // vsetvli code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:123,Performance,scalab,scalable,123,"// Convert right out of the scalable type so we can use standard ISD; // nodes for the rest of the computation. If we used scalable types with; // these, we'd lose the fixed-length vector info and generate worse; // vsetvli code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Energy Efficiency,reduce,reduce,23,// TODO: Use vfwcvt to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Deployability,toggle,toggle,101,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Deployability,toggle,toggle,118,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Modifiability,extend,extend,17,"// On RV64, sign-extend from 32 to 64 bits where possible in order to; // achieve better constant materializion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:307,Performance,optimiz,optimization,307,"// Attempt to detect ""hidden"" splats, which only reveal themselves as splats; // when re-interpreted as a vector with a larger element type. For example,; // v4i16 = build_vector i16 0, i16 1, i16 0, i16 1; // could be instead splat as; // v2i32 = build_vector i32 0x00010000, i32 0x00010000; // TODO: This optimization could also work on non-constant splats, but it; // would require bit-manipulation instructions to construct the splat value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Safety,detect,detect,14,"// Attempt to detect ""hidden"" splats, which only reveal themselves as splats; // when re-interpreted as a vector with a larger element type. For example,; // v4i16 = build_vector i16 0, i16 1, i16 0, i16 1; // could be instead splat as; // v2i32 = build_vector i32 0x00010000, i32 0x00010000; // TODO: This optimization could also work on non-constant splats, but it; // would require bit-manipulation instructions to construct the splat value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Deployability,toggle,toggle,101,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Deployability,toggle,toggle,118,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Modifiability,extend,extend,17,"// On RV64, sign-extend from 32 to 64 bits where possible in order to; // achieve better constant materializion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:128,Modifiability,extend,extended,128,"// Since we can't introduce illegal i64 types at this stage, we can only; // perform an i64 splat on RV32 if it is its own sign-extended value. That; // way we can use RVV instructions to splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:77,Performance,perform,perform,77,"// Since we can't introduce illegal i64 types at this stage, we can only; // perform an i64 splat on RV32 if it is its own sign-extended value. That; // way we can use RVV instructions to splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Energy Efficiency,reduce,reduce,101,"// If the number of signbits allows, see if we can lower as a <N x i8>.; // Our main goal here is to reduce LMUL (and thus work) required to; // build the constant, but we will also narrow if the resulting; // narrow vector is known to materialize cheaply.; // TODO: We really should be costing the smaller vector. There are; // profitable cases this misses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:67,Availability,mask,mask,67,"// A BUILD_VECTOR can be lowered as a SETCC. For each fixed-length mask; // vector type, we have a legal equivalently-sized i8 type, so we can use; // that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Performance,perform,perform,16,"// For a splat, perform a scalar truncate before creating the wider; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:125,Performance,scalab,scalable,125,// The following semantically builds up a fixed length concat_vector; // of the component build_vectors. We eagerly lower to scalable and; // insert_subvector here to avoid DAG combining it back to a large; // build_vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:167,Safety,avoid,avoid,167,// The following semantically builds up a fixed length concat_vector; // of the component build_vectors. We eagerly lower to scalable and; // insert_subvector here to avoid DAG combining it back to a large; // build_vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:147,Performance,load,loads,147,"// Cap the cost at a value linear to the number of elements in the vector.; // The default lowering is to use the stack. The vector store + scalar loads; // is linear in VL. However, at high lmuls vslide1down and vslidedown end up; // being (at least) linear in LMUL. As a result, using the vslidedown; // lowering for every element ends up being VL*LMUL..; // TODO: Should we be directly costing the stack alternative? Doing so might; // give us a more accurate upper bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Integrability,depend,dependency,101,// Start our sequence with a TA splat in the hopes that hardware is able to; // recognize there's no dependency on the prior value of our temporary; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:67,Modifiability,extend,extended,67,"// Detect cases where Hi is (SRA Lo, 31) which means Hi is Lo sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Detect,Detect,3,"// Detect cases where Hi is (SRA Lo, 31) which means Hi is Lo sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Modifiability,extend,extended,107,"// If the hi bits of the splat are undefined, then it's fine to just splat Lo; // even if it might be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Performance,load,load,51,// Fall back to a stack store and stride x0 vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,Performance,optimiz,optimize,81,// Called by type legalization to handle splat of i64 on RV32.; // FIXME: We can optimize this when the type has sign or zero bits in one; // of the halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simplest,3,// Simplest case is that the operand needs to be promoted to XLenVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extend,38,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Modifiability,extend,extend,150,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid the tricky legalization cases by falling back to using the; // splat code which already handles it gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extend,38,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Modifiability,extend,extend,150,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Safety,detect,detect,14,"// We need to detect various ways of spelling a rotation:; // [11, 12, 13, 14, 15, 0, 1, 2]; // [-1, 12, 13, 14, -1, -1, 1, -1]; // [-1, -1, -1, -1, -1, -1, 1, 2]; // [ 3, 4, 5, 6, 7, 8, 9, 10]; // [-1, 4, 5, 6, -1, -1, 9, -1]; // [-1, 4, 5, 6, -1, -1, -1, -1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Availability,mask,mask,53,"// The rotations don't match, so we can't match this mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Availability,mask,mask,28,// Compute which value this mask is pointing at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:43,Availability,mask,mask,43,"// Check that we successfully analyzed the mask, and normalize the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,scalab,scalable,28,// Convert fixed vectors to scalable if needed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,scalab,scalable,76,// EXTRACT_SUBVECTOR can be used to extract a fixed-width vector from; // a scalable vector. But we don't want to match the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Availability,mask,mask,11,// Rebuild mask because Src may be from multiple EXTRACT_SUBVECTORs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Deployability,continuous,continuous,19,// NewMask is also continuous.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Performance,perform,perform,94,"// Because vslideup leaves the destination elements at the start intact, we can; // use it to perform shuffles that insert subvectors:; //; // vector_shuffle v8:v8i8, v9:v8i8, <0, 1, 2, 3, 8, 9, 10, 11>; // ->; // vsetvli zero, 8, e8, mf2, ta, ma; // vslideup.vi v8, v9, 4; //; // vector_shuffle v8:v8i8, v9:v8i8 <0, 1, 8, 9, 10, 5, 6, 7>; // ->; // vsetvli zero, 5, e8, mf2, tu, ma; // vslideup.v1 v8, v9, 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,down,down,23,/// Match v(f)slide1up/down idioms. These operations involve sliding; /// N-1 elements to make room for an inserted scalar at one end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,"// Return true if the mask could describe a slide of Mask.size() - 1; // elements from concat_vector(V1, V2)[Base:] to [Offset:].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Availability,Mask,Mask,53,"// Return true if the mask could describe a slide of Mask.size() - 1; // elements from concat_vector(V1, V2)[Base:] to [Offset:].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Performance,scalab,scalable,50,// <vscale x n x ty>; // Convert fixed vectors to scalable if needed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Availability,mask,mask,19,"// Given a shuffle mask like <3, 0, 1, 2, 7, 4, 5, 6> for v8i8, we can; // reinterpret it as a v2i32 and rotate it right by 8 instead. We can lower this; // as a vror.vi if we have Zvkb, or otherwise as a vsll, vsrl and vor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Check if our mask can be done as a 1-to-1 mapping from source; // to destination registers in the group without needing to; // write each destination more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Performance,scalab,scalable,127,// The following semantically builds up a fixed length concat_vector; // of the component shuffle_vectors. We eagerly lower to scalable here; // to avoid DAG combining it back to a large shuffle_vector again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:148,Safety,avoid,avoid,148,// The following semantically builds up a fixed length concat_vector; // of the component shuffle_vectors. We eagerly lower to scalable here; // to avoid DAG combining it back to a large shuffle_vector again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Performance,load,load,24,// Turn splatted vector load into a strided load with an X0 stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Performance,load,load,44,// Turn splatted vector load into a strided load with an X0 stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,Performance,load,load,25,// We need to ensure the load isn't atomic or volatile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Performance,load,load,44,"// If this is SEW=64 on RV32, use a strided load with a stride of x0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:26,Performance,load,load,26,// Otherwise use a scalar load and splat. This will give the best; // opportunity to fold a splat into the operation. ISel can turn it into; // the x0 strided load if we aren't able to fold away the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:159,Performance,load,load,159,// Otherwise use a scalar load and splat. This will give the best; // opportunity to fold a splat into the operation. ISel can turn it into; // the x0 strided load if we aren't able to fold away the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:83,Availability,avail,available,83,"// A bitrotate will be one instruction on Zvkb, so try to lower to it first if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Availability,down,down,45,// We found a rotation. We need to slide HiV down by Rotation. Then we need; // to slide LoV up by (NumElts - Rotation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:72,Deployability,toggle,toggle,72,"// Even though we could use a smaller VL, don't to avoid a vsetivli; // toggle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Safety,avoid,avoid,51,"// Even though we could use a smaller VL, don't to avoid a vsetivli; // toggle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Detect,Detect,3,"// Detect an interleave shuffle and lower to; // (vmaccu.vx (vwaddu.vx lohalf(V1), lohalf(V2)), lohalf(V2), (2^eltbits - 1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect shuffles which can be re-expressed as vector selects; these are; // shuffles in which each element in the destination is taken from an element; // at the corresponding index in either source vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:64,Availability,mask,mask,64,"// By default we preserve the original operand order, and use a mask to; // select LHS as true and RHS as false. However, since RVV vector selects may; // feature splats but only on the LHS, we may choose to invert our mask and; // instead select between RHS and LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:219,Availability,mask,mask,219,"// By default we preserve the original operand order, and use a mask to; // select LHS as true and RHS as false. However, since RVV vector selects may; // feature splats but only on the LHS, we may choose to invert our mask and; // instead select between RHS and LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Availability,mask,mask,21,// Now construct the mask that will be used by the vselect operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:189,Performance,throughput,throughput,189,"// We might be able to express the shuffle as a bitrotate. But even if we; // don't have Zvkb and have to expand, the expanded sequence of approx. 2; // shifts and a vor will have a higher throughput than a vrgather.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Availability,mask,mask,21,// Now construct the mask that will be used by the blended vrgather operation.; // Cconstruct the appropriate indices into each vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask allows, we can do all the index computation in 16 bits. This; // requires less work and less register pressure at high LMUL, and creates; // smaller constants which may be cheaper to materialize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Safety,avoid,avoid,14,// Use RTZ to avoid rounding influencing exponent of FloatVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:69,Performance,load,load,69,"// While RVV has alignment restrictions, we should always be able to load as a; // legal equivalently-sized byte-typed vector instead. This method is; // responsible for re-expressing a ISD::LOAD via a correctly-aligned type. If; // the load is already correctly-aligned, it returns SDValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:191,Performance,LOAD,LOAD,191,"// While RVV has alignment restrictions, we should always be able to load as a; // legal equivalently-sized byte-typed vector instead. This method is; // responsible for re-expressing a ISD::LOAD via a correctly-aligned type. If; // the load is already correctly-aligned, it returns SDValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:237,Performance,load,load,237,"// While RVV has alignment restrictions, we should always be able to load as a; // legal equivalently-sized byte-typed vector instead. This method is; // responsible for re-expressing a ISD::LOAD via a correctly-aligned type. If; // the load is already correctly-aligned, it returns SDValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:145,Availability,redundant,redundant,145,"// All simm32 constants should be handled by isel.; // NOTE: The getMaxBuildIntsCost call below should return a value >= 2 making; // this check redundant, but small immediates are common so this check; // should have better compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:145,Safety,redund,redundant,145,"// All simm32 constants should be handled by isel.; // NOTE: The getMaxBuildIntsCost call below should return a value >= 2 making; // this check redundant, but small immediates are common so this check; // should have better compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimizations,3,"// Optimizations below are disabled for opt size. If we're optimizing for; // size, use a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,Performance,optimiz,optimizing,59,"// Optimizations below are disabled for opt size. If we're optimizing for; // size, use a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Safety,avoid,avoid,97,"// Special case. See if we can build the constant as (ADD (SLLI X, C), X) do; // that if it will avoid a constant pool.; // It will require an extra temporary register though.; // If we have Zba we can use (ADD_UW X, (SLLI X, 32)) to handle cases where; // low and high 32 bits are the same and bit 31 and 63 are set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Integrability,synchroniz,synchronize,28,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Performance,scalab,scalable,51,// Check no NaNs before converting to fixed vector scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Availability,mask,mask,54,/// Return true if a RISC-V target specified op has a mask operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Usability,simpl,simple,53,// We can handle fixed length vector bitcasts with a simple replacement; // in isel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Performance,perform,perform,127,"// When bitcasting from scalar to fixed-length vector, insert the scalar; // into a one-element vector of the result type, and perform a vector; // bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Performance,scalab,scalable,17,// We define our scalable vector types for lmul=1 to use a 64 bit known; // minimum size. e.g. <vscale x 2 x i32>. VLENB is in bytes so we calculate; // vscale as VLENB / 8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:90,Usability,Simpl,SimplifyDemandedBits,90,// We assume VLENB is a multiple of 8. We manually choose the best shift; // here because SimplifyDemandedBits isn't always able to simplify it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:132,Usability,simpl,simplify,132,// We assume VLENB is a multiple of 8. We manually choose the best shift; // here because SimplifyDemandedBits isn't always able to simplify it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Availability,down,down,50,"// If the multiplier is a multiple of 8, scale it down to avoid needing; // to shift the VLENB value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Safety,avoid,avoid,58,"// If the multiplier is a multiple of 8, scale it down to avoid needing; // to shift the VLENB value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectors can exit here. Patterns will handle equally-sized; // conversions halving/doubling ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,Safety,avoid,avoids,175,"// If the RHS is a constant in the range [-2049, 0) or (0, 2046], we can; // convert this to the equivalent of (set(u)ge X, C+1) by using; // (xori (slti(u) X, C+1), 1). This avoids materializing a small constant; // in a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Modifiability,variab,variables,45,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:85,Security,access,accessed,85,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the symbol. This generates the; // pattern (PseudoLLA sym), which expands to (addi (auipc %pcrel_hi(sym)); // %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,Performance,load,load,70,"// Use PC-relative addressing to access the GOT for this symbol, then load; // the address from the GOT. This generates the pattern (PseudoLGA sym),; // which expands to (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the GOT for this symbol, then load; // the address from the GOT. This generates the pattern (PseudoLGA sym),; // which expands to (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Security,access,accessing,27,// Generate a sequence for accessing addresses within the first 2 GiB of; // address space. This generates the pattern (addi (lui %hi(sym)) %lo(sym)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:136,Security,access,access,136,"// An extern weak symbol may be undefined, i.e. have value 0, which may; // not be within 2GiB of PC, so use GOT-indirect addressing to access the; // symbol. This generates the pattern (PseudoLGA sym), which expands to; // (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Security,access,accessing,27,"// Generate a sequence for accessing addresses within any 2GiB range within; // the address space. This generates the pattern (PseudoLLA sym), which; // expands to (addi (auipc %pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:78,Performance,load,load,78,"// Use PC-relative addressing to access the GOT for this TLS symbol, then; // load the address from the GOT and add the thread pointer. This generates; // the pattern (PseudoLA_TLS_IE sym), which expands to; // (ld (auipc %tls_ie_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the GOT for this TLS symbol, then; // load the address from the GOT and add the thread pointer. This generates; // the pattern (PseudoLA_TLS_IE sym), which expands to; // (ld (auipc %tls_ie_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Security,access,accessing,27,"// Generate a sequence for accessing the address relative to the thread; // pointer, with the appropriate adjustment for the thread pointer offset.; // This generates the pattern; // (add (add_tprel (lui %tprel_hi(sym)) tp %tprel_add(sym)) %tprel_lo(sym))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Security,access,access,40,"// Use a PC-relative addressing mode to access the global dynamic GOT address.; // This generates the pattern (PseudoLA_TLS_GD sym), which expands to; // (addi (auipc %tls_gd_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Security,access,access,40,"// Use a PC-relative addressing mode to access the global dynamic GOT address.; // This generates the pattern (PseudoLA_TLSDESC sym), which expands to; //; // auipc tX, %tlsdesc_hi(symbol) // R_RISCV_TLSDESC_HI20(symbol); // lw tY, tX, %tlsdesc_lo_load(label) // R_RISCV_TLSDESC_LOAD_LO12_I(label); // addi a0, tX, %tlsdesc_lo_add(label) // R_RISCV_TLSDESC_ADD_LO12_I(label); // jalr t0, tY // R_RISCV_TLSDESC_CALL(label)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,Performance,Perform,Performing,110,"// When Zicond or XVentanaCondOps is present, emit CZERO_EQZ and CZERO_NEZ; // nodes to implement the SELECT. Performing the lowering here allows for; // greater control over when CZERO_{EQZ/NEZ} are used vs another branchless; // sequence or RISCVISD::SELECT_CC node (branch-based select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Performance,optimiz,optimizations,18,// Try some other optimizations before falling back to generic lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Performance,optimiz,optimization,107,"// (select c, t, f) -> (or (czero_eqz t, c), (czero_nez f, c)); // Unless we have the short forward branch optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:460,Safety,avoid,avoid,460,"// Special case for a select of 2 constants that have a diffence of 1.; // Normally this is done by DAGCombine, but if the select is introduced by; // type legalization or op legalization, we miss it. Restricting to SETLT; // case for now because that is what signed saturating add/sub need.; // FIXME: We don't need the condition to be SETLT or even a SETCC,; // but we would probably want to swap the true/false values if the condition; // is SETGE/SETLE to avoid an XORI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Availability,mask,mask,47,"// Lower splats of i1 types to SETCC. For each mask vector type, we have a; // legal equivalently-sized i8 type, so we can use that as a go-between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:170,Modifiability,extend,extended,170,"// Custom-lower a SPLAT_VECTOR_PARTS where XLEN<SEW, as the SEW element type is; // illegal (currently only vXi64 RV32).; // FIXME: We could also catch non-constant sign-extended i32 values and lower; // them to VMV_V_X_VL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,"// Custom-lower extensions from mask vectors by using a vselect either with 1; // for zero/any-extension or -1 for sign-extension:; // (vXiN = (s|z)ext vXi1:vmask) -> (vXiN = vselect vmask, (-1 or 1), 0); // Note that any-extension is lowered identically to zero-extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:37,Availability,mask,mask,37,// Only custom-lower extensions from mask types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Modifiability,extend,extended,45,"// Grab the canonical container type for the extended type. Infer the smaller; // type from that to ensure the same number of vector elements, as we know; // the LMUL will be sufficient to hold the smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Modifiability,extend,extended,11,// Get the extended container type manually to ensure the same number of; // vector elements between source and dest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Availability,mask,mask,44,"// Custom-lower truncations from vectors to mask vectors by using a mask and a; // setcc operation:; // (vXi1 = trunc vXiN vec) -> (vXi1 = setcc (and vec, 1), 0, ne)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:68,Availability,mask,mask,68,"// Custom-lower truncations from vectors to mask vectors by using a mask and a; // setcc operation:; // (vXi1 = trunc vXiN vec) -> (vXi1 = setcc (and vec, 1), 0, ne)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:46,Availability,mask,mask,46,// Only expect to custom-lower truncations to mask types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If this is a fixed vector, we need to convert it to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Truncates to mask types are handled differently,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:168,Energy Efficiency,power,power,168,"// RVV only has truncates which operate from SEW*2->SEW, so lower arbitrary; // truncates as a series of ""RISCVISD::TRUNCATE_VECTOR_VL"" nodes which; // truncate by one power of two at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:146,Energy Efficiency,reduce,reduce,146,"// Given a scalable vector type and an index into it, returns the type for the; // smallest subvector that the index fits in. This can be used to reduce LMUL; // for operations like vslidedown.; //; // E.g. With Zvl128b, index 3 in a nxv4i32 fits within the first nxv2i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Performance,scalab,scalable,11,"// Given a scalable vector type and an index into it, returns the type for the; // smallest subvector that the index fits in. This can be used to reduce LMUL; // for operations like vslidedown.; //; // E.g. With Zvl128b, index 3 in a nxv4i32 fits within the first nxv2i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If the operand is a fixed-length vector, convert to a scalable one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:86,Performance,perform,performing,86,"// If we know the index we're going to insert at, we can shrink Vec so that; // we're performing the scalar inserts and slideup on a smaller LMUL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:61,Performance,perform,perform,61,"// If we're compiling for an exact VLEN value, we can always perform; // the insert in m1 as we can determine the register corresponding to; // the index in the register group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Safety,avoid,avoid,82,"// First slide in the lo value, then the hi in above it. We use slide1down; // to avoid the register group overlap constraint of vslide1up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Safety,avoid,avoid,82,"// First slide in the lo value, then the hi in above it. We use slide1down; // to avoid the register group overlap constraint of vslide1up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,Availability,down,down,66,"// Custom-lower EXTRACT_VECTOR_ELT operations to slide the vector down, then; // extract the first element: (extractelt (slidedown vec, idx), 0). For integer; // types this is done using VMV_X_S to allow us to glean information about the; // sign bits of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Availability,mask,mask,3,// mask bit index = index % element width,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If this is a fixed vector, we need to convert it to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,perform,perform,100,"// If we're compiling for an exact VLEN value and we have a known; // constant index, we can always perform the extract in m1 (or; // smaller) as we can determine the register corresponding to; // the index in the register group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the LMUL of our slidedown and vmv.x.s to the smallest LMUL which; // contains our index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:309,Performance,perform,performing,309,"// If after narrowing, the required slide is still greater than LMUL2,; // fallback to generic expansion and go through the stack. This is done; // for a subtle reason: extracting *all* elements out of a vector is; // widely expected to be linear in vector size, but because vslidedown; // is linear in LMUL, performing N extracts using vslidedown becomes; // O(n^2) / (VLEN/ETYPE) work. On the surface, going through the stack; // seems to have the same problem (the store is linear in LMUL), but the; // generic expansion *memoizes* the store, and thus for many extracts of; // the same vector we end up with one store and a bunch of loads.; // TODO: We don't have the same code for insert_vector_elt because we; // have BUILD_VECTOR and handle the degenerate case there. Should we; // consider adding an inverse BUILD_VECTOR node?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:636,Performance,load,loads,636,"// If after narrowing, the required slide is still greater than LMUL2,; // fallback to generic expansion and go through the stack. This is done; // for a subtle reason: extracting *all* elements out of a vector is; // widely expected to be linear in vector size, but because vslidedown; // is linear in LMUL, performing N extracts using vslidedown becomes; // O(n^2) / (VLEN/ETYPE) work. On the surface, going through the stack; // seems to have the same problem (the store is linear in LMUL), but the; // generic expansion *memoizes* the store, and thus for many extracts of; // the same vector we end up with one store and a bunch of loads.; // TODO: We don't have the same code for insert_vector_elt because we; // have BUILD_VECTOR and handle the degenerate case there. Should we; // consider adding an inverse BUILD_VECTOR node?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Safety,avoid,avoid,20,// Use a VL of 1 to avoid processing more elements than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simplest,3,// Simplest case is that the operand needs to be promoted to XLenVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extend,38,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Modifiability,extend,extend,150,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:71,Availability,mask,mask,71,"// Use the previous operand to get the vXi64 VT. The result might be a mask; // VT for compares. Using the previous operand assumes that the previous; // operand will never have a smaller element size than a scalar operand and; // that a widening operation never uses SEW=64.; // NOTE: If this fails the below assert, we can probably just find the; // element count from any operand or result and use it to construct the VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:310,Testability,assert,assert,310,"// Use the previous operand to get the vXi64 VT. The result might be a mask; // VT for compares. Using the previous operand assumes that the previous; // operand will never have a smaller element size than a scalar operand and; // that a widening operation never uses SEW=64.; // NOTE: If this fails the below assert, we can probably just find the; // element count from any operand or result and use it to construct the VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Modifiability,extend,extended,21,"// If this is a sign-extended 32-bit value, we can truncate it and rely on the; // instruction to sign-extend since SEW>XLEN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:103,Modifiability,extend,extend,103,"// If this is a sign-extended 32-bit value, we can truncate it and rely on the; // instruction to sign-extend since SEW>XLEN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for constant AVL,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Availability,mask,mask,9,// Apply mask after the operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Availability,mask,maskedoff,27,// We don't need to select maskedoff if it's undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:117,Availability,mask,mask,117,// TUMA or TUMU: Currently we always emit tumu policy regardless of tuma.; // It's fine because vmerge does not care mask policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:78,Performance,scalab,scalable,78,// Lower the llvm.get.vector.length intrinsic to vsetvli. We only support; // scalable vector llvm.get.vector.length for now.; //; // We need to convert from a scalable VF to a vsetvli with VLMax equal to; // (vscale * VF). The vscale and VF are independent of element width. We use; // SEW=8 for the vsetvli because it is the only element width that supports all; // fractional LMULs. The LMUL is choosen so that with SEW=8 the VLMax is; // (vscale * VF). Where vscale is defined as VLEN/RVVBitsPerBlock. The; // InsertVSETVLI pass can fix up the vtype of the vsetvli if a different; // SEW and LMUL are better for the surrounding vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:160,Performance,scalab,scalable,160,// Lower the llvm.get.vector.length intrinsic to vsetvli. We only support; // scalable vector llvm.get.vector.length for now.; //; // We need to convert from a scalable VF to a vsetvli with VLMax equal to; // (vscale * VF). The vscale and VF are independent of element width. We use; // SEW=8 for the vsetvli because it is the only element width that supports all; // fractional LMULs. The LMUL is choosen so that with SEW=8 the VLMax is; // (vscale * VF). Where vscale is defined as VLEN/RVVBitsPerBlock. The; // InsertVSETVLI pass can fix up the vtype of the vsetvli if a different; // SEW and LMUL are better for the surrounding vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:249,Availability,mask,mask,249,"// This is an i64 value that lives in two scalar registers. We have to; // insert this in a convoluted way. First we build vXi64 splat containing; // the two values that we assemble using some bit math. Next we'll use; // vid.v and vmseq to build a mask with bit 0 set. Then we'll use that mask; // to merge element 0 from our splat into the source vector.; // FIXME: This is probably not the best way to do this, but it is; // consistent with INSERT_VECTOR_ELT lowering so it is a good starting; // point.; // sw lo, (a0); // sw hi, 4(a0); // vlse vX, (a0); //; // vid.v vVid; // vmseq.vx mMask, vVid, 0; // vmerge.vvm vDest, vSrc, vVal, mMask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:290,Availability,mask,mask,290,"// This is an i64 value that lives in two scalar registers. We have to; // insert this in a convoluted way. First we build vXi64 splat containing; // the two values that we assemble using some bit math. Next we'll use; // vid.v and vmseq to build a mask with bit 0 set. Then we'll use that mask; // to merge element 0 from our splat into the source vector.; // FIXME: This is probably not the best way to do this, but it is; // consistent with INSERT_VECTOR_ELT lowering so it is a good starting; // point.; // sw lo, (a0); // sw hi, 4(a0); // vlse vX, (a0); //; // vid.v vVid; // vmseq.vx mMask, vVid, 0; // vmerge.vvm vDest, vSrc, vVal, mMask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:116,Availability,mask,masks,116,// TODO: We restrict this to unmasked loads currently in consideration of; // the complexity of hanlding all falses masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Performance,load,loads,38,// TODO: We restrict this to unmasked loads currently in consideration of; // the complexity of hanlding all falses masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:367,Usability,simpl,simply,367,"// Now include the start value in the operation.; // Note that we must return the start value when no elements are operated; // upon. The vcpop instructions we've emitted in each case above will return; // 0 for an inactive vector, and so we've already received the neutral value:; // AND gives us (0 == 0) -> 1 and OR/XOR give us (0 != 0) -> 0. Therefore we; // can simply include the start value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Deployability,toggle,toggles,54,"// We reuse the VL of the reduction to reduce vsetvli toggles if we can; // prove it is non-zero. For the AVL=0 case, we need the scalar to; // be the result of the reduction operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Energy Efficiency,reduce,reduce,39,"// We reuse the VL of the reduction to reduce vsetvli toggles if we can; // prove it is non-zero. For the AVL=0 case, we need the scalar to; // be the result of the reduction operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:122,Availability,down,down,122,// Due to ordering in legalize types we may have a vector type that needs to; // be split. Do that manually so we can get down to a legal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Availability,mask,mask,38,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:235,Performance,scalab,scalable,235,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:286,Performance,scalab,scalable,286,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:311,Safety,safe,safely,311,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,mask,mask,23,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:260,Availability,down,down,260,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:216,Modifiability,extend,extend,216,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:116,Performance,scalab,scalable,116,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Usability,simpl,simplify,97,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group up the full; // amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:579,Performance,perform,performing,579,"// 1. If the Idx has been completely eliminated and this subvector's size is; // a vector register or a multiple thereof, or the surrounding elements are; // undef, then this is a subvector insert which naturally aligns to a vector; // register. These can easily be handled using subregister manipulation.; // 2. If the subvector is smaller than a vector register, then the insertion; // must preserve the undisturbed elements of the register. We do this by; // lowering to an EXTRACT_SUBVECTOR grabbing the nearest LMUL=1 vector type; // (which resolves to a subregister copy), performing a VSLIDEUP to place the; // subvector within the vector register, and an INSERT_SUBVECTOR of that; // LMUL=1 type back into the larger vector (resolving to another subregister; // operation). See below for how our VSLIDEUP works. We go via a LMUL=1 type; // to avoid allocating a large register group to hold our subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:851,Safety,avoid,avoid,851,"// 1. If the Idx has been completely eliminated and this subvector's size is; // a vector register or a multiple thereof, or the surrounding elements are; // undef, then this is a subvector insert which naturally aligns to a vector; // register. These can easily be handled using subregister manipulation.; // 2. If the subvector is smaller than a vector register, then the insertion; // must preserve the undisturbed elements of the register. We do this by; // lowering to an EXTRACT_SUBVECTOR grabbing the nearest LMUL=1 vector type; // (which resolves to a subregister copy), performing a VSLIDEUP to place the; // subvector within the vector register, and an INSERT_SUBVECTOR of that; // LMUL=1 type back into the larger vector (resolving to another subregister; // operation). See below for how our VSLIDEUP works. We go via a LMUL=1 type; // to avoid allocating a large register group to hold our subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,// We might have bitcast from a mask type: cast back to the original type if; // required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Availability,mask,mask,38,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Availability,down,down,51,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:238,Performance,scalab,scalable,238,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:289,Performance,scalab,scalable,289,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:314,Safety,safe,safely,314,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,mask,mask,23,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Availability,down,down,35,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:264,Availability,down,down,264,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:220,Modifiability,extend,extend,220,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,Performance,scalab,scalable,120,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,Performance,perform,performed,66,"// With an index of 0 this is a cast-like subvector, which can be performed; // with subregister operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:288,Availability,down,down,288,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group down the full; // amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Usability,simpl,simplify,97,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group down the full; // amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,down,down,10,// Shrink down Vec so we're performing the slidedown on a smaller LMUL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,perform,performing,28,// Shrink down Vec so we're performing the slidedown on a smaller LMUL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,Availability,down,down,95,// Set the vector length to only the number of elements we care about. This; // avoids sliding down elements we're going to discard straight away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,Safety,avoid,avoids,80,// Set the vector length to only the number of elements we care about. This; // avoids sliding down elements we're going to discard straight away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:62,Availability,down,down,62,// Else SubVecVT is a fractional LMUL and may need to be slid down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,Availability,down,down,30,// Slide this vector register down by the desired number of elements in order; // to place the desired subvector starting at element 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,// We might have bitcast from a mask type: cast back to the original type if; // required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Availability,mask,mask,47,"// We want to operate on all lanes, so get the mask and VL and mask for it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Availability,mask,mask,63,"// We want to operate on all lanes, so get the mask and VL and mask for it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Safety,avoid,avoid,40,"// For the indices, use the same SEW to avoid an extra vsetvli",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,// Then perform the interleave; // v[0] v[n] v[1] v[n+1] v[2] v[n+2] v[3] v[n+3] ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:114,Performance,load,load,114,"// If we know the exact VLEN and our fixed length vector completely fills; // the container, use a whole register load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:64,Availability,mask,mask,64,// VMFLT/VMFLE/VMFGT/VMFGE raise exception for qNan. Generate a mask to only; // active when both input elements are ordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:7,Availability,Mask,Mask,7,// Use Mask as the merge operand to let the result be 0 if either of the; // inputs is unordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Performance,scalab,scalable,58,// Create list of operands by converting existing ones to scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Performance,scalab,scalable,35,"// ""cast"" fixed length vector to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:241,Performance,scalab,scalable-vector,241,// Lower a VP_* ISD node to the corresponding RISCVISD::*_VL node:; // * Operands of each node are assumed to be in the same order.; // * The EVL operand is promoted from i32 to i64 on RV64.; // * Fixed-length vectors are converted to their scalable-vector container; // types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Availability,mask,mask,36,"// Add dummy merge value before the mask. Or if there isn't a mask, before; // EVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:62,Availability,mask,mask,62,"// Add dummy merge value before the mask. Or if there isn't a mask, before; // EVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Performance,scalab,scalable,35,"// ""cast"" fixed length vector to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Availability,Mask,Mask,9,// NOTE: Mask is dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Availability,Mask,Mask,9,// NOTE: Mask is dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,Availability,mask,mask,59,"// First convert to the same size integer, then convert to mask using; // setcc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Availability,mask,mask,29,// Truncate Result back to a mask vector (Result has same EVL as Op2),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,// Check if we are working with mask vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:106,Availability,mask,masks,106,"// Reassemble the low and high pieces reversed.; // NOTE: this Result is unmasked (because we do not need masks for; // shuffles). If in the future this has to change, we can use a SELECT_VL; // between Result and UNDEF using the mask originally passed to VP_REVERSE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:230,Availability,mask,mask,230,"// Reassemble the low and high pieces reversed.; // NOTE: this Result is unmasked (because we do not need masks for; // shuffles). If in the future this has to change, we can use a SELECT_VL; // between Result and UNDEF using the mask originally passed to VP_REVERSE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Availability,mask,mask,29,// Truncate Result back to a mask vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Availability,mask,mask,29,// Truncate Result back to a mask vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Availability,mask,masked-off,40,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Safety,safe,safe,9,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Check if the mask is known to be all ones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Check if the mask is known to be all ones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:238,Modifiability,extend,extended,238,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:338,Modifiability,extend,extended,338,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:108,Performance,load,load,108,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:130,Performance,load,load,130,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Modifiability,extend,extending,22,// VP doesn't support extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Performance,load,loads,32,// VP doesn't support extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:41,Modifiability,extend,extending,41,// Targets have to explicitly opt-in for extending vector loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Performance,load,loads,58,// Targets have to explicitly opt-in for extending vector loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:242,Modifiability,extend,extended,242,"// Custom lower MSCATTER/VP_SCATTER to a legalized form for RVV. It will then be; // matched to a RVV indexed store. The RVV indexed store instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:342,Modifiability,extend,extended,342,"// Custom lower MSCATTER/VP_SCATTER to a legalized form for RVV. It will then be; // matched to a RVV indexed store. The RVV indexed store instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:41,Modifiability,extend,extending,41,// Targets have to explicitly opt-in for extending vector loads and; // truncating vector stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Performance,load,loads,58,// Targets have to explicitly opt-in for extending vector loads and; // truncating vector stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Energy Efficiency,reduce,reduce,96,// Converts the given 32-bit operation to a i64 operation with signed extension; // semantic to reduce the signed extension instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:138,Modifiability,extend,extend,138,"// If the input is i32, use ANY_EXTEND since the W instructions don't read; // the upper 32 bits. For other types we need to sign or zero extend; // based on the opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Usability,simpl,simplify,36,"// If the RHS is a constant, we can simplify ConditionRHS below. Otherwise; // use the default legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:147,Energy Efficiency,reduce,reduce,147,"// Special case uaddo X, 1 overflowed if the addition result is 0.; // The general case (X + C) < C is not necessarily beneficial. Although we; // reduce the live range of X, we may introduce the materialization of; // constant C, especially when the setcc result is used by branch. We have; // no compare with constant and branch instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Modifiability,extend,extend,8,"// Sign extend the LHS and perform an unsigned compare with the ADDW; // result. Since the inputs are sign extended from i32, this is equivalent; // to comparing the lower 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Modifiability,extend,extended,107,"// Sign extend the LHS and perform an unsigned compare with the ADDW; // result. Since the inputs are sign extended from i32, this is equivalent; // to comparing the lower 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Performance,perform,perform,27,"// Sign extend the LHS and perform an unsigned compare with the ADDW; // result. Since the inputs are sign extended from i32, this is equivalent; // to comparing the lower 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Modifiability,extend,extend,24,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,Modifiability,extend,extend,81,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:131,Safety,detect,detected,131,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:126,Modifiability,extend,extended,126,// Emit a special ABSW node that will be expanded to NEGW+MAX at isel.; // This allows us to remember that the result is sign extended. Expanding; // to NEGW+MAX here requires a Freeze which breaks ComputeNumSignBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:342,Availability,down,down,342,"// Custom-legalize an EXTRACT_VECTOR_ELT where XLEN<SEW, as the SEW element; // type is illegal (currently only vXi64 RV32).; // With vmv.x.s, when SEW > XLEN, only the least-significant XLEN bits are; // transferred to the destination register. We issue two of these from the; // upper- and lower- halves of the SEW-bit vector element, slid down to the; // first element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If this is a fixed vector, we need to convert it to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Safety,avoid,avoid,20,// Use a VL of 1 to avoid processing more elements than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Availability,down,down,63,"// Unless the index is known to be 0, we must slide the vector down to get; // the desired element into index 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:266,Availability,mask,mask,266,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:344,Availability,mask,mask,344,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:467,Availability,mask,mask,467,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Modifiability,Extend,Extend,3,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:416,Modifiability,extend,extended,416,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:453,Modifiability,extend,extended,453,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:148,Performance,Perform,Perform,148,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple case just extract using vmv.x.s and truncate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:179,Availability,recover,recover,179,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:4,Performance,Perform,Perform,4,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:179,Safety,recover,recover,179,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:162,Safety,safe,safe,162,"// This transforms need to run before all integer types have been legalized; // to i64 (so that the vector element type matches the add type), and while; // it's safe to introduce odd sized vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:188,Modifiability,extend,extend,188,"// match binop (extract_vector_elt V, 0), (extract_vector_elt V, 1) to; // reduce_op (extract_subvector [2 x VT] from V). This will form the; // root of our reduction tree. TODO: We could extend this to any two; // adjacent aligned constant indices if desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Energy Efficiency,reduce,reduce,17,"// Match (binop (reduce (extract_subvector V, 0),; // (extract_vector_elt V, sizeof(SubVec)))); // into a reduction of one more element from the original vector V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Safety,safe,safe,63,"// If the AVL is zero, operand 0 will be returned. So it's not safe to fold.; // FIXME: We might be able to improve this if operand 0 is undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (add (shl x, c0), (shl y, c1)) ->; // (SLLI (SH*ADD x, y), c0), if c1-c0 equals to [1|2|3].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform this optimization only in the zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Performance,optimiz,optimization,16,// Perform this optimization only in the zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Performance,optimiz,optimizations,11,// All our optimizations involve subtracting 1 from the immediate and forming; // an ADDI. Make sure the new immediate is valid for an ADDI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:151,Energy Efficiency,reduce,reduces,151,"// Apply DeMorgan's law to (and/or (xor X, 1), (xor Y, 1)) if X and Y are 0/1.; // Legalizing setcc can introduce xors like this. Doing this transform reduces; // the number of xors and may allow the xor to fold into a branch condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,Usability,Simpl,SimplifyDemandedBits,12,"// For AND, SimplifyDemandedBits may have turned one of the (xor X, 1) into; // (xor X, -1) based on the upper bits of the other operand being 0. If the; // operation is And, allow one of the Xors to use -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:285,Availability,recover,recover,285,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Modifiability,extend,extending,76,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Safety,safe,safe,97,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:285,Safety,recover,recover,285,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:170,Performance,optimiz,optimization,170,"// Combines two comparison operation and logic operation to one selection; // operation(min, max) and logic operation. Returns new constructed Node if; // conditions for optimization are satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:41,Testability,log,logic,41,"// Combines two comparison operation and logic operation to one selection; // operation(min, max) and logic operation. Returns new constructed Node if; // conditions for optimization are satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Testability,log,logic,102,"// Combines two comparison operation and logic operation to one selection; // operation(min, max) and logic operation. Returns new constructed Node if; // conditions for optimization are satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:284,Availability,recover,recover,284,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Modifiability,extend,extending,75,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Safety,safe,safe,96,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:284,Safety,recover,recover,284,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:186,Availability,recover,recover,186,"// Pre-promote (i32 (xor (shl -1, X), ~0)) on RV64 with Zbs so we can use; // (ADDI (BSET X0, X), -1). If we wait until/ type legalization, we'll create; // RISCVISD:::SLLW and we can't recover it to use a BSET instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:186,Safety,recover,recover,186,"// Pre-promote (i32 (xor (shl -1, X), ~0)) on RV64 with Zbs so we can use; // (ADDI (BSET X0, X), -1). If we wait until/ type legalization, we'll create; // RISCVISD:::SLLW and we can't recover it to use a BSET instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:72,Modifiability,extend,extend,72,"/// According to the property that indexed load/store instructions zero-extend; /// their indices, try to narrow the type of index operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:43,Performance,load,load,43,"/// According to the property that indexed load/store instructions zero-extend; /// their indices, try to narrow the type of index operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Modifiability,extend,extended,53,// Skip if NewElen is not narrower than the original extended type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,Modifiability,extend,extended,120,"// Replace (seteq (i64 (and X, 0xffffffff)), C1) with; // (seteq (i64 (sext_inreg (X, i32)), C1')) where C1' is C1 sign extended from; // bit 31. Same for setne. C1' may be cheaper to materialize and the sext_inreg; // can become a sext.w instead of a shift pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:558,Availability,Mask,Mask,558,"/// Helper class for folding sign/zero extensions.; /// In particular, this class is used for the following combines:; /// add | add_vl -> vwadd(u) | vwadd(u)_w; /// sub | sub_vl -> vwsub(u) | vwsub(u)_w; /// mul | mul_vl -> vwmul(u) | vwmul_su; ///; /// An object of this class represents an operand of the operation we want to; /// combine.; /// E.g., when trying to combine `mul_vl a, b`, we will have one instance of; /// NodeExtensionHelper for `a` and one for `b`.; ///; /// This class abstracts away how the extension is materialized and; /// how its Mask, VL, number of users affect the combines.; ///; /// In particular:; /// - VWADD_W is conceptually == add(op0, sext(op1)); /// - VWADDU_W == add(op0, zext(op1)); /// - VWSUB_W == sub(op0, sext(op1)); /// - VWSUBU_W == sub(op0, zext(op1)); ///; /// And VMV_V_X_VL, depending on the value, is conceptually equivalent to; /// zext|sext(smaller_value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:826,Integrability,depend,depending,826,"/// Helper class for folding sign/zero extensions.; /// In particular, this class is used for the following combines:; /// add | add_vl -> vwadd(u) | vwadd(u)_w; /// sub | sub_vl -> vwsub(u) | vwsub(u)_w; /// mul | mul_vl -> vwmul(u) | vwmul_su; ///; /// An object of this class represents an operand of the operation we want to; /// combine.; /// E.g., when trying to combine `mul_vl a, b`, we will have one instance of; /// NodeExtensionHelper for `a` and one for `b`.; ///; /// This class abstracts away how the extension is materialized and; /// how its Mask, VL, number of users affect the combines.; ///; /// In particular:; /// - VWADD_W is conceptually == add(op0, sext(op1)); /// - VWADDU_W == add(op0, zext(op1)); /// - VWSUB_W == sub(op0, sext(op1)); /// - VWSUBU_W == sub(op0, zext(op1)); ///; /// And VMV_V_X_VL, depending on the value, is conceptually equivalent to; /// zext|sext(smaller_value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Modifiability,extend,extended,47,/// Records if this operand is like being zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Modifiability,extend,extended,47,"/// Records if this operand is like being sign extended.; /// Note: SupportsZExt and SupportsSExt are not mutually exclusive. For; /// instance, a splat constant (e.g., 3), would support being both sign and; /// zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:217,Modifiability,extend,extended,217,"/// Records if this operand is like being sign extended.; /// Note: SupportsZExt and SupportsSExt are not mutually exclusive. For; /// instance, a splat constant (e.g., 3), would support being both sign and; /// zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,Availability,mask,mask,30,/// Records if this operand's mask needs to match the mask of the operation; /// that it will fold into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Availability,mask,mask,54,/// Records if this operand's mask needs to match the mask of the operation; /// that it will fold into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,Mask,Mask,17,/// Value of the Mask for this operand.; /// It may be SDValue().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Modifiability,extend,extended,51,/// Check if this node needs to be fully folded or extended for all users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Availability,Mask,Mask,58,/// Check if this operand is compatible with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Availability,Mask,Mask,31,/// Helper function to get the Mask and VL from \p Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,Mask,Mask,17,/// Check if the Mask and VL of this operand are compatible with \p Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:113,Modifiability,extend,extended,113,"// No value means no extension is needed. If extension is needed, the value; // indicates if it needs to be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:158,Testability,test,testing,158,// FIXME: Is it useful to form a vwadd.wx or vwsub.wx if it removes a scalar; // sext/zext?; // Control this behavior behind an option (AllowSplatInVW_W) for testing; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Modifiability,extend,extended,27,"// All the inputs that are extended need to be folded, otherwise; // we would be leaving the old input (since it is may still be used),; // and the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Performance,perform,performMemPairCombine,23,// Helper function for performMemPairCombine.; // Try to combine the memory loads/stores LSNode1 and LSNode2; // into a single memory pair operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,load,loads,76,// Helper function for performMemPairCombine.; // Try to combine the memory loads/stores LSNode1 and LSNode2; // into a single memory pair operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Performance,load,loads,31,// Try to combine two adjacent loads/stores to a single pair instruction from; // the XTHeadMemPair vendor extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Performance,load,load,27,// Target does not support load/store pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:34,Performance,load,loads,34,"// No volatile, indexed or atomic loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:34,Performance,load,loads,34,"// No volatile, indexed or atomic loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Performance,scalab,scalable,29,// Make fixed-length vectors scalable first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:37,Performance,scalab,scalable,37,"// If converted from fixed-length to scalable, convert back",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Modifiability,extend,extends,18,// fcvt.wu.* sign extends bit 31 on RV64. FP_TO_UINT_SAT expects to zero; // extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:77,Modifiability,extend,extend,77,// fcvt.wu.* sign extends bit 31 on RV64. FP_TO_UINT_SAT expects to zero; // extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Deployability,toggle,toggles,54,// Negating the multiply result changes ADD<->SUB and toggles 'N'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor to handle more complex cases similar to; // combineBinOp_VLToVWBinOp_VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,Availability,mask,mask,13,// Check the mask and VL are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor to handle more complex cases similar to; // combineBinOp_VLToVWBinOp_VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,Availability,mask,mask,13,// Check the mask and VL are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,Availability,mask,mask,13,// Check the mask and VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Modifiability,extend,extend,44,// Sub requires at least operand 1 to be an extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Modifiability,extend,extend,21,// Op1 is a foldable extend. Op0 might be foldable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,optimiz,optimization,100,// All users should be a shift by constant less than or equal to 32. This; // ensures we'll do this optimization for each of them to produce an; // add/sub+sext_inreg they can all share.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Usability,Simpl,SimplifyDemandedBits,31,"// If the condition is an And, SimplifyDemandedBits may have changed; // (xor Z, 1) to (not Z).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform common combines for BR_CC and SELECT_CC condtions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,Energy Efficiency,power,power,95,"// Replace (setcc eq (and x, C)) with (setcc ne (and x, C))) to generate; // BEXTI, where C is power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:311,Performance,perform,performing,311,"/// If we have a build_vector where each lane is binop X, C, where C; /// is a constant (but not necessarily the same constant on all lanes),; /// form binop (build_vector x1, x2, ...), (build_vector c1, c2, c3, ..).; /// We assume that materializing a constant build vector will be no more; /// expensive that performing O(n) binops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,failure,failure,17,// FIXME: Return failure if the RHS type doesn't match the LHS. Shifts may; // have different LHS and RHS types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,failure,failure,17,// FIXME: Return failure if the RHS type doesn't match the LHS. Shifts may; // have different LHS and RHS types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Performance,load,loads,45,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,load,load,76,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Performance,load,load,94,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:112,Performance,load,load,112,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,Performance,load,load,175,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,// Only perform this combine on legal MVTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Modifiability,extend,extend,21,// TODO: Potentially extend this to scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Performance,scalab,scalable,36,// TODO: Potentially extend this to scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Performance,load,loads,18,// Go through the loads and check that they're strided,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,Performance,load,loads,70,// The common alignment is the most restrictive (smallest) of all the loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Performance,load,load,10,"// If the load ptrs can be decomposed into a common (Base + Index) with a; // common constant stride, then return the constant stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:49,Performance,load,loads,49,// Get the distance between the first and second loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Performance,load,loads,17,// Check all the loads are the same distance apart,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,load,load,76,"// TODO: At this point, we've successfully matched a generalized gather; // load. Maybe we should emit that, and then move the specialized; // matchers above and below into a DAG combine?; // Get the widened scalar type, e.g. v4i8 -> i64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Performance,load,load,39,"// Get the vector type for the strided load, e.g. 4 x v4i8 -> v4i64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Performance,load,load,65,"// If Stride isn't constant, then we can't know how much it will load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Performance,load,loads,18,"// RISC-V indexed loads only support the ""unsigned unscaled"" addressing; // mode, so anything else must be manually legalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,Availability,mask,mask,70,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:86,Performance,perform,performs,86,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:239,Security,access,access,239,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,// Create the shuffle mask and check all bits active,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:271,Deployability,toggle,toggles,271,"/// Match the index of a gather or scatter operation as an operation; /// with twice the element width and half the number of elements. This is; /// generally profitable (if legal) because these operations are linear; /// in VL, so even if we cause some extract VTYPE/VL toggles, we still; /// come out ahead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Usability,Simpl,SimplifyDemandedBits,18,"// Helper to call SimplifyDemandedBits on an operand of N where only some low; // bits are demanded. N will be added to the Worklist if it was not deleted.; // Caller should return SDValue(N, 0) if this returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Availability,redundant,redundant,75,"// If the input to SplitF64 is just BuildPairF64 then the operation is; // redundant. Instead, use BuildPairF64's operands directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Safety,redund,redundant,75,"// If the input to SplitF64 is just BuildPairF64 then the operation is; // redundant. Instead, use BuildPairF64's operands directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,Performance,load,load,59,// It's cheaper to materialise two 32-bit integers than to load a double; // from the constant pool and transfer it to integer registers through the; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Performance,perform,performed,53,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,perform,performs,100,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Performance,perform,performed,53,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,perform,performs,100,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Safety,safe,safe,107,// Fold (zero_extend (fp_to_uint X)) to prevent forming fcvt+zexti32 during; // type legalization. This is safe because fp_to_uint produces poison if; // it overflows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Safety,safe,safe,19,// freeze it to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Integrability,inject,injects,35,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:124,Modifiability,extend,extend,124,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,Performance,optimiz,optimized,157,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:176,Safety,Avoid,Avoid,176,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Security,inject,injects,35,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,Modifiability,extend,extend,25,"// Avoid cases where the extend/round has multiple uses, as duplicating; // those is typically more expensive than removing a fneg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Avoid,Avoid,3,"// Avoid cases where the extend/round has multiple uses, as duplicating; // those is typically more expensive than removing a fneg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,Safety,avoid,avoid,95,"// The sequence will be XLenVT, not the type of Index. Tell; // isSimpleVIDSequence this so we avoid overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Energy Efficiency,power,power-of-two,82,"// If sufficiently aligned we can scalarize stores of constant vectors of; // any power-of-two size up to XLen bits, provided that they aren't too; // expensive to materialize.; // vsetivli zero, 2, e8, m1, ta, ma; // vmv.v.i v8, 4; // vse64.v v8, (a0); // ->; // li a1, 1028; // sh a1, 0(a0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:130,Safety,avoid,avoid,130,// Combine store of vmv.x.s/vfmv.f.s to vse with VL of 1.; // vfmv.f.s is represented as extract element from 0. Match it late to avoid; // any illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Performance,scalab,scalable,19,// VecVT should be scalable and memory VT should match the element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,// Only perform this combine on legal MVT types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Safety,avoid,avoid,24,// Use M1 or smaller to avoid over constraining register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,Availability,mask,masked,73,"// If the stride is equal to the element size in bytes, we can use; // a masked.load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,Performance,load,load,80,"// If the stride is equal to the element size in bytes, we can use; // a masked.load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,Availability,mask,masked,73,"// If the stride is equal to the element size in bytes, we can use; // a masked.store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Safety,avoid,avoid,107,"// If this is a bitcast between a MVT::v4i1/v2i1/v1i1 and an illegal integer; // type, widen both sides to avoid a trip through memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Performance,optimiz,optimization,14,// Delay this optimization as late as possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear all non-demanded bits initially.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,mask,mask,17,"// If the shrunk mask fits in sign extended 12 bits, let the target; // independent code apply it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Modifiability,extend,extended,35,"// If the shrunk mask fits in sign extended 12 bits, let the target; // independent code apply it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,Availability,mask,mask,110,"// For the remaining optimizations, we need to be able to make a negative; // number through a combination of mask and undemanded bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Performance,optimiz,optimizations,21,"// For the remaining optimizations, we need to be able to make a negative; // number through a combination of mask and undemanded bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,// Check that our new mask is a subset of the demanded mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:55,Availability,mask,mask,55,// Check that our new mask is a subset of the demanded mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extending,38,// Restore the original width by sign extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extending,38,// Restore the original width by sign extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extending,38,// Restore the original width by sign extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:93,Energy Efficiency,power,power,93,// We can use the minimum and maximum VLEN values to bound VLENB. We; // know VLEN must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:128,Integrability,depend,depending,128,"// TODO: As the result is sign-extended, this is conservatively correct. A; // more precise answer could be calculated for SRAW depending on known; // bits in the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Modifiability,extend,extended,31,"// TODO: As the result is sign-extended, this is conservatively correct. A; // more precise answer could be calculated for SRAW depending on known; // bits in the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:229,Modifiability,extend,extended,229,"// riscv_masked_{atomicrmw_*,cmpxchg} intrinsics represent an emulated; // narrow atomic operation. These are implemented using atomic; // operations at the minimum supported atomicrmw/cmpxchg width whose; // result is then sign extended to XLEN. With +A, the minimum width is; // 32 for both 64 and 32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simple,3,"// Simple case, LLA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Integrability,wrap,wrapped,102,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:197,Performance,load,load,197,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:238,Performance,load,load,238,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:279,Performance,load,load,279,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:949,Integrability,depend,depend,949,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:1058,Integrability,depend,depend,1058,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:474,Performance,optimiz,optimize,474,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:771,Safety,safe,safe,771,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:907,Security,access,access,907,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi nodes for the selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi nodes for the selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Integrability,depend,dependency,11,// Add FRM dependency to any instructions with dynamic rounding mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:592,Availability,avail,available,592,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:1057,Integrability,depend,depending,1057,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:160,Safety,avoid,avoid,160,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:247,Usability,simpl,simply,247,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:298,Usability,simpl,simple,298,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Availability,mask,mask,20,// Assign the first mask argument to V0.; // This is an interim calling convention and it may be changed in the; // future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Availability,failure,failure,63,// Implements the RISC-V calling convention. Returns true upon failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:114,Availability,avail,available,114,// Any return value split in to more than two values can't be returned; // directly. Vectors are returned via the available vector registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:137,Availability,avail,available,137,"// UseGPRForF16_F32 if targeting one of the soft-float ABIs, if passing a; // variadic argument, or if no F16/F32 argument registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:136,Availability,avail,available,136,"// UseGPRForF64 if targeting soft-float ABIs or an FLEN=32 ABI, if passing a; // variadic argument, or if no F64 argument registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:84,Modifiability,variab,variables,84,"// From this point on, rely on UseGPRForF16_F32, UseGPRForF64 and; // similar local variables rather than directly checking against the target; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,avail,available,16,"// Depending on available argument GPRS, f64 may be passed in a pair of; // GPRs, split between a GPR and the stack, or passed completely on the; // stack. LowerCall/LowerFormalArguments/LowerReturn must recognise these; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Integrability,Depend,Depending,3,"// Depending on available argument GPRS, f64 may be passed in a pair of; // GPRs, split between a GPR and the stack, or passed completely on the; // stack. LowerCall/LowerFormalArguments/LowerReturn must recognise these; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable-vector,57,// Fixed-length vectors are located in the corresponding scalable-vector; // container types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate to a register if possible, or else a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Performance,load,loading,33,// The caller is responsible for loading the full value if the argument is; // passed with CCValAssign::Indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Modifiability,extend,extended,20,"// If input is sign extended from 32 bits, note it for the SExtWRemoval pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Modifiability,extend,extended,17,// An input zero extended from i31 can also be considered sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Modifiability,extend,extended,63,// An input zero extended from i31 can also be considered sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Performance,load,loading,33,// The caller is responsible for loading the full value if the argument is; // passed with CCValAssign::Indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Performance,scalab,scalable,23,"// When the value is a scalable vector, we save the pointer which points to; // the scalable vector value in the stack. The ValVT will be the pointer; // type, instead of the scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:84,Performance,scalab,scalable,84,"// When the value is a scalable vector, we save the pointer which points to; // the scalable vector value in the stack. The ValVT will be the pointer; // type, instead of the scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,Performance,scalab,scalable,175,"// When the value is a scalable vector, we save the pointer which points to; // the scalable vector value in the stack. The ValVT will be the pointer; // type, instead of the scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Performance,perform,performance,27,"// FastCC has less than 1% performance improvement for some particular; // benchmark. But theoretically, it may has benenfit for some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Testability,benchmark,benchmark,75,"// FastCC has less than 1% performance improvement for some particular; // benchmark. But theoretically, it may has benenfit for some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Availability,avail,available,24,// Check if there is an available GPR before hitting the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable-vector,57,// Fixed-length vectors are located in the corresponding scalable-vector; // container types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Performance,scalab,scalable,14,// Can't pass scalable vectors on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,Performance,load,load,98,"// If the original argument was split and passed by reference (e.g. i128; // on RV32), we need to load all parts of it here (using the same; // address). Vectors may be partly split to registers and partly to the; // stack, in which case the base address is partly offset and subsequent; // stores are relative to that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Performance,optimiz,optimization,94,/// isEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.; /// Note: This is modelled after ARM's IsEligibleForTailCallOptimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:240,Availability,avail,available,240,"// Do not tail call opt if any parameters need to be passed indirectly.; // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are; // passed indirectly. So the address of the value will be passed in a; // register, or if not available, then the address is put on the stack. In; // order to pass indirectly, space on the stack often needs to be allocated; // in order to store the value. In this case the CCInfo.getNextStackOffset(); // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs; // are passed CCValAssign::Indirect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:359,Energy Efficiency,allocate,allocated,359,"// Do not tail call opt if any parameters need to be passed indirectly.; // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are; // passed indirectly. So the address of the value will be passed in a; // register, or if not available, then the address is put on the stack. In; // order to pass indirectly, space on the stack often needs to be allocated; // in order to store the value. In this case the CCInfo.getNextStackOffset(); // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs; // are passed CCValAssign::Indirect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,Energy Efficiency,efficient,efficient,165,// Byval parameters hand the function a pointer directly into the stack area; // we want to reuse during a tail call. Working around this *is* possible; // but less efficient and uglier in LowerCall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:105,Performance,perform,performing,105,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:52,Security,access,access,52,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,Availability,error,error,98,"// Validate that none of the argument registers have been marked as; // reserved, if so report an error. Do the same for the return address if this; // is not a tailcall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,"// Validate that none of the argument registers have been marked as; // reserved, if so report an error. Do the same for the return address if this; // is not a tailcall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue node if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Integrability,rout,routines,21,// Interrupt service routines use different return instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:93,Performance,perform,perform,93,"// Check if the result of the node is only used as a return value, as; // otherwise we can't perform a tail-call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:91,Performance,perform,perform,91,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:83,Safety,safe,safe,83,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:251,Availability,avail,available,251,"// Since TargetLowering::getRegForInlineAsmConstraint uses the name of the; // TableGen record rather than the AsmName to choose registers for InlineAsm; // constraints, plus we want to match those names to the widest floating point; // register type available, manually select floating point registers here.; //; // The second case is the ABI name of the register, so that frontends can also; // use the ABI names in register constraint lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 12-bit signed immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create an integer zero operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 5-bit unsigned immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:152,Availability,mask,mask,152,"// In the case of an atomicrmw xchg with a constant 0/-1 operand, replace; // the atomic instruction with an AtomicRMWInst::And/Or with appropriate; // mask, as this produces better code than the LR/SC loop emitted by; // int_riscv_masked_atomicrmw_xchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Modifiability,extend,extend,45,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:307,Modifiability,extend,extend,307,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:56,Performance,load,loaded,56,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Performance,perform,performing,82,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,Modifiability,extend,extended,80,// We have indexed loads for all legal index types. Indices are always; // zero extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Performance,load,loads,19,// We have indexed loads for all legal index types. Indices are always; // zero extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:48,Energy Efficiency,reduce,reduce,48,"// If we are using the small code model, we can reduce size of jump table; // entry to 4 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Energy Efficiency,power,power,65,"// We define vscale to be VLEN/RVVBitsPerBlock. VLEN is always a power; // of two >= 64, and RVVBitsPerBlock is 64. Thus, vscale must be; // a power of two as well.; // FIXME: This doesn't work for zve32, but that's already broken; // elsewhere for the same reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:143,Energy Efficiency,power,power,143,"// We define vscale to be VLEN/RVVBitsPerBlock. VLEN is always a power; // of two >= 64, and RVVBitsPerBlock is 64. Thus, vscale must be; // a power of two as well.; // FIXME: This doesn't work for zve32, but that's already broken; // elsewhere for the same reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Performance,load,loads,35,// Target does not support indexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Deployability,update,updates,17,"// Post-indexing updates the base, so it's not a valid transform; // if that's not the same as the load's pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:99,Performance,load,load,99,"// Post-indexing updates the base, so it's not a valid transform; // if that's not the same as the load's pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,Performance,optimiz,optimization,12,// Omit the optimization if the sub target has the M extension and the data; // size exceeds XLen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the MUL to (SH*ADD x, (SLLI x, bits)) if Imm is not simm12.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Security,access,access,47,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Security,access,access,94,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,Security,access,accesses,165,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:240,Security,access,accesses,240,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:366,Performance,load,load,366,"// We use LMUL1 memory operations here for a non-obvious reason. Our caller; // has an expansion threshold, and we want the number of hardware memory; // operations to correspond roughly to that threshold. LMUL>1 operations; // are typically expanded linearly internally, and thus correspond to more; // than one actual memory operation. Note that store merging and load; // combining will typically form larger LMUL operations from the LMUL1; // operations emitted here, and that's okay because combining isn't; // introducing new memory operations; it's just merging existing ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:52,Safety,avoid,avoid,52,"// Prefer i8 for non-zero memset as it allows us to avoid materializing; // a large scalar constant and instead use vmv.v.x/i to do the; // broadcast. For everything else, prefer ELenVT to minimize VL and thus; // maximize the chance we can encode the size in the vsetvli.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Modifiability,extend,extend,27,"// Cast the [b]f16 to i16, extend to i32, pad with ones to make a float; // nan, and cast to f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Performance,optimiz,optimizing,21,"// When aggressively optimizing for code size, we prefer to use a div; // instruction, as it is usually smaller than the alternative sequence.; // TODO: Add vector division?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Security,access,access,29,// Sometimes the interleaved access pass picks up splats as interleaves of; // one element. Don't lower these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,Performance,load,load,25,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:91,Performance,load,load,91,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Performance,load,load,127,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:380,Performance,load,load,380,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Performance,perform,perform,31,// Lower SDIV as SDIV; // Only perform this transform if short forward branch opt is supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:50,Integrability,Interface,Interface,50,"//===-- RISCVISelLowering.h - RISC-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that RISC-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- RISCVISelLowering.h - RISC-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that RISC-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:46,Usability,simpl,simply,46,// 32-bit operations from RV64M that can't be simply matched with a pattern; // at instruction selection time. These have undefined behavior for division; // by 0 or overflow (divw) like their target independent counterparts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:229,Modifiability,extend,extended,229,"// FPR<->GPR transfer operations when the FPR is smaller than XLEN, needed as; // XLEN is the only legal integer width.; //; // FMV_H_X matches the semantics of the FMV.H.X.; // FMV_X_ANYEXTH is similar to FMV.X.H but has an any-extended result.; // FMV_X_SIGNEXTH is similar to FMV.X.H and has a sign-extended result.; // FMV_W_X_RV64 matches the semantics of the FMV.W.X.; // FMV_X_ANYEXTW_RV64 is similar to FMV.X.W but has an any-extended result.; //; // This is a more convenient semantic for producing dagcombines that remove; // unnecessary GPR->FPR->GPR moves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:302,Modifiability,extend,extended,302,"// FPR<->GPR transfer operations when the FPR is smaller than XLEN, needed as; // XLEN is the only legal integer width.; //; // FMV_H_X matches the semantics of the FMV.H.X.; // FMV_X_ANYEXTH is similar to FMV.X.H but has an any-extended result.; // FMV_X_SIGNEXTH is similar to FMV.X.H and has a sign-extended result.; // FMV_W_X_RV64 matches the semantics of the FMV.W.X.; // FMV_X_ANYEXTW_RV64 is similar to FMV.X.W but has an any-extended result.; //; // This is a more convenient semantic for producing dagcombines that remove; // unnecessary GPR->FPR->GPR moves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:434,Modifiability,extend,extended,434,"// FPR<->GPR transfer operations when the FPR is smaller than XLEN, needed as; // XLEN is the only legal integer width.; //; // FMV_H_X matches the semantics of the FMV.H.X.; // FMV_X_ANYEXTH is similar to FMV.X.H but has an any-extended result.; // FMV_X_SIGNEXTH is similar to FMV.X.H and has a sign-extended result.; // FMV_W_X_RV64 matches the semantics of the FMV.W.X.; // FMV_X_ANYEXTW_RV64 is similar to FMV.X.W but has an any-extended result.; //; // This is a more convenient semantic for producing dagcombines that remove; // unnecessary GPR->FPR->GPR moves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:100,Modifiability,extend,extended,100,// FP to 32 bit int conversions for RV64. These are used to keep track of the; // result being sign extended to 64 bit. These saturate out of range inputs.; // Used for FP_TO_S/UINT and FP_TO_S/UINT_SAT lowering. Rounding mode; // is passed as a TargetConstant operand using the RISCVFPRndMode enum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:82,Modifiability,extend,extended,82,// VMV_X_S matches the semantics of vmv.x.s. The result is always XLenVT sign; // extended from the vector element size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:135,Performance,load,load,135,// Splats an 64-bit value that has been split into two i32 parts. This is; // expanded late to two scalar stores and a stride 0 vector load.; // The first operand is passthru operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:81,Availability,mask,mask,81,// Truncates a RVV integer vector by one power-of-two. Carries both an extra; // mask and VL operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:41,Energy Efficiency,power,power-of-two,41,// Truncates a RVV integer vector by one power-of-two. Carries both an extra; // mask and VL operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:217,Availability,mask,mask,217,"// Matches the semantics of vslideup/vslidedown. The first operand is the; // pass-thru operand, the second is the source vector, the third is the XLenVT; // index (either constant or non-constant), the fourth is the mask, the fifth; // is the VL and the sixth is the policy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:198,Availability,mask,mask,198,"// Matches the semantics of vslide1up/slide1down. The first operand is; // passthru operand, the second is source vector, third is the XLenVT scalar; // value. The fourth and fifth operands are the mask and VL operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:247,Availability,mask,mask,247,"// Matches the semantics of vfslide1up/vfslide1down. The first operand is; // passthru operand, the second is source vector, third is a scalar value; // whose type matches the element type of the vectors. The fourth and fifth; // operands are the mask and VL operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:58,Availability,mask,mask,58,"// Matches the semantics of the vid.v instruction, with a mask and VL; // operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:221,Availability,mask,mask,221,"// Matches the semantics of the vfcnvt.rod function (Convert double-width; // float to single-width float, rounding towards odd). Takes a double-width; // float vector and produces a single-width float vector. Also has a mask and; // VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:755,Availability,mask,mask,755,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:684,Energy Efficiency,reduce,reduces,684,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:151,Performance,perform,performed,151,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:56,Availability,mask,mask,56,"// Vector binary ops with a merge as a third operand, a mask as a fourth; // operand, and VL as a fifth operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:27,Availability,mask,mask,27,// Vector unary ops with a mask as a second operand and VL as a third operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:25,Availability,mask,mask,25,// Vector FMA ops with a mask as a fourth operand and VL as a fifth operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:34,Availability,mask,mask,34,// Vector widening FMA ops with a mask as a fourth operand and VL as a fifth; // operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:63,Availability,mask,mask,63,"// Widening instructions with a merge value a third operand, a mask as a; // fourth operand, and VL as a fifth operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:38,Availability,mask,mask,38,// Widening ternary operations with a mask as the fourth operand and VL as the; // fifth operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:77,Availability,mask,mask,77,"// Narrowing logical shift right.; // Operands are (source, shift, passthru, mask, vl)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:13,Testability,log,logical,13,"// Narrowing logical shift right.; // Operands are (source, shift, passthru, mask, vl)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:30,Availability,mask,mask,30,// Vector compare producing a mask. Fourth operand is input mask. Fifth; // operand is VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:60,Availability,mask,mask,60,// Vector compare producing a mask. Fourth operand is input mask. Fifth; // operand is VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,Availability,mask,mask,28,"// General vmerge node with mask, true, false, passthru, and vl operands.; // Tail agnostic vselect can be implemented by setting passthru to undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:3,Availability,Mask,Mask,3,// Mask binary operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:7,Availability,mask,mask,7,// Set mask vector to all zeros or ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:127,Availability,mask,mask,127,"// Matches the semantics of vrgather.vx and vrgather.vv with extra operands; // for passthru and VL. Operands are (src, index, mask, passthru, vl).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:43,Availability,mask,mask,43,// Vector sign/zero extend with additional mask & VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:20,Modifiability,extend,extend,20,// Vector sign/zero extend with additional mask & VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:27,Availability,mask,mask,27,// vcpop.m with additional mask and VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,Availability,mask,mask,28,// vfirst.m with additional mask and VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:6,Availability,mask,maskc,6,// vt.maskc for XVentanaCondOps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:6,Availability,mask,maskcn,6,// vt.maskcn for XVentanaCondOps.; // FP to 32 bit int conversions for RV64. These are used to keep track of the; // result being sign extended to 64 bit. These saturate out of range inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:135,Modifiability,extend,extended,135,// vt.maskcn for XVentanaCondOps.; // FP to 32 bit int conversions for RV64. These are used to keep track of the; // result being sign extended to 64 bit. These saturate out of range inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:37,Availability,mask,mask,37,"/// Return true if the given shuffle mask can be codegen'd directly, or if it; /// should be stack expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:240,Safety,avoid,avoids,240,"// If the pair to store is a mixture of float and int values, we will; // save two bitwise instructions and one float-to-int instruction and; // increase one store instruction. There is potentially a more; // significant benefit because it avoids the float->int domain switch; // for input value. So It is more likely a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:231,Testability,test,testcase,231,"// If the pair only contains int values, we will save two bitwise; // instructions and increase one store instruction (costing one more; // store buffer). Since the benefit is more blurred we leave such a pair; // out until we get testcase to prove it is a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:128,Performance,load,load,128,"// If we can replace 4 or more scalar stores, there will be a reduction; // in instructions even after we add a vector constant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:257,Security,access,access,257,/// Returns the register with the specified architectural or ABI name. This; /// method is necessary to lower the llvm.read_register.* and; /// llvm.write_register.* intrinsics. Allocatable registers must be reserved; /// with the clang -ffixed-xX flag for access to be allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:55,Security,access,accesses,55,/// Returns true if the target allows unaligned memory accesses of the; /// specified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:79,Performance,scalab,scalable,79,"// Return inclusive (low, high) bounds on the value of VLMAX for the; // given scalable container type given known bounds on VLEN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:46,Performance,load,load,46,// Scaled addressing not supported on indexed load/stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:52,Performance,load,load,52,/// Returns whether or not generating a interleaved load/store intrinsic for; /// this type will be legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,Performance,load,load,28,/// Return true if a stride load store of the given result type and; /// alignment is legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:52,Modifiability,extend,extends,52,/// RISCVCCAssignFn - This target-specific function extends the default; /// CCValAssign with additional information used to lower RISC-V calling; /// conventions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:13,Availability,error,error,13,/// Generate error diagnostics if any register used by CC has been marked; /// reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:197,Performance,perform,perform,197,"/// Disable normalizing; /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and; /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)); /// RISC-V doesn't have flags so it's better to perform the and/or in a GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:8,Availability,avail,available,8,/// For available scheduling models FDIV + two independent FMULs are much; /// faster than two FDIVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:18,Energy Efficiency,schedul,scheduling,18,/// For available scheduling models FDIV + two independent FMULs are much; /// faster than two FDIVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMachineFunctionInfo.h:34,Modifiability,extend,extended,34,/// Registers that have been sign extended from i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:730,Availability,avail,available,730,"//===-- RISCVMakeCompressible.cpp - Make more instructions compressible ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1076,Availability,avail,available,1076,"e Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1301,Availability,avail,available,1301,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1738,Availability,avail,available,1738,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:2162,Energy Efficiency,reduce,reduced,2162,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:2061,Performance,optimiz,optimization,2061,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1819,Security,access,accessed,1819,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:32,Performance,load,load,32,// Return log2(widthInBytes) of load/store done by Opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:12,Availability,mask,mask,12,// Return a mask for the offset bits of a non-stack-pointer based compressed; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:81,Performance,load,load,81,// Return a mask for the offset bits of a non-stack-pointer based compressed; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:74,Performance,load,load,74,// Return true if Offset fits within a compressed stack-pointer based; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:25,Performance,load,load,25,"// Given an offset for a load/store, return the adjustment required to the base; // register such that the address can be accessed with a compressible offset.; // This will return 0 if the offset is already compressible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:122,Security,access,accessed,122,"// Given an offset for a load/store, return the adjustment required to the base; // register such that the address can be accessed with a compressible offset.; // This will return 0 if the offset is already compressible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:26,Performance,load,load,26,// Return true if MI is a load for which there exists a compressed version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:434,Performance,optimiz,optimization,434,"// Find a single register and/or large offset which, if compressible, would; // allow the given instruction to be compressed.; //; // Possible return values:; //; // {Reg, 0} - Uncompressed Reg needs replacing with a compressed; // register.; // {Reg, N} - Reg needs replacing with a compressed register and; // N needs adding to the new register. (Reg may be; // compressed or uncompressed).; // {RISCV::NoRegister, 0} - No suitable optimization found for this; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:10,Security,access,accesses,10,// Memory accesses via the stack pointer do not have a requirement for; // either of the registers to be compressible and can take a larger offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:7,Performance,load,loads,7,"// For loads, we can only change the base register since dest is defined; // rather than used.; //; // For stores, we can change SrcDest (and Base if SrcDest == Base) but; // cannot resolve an uncompressible offset in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:300,Availability,avail,available,300,"// Check all uses after FirstMI of the given register, keeping a vector of; // instructions that would be compressible if the given register (and offset if; // applicable) were compressible.; //; // If there are enough uses for this optimization to improve code size and a; // compressed register is available, return that compressed register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:233,Performance,optimiz,optimization,233,"// Check all uses after FirstMI of the given register, keeping a vector of; // instructions that would be compressible if the given register (and offset if; // applicable) were compressible.; //; // If there are enough uses for this optimization to improve code size and a; // compressed register is available, return that compressed register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:65,Performance,optimiz,optimize,65,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:168,Performance,optimiz,optimize,168,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:245,Safety,detect,detected,245,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:46,Availability,avail,available,46,// Find a compressible register which will be available from the first; // instruction we care about to the last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update uses of the old register in the given instruction to the new register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:19,Modifiability,extend,extended,19,"// If this pass is extended to support more instructions, the check for; // definedness may need to be strengthened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:110,Safety,avoid,avoid,110,"// Skip the first (value) operand to a store instruction (except if the store; // offset is zero) in order to avoid an incorrect transformation.; // e.g. sd a0, 808(a0) to addi a2, a0, 768; sd a2, 40(a2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:10,Deployability,update,update,10,"// Do not update operands that define the old register.; //; // The new register was scavenged for the range of instructions that are; // being updated, therefore it should not be defined within this range; // except possibly in the final instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:144,Deployability,update,updated,144,"// Do not update operands that define the old register.; //; // The new register was scavenged for the range of instructions that are; // being updated, therefore it should not be defined within this range; // except possibly in the final instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update reg,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:18,Performance,optimiz,optimization,18,// This is a size optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:8,Performance,optimiz,optimization,8,"// This optimization only makes sense if compressed instructions are emitted.; // FIXME: Support Zca, Zcf, Zcd granularity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:151,Performance,load,loads,151,"// If we are looking at replacing an FPR register we don't expect to; // have any offset. The only compressible FP instructions with an offset; // are loads and stores, for which the offset applies to the GPR operand; // not the FPR operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update the set of instructions to use the compressed register and; // compressible offset instead. These instructions should now be; // compressible.; // TODO: Update all uses if RegImm.Imm == 0? Not just those that are; // expected to become compressible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:163,Deployability,Update,Update,163,// Update the set of instructions to use the compressed register and; // compressible offset instead. These instructions should now be; // compressible.; // TODO: Update all uses if RegImm.Imm == 0? Not just those that are; // expected to become compressible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:49,Performance,Optimiz,Optimization,49,/// Returns an instance of the Make Compressible Optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Safety,Detect,Detect,3,"// Detect either of the patterns:; //; // 1. (medlow pattern):; // lui vreg1, %hi(s); // addi vreg2, vreg1, %lo(s); //; // 2. (medany pattern):; // .Lpcrel_hi1:; // auipc vreg1, %pcrel_hi(s); // addi vreg2, vreg1, %pcrel_lo(.Lpcrel_hi1); //; // The pattern is only accepted if:; // 1) The first instruction has only one use, which is the ADDI.; // 2) The address operands have the appropriate type, reflecting the; // lowering of a global address or constant pool using medlow or medany.; // 3) The offset value in the Global Address or Constant Pool is 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Deployability,Update,Update,3,// Update the offset in Hi and Lo instructions.; // Delete the tail instruction and update all the uses to use the; // output from Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:84,Deployability,update,update,84,// Update the offset in Hi and Lo instructions.; // Delete the tail instruction and update all the uses to use the; // output from Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:107,Deployability,update,updates,107,"// Detect patterns for large offsets that are passed into an ADD instruction.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailAdd and the instructions that produced the offset.; //; // Base address lowering is of the form:; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // / \; // / \; // / \; // / The large offset can be of two forms: \; // 1) Offset that has non zero bits in lower 2) Offset that has non zero; // 12 bits and upper 20 bits bits in upper 20 bits only; // OffseLUI: lui vreg3, 4; // OffsetTail: addi voff, vreg3, 188 OffsetTail: lui voff, 128; // \ /; // \ /; // \ /; // \ /; // TailAdd: add vreg4, vreg2, voff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Safety,Detect,Detect,3,"// Detect patterns for large offsets that are passed into an ADD instruction.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailAdd and the instructions that produced the offset.; //; // Base address lowering is of the form:; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // / \; // / \; // / \; // / The large offset can be of two forms: \; // 1) Offset that has non zero bits in lower 2) Offset that has non zero; // 12 bits and upper 20 bits bits in upper 20 bits only; // OffseLUI: lui vreg3, 4; // OffsetTail: addi voff, vreg3, 188 OffsetTail: lui voff, 128; // \ /; // \ /; // \ /; // \ /; // TailAdd: add vreg4, vreg2, voff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:69,Safety,Detect,Detect,69,// The offset value has non zero bits in both %hi and %lo parts.; // Detect an ADDI that feeds from a LUI instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:46,Modifiability,extend,extends,46,// RV32 ignores the upper 32 bits. ADDIW sign extends the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:313,Deployability,update,updates,313,"// Detect patterns for offsets that are passed into a SHXADD instruction.; // The offset has 1, 2, or 3 trailing zeros and fits in simm13, simm14, simm15.; // The constant is created with addi voff, x0, C, and shXadd is used to; // fill insert the trailing zeros and do the addition.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailShXAdd and the instructions that produced the offset.; //; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // OffsetTail: addi voff, x0, C; // TailAdd: shXadd vreg4, voff, vreg2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Safety,Detect,Detect,3,"// Detect patterns for offsets that are passed into a SHXADD instruction.; // The offset has 1, 2, or 3 trailing zeros and fits in simm13, simm14, simm15.; // The constant is created with addi voff, x0, C, and shXadd is used to; // fill insert the trailing zeros and do the addition.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailShXAdd and the instructions that produced the offset.; //; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // OffsetTail: addi voff, x0, C; // TailAdd: shXadd vreg4, voff, vreg2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:13,Usability,simpl,simply,13,// Offset is simply an immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:7,Performance,load,load,7,// All load/store instructions must use the same offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:33,Deployability,Update,Update,33,// We found a common offset.; // Update the offsets in global address lowering.; // We may have already folded some arithmetic so we need to add to any; // existing offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Deployability,Update,Update,3,// Update the immediate in the load/store instructions to add the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:31,Performance,load,load,31,// Update the immediate in the load/store instructions to add the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:49,Performance,Optimiz,Optimization,49,/// Returns an instance of the Merge Base Offset Optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:414,Performance,perform,performs,414,"//===-- RISCVMoveMerger.cpp - RISC-V move merge pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs move related peephole optimizations; // as Zcmp has specified. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:445,Performance,optimiz,optimizations,445,"//===-- RISCVMoveMerger.cpp - RISC-V move merge pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs move related peephole optimizations; // as Zcmp has specified. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:22,Integrability,depend,depends,22,"// The order of S-reg depends on which instruction holds A0, instead of; // the order of register pair.; // e,g.; // mv a1, s1; // mv a0, s2 => cm.mva01s s2,s1; //; // mv a0, s2; // mv a1, s1 => cm.mva01s s2,s1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:3,Deployability,Update,Update,3,// Update modified / used register units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:136,Performance,optimiz,optimize,136,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we optimize a; // move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:98,Usability,clear,clear,98,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we optimize a; // move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:923,Energy Efficiency,reduce,reduce,923,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:731,Integrability,depend,dependent,731,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:536,Modifiability,extend,extended,536,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:604,Modifiability,extend,extended,604,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:46,Performance,optimiz,optimizations,46,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:402,Performance,optimiz,optimizations,402,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:930,Testability,test,test,930,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:77,Integrability,depend,depends,77,"// these overwrite higher input bits, otherwise the lower word of output; // depends only on the lower word of input. So check their uses read W.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:32,Modifiability,extend,extended,32,// Operand 1 is implicitly zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,Integrability,depend,depends,56,"// For these, lower word of output in these operations, depends only on; // the lower word of input. So, we check all uses only read lower word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:59,Modifiability,extend,extended,59,// shifting right sufficiently makes the value 32-bit sign-extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:43,Modifiability,extend,extended,43,"// The LI pattern ADDI rd, X0, imm is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:27,Modifiability,extend,extended,27,// A bseti with X0 is sign extended if the immediate is less than 31.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:21,Modifiability,extend,extending,21,// If this is a sign extending operation we don't need to look any further.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:47,Modifiability,extend,extend,47,// Is this an instruction that propagates sign extend?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:88,Modifiability,extend,extended,88,"// If this is the entry block and the register is livein, see if we know; // it is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:63,Modifiability,extend,extended,63,"// For these, we just need to check if the 1st operand is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:178,Modifiability,extend,extended,178,"// |Remainder| is always <= |Dividend|. If D is 32-bit, then so is R.; // DIV doesn't work because of the edge case 0xf..f 8000 0000 / (long)-1; // Logical operations use a sign extended 12-bit immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:148,Testability,Log,Logical,148,"// |Remainder| is always <= |Dividend|. If D is 32-bit, then so is R.; // DIV doesn't work because of the edge case 0xf..f 8000 0000 / (long)-1; // Logical operations use a sign extended 12-bit immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:110,Modifiability,extend,extended,110,// Returns operand 4 or an ADDW/SUBW/etc. of operands 5 and 6. We only; // need to check if operand 4 is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:35,Modifiability,extend,extended,35,"// If all incoming values are sign-extended, the output of AND, OR, XOR,; // MIN, MAX, or PHI is also sign-extended.; // The input registers for PHI are operand 1, 3, ...; // The input registers for PseudoCCMOVGPR are 4 and 5.; // The input registers for PseudoCCAND/OR/XOR are 4, 5, and 6.; // The input registers for others are operand 1 and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:107,Modifiability,extend,extended,107,"// If all incoming values are sign-extended, the output of AND, OR, XOR,; // MIN, MAX, or PHI is also sign-extended.; // The input registers for PHI are operand 1, 3, ...; // The input registers for PseudoCCMOVGPR are 4 and 5.; // The input registers for PseudoCCAND/OR/XOR are 4, 5, and 6.; // The input registers for others are operand 1 and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:57,Modifiability,extend,extended,57,// Instructions return zero or operand 1. Result is sign extended if; // operand 1 is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:91,Modifiability,extend,extended,91,// Instructions return zero or operand 1. Result is sign extended if; // operand 1 is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:62,Modifiability,extend,extended,62,"// If we get here, then every node we visited produces a sign extended value; // or propagated sign extended values. So the result must be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:100,Modifiability,extend,extended,100,"// If we get here, then every node we visited produces a sign extended value; // or propagated sign extended values. So the result must be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:144,Modifiability,extend,extended,144,"// If we get here, then every node we visited produces a sign extended value; // or propagated sign extended values. So the result must be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,Availability,redundant,redundant,56,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:150,Availability,redundant,redundant,150,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:110,Modifiability,extend,extend,110,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,Safety,redund,redundant,56,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:150,Safety,redund,redundant,150,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp:559,Energy Efficiency,schedul,scheduling,559,"//===-- RISCVPostRAExpandPseudoInsts.cpp - Expand pseudo instrs ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands the pseudo instruction pseudolisimm32; // into target instructions. This pass should be run during the post-regalloc; // passes, before post RA scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:57,Deployability,pipeline,pipeline,57,"// Since Pseudo instruction lowering happen later in the pipeline,; // this will detect all ret instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:81,Safety,detect,detect,81,"// Since Pseudo instruction lowering happen later in the pipeline,; // this will detect all ret instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:3,Deployability,Update,Update,3,// Update modified / used register units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:39,Safety,abort,abort,39,"// If Zcmp extension is not supported, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:51,Safety,abort,abort,51,"// If frame pointer elimination has been disabled, abort to avoid breaking the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:60,Safety,avoid,avoid,60,"// If frame pointer elimination has been disabled, abort to avoid breaking the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:98,Usability,clear,clear,98,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we determine; // correct return value for the POP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:82,Performance,optimiz,optimization,82,/// createRISCVPushPopOptimizationPass - returns an instance of the; /// Push/Pop optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:10,Availability,redundant,redundant,10,// Remove redundant Copy instructions unless TargetReg is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:10,Safety,redund,redundant,10,// Remove redundant Copy instructions unless TargetReg is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:3,Usability,Clear,Clear,3,// Clear any kills of TargetReg between CondBr and the last removed COPY.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:72,Energy Efficiency,allocate,allocate,72,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:85,Modifiability,variab,variable-sized,85,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for constant VLEN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:58,Performance,load,loads,58,// Split a VSPILLx_Mx pseudo into multiple whole register loads separated by; // LMUL*VLENB bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for constant VLEN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:28,Performance,scalab,scalable,28,"// For an exact VLEN value, scalable offsets become constant and thus; // can be converted entirely into fixed offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:268,Usability,clear,clear,268,// We chose to emit the canonical immediate sequence rather than folding; // the offset into the using add under the theory that doing so doesn't; // save dynamic instruction count and some target may fuse the canonical; // 32 bit immediate sequence. We still need to clear the portion of the; // offset encoded in the immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:163,Performance,optimiz,optimizations,163,"// Handle spill/fill of synthetic register classes for segment operations to; // ensure correctness in the edge case one gets spilled. There are many; // possible optimizations here, but given the extreme rarity of such spills,; // we prefer simplicity of implementation for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:242,Usability,simpl,simplicity,242,"// Handle spill/fill of synthetic register classes for segment operations to; // ensure correctness in the edge case one gets spilled. There are many; // possible optimizations here, but given the extreme rarity of such spills,; // we prefer simplicity of implementation for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:82,Performance,load,load,82,"// For RISC-V, The machine instructions that include a FrameIndex operand; // are load/store, ADDI instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:47,Performance,load,loads,47,"// We only generate virtual base registers for loads and stores, so; // return false for everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:54,Integrability,interface,interface,54,// Add fixed-sized offset using existing DIExpression interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.h:3,Deployability,Update,Update,3,"// Update DestReg to have the value SrcReg plus an offset. This is; // used during frame layout, and we may need to ensure that if we; // split the offset internally that the DestReg is always aligned,; // assuming that source reg was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:1579,Availability,redundant,redundant,1579,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:949,Energy Efficiency,allocate,allocated,949," undef vector value to pseudo ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to sid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:640,Modifiability,rewrite,rewrites,640,"//===- RISCVRVVInitUndef.cpp - Initialize undef vector value to pseudo ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // ope",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:1873,Modifiability,rewrite,rewrites,1873,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:2065,Performance,optimiz,optimization,2065,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:1579,Safety,redund,redundant,1579,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:26,Deployability,update,update,26,"// We don't have a way to update dead lanes, so keep track of the; // new register so that we avoid querying it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:94,Safety,avoid,avoid,94,"// We don't have a way to update dead lanes, so keep track of the; // new register so that we avoid querying it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:18,Performance,Tune,TuneInfo,18,"// If there is no TuneInfo for this CPU, we fail back to generic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:3,Performance,Load,Loading,3,"// Loading integer from constant pool needs two instructions (the reason why; // the minimum cost is 2): an address calculation instruction and a load; // instruction. Usually, address calculation and instructions used for; // building integers (addi, slli, etc.) can be done in one cycle, so here we; // set the default cost to (LoadLatency + 1) if no threshold is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:146,Performance,load,load,146,"// Loading integer from constant pool needs two instructions (the reason why; // the minimum cost is 2): an address calculation instruction and a load; // instruction. Usually, address calculation and instructions used for; // building integers (addi, slli, etc.) can be done in one cycle, so here we; // set the default cost to (LoadLatency + 1) if no threshold is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:330,Performance,Load,LoadLatency,330,"// Loading integer from constant pool needs two instructions (the reason why; // the minimum cost is 2): an address calculation instruction and a load; // instruction. Usually, address calculation and instructions used for; // building integers (addi, slli, etc.) can be done in one cycle, so here we; // set the default cost to (LoadLatency + 1) if no threshold is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:97,Performance,load,load,97,// FIXME: Enable subregister liveness by default for RVV to better handle; // LMUL>1 and segment load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h:42,Safety,Avoid,Avoid,42,/// Returns RISC-V processor family.; /// Avoid this function! CPU specifics should be kept local to this class; /// and preferably modeled with SubtargetFeatures or properties in; /// initializeProperties().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:96,Security,access,accesses,96,"// A RISC-V hart has a single byte-addressable address space of 2^XLEN bytes; // for all memory accesses, so it is reasonable to assume that an; // implementation has no-op address space casts. If an implementation makes a; // change to this, they can override it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:43,Energy Efficiency,schedul,schedule,43,"// TODO: It would potentially be better to schedule copy propagation after; // expanding pseudos (in addPreEmitPass2). However, performing copy; // propagation after the machine outliner (which runs after addPreEmitPass); // currently leads to incorrect code-gen, where copies to registers within; // outlined functions are removed erroneously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:128,Performance,perform,performing,128,"// TODO: It would potentially be better to schedule copy propagation after; // expanding pseudos (in addPreEmitPass2). However, performing copy; // propagation after the machine outliner (which runs after addPreEmitPass); // currently leads to incorrect code-gen, where copies to registers within; // outlined functions are removed erroneously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:20,Performance,Optimiz,Optimization,20,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:108,Safety,detect,detected,108,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LR/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:63,Safety,avoid,avoiding,63,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LR/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:21,Performance,load,loaded,21,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section could be addressed by; // using gp_rel operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:15,Modifiability,variab,variables,15,"// Only global variables, not functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:10,Modifiability,variab,variable,10,"// If the variable has an explicit section, it is placed in that section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:26,Modifiability,variab,variable,26,// Explicitly placing any variable in the small data section overrides; // the global -G value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:32,Modifiability,variab,variable,32,// Otherwise reject putting the variable to small section if it has an; // explicit section name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:86,Availability,mask,mask,86,"// (and (shl x, c2), c1) will be matched to (srli (slli x, c2+c3), c3) if c1; // is a mask shifted by c2 bits with c3 leading zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Energy Efficiency,Power,Power,3,// Power of 2 is a shift. Negated power of 2 is a shift and a negate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:34,Energy Efficiency,power,power,34,// Power of 2 is a shift. Negated power of 2 is a shift and a negate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:27,Energy Efficiency,power,power,27,// One more or less than a power of 2 can use SLLI+ADD/SUB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:53,Performance,scalab,scalable-vector,53,"// Currently, the ExpandReductions pass can't expand scalable-vector; // reductions, but we still request expansion as RVV doesn't support certain; // reductions and the SelectionDAG can't legalize them either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:54,Performance,load,load,54,// Add a cost of address generation + the cost of the load. The address; // is expected to be a PC relative offset to a constant pool entry; // using auipc/addi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:131,Performance,scalab,scalable,131,"// First, handle cases where having a fixed length vector enables us to; // give a more accurate cost than falling back to generic scalable codegen.; // TODO: Each of these cases hints at a modeling gap around scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:210,Performance,scalab,scalable,210,"// First, handle cases where having a fixed length vector enables us to; // give a more accurate cost than falling back to generic scalable codegen.; // TODO: Each of these cases hints at a modeling gap around scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:37,Availability,mask,mask,37,// vrgather + cost of generating the mask constant.; // We model this for an unknown mask with a single vrgather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:85,Availability,mask,mask,85,// vrgather + cost of generating the mask constant.; // We model this for an unknown mask with a single vrgather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:42,Availability,mask,mask,42,// 2 x (vrgather + cost of generating the mask constant) + cost of mask; // register for the second vrgather. We model this for an unknown; // (shuffle) mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:67,Availability,mask,mask,67,// 2 x (vrgather + cost of generating the mask constant) + cost of mask; // register for the second vrgather. We model this for an unknown; // (shuffle) mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:153,Availability,mask,mask,153,// 2 x (vrgather + cost of generating the mask constant) + cost of mask; // register for the second vrgather. We model this for an unknown; // (shuffle) mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:10,Performance,scalab,scalable,10,// Handle scalable vectors (and fixed vectors legalized to scalable vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:59,Performance,scalab,scalable,59,// Handle scalable vectors (and fixed vectors legalized to scalable vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:165,Availability,mask,mask,165,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:225,Availability,mask,masks,225,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:338,Performance,load,load,338,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Availability,Mask,Mask,3,// Mask operation additionally required extend and truncate,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:40,Modifiability,extend,extend,40,// Mask operation additionally required extend and truncate,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:83,Performance,load,load,83,// The interleaved memory access pass will lower interleaved memory ops (i.e; // a load and store followed by a specific shuffle) to vlseg/vsseg; // intrinsics. In those cases then we can treat it as if it's just one (legal); // memory op,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:26,Security,access,access,26,// The interleaved memory access pass will lower interleaved memory ops (i.e; // a load and store followed by a specific shuffle) to vlseg/vsseg; // intrinsics. In those cases then we can treat it as if it's just one (legal); // memory op,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:176,Availability,mask,mask,176,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:253,Availability,mask,mask,253,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:330,Availability,mask,mask,330,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:18,Performance,load,load,18,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:73,Performance,load,load,73,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:552,Availability,mask,mask,552,"// TODO: Model for NF > 2; // We'll need to enhance getShuffleCost to model shuffles that are just; // inserts and extracts into subvectors, since they won't have the full cost; // of a vrgather.; // An interleaved store for 3 vectors of 4 lanes will look like; // %11 = shufflevector <4 x i32> %4, <4 x i32> %6, <8 x i32> <0...7>; // %12 = shufflevector <4 x i32> %9, <4 x i32> poison, <8 x i32> <0...3>; // %13 = shufflevector <8 x i32> %11, <8 x i32> %12, <12 x i32> <0...11>; // %interleaved.vec = shufflevector %13, poison, <12 x i32> <interleave mask>; // store <12 x i32> %interleaved.vec, ptr %10, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:44,Modifiability,enhance,enhance,44,"// TODO: Model for NF > 2; // We'll need to enhance getShuffleCost to model shuffles that are just; // inserts and extracts into subvectors, since they won't have the full cost; // of a vrgather.; // An interleaved store for 3 vectors of 4 lanes will look like; // %11 = shufflevector <4 x i32> %4, <4 x i32> %6, <8 x i32> <0...7>; // %12 = shufflevector <4 x i32> %9, <4 x i32> poison, <8 x i32> <0...3>; // %13 = shufflevector <8 x i32> %11, <8 x i32> %12, <12 x i32> <0...11>; // %interleaved.vec = shufflevector %13, poison, <12 x i32> <interleave mask>; // store <12 x i32> %interleaved.vec, ptr %10, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:46,Performance,perform,perform,46,"// For an interleaving store of 2 vectors, we perform one large interleaving; // shuffle that goes into the wide store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:76,Performance,scalab,scalable,76,"// Cost is proportional to the number of memory operations implied. For; // scalable vectors, we use an estimate on that number since we don't; // know exactly what VL will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:35,Performance,throughput,throughput,35,"// Currently, these represent both throughput and codesize costs; // for the respective intrinsics. The costs in this table are simply; // instruction counts with the following adjustments made:; // * One vsetvli is considered free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:128,Usability,simpl,simply,128,"// Currently, these represent both throughput and codesize costs; // for the respective intrinsics. The costs in this table are simply; // instruction counts with the following adjustments made:; // * One vsetvli is considered free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:44,Availability,mask,mask,44,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:118,Availability,mask,mask,118,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:32,Modifiability,extend,extend,32,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:106,Modifiability,extend,extend,106,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:46,Availability,mask,mask,46,"// We do not use several vncvt to truncate to mask vector. So we could; // not use PowDiff to calculate it.; // Instead we use the following instructions to truncate to mask vector:; // vand.vi v8, v8, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:169,Availability,mask,mask,169,"// We do not use several vncvt to truncate to mask vector. So we could; // not use PowDiff to calculate it.; // Instead we use the following instructions to truncate to mask vector:; // vand.vi v8, v8, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:34,Availability,mask,mask,34,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:131,Availability,mask,mask,131,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:288,Availability,mask,mask,288,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:35,Availability,mask,mask,35,"// vcpop sequences, see vreduction-mask.ll. umax, smin actually only; // cost 2, but we don't have enough info here so we slightly over cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:35,Availability,mask,mask,35,"// vcpop sequences, see vreduction-mask.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:81,Security,access,accessed,81,// Assume memory ops cost scale with the number of vector registers; // possible accessed by the instruction. Note that BasicTTI already; // handles the LT.first term for us.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:177,Performance,scalab,scalable,177,"// If we do not support the input floating point vector type, use the base; // one which will calculate as:; // ScalarizeCost + Num * Cost for fixed vector,; // InvalidCost for scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:30,Safety,predict,predicted,30,// Branches are assumed to be predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:102,Performance,load,loads,102,"// Extract/InsertElement with non-constant index is very costly when; // scalarized; estimate cost of loads/stores sequence via the stack:; // ExtractElement cost: store vector to stack, load scalar;; // InsertElement cost: store vector to stack, store scalar, load vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:187,Performance,load,load,187,"// Extract/InsertElement with non-constant index is very costly when; // scalarized; estimate cost of loads/stores sequence via the stack:; // ExtractElement cost: store vector to stack, load scalar;; // InsertElement cost: store vector to stack, store scalar, load vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:261,Performance,load,load,261,"// Extract/InsertElement with non-constant index is very costly when; // scalarized; estimate cost of loads/stores sequence via the stack:; // ExtractElement cost: store vector to stack, load scalar;; // InsertElement cost: store vector to stack, store scalar, load vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:19,Performance,scalab,scalable,19,// For unsupported scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Availability,Mask,Mask,3,// Mask vector extract/insert is expanded via e8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:563,Integrability,depend,dependecies,563,"// In the basic model we take into account GEP instructions only; // (although here can come alloca instruction, a value, constants and/or; // constant expressions, PHIs, bitcasts ... whatever allowed to be used as a; // pointer). Typically, if Base is a not a GEP-instruction and all the; // pointers are relative to the same base address, all the rest are; // either GEP instructions, PHIs, bitcasts or constants. When we have same; // base, we just calculate cost of each non-Base GEP as an ADD operation if; // any their index is a non-const.; // If no known dependecies between the pointers cost is calculated as a sum; // of costs of GEP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:118,Performance,perform,performance,118,// TODO: More tuning on benchmarks and metrics with changes as needed; // would apply to all settings below to enable performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:24,Testability,benchmark,benchmarks,24,// TODO: More tuning on benchmarks and metrics with changes as needed; // would apply to all settings below to enable performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:49,Integrability,depend,dependant,49,"// Enable Upper bound unrolling universally, not dependant upon the conditions; // below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:60,Safety,predict,predictor,60,// Limit the CFG of the loop body for targets with a branch predictor.; // Allowing 4 blocks permits if-then-else diamonds in the body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:81,Integrability,rout,routine,81,"// Return how many elements can fit in getRegisterBitwidth. This is the; // same routine as used in LoopVectorizer. We should probably be; // accounting for whether we actually have instructions with the right; // lane type, but we don't have enough information to do that without; // some additional plumbing which hasn't been justified yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:167,Performance,scalab,scalable,167,"/// This function returns an estimate for VL to be used in VL based terms; /// of the cost model. For fixed length vectors, this is simply the; /// vector length. For scalable vectors, we return results consistent; /// with getVScaleForTuning under the assumption that clients are also; /// using that when comparing costs between scalar and vector representation.; /// This does unfortunately mean that we can both undershoot and overshot; /// the true cost significantly if getVScaleForTuning is wildly off for the; /// actual target hardware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:132,Usability,simpl,simply,132,"/// This function returns an estimate for VL to be used in VL based terms; /// of the cost model. For fixed length vectors, this is simply the; /// vector length. For scalable vectors, we return results consistent; /// with getVScaleForTuning under the assumption that clients are also; /// using that when comparing costs between scalar and vector representation.; /// This does unfortunately mean that we can both undershoot and overshot; /// the true cost significantly if getVScaleForTuning is wildly off for the; /// actual target hardware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:23,Security,access,accessing,23,/// Return the cost of accessing a constant pool entry of the specified; /// type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:190,Performance,tune,tuned,190,// Epilogue vectorization is usually unprofitable - tail folding or; // a smaller VF would have been better. This a blunt hammer - we; // should re-examine this once vectorization is better tuned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:13,Availability,mask,masked,13,// Scalarize masked gather for RV64 if EEW=64 indices aren't supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:13,Availability,mask,masked,13,// Scalarize masked scatter for RV64 if EEW=64 indices aren't supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:57,Performance,scalab,scalable,57,// Don't interleave if the loop has been vectorized with scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:120,Availability,mask,mask,120,"// Although there are 32 vector registers, v0 is special in that it is the; // only register that can be used to hold a mask.; // FIXME: Should we conservatively return 31 as the number of usable; // vector registers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:189,Usability,usab,usable,189,"// Although there are 32 vector registers, v0 is special in that it is the; // only register that can be used to hold a mask.; // FIXME: Should we conservatively return 31 as the number of usable; // vector registers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:120,Performance,perform,performed,120,"// Helper to actually emit an instruction to the MCStreamer. Also, when; // possible, compression of the instruction is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:25,Performance,load,load,25,// Helper to emit pseudo load/store instruction with a symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:35,Modifiability,extend,extend,35,// Helper to emit pseudo sign/zero extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:222,Performance,perform,performed,222,"/// Helper for processing MC instructions that have been successfully matched; /// by MatchAndEmitInstruction. Modifications to the emitted instructions,; /// like the expansion of pseudo instructions (e.g., ""li""), can be performed; /// in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:150,Availability,error,error,150,/// Helper to reset target features for a new arch string. It; /// also records the new arch string that is expanded by RISCVISAInfo; /// and reports error for invalid arch string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:77,Availability,error,error,77,"// Use computeTargetABI to check if ABIName is valid. If invalid, output; // error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:83,Integrability,message,message,83,"// Use computeTargetABI to check if ABIName is valid. If invalid, output; // error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:54,Modifiability,extend,extend,54,"// If this a RV32 and the immediate is a uimm32, sign extend it to 32 bits.; // This allows writing 'addi a0, a0, 0xffffffff'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:28,Availability,error,error,28,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:34,Integrability,message,message,34,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:151,Availability,failure,failure,151,"// Attempts to match Name as a register (either using the default name or; // alternative ABI names), setting RegNo to the matching register. Upon; // failure, returns a non-valid MCRegister. If IsRVE, then registers x16-x31; // will be rejected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Safety,Avoid,Avoid,3,"// Avoid parsing the register in `call rd, foo` as a call symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:307,Testability,log,logical,307,"// Parsing jal operands is fiddly due to the `jal foo` and `jal ra, foo`; // both being acceptable forms. When parsing `jal ra, foo` this function; // will be called for the `ra` register operand in an attempt to match the; // single-operand alias. parseJALOffset must fail for this case. It would; // seem logical to try parse the operand using parseImmediate and return; // NoMatch if the next token is a comma (meaning we must be parsing a jal in; // the second form rather than the first). We can't do this as there's no; // way of rewinding the lexer state. Instead, return NoMatch if this operand; // is an identifier and is followed by a comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:52,Availability,error,error,52,"// Create a RISCVOperand for checking later (so the error messages are; // nicer), but we don't add it to Operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:58,Integrability,message,messages,58,"// Create a RISCVOperand for checking later (so the error messages are; // nicer), but we don't add it to Operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:57,Availability,error,error,57,// Deferred Handling of non-zero offsets. This makes the error messages nicer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:63,Integrability,message,messages,63,// Deferred Handling of non-zero offsets. This makes the error messages nicer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:177,Availability,reliab,reliably,177,"// Ensure that if the instruction occurs when relaxation is enabled,; // relocations are forced for the file. Ideally this would be done when there; // is enough information to reliably determine if the instruction itself may; // cause relaxations. Unfortunately instruction processing stage occurs in the; // same pass as relocation emission, so it's too late to set a 'sticky bit'; // for the entire file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:85,Integrability,depend,depend,85,// It is invalid to disable an extension that there are other enabled; // extensions depend on it.; // TODO: Make use of RISCVISAInfo to handle this,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load local address pseudo-instruction ""lla"" is used in PC-relative; // addressing of local symbols:; // lla rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %pcrel_hi(symbol); // ADDI rdest, rdest, %pcrel_lo(TmpLabel)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load global address pseudo-instruction ""lga"" is used in GOT-indirect; // addressing of global symbols:; // lga rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %got_pcrel_hi(symbol); // Lx rdest, %pcrel_lo(TmpLabel)(rdest)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load address pseudo-instruction ""la"" is used in PC-relative and; // GOT-indirect addressing of global symbols:; // la rdest, symbol; // is an alias for either (for non-PIC); // lla rdest, symbol; // or (for PIC); // lga rdest, symbol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load TLS IE address pseudo-instruction ""la.tls.ie"" is used in; // initial-exec TLS model addressing of global symbols:; // la.tls.ie rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %tls_ie_pcrel_hi(symbol); // Lx rdest, %pcrel_lo(TmpLabel)(rdest)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load TLS GD address pseudo-instruction ""la.tls.gd"" is used in; // global-dynamic TLS model addressing of global symbols:; // la.tls.gd rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %tls_gd_pcrel_hi(symbol); // ADDI rdest, rdest, %pcrel_lo(TmpLabel)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load/store pseudo-instruction does a pc-relative load with; // a symbol.; //; // The expansion looks like this; //; // TmpLabel: AUIPC tmp, %pcrel_hi(symbol); // [S|L]X rd, %pcrel_lo(TmpLabel)(tmp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:56,Performance,load,load,56,"// The load/store pseudo-instruction does a pc-relative load with; // a symbol.; //; // The expansion looks like this; //; // TmpLabel: AUIPC tmp, %pcrel_hi(symbol); // [S|L]X rd, %pcrel_lo(TmpLabel)(tmp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:87,Integrability,depend,dependent,87,"// The sign/zero extend pseudo-instruction does two shifts, with the shift; // amounts dependent on the XLEN.; //; // The expansion looks like this; //; // SLLI rd, rs, XLEN - Width; // SR[A|R]I rd, rd, XLEN - Width",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:17,Modifiability,extend,extend,17,"// The sign/zero extend pseudo-instruction does two shifts, with the shift; // amounts dependent on the XLEN.; //; // The expansion looks like this; //; // SLLI rd, rs, XLEN - Width; // SR[A|R]I rd, rd, XLEN - Width",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Availability,mask,masked,3,"// masked va >= x, vd != v0; //; // pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t; // expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Availability,mask,masked,3,"// masked va >= x, vd == v0; //; // pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt; // expansion: vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Availability,mask,masked,3,"// masked va >= x, any vd; //; // pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt; // expansion: vmslt{u}.vx vt, va, x; vmandn.mm vt, v0, vt;; // vmandn.mm vd, vd, v0; vmor.mm vd, vt, vd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:62,Performance,load,load,62,// The encoding with rd1 == rd2 == rs1 is reserved for XTHead load pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:78,Integrability,depend,depending,78,// The last operand of XTHeadMemPair instructions must be constant 3 or 4; // depending on the data width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:60,Availability,mask,mask,60,"// vadc, vsbc are special cases. These instructions have no mask register.; // The destination register could not be V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:14,Availability,mask,masked,14,"// Regardless masked or unmasked version, the number of operands is the; // same. For example, ""viota.m v0, v2"" is ""viota.m v0, v2, NoRegister""; // actually. We need to check the last operand to ensure whether it is; // masked or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:220,Availability,mask,masked,220,"// Regardless masked or unmasked version, the number of operands is the; // same. For example, ""viota.m v0, v2"" is ""viota.m v0, v2, NoRegister""; // actually. We need to check the last operand to ensure whether it is; // masked or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:112,Performance,perform,performed,112,// On RV32 the immediate here can either be a signed or an unsigned; // 32-bit number. Sign extension has to be performed to ensure that Imm; // represents the expected signed 64-bit number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp:8,Modifiability,extend,extend,8,// Sign-extend the number in the bottom N bits of Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp:8,Modifiability,extend,extend,8,// Sign-extend the number in the bottom N bits of Imm after accounting for; // the fact that the N bit immediate is stored in N-1 bits (the LSB is; // always zero),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:3,Performance,Cache,Cache,3,// Cache the SP register vreg if we need it more than once in this call site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:19,Performance,scalab,scalable,19,/// Return true if scalable vector with ScalarTy is legal for lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument which is a value; // necessary to G_VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:172,Modifiability,variab,variable,172,"// FIXME: This is necessary because DAGISel uses ""Subtarget->"" and GlobalISel; // uses ""STI."" in the code generated by TableGen. We need to unify the name of; // Subtarget variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:47,Availability,mask,mask,47,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,Performance,optimiz,optimized,33,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:3,Usability,Simpl,SimplifyDemandedBits,3,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:80,Safety,avoid,avoid,80,"// If we are shifting by X+N where N == 0 mod Size, then just shift by X; // to avoid the ADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:21,Availability,mask,mask,21,"// (and (shl y, c2), mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:22,Availability,mask,mask,22,"// (and (lshr y, c2), mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,Availability,mask,mask,27,"// Given (and (shl y, c2), mask) in which mask has no leading zeros and; // c3 trailing zeros. We can use an SRLI by c3 - c2 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:42,Availability,mask,mask,42,"// Given (and (shl y, c2), mask) in which mask has no leading zeros and; // c3 trailing zeros. We can use an SRLI by c3 - c2 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:28,Availability,mask,mask,28,"// Given (and (lshr y, c2), mask) in which mask has c2 leading zeros and; // c3 trailing zeros. We can use an SRLI by c2 + c3 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:43,Availability,mask,mask,43,"// Given (and (lshr y, c2), mask) in which mask has c2 leading zeros and; // c3 trailing zeros. We can use an SRLI by c2 + c3 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:16,Availability,mask,mask,16,"// (shl (and y, mask), c2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:17,Availability,mask,mask,17,"// (lshr (and y, mask), c2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:22,Availability,mask,mask,22,"// Given (shl (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c1 + c3 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:42,Availability,mask,mask,42,"// Given (shl (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c1 + c3 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:23,Availability,mask,mask,23,"// Given (lshr (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c3 - c1 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:43,Availability,mask,mask,43,"// Given (lshr (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c3 - c1 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,Availability,mask,mask,27,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:42,Availability,mask,mask,42,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:60,Availability,mask,mask,60,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:61,Performance,Optimiz,Optimize,61,// TODO: Use constant pool for complext constants.; // TODO: Optimize +0.0 to use fcvt.d.w for s64 on rv32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:45,Modifiability,variab,variables,45,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:85,Security,access,accessed,85,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the symbol. This generates the; // pattern (PseudoLLA sym), which expands to (addi (auipc %pcrel_hi(sym)); // %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:74,Performance,load,load,74,"// Use PC-relative addressing to access the GOT for this symbol, then; // load the address from the GOT. This generates the pattern (PseudoLGA; // sym), which expands to (ld (addi (auipc %got_pcrel_hi(sym)); // %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the GOT for this symbol, then; // load the address from the GOT. This generates the pattern (PseudoLGA; // sym), which expands to (ld (addi (auipc %got_pcrel_hi(sym)); // %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:136,Security,access,access,136,"// An extern weak symbol may be undefined, i.e. have value 0, which may; // not be within 2GiB of PC, so use GOT-indirect addressing to access the; // symbol. This generates the pattern (PseudoLGA sym), which expands to; // (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,Security,access,accessing,27,"// Generate a sequence for accessing addresses within any 2GiB range; // within the address space. This generates the pattern (PseudoLLA sym),; // which expands to (addi (auipc %pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:28,Integrability,synchroniz,synchronize,28,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:9,Deployability,release,release,9,"// fence release -> fence rw, w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp:3,Performance,Load,Load,3,// Load the source va_list,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp:67,Usability,simpl,simply,67,"// Turn LLVM IR's floating point classes to that in RISC-V,; // by simply rotating the 10-bit immediate right by two bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:185,Modifiability,refactor,refactor,185,"/// Returns whether opcode \p Opc is a pre-isel generic floating-point opcode,; /// having only floating-point operands.; /// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in GlobalISel/Utils.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:19,Testability,log,logic,19,// Try the default logic for non-generic instructions that are either copies; // or already have some operands assigned to banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:21,Performance,load,loads,21,// Use FPR64 for s64 loads on rv32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:17,Performance,load,load,17,"// Check if that load feeds fp instructions.; // In that case, we want the default mapping to be on FPR; // instead of blind map every scalar to GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:96,Performance,load,load,96,"// If we have at least one direct use in a FP instruction,; // assume this was a floating point load in the IR. If it was; // not, we would have had a bitcast before reaching that; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:3,Testability,assert,assertion,3,// assertion prevents us from needing llvm_unreachable in the StringSwitch; // below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:3,Testability,assert,assertion,3,// assertion prevents us from needing llvm_unreachable in the StringSwitch; // below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:126,Integrability,depend,depends,126,"// getBaseInfo works with (Opcode, LMUL, 0) if no SEW instrument,; // or (Opcode, LMUL, SEW) if SEW instrument is active, and depends on LMUL; // and SEW, or (Opcode, LMUL, 0) if does not depend on SEW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:188,Integrability,depend,depend,188,"// getBaseInfo works with (Opcode, LMUL, 0) if no SEW instrument,; // or (Opcode, LMUL, SEW) if SEW instrument is active, and depends on LMUL; // and SEW, or (Opcode, LMUL, 0) if does not depend on SEW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:15,Integrability,depend,depends,15,// Check if it depends on LMUL and SEW,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:15,Integrability,depend,depends,15,// Check if it depends only on LMUL,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h:615,Energy Efficiency,schedul,scheduling,615,"//===-------------------- RISCVCustomBehaviour.h -----------------*-C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines the RISCVCustomBehaviour class which inherits from; /// CustomBehaviour. This class is used by the tool llvm-mca to enforce; /// target specific behaviour that is not expressed well enough in the; /// scheduling model for mca to enforce it automatically.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h:451,Modifiability,inherit,inherits,451,"//===-------------------- RISCVCustomBehaviour.h -----------------*-C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines the RISCVCustomBehaviour class which inherits from; /// CustomBehaviour. This class is used by the tool llvm-mca to enforce; /// target specific behaviour that is not expressed well enough in the; /// scheduling model for mca to enforce it automatically.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:40,Modifiability,extend,extended,40,"// Jalr will add UpperImm with the sign-extended 12-bit LowerImm,; // we need to add 0x800ULL before extract upper bits to reflect the; // effect of the sign extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:43,Availability,error,error,43,"// MCAssembler::evaluateFixup will emit an error for this case when it sees; // the %pcrel_hi, so don't duplicate it when also seeing the %pcrel_lo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:80,Usability,simpl,simply,80,// Calculate total Nops we need to insert. If there are none to insert; // then simply return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp:6,Safety,avoid,avoid,6,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value. RV32E only has X8 and X9 as callee; // saved registers and X8 will be used as fp. So we choose X9 as bp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp:280,Availability,mask,mask,280,// namespace RISCVFeatures; // Encode VTYPE into the binary format used by the the VSETVLI instruction which; // is used by our MC layer representation.; //; // Bits | Name | Description; // -----+------------+------------------------------------------------; // 7 | vma | Vector mask agnostic; // 6 | vta | Vector tail agnostic; // 5:3 | vsew[2:0] | Standard element width (SEW) setting; // 2:0 | vlmul[2:0] | Vector register group multiplier (LMUL) setting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:36,Availability,mask,mask,36,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:67,Availability,mask,mask,67,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:215,Availability,mask,mask,215,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:52,Modifiability,extend,extended,52,"// Indicates that the result can be considered sign extended from bit 31. Some; // instructions with this flag aren't W instructions, but are either sign; // extended from a smaller size, always outputs a small integer, or put zeros; // in bits 63:31. Used by the SExtWRemoval pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:158,Modifiability,extend,extended,158,"// Indicates that the result can be considered sign extended from bit 31. Some; // instructions with this flag aren't W instructions, but are either sign; // extended from a smaller size, always outputs a small integer, or put zeros; // in bits 63:31. Used by the SExtWRemoval pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:21,Availability,mask,mask,21,/// \returns true if mask policy is valid for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:142,Availability,mask,mask,142,// Is the first def operand tied to the first use operand. This is true for; // vector pseudo instructions that have a merge operand for tail/mask; // undisturbed. It's also true for vector FMA instructions where one of the; // operands is also the destination register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:65,Security,Access,Access,65,"// FIXME: add these additional fields when needed.; // Privilege Access: Read, Write, Read-Only.; // unsigned ReadWrite;; // Privilege Mode: User, System or Machine.; // unsigned Mode;; // Check field name.; // unsigned Extra;; // Register number without the privilege bits.; // unsigned Number;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:3,Security,Validat,Validates,3,// Validates if the given combination of features are valid for the target; // triple. Exits with report_fatal_error if not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp:36,Deployability,update,update,36,"// TODO: this is very conservative, update once RISC-V psABI requirements; // are clarified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Integrability,Depend,Depending,3,"// Depending on the active bits in the immediate Value v, the following; // instruction sequences are emitted:; //; // v == 0 : ADDI; // v[0,12) != 0 && v[12,32) == 0 : ADDI; // v[0,12) == 0 && v[12,32) != 0 : LUI; // v[0,32) != 0 : LUI+ADDI(W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:576,Modifiability,extend,extended,576,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:560,Performance,perform,performs,560,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:959,Performance,perform,performed,959,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:1398,Performance,perform,performed,1398,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:376,Usability,simpl,simply,376,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:67,Energy Efficiency,reduce,reduce,67,"// If the remaining bits don't fit in 12 bits, we might be able to reduce the; // shift amount in order to use LUI which will zero the lower 12 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the shift amount and add zeros to the LSBs so it will match LUI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce the shift amount and add zeros to the LSBs so it will match; // LUI, then shift left with SLLI.UW to clear the upper 32 set bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:111,Usability,clear,clear,111,"// Reduce the shift amount and add zeros to the LSBs so it will match; // LUI, then shift left with SLLI.UW to clear the upper 32 set bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:40,Usability,clear,clear,40,"// Use LUI+ADDI or LUI to compose, then clear the upper 32 bits with; // SLLI_UW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:102,Availability,mask,masks,102,// Fill in the bits that will be shifted out with 1s. An example where this; // helps is trailing one masks with 32 or more ones. This will generate; // ADDI -1 and an SRLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:142,Modifiability,extend,extended,142,"// If the low 12 bits are non-zero, the first expansion may end with an ADDI; // or ADDIW. If there are trailing zeros, try generating a sign extended; // constant with no trailing zeros and use a final SLLI to restore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:81,Performance,optimiz,optimizations,81,"// If the constant is negative, trying inverting and using our trailing zero; // optimizations. Use an xori to invert the final value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Performance,Perform,Perform,3,// Perform optimization with BCLRI/BSETI in the Zbs extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:11,Performance,optimiz,optimization,11,// Perform optimization with BCLRI/BSETI in the Zbs extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Usability,Clear,Clear,3,// Clear lowest set bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Performance,Perform,Perform,3,// Perform optimization with SH*ADD in the Zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:11,Performance,optimiz,optimization,11,// Perform optimization with SH*ADD in the Zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:123,Performance,optimiz,optimization,123,// For Val that has zero Lo12 (implies Val equals to Hi52) should has; // already been processed to LUI+SH*ADD by previous optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Performance,Perform,Perform,3,// Perform optimization with rori in the Zbb and th.srri in the XTheadBb; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:11,Performance,optimiz,optimization,11,// Perform optimization with rori in the Zbb and th.srri in the XTheadBb; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h:163,Usability,simpl,simple,163,// Helper to generate an instruction sequence that will materialise the given; // immediate value into a register. A sequence of instructions represented by a; // simple struct is produced rather than directly emitting the instructions in; // order to allow this helper to be used from both the MC layer and during; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp:30,Usability,simpl,simple,30,// Expand PseudoAddTPRel to a simple ADD with the correct relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp:250,Availability,error,error,250,// tprel_add is only used to indicate that a relocation should be emitted; // for an add instruction used in TP-relative addressing. It should not be; // expanded as if representing an actual instruction operand and so to; // encounter it here is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp:3,Usability,Clear,Clear,3,// Clear the state of all defined registers for instructions that we don't; // explicitly support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp:393,Usability,simpl,simple,393,"//===-- DelaySlotFiller.cpp - SPARC delay slot filler ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a simple local pass that attempts to fill delay slots with useful; // instructions. If no instructions can be moved into the delay slot, then a; // NOP is placed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp:57,Modifiability,extend,extended,57,"// TODO: If we ever want to support v7, this needs to be extended; // to cover all floating point operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp:3,Testability,assert,assert,3,"// assert that MBBI is a ""restore %g0, %g0, %g0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:232,Performance,Load,Load,232,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:368,Performance,load,load,368,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:404,Performance,Load,Load,404,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:88,Safety,Detect,DetectRoundChange,88,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:271,Safety,detect,detects,271,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:395,Safety,Detect,Detects,395,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:726,Deployability,pipeline,pipeline,726,"//*****************************************************************************; //**** FixAllFDIVSQRT pass; //*****************************************************************************; // This pass fixes the incorrectly working FDIVx and FSQRTx instructions that; // exist for some earlier versions of the LEON processor line. Five NOP; // instructions need to be inserted after these instructions to ensure the; // correct result is placed in the destination registers before they are used.; //; // This pass implements two fixes:; // 1) fixing the FSQRTS and FSQRTD instructions.; // 2) fixing the FDIVS and FDIVD instructions.; //; // FSQRTS and FDIVS are converted to FDIVD and FSQRTD respectively earlier in; // the pipeline when this option is enabled, so this pass needs only to deal; // with the changes that still need implementing for the ""double"" versions; // of these instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:208,Deployability,pipeline,pipeline,208,// Note: FDIVS and FSQRTS cannot be generated when this erratum fix is; // switched on so we don't need to check for them here. They will; // already have been converted to FSQRTD or FDIVD earlier in the; // pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h:44,Energy Efficiency,allocate,allocate,44,// this vector holds free registers that we allocate in groups for some of the; // LEON passes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h:28,Integrability,interface,interface,28,"//===-- Sparc.h - Top-level interface for Sparc representation --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // Sparc back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h:9,Usability,Clear,Clear,9,// Carry Clear/Great or Equal Unsigned,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h:12,Usability,Clear,Clear,12,// Overflow Clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- SparcAsmPrinter.cpp - Sparc LLVM assembly writer ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format SPARC assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:8,Performance,load,load,8,// Just load the address of GOT to MCRegOP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:23,Performance,load,load,23,// Use register %o7 to load the lower 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:100,Performance,optimiz,optimization,100,"// TODO find out whether it is possible to store PC; // in other registers, to enable leaf function optimization.; // (On the other hand, approx. over 97.8% of GETPCXes happen; // in non-leaf functions, so would this be worth the effort?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:72,Availability,avail,available,72,// Emit this the hard way. This clobbers G1 which we always know is; // available here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:3,Deployability,Update,Update,3,// Update stack size with corrected value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:44,Availability,avail,available,44,// This clobbers G1 which we always know is available here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:38,Modifiability,variab,variable,38,// Reserve call frame if there are no variable sized objects on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:134,Modifiability,variab,variable,134,// hasFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas or; // if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:33,Security,access,accessed,33,"// Addressable stack objects are accessed using neg. offsets from; // %fp, or positive offsets from %sp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:149,Availability,avail,available,149,"// Sparc uses FP-based references in general, even when ""hasFP"" is; // false. That function is rather a misnomer, because %fp is; // actually always available, unless isLeafProc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:23,Security,access,access,23,"// Otherwise, argument access should always use %fp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite MBB's Live-ins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:493,Energy Efficiency,allocate,allocated,493,"// Re-assemble i64 arguments split up in SelectionDAGBuilder's; // visitInlineAsm / GetRegistersForValue functions.; //; // Note: This function was copied from, and is essentially identical; // to ARMISelDAGToDAG::SelectInlineAsm. It is very unfortunate that; // such hacking-up is necessary; a rethink of how inline asm operands; // are handled may be in order to make doing this more sane.; //; // TODO: fix inline asm support so I can simply tell it that 'i64'; // inputs to asm need to be allocated to the IntPair register type,; // and have that work. Then, delete this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:438,Usability,simpl,simply,438,"// Re-assemble i64 arguments split up in SelectionDAGBuilder's; // visitInlineAsm / GetRegistersForValue functions.; //; // Note: This function was copied from, and is essentially identical; // to ARMISelDAGToDAG::SelectInlineAsm. It is very unfortunate that; // such hacking-up is necessary; a rethink of how inline asm operands; // are handled may be in order to make doing this more sane.; //; // TODO: fix inline asm support so I can simply tell it that 'i64'; // inputs to asm need to be allocated to the IntPair register type,; // and have that work. Then, delete this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the original glue user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:42,Security,expose,expose,42,// FIXME: should use a custom expander to expose the SRA to the dag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// createSparcISelDag - This pass converts a legalized DAG into a; /// SPARC-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:408,Integrability,interface,interfaces,408,"//===-- SparcISelLowering.cpp - Sparc DAG Lowering Implementation ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interfaces that Sparc uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a full-sized argument for the 64-bit ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,Energy Efficiency,allocate,allocated,18,// Stack space is allocated for all arguments starting from [%fp+BIAS+128].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate a half-sized argument for the 64-bit ABI.; //; // This is used when passing { float, int } structs by value in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:46,Modifiability,extend,extended,46,// Integer return values must be sign or zero extended by the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the flag if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:44,Usability,simpl,simple,44,"/// LowerFormalArguments32 - V8 uses a very simple ABI, where all values are; /// passed in either one or two GPRs, including FP values. TODO: we should; /// pass FP values in FP registers for fastcc functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:38,Performance,load,load,38,"// If it is double-word aligned, just load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:50,Testability,Assert,Assert,50,"// The caller promoted the argument, so insert an Assert?ext SDNode so we; // won't promote the value again in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,down,down,25,// Truncate the register down to the argument type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:21,Modifiability,extend,extended,21,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:114,Modifiability,extend,extended,114,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:156,Modifiability,extend,extending,156,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:166,Performance,load,loads,166,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:23,Modifiability,variab,variable,23,"// This function takes variable arguments, some of which may have been passed; // in registers %i0-%i5. Variable floating point arguments are never passed; // in floating point registers. They go on %i0-%i5 or on the stack like; // integer arguments.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:104,Modifiability,Variab,Variable,104,"// This function takes variable arguments, some of which may have been passed; // in registers %i0-%i5. Variable floating point arguments are never passed; // in floating point registers. They go on %i0-%i5 or on the stack like; // integer arguments.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:320,Modifiability,variab,variable,320,"// This function takes variable arguments, some of which may have been passed; // in registers %i0-%i5. Variable floating point arguments are never passed; // in floating point registers. They go on %i0-%i5 or on the stack like; // integer arguments.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:12,Modifiability,variab,variable,12,// Save the variable arguments that were passed in registers.; // The caller is required to reserve stack space for 6 arguments regardless; // of how many arguments were actually passed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:143,Energy Efficiency,allocate,allocate,143,// Do not tail call opt if the stack is used to pass parameters.; // 64-bit targets have a slightly higher limit since the ABI requires; // to allocate some space even when all the parameters fit inside registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:99,Safety,avoid,avoid,99,// Adjust the stack pointer to make room for the arguments.; // FIXME: Use hasReservedCallFrame to avoid %sp adjustments around all calls; // with more than 6 arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Performance,Load,Load,3,// Load into Reg and Reg+1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:174,Safety,avoid,avoid,174,"// When returning 'inreg {i32, i32 }', two consecutive i32 arguments can; // reside in the same register in the high and low bits. Reuse the; // CopyFromReg previous node to avoid duplicate copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:54,Testability,Assert,Assert,54,"// The callee promoted the return value, so insert an Assert?ext SDNode so; // we won't promote the value again in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,down,down,25,// Truncate the register down to the return value type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:14,Modifiability,extend,extending,14,// Truncating/extending stores/loads are also not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:31,Performance,load,loads,31,// Truncating/extending stores/loads are also not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:12,Performance,load,load,12,"// However, load and store *are* legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,Performance,load,loads,30,// And we need to promote i64 loads/stores into vector load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:55,Performance,load,load,55,// And we need to promote i64 loads/stores into vector load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:56,Performance,LOAD,LOAD,56,"// Sadly, this doesn't work:; // AddPromotedToType(ISD::LOAD, MVT::i64, MVT::v2i32);; // AddPromotedToType(ISD::STORE, MVT::i64, MVT::v2i32);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:24,Performance,load,load,24,// Turn FP extload into load/fpextend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,Modifiability,extend,extending,30,// Sparc doesn't have i1 sign extending load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:40,Performance,load,load,40,// Sparc doesn't have i1 sign extending load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:23,Performance,LOAD,LOAD,23,// Custom Lower Atomic LOAD/STORE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:49,Security,access,accesses,49,// VAARG needs to be lowered to not do unaligned accesses for doubles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:58,Availability,Mask,Mask,58,/// isMaskedValueZeroForTargetNode - Return true if 'Op & Mask' is known to; /// be zero. Op is expected to be a target specific node. Used by DAG; /// combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:59,Modifiability,variab,variable,59,// Handle PIC mode first. SPARC needs a got load for every variable!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:44,Performance,load,load,44,// Handle PIC mode first. SPARC needs a got load for every variable!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Performance,Load,Load,3,// Load RetPtr to get the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList.; // We can't count on greater alignment than the word size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:16,Performance,load,load,16,// Lower a f128 load into two f64 loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:34,Performance,load,loads,34,// Lower a f128 load into two f64 loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:13,Performance,load,load,13,// Monotonic load/stores are legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the fN constraint according to the value type if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:42,Performance,load,load,42,"// Custom handling only for i64: turn i64 load into a v2i32 load,; // and a bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:60,Performance,load,load,60,"// Custom handling only for i64: turn i64 load into a v2i32 load,; // and a bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,Modifiability,variab,variable,30,// Override to disable global variable loading on Linux.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:39,Performance,load,loading,39,// Override to disable global variable loading on Linux.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:49,Integrability,Interface,Interface,49,"//===-- SparcISelLowering.h - Sparc DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Sparc uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- SparcISelLowering.h - Sparc DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Sparc uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:41,Safety,predict,prediction,41,"// Branch to dest on icc condition, with prediction (64-bit only).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:41,Safety,predict,prediction,41,"// Branch to dest on xcc condition, with prediction (64-bit only).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:3,Performance,Load,Load,3,// Load operation w/ gdop relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:82,Availability,Mask,Mask,82,/// computeKnownBitsForTargetNode - Determine which of the bits specified; /// in Mask are known to be either zero or one and return them in the; /// KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:47,Performance,load,loading,47,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:38,Availability,avail,available,38,// Unaliased double registers are not available in non-V9 targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:155,Integrability,depend,depending,155,"// Sparc has no architectural need for stack realignment support,; // except that LLVM unfortunately currently implements overaligned; // stack objects by depending upon stack realignment support.; // If that ever changes, this can probably be deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:310,Security,access,access,310,"// Sparc always has a fixed frame pointer register, so don't need to; // worry about needing to reserve it. [even if we don't have a frame; // pointer for our frame, it still cannot be used for other things,; // or register window traps will be SADNESS.]; // If there's a reserved call frame, we can use SP to access locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h:43,Availability,avail,available,43,// ReserveRegister[i] - Register #i is not available as a general purpose; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp:30,Deployability,Configurat,Configuration,30,/// Sparc Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp:30,Modifiability,Config,Configuration,30,/// Sparc Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp:66,Testability,stub,stub,66,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:17,Integrability,interface,interface,17,/// }; // public interface of the MCTargetAsmParser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:285,Usability,clear,clearing,285,"// The low bits require touching in 3 cases:; // * A non-immediate value will always require both instructions.; // * An effectively imm13 value needs only an 'or' instruction.; // * Otherwise, an immediate that is not effectively imm13 requires the; // 'or' only if bits remain after clearing the 22 bits that 'sethi' set.; // If the low bits are known zeros, there's nothing to do.; // In the second case, and only in that case, must we NOT clear; // bits of the immediate value via the %lo() assembler function.; // Note also, the 'or' instruction doesn't mind a large value in the case; // where the operand to 'set' was 0xFFFFFzzz - it does exactly what you mean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:443,Usability,clear,clear,443,"// The low bits require touching in 3 cases:; // * A non-immediate value will always require both instructions.; // * An effectively imm13 value needs only an 'or' instruction.; // * Otherwise, an immediate that is not effectively imm13 requires the; // 'or' only if bits remain after clearing the 22 bits that 'sethi' set.; // If the low bits are known zeros, there's nothing to do.; // In the second case, and only in that case, must we NOT clear; // bits of the immediate value via the %lo() assembler function.; // Note also, the 'or' instruction doesn't mind a large value in the case; // where the operand to 'set' was 0xFFFFFzzz - it does exactly what you mean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:74,Performance,optimiz,optimization,74,"// For compatibility, ignore this directive.; // (It's supposed to be an ""optimization"" in the Sun assembler)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:11,Deployability,patch,patch,11,"// Here we patch the MEM operand from [base + %g0] into [base + 0]; // as memory operations with ASI tag stored in %asi register needs; // to use immediate offset. We need to do this because Reg addressing; // will be parsed as Reg+G0 initially.; // This allows forms such as `ldxa [%o0] %asi, %o0` to parse correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:208,Performance,Load,LoadASI,208,"// Eat the identifier.; // In this context, we convert the register operand into; // a plain ""%asi"" token since the register access is already; // implicit in the instruction definition and encoding.; // See LoadASI/StoreASI in SparcInstrInfo.td.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:125,Security,access,access,125,"// Eat the identifier.; // In this context, we convert the register operand into; // a plain ""%asi"" token since the register access is already; // implicit in the instruction definition and encoding.; // See LoadASI/StoreASI in SparcInstrInfo.td.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp:78,Integrability,depend,depending,78,"// This is used for the type ""ptr_rc"", which is either IntRegs or I64Regs; // depending on SparcRegisterInfo::getPointerRegClass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp:39,Safety,Predict,Prediction,39,// A.3 Branch on Integer Register with Prediction (BPr); // Inst{21-20} = d16hi;; // Inst{13-0} = d16lo;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRV.h:28,Integrability,interface,interface,28,"//===-- SPIRV.h - Top-level interface for SPIR-V representation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRV.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRV.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- SPIRVAsmPrinter.cpp - SPIR-V LLVM assembly writer ------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the SPIR-V assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:43,Usability,clear,clear,43,// Emit OpFunctionEnd at the end of MF and clear BBNumToRegMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:74,Integrability,interface,interfaces,74,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:90,Integrability,interface,interface,90,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:230,Integrability,interface,interface,230,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:188,Modifiability,variab,variables,188,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:27,Integrability,interface,interface,27,"// Before version 1.4, the interface's storage classes are limited to; // the Input and Output storage classes. Starting with version 1.4,; // the interface's storage classes are all storage classes used in; // declaring all global variables referenced by the entry point call tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:147,Integrability,interface,interface,147,"// Before version 1.4, the interface's storage classes are limited to; // the Input and Output storage classes. Starting with version 1.4,; // the interface's storage classes are all storage classes used in; // declaring all global variables referenced by the entry point call tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:232,Modifiability,variab,variables,232,"// Before version 1.4, the interface's storage classes are limited to; // the Input and Output storage classes. Starting with version 1.4,; // the interface's storage classes are all storage classes used in; // declaring all global variables referenced by the entry point call tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:31,Integrability,interface,interface,31,// Output OpEntryPoints adding interface args to all of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:3,Safety,Abort,Abort,3,// Abort here if not all requirements can be satisfied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:50,Modifiability,variab,variable,50,// Process llvm.global.annotations special global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:73,Modifiability,variab,variable,73,// The first field of the struct contains a pointer to; // the annotated variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:40,Testability,Log,Logical,40,"// Output instructions according to the Logical Layout of a Module:; // 1,2. All OpCapability instructions, then optional OpExtension instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:100,Modifiability,variab,variable,100,"// 9. All type declarations (OpTypeXXX instructions), all constant; // instructions, and all global variable declarations. This section is; // the first section to allow use of: OpLine and OpNoLine debug information;; // non-semantic instructions with OpExtInst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:723,Integrability,Wrap,Wrapper,723,"// namespace SPIRV; //===----------------------------------------------------------------------===//; // Misc functions for looking up builtins and veryfying requirements using; // TableGen records; //===----------------------------------------------------------------------===//; /// Looks up the demangled builtin call in the SPIRVBuiltins.td records using; /// the provided \p DemangledCall and specified \p Set.; ///; /// The lookup follows the following algorithm, returning the first successful; /// match:; /// 1. Search with the plain demangled name (expecting a 1:1 match).; /// 2. Search with the prefix before or suffix after the demangled name; /// signyfying the type of the first argument.; ///; /// \returns Wrapper around the demangled call and found builtin definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:300,Integrability,depend,depending,300,//===----------------------------------------------------------------------===//; // Helper functions for building misc instructions; //===----------------------------------------------------------------------===//; /// Helper function building either a resulting scalar or vector bool register; /// depending on the expected \p ResultType.; ///; /// \returns Tuple of the resulting register and its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:83,Integrability,depend,depending,83,/// Helper function for building either a vector or scalar select instruction; /// depending on the expected \p ResultType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:35,Performance,load,load,35,/// Helper function for building a load instruction loading into the; /// \p DestinationReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:52,Performance,load,loading,52,/// Helper function for building a load instruction loading into the; /// \p DestinationReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:86,Modifiability,variab,variable,86,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:35,Performance,load,load,35,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:56,Performance,load,loading,56,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:34,Modifiability,variab,variable,34,// Load the value from the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:3,Performance,Load,Load,3,// Load the value from the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:43,Performance,load,load,43,/// Helper function for building an atomic load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:43,Performance,load,load,43,/// Helper function for building an atomic load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:14,Modifiability,extend,extended,14,// Lookup the extended instruction number in the TableGen records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:9,Modifiability,extend,extended,9,// Build extended instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:272,Integrability,depend,depending,272,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:312,Modifiability,extend,extending,312,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:1102,Modifiability,extend,extend,1102,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:686,Performance,load,loadedVec,686,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:813,Performance,load,loadedVec,813,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:911,Performance,load,loadedVec,911,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:104,Integrability,depend,depending,104,"// If it's out of range (max dimension is 3), we can just return the constant; // default value (0 or 1 depending on which query function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:39,Performance,load,load,39,"// If it could be in range, we need to load from the given builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:109,Performance,Load,LoadedVector,109,"// Use Intrinsic::spv_extractelt so dynamic vs static extraction is; // handled later: extr = spv_extractelt LoadedVector, IndexRegister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:46,Integrability,depend,depending,46,// Get constant for the default value (0 or 1 depending on which; // function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:22,Modifiability,variab,variable,22,// Lookup the builtin variable record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:44,Modifiability,variab,variable,44,// Build a load instruction for the builtin variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:11,Performance,load,load,11,// Build a load instruction for the builtin variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:15,Usability,simpl,simplify,15,// TODO: Maybe simplify generation of the type of the fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:266,Modifiability,variab,variable,266,"// In principle, this information should be passed to us from Clang via; // an elementtype attribute. However, said attribute requires that; // the function call be an intrinsic, which is not. Instead, we rely on being; // able to trace this to the declaration of a variable: OpenCL C specification; // section 6.12.5 should guarantee that we can do this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:21,Performance,load,load,21,// Lookup the vector load/store builtin in the TableGen records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:9,Modifiability,extend,extended,9,// Build extended instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:33,Performance,load,load,33,// Add a pointer to the value to load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:3,Modifiability,Parameteriz,Parameterized,3,"// Parameterized SPIR-V builtins names follow this format:; // e.g. %spirv.Image._void_1_0_0_0_0_0_0, %spirv.Pipe._0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:533,Deployability,release,release,533,"// In LLVM IR, SPIR-V and OpenCL builtin types are represented as either; // target(...) target extension types or pointers-to-opaque-structs. The; // approach relying on structs is deprecated and works only in the non-opaque; // pointer mode (-opaque-pointers=0).; // In order to maintain compatibility with LLVM IR generated by older versions; // of Clang and LLVM/SPIR-V Translator, the pointers-to-opaque-structs are; // ""translated"" to target extension types. This translation is temporary and; // will be removed in the future release of LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp:19,Security,access,access,19,// Read argument's access qualifier from metadata or default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp:102,Integrability,depend,dependencies,102,// Emit the type info and forward function declaration to the first MBB; // to ensure VReg definition dependencies are valid across all MBBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:89,Integrability,depend,dependency,89,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:217,Integrability,depend,dependency,217,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:34,Security,access,access,34,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:52,Integrability,depend,dependency,52,"// NOTE: using MOs instead of regs to get rid of MF dependency to be able; // to use flat data structure.; // NOTE: replacing DenseMap with MapVector doesn't affect overall correctness; // but makes LITs more stable, should prefer DenseMap still due to; // significant perf difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp:364,Modifiability,variab,variable,364,"// This pass performs the following transformation on LLVM IR level required; // for the following translation to SPIR-V:; // - replaces direct usages of aggregate constants with target-specific; // intrinsics;; // - replaces aggregates-related instructions (extract/insert, ld/st, etc); // with a target-specific intrinsics;; // - emits intrinsics for the global variable initializers since IRTranslator; // doesn't handle them and it's not very convenient to translate them; // ourselves;; // - emits intrinsics to keep track of the string names assigned to the values;; // - emits intrinsics to keep track of constants (this is necessary to have an; // LLVM IR constant after the IRTranslation is completed) for their further; // deduplication;; // - emits intrinsics to keep track of original LLVM types of the values; // to be able to emit proper SPIR-V types eventually.; //; // TODO: consider removing spv.track.constant in favor of spv.assign.type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp:13,Performance,perform,performs,13,"// This pass performs the following transformation on LLVM IR level required; // for the following translation to SPIR-V:; // - replaces direct usages of aggregate constants with target-specific; // intrinsics;; // - replaces aggregates-related instructions (extract/insert, ld/st, etc); // with a target-specific intrinsics;; // - emits intrinsics for the global variable initializers since IRTranslator; // doesn't handle them and it's not very convenient to translate them; // ourselves;; // - emits intrinsics to keep track of the string names assigned to the values;; // - emits intrinsics to keep track of constants (this is necessary to have an; // LLVM IR constant after the IRTranslation is completed) for their further; // deduplication;; // - emits intrinsics to keep track of original LLVM types of the values; // to be able to emit proper SPIR-V types eventually.; //; // TODO: consider removing spv.track.constant in favor of spv.assign.type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp:26,Modifiability,variab,variable,26,// Skip special artifical variable llvm.global.annotations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:739,Modifiability,variab,variables,739,"//===-- SPIRVGlobalRegistry.cpp - SPIR-V Global Registry --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the SPIRVGlobalRegistry class,; // which is used to maintain rich type information required for SPIR-V even; // after lowering from LLVM IR to GMIR. It can convert an llvm::Type into; // an OpTypeXXX instruction, and map it to a virtual register. Also it builds; // and supports consistency of constants and global variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:79,Availability,error,error,79,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:56,Safety,avoid,avoid,56,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:88,Security,validat,validation,88,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:84,Modifiability,variab,variable,84,"// If GV is not passed explicitly, use the name to find or construct; // the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:103,Safety,avoid,avoiding,103,"// ISel may introduce a new register on this step, so we need to add it to; // DT and correct its type avoiding fails on the next stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:20,Modifiability,variab,variable,20,"// If it's a global variable with name, output OpName for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h:677,Modifiability,variab,variables,677,"//===-- SPIRVGlobalRegistry.h - SPIR-V Global Registry ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SPIRVGlobalRegistry is used to maintain rich type information required for; // SPIR-V even after lowering from LLVM IR to GMIR. It can convert an llvm::Type; // into an OpTypeXXX instruction, and map it to a virtual register. Also it; // builds and supports consistency of constants and global variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h:56,Modifiability,variab,variables,56,// Return the number of bits SPIR-V pointers and size_t variables require.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp:1271,Integrability,rout,routine,1271,"// Analyze the branching code at the end of MBB, returning; // true if it cannot be understood (e.g. it's a switch dispatch or isn't; // implemented for a target). Upon success, this returns false and returns; // with the following information in various cases:; //; // 1. If this block ends with no branches (it just falls through to its succ); // just return false, leaving TBB/FBB null.; // 2. If this block ends with only an unconditional branch, it sets TBB to be; // the destination block.; // 3. If this block ends with a conditional branch and it falls through to a; // successor block, it sets TBB to be the branch destination block and a; // list of operands that evaluate the condition. These operands can be; // passed to other TargetInstrInfo methods to create new branches.; // 4. If this block ends with a conditional branch followed by an; // unconditional branch, it returns the 'true' destination in TBB, the; // 'false' destination in FBB, and a list of operands that evaluate the; // condition. These operands can be passed to other TargetInstrInfo; // methods to create new branches.; //; // Note that removeBranch and insertBranch must be implemented to support; // cases where this method returns success.; //; // If AllowModify is true, then this routine is allowed to modify the basic; // block (e.g. delete instructions after the unconditional branch).; //; // The CFG information in MBB.Predecessors and MBB.Successors must be valid; // before calling this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp:280,Safety,safe,safely,280,"// Actually we don't need this COPY instruction. However if we do nothing with; // it, post RA pseudo instrs expansion just removes it and we get the code; // with undef registers. Therefore, we need to replace all uses of dst with; // the src register. COPY instr itself will be safely removed later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:74,Modifiability,variab,variables,74,"// Currently, we get G_PTR_ADD only as a result of translating; // global variables, initialized with constant expressions like GV + Const; // (see test opencl/basic/progvar_prog_scope_init.ll).; // TODO: extend the handler once we have other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:205,Modifiability,extend,extend,205,"// Currently, we get G_PTR_ADD only as a result of translating; // global variables, initialized with constant expressions like GV + Const; // (see test opencl/basic/progvar_prog_scope_init.ll).; // TODO: extend the handler once we have other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:148,Testability,test,test,148,"// Currently, we get G_PTR_ADD only as a result of translating; // global variables, initialized with constant expressions like GV + Const; // (see test opencl/basic/progvar_prog_scope_init.ll).; // TODO: extend the handler once we have other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:60,Testability,test,test,60,// TODO: Changed as it's implemented in the translator. See test/atomicrmw.ll; // auto ScSem =; // getMemSemanticsForStorageClass(GR.getPointerStorageClass(Ptr));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:388,Safety,safe,safe,388,"// In SPIR-V address space casting can only happen to and from the Generic; // storage class. We can also only case Workgroup, CrossWorkgroup, or Function; // pointers to and from Generic pointers. As such, we can convert e.g. from; // Workgroup to Function by going via a Generic pointer as an intermediary. All; // other combinations can only be done by a bitcast, and are probably not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:36,Safety,abort,abort,36,"// Return the logical operation, or abort if none exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:14,Testability,log,logical,14,"// Return the logical operation, or abort if none exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:6,Modifiability,extend,extend,6,"// To extend a bool, we need to use OpSelect between constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:188,Security,Access,AccessChain,188,"// OpAccessChain could be used for OpenCL, but the SPIRV-LLVM Translator only; // relies on PtrAccessChain, so we'll try not to deviate. For Vulkan however,; // we have to use Op[InBounds]AccessChain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:344,Usability,simpl,simply,344,"// InstructionSelector walks backwards through the instructions. For an; // explicit conditional branch with no fallthrough, we use both a G_BR and a; // G_BRCOND to create an OpBranchConditional. We should hit G_BR first, and; // generate the OpBranchConditional in selectBranch above.; //; // If an OpBranchConditional has been generated, we simply return, as the work; // is alread done. If there is no OpBranchConditional, LLVM must be relying on; // implicit fallthrough to the next basic block, so we need to create an; // OpBranchConditional with an explicit ""false"" argument pointing to the next; // basic block that LLVM would fall through to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:36,Testability,test,tests,36,// We have functions as operands in tests with blocks of instruction e.g. in; // transcoding/global_block.ll. These operands are not used and should be; // substituted by zero constants. Their type is expected to be always; // OpTypePointer Function %uchar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:45,Modifiability,Extend,Extended,45,"// There is no log10 instruction in the GLSL Extended Instruction set, so it; // is implemented as:; // log10(x) = log2(x) * (1 / log2(10)); // = log2(x) * 0.30103",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp:13,Safety,avoid,avoids,13,// This code avoids CallLowering fail inside getVectorTypeBreakdown; // on v3i1 arguments. Maybe we need to return 1 for all types.; // TODO: remove it once this case is supported by the default implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp:13,Safety,avoid,avoids,13,// This code avoids CallLowering fail inside getVectorTypeBreakdown; // on v3i1 arguments. Maybe we need to return i32 for all types.; // TODO: remove it once this case is supported by the default implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h:50,Integrability,Interface,Interface,50,"//===-- SPIRVISelLowering.h - SPIR-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SPIR-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- SPIRVISelLowering.h - SPIR-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SPIR-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVLegalizerInfo.cpp:43,Modifiability,Extend,Extended,43,"// TODO: Review the target OpenCL and GLSL Extended Instruction Set specs to; // tighten these requirements. Many of these math functions are only legal on; // specific bitwidths, so they are not selectable for; // allFloatScalarsAndVectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:468,Performance,perform,performs,468,"//===- SPIRVModuleAnalysis.cpp - analysis of global instrs & regs - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The analysis collects instructions that should be output at the module level; // and performs the global register numbering.; //; // The results of this analysis are used in AsmPrinter to rename registers; // globally and to output required instructions at the module level.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:61,Deployability,configurat,configuratoin,61,// TODO: determine memory model and source language from the configuratoin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:61,Modifiability,config,configuratoin,61,// TODO: determine memory model and source language from the configuratoin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:3,Deployability,Update,Update,3,"// Update required capabilities for this memory model, addressing model and; // source language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:115,Modifiability,variab,variable,115,"// Look for IDs declared with Import linkage, and map the corresponding function; // to the register defining that variable (which will usually be the result of; // an OpFunction). This lets us call externally imported functions using; // the correct ID registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:80,Security,hash,hash,80,"// Returns a representation of an instruction as a vector of MachineOperand; // hash values, see llvm::hash_value(const MachineOperand &MO) for details.; // This creates a signature of the instruction with the same content; // that MachineOperand::isIdenticalTo uses for comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:177,Safety,detect,detecting,177,// Collect the given instruction in the specified MS. We assume global register; // numbering has already occurred by this point. We can directly compare reg; // arguments when detecting duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:18,Availability,error,errors,18,// Report as many errors as possible before aborting the compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:44,Safety,abort,aborting,44,// Report as many errors as possible before aborting the compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:16,Security,access,access,16,// Has optional access qualifier.; // TODO: check if it's OpenCL's kernel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:468,Performance,perform,performs,468,"//===- SPIRVModuleAnalysis.h - analysis of global instrs & regs -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The analysis collects instructions that should be output at the module level; // and performs the global register numbering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:21,Testability,log,logical,21,// The enum contains logical module sections for the instruction collection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:15,Availability,Avail,AvailableCaps,15,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:83,Availability,Avail,AvailableCaps,83,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:98,Availability,Avail,AvailableCaps,98,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:161,Availability,avail,available,161,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:121,Safety,abort,abort,121,"// Add the given requirements to the lists. If constraints conflict, or these; // requirements cannot be satisfied, then abort the compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:90,Safety,abort,abort,90,"// Check if all the requirements can be satisfied for the given subtarget, and; // if not abort compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:33,Availability,avail,available,33,// Add the given capabilities to available and all their implicitly defined; // capabilities too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:73,Security,access,access,73,// The struct contains results of the module analysis and methods; // to access them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:594,Safety,avoid,avoid,594,"//===-- SPIRVPreLegalizer.cpp - prepare IR for legalization -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The pass prepares IR for legalization: it assigns SPIR-V types to registers; // and removes intrinsics which holded these types during IR translation.; // Also it processes constants and registers them in GR to avoid duplication.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:27,Availability,redundant,redundant,27,"// If the bitcast would be redundant, replace all uses with the source; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:27,Safety,redund,redundant,27,"// If the bitcast would be redundant, replace all uses with the source; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:14,Modifiability,rewrite,rewrite,14,// We need to rewrite dst types for ASSIGN_TYPE instrs to be able; // to perform tblgen'erated selection and we can't do that on Legalizer; // as it operates on gMIR only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:73,Performance,perform,perform,73,// We need to rewrite dst types for ASSIGN_TYPE instrs to be able; // to perform tblgen'erated selection and we can't do that on Legalizer; // as it operates on gMIR only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:917,Availability,redundant,redundant,917,"// Before IRTranslator pass, calls to spv_switch intrinsic are inserted before; // each switch instruction. IRTranslator lowers switches to G_ICMP + G_BRCOND; // + G_BR triples. A switch with two cases may be transformed to this MIR; // sequence:; //; // intrinsic(@llvm.spv.switch), %CmpReg, %Const0, %Const1; // %Dst0 = G_ICMP intpred(eq), %CmpReg, %Const0; // G_BRCOND %Dst0, %bb.2; // G_BR %bb.5; // bb.5.entry:; // %Dst1 = G_ICMP intpred(eq), %CmpReg, %Const1; // G_BRCOND %Dst1, %bb.3; // G_BR %bb.4; // bb.2.sw.bb:; // ...; // bb.3.sw.bb1:; // ...; // bb.4.sw.epilog:; // ...; //; // Sometimes (in case of range-compare switches), additional G_SUBs; // instructions are inserted before G_ICMPs. Those need to be additionally; // processed.; //; // This function modifies spv_switch call's operands to include destination; // MBBs (default and for each constant value).; //; // At the end, the function removes redundant [G_SUB] + G_ICMP + G_BRCOND +; // G_BR sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:917,Safety,redund,redundant,917,"// Before IRTranslator pass, calls to spv_switch intrinsic are inserted before; // each switch instruction. IRTranslator lowers switches to G_ICMP + G_BRCOND; // + G_BR triples. A switch with two cases may be transformed to this MIR; // sequence:; //; // intrinsic(@llvm.spv.switch), %CmpReg, %Const0, %Const1; // %Dst0 = G_ICMP intpred(eq), %CmpReg, %Const0; // G_BRCOND %Dst0, %bb.2; // G_BR %bb.5; // bb.5.entry:; // %Dst1 = G_ICMP intpred(eq), %CmpReg, %Const1; // G_BRCOND %Dst1, %bb.3; // G_BR %bb.4; // bb.2.sw.bb:; // ...; // bb.3.sw.bb1:; // ...; // bb.4.sw.epilog:; // ...; //; // Sometimes (in case of range-compare switches), additional G_SUBs; // instructions are inserted before G_ICMPs. Those need to be additionally; // processed.; //; // This function modifies spv_switch call's operands to include destination; // MBBs (default and for each constant value).; //; // At the end, the function removes redundant [G_SUB] + G_ICMP + G_BRCOND +; // G_BR sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:11,Availability,redundant,redundant,11,"// Collect redundant MIs from [G_SUB] + G_ICMP + G_BRCOND + G_BR sequences.; // After updating spv_switches, the instructions can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:11,Safety,redund,redundant,11,"// Collect redundant MIs from [G_SUB] + G_ICMP + G_BRCOND + G_BR sequences.; // After updating spv_switches, the instructions can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:3,Deployability,Update,Update,3,// Update each spv_switch with destination MBBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:244,Availability,down,down,244,"// If G_ICMP + G_BRCOND + G_BR were the only MIs in MBB, erase this MBB. It; // can be safely assumed, there are no breaks or phis directing into this; // MBB. However, we need to remove this MBB from the CFG graph. MBBs must be; // erased top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:87,Safety,safe,safely,87,"// If G_ICMP + G_BRCOND + G_BR were the only MIs in MBB, erase this MBB. It; // can be safely assumed, there are no breaks or phis directing into this; // MBB. However, we need to remove this MBB from the CFG graph. MBBs must be; // erased top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:39,Safety,detect,detected,39,"// Branching SPIR-V intrinsics are not detected by this generic method.; // Thus, we can only trust negative result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:108,Usability,simpl,simply,108,"// It is valid for MachineBasicBlocks to not finish with a branch instruction.; // In such cases, they will simply fallthrough their immediate successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:170,Integrability,wrap,wrap,170,"// For @llvm.memset.* intrinsic cases with constant value and length arguments; // are emulated via ""storing"" a constant array to the destination. For other; // cases we wrap the intrinsic in @spirv.llvm_memset_* function and expand the; // intrinsic to a loop via expandMemSetAsLoop().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:97,Usability,simpl,simply,97,"// Get a separate function - otherwise, we'd have to rework the CFG of the; // current one. Then simply replace the intrinsic uses with a call to the new; // function.; // Generate LLVM IR for i* @spirv.llvm_fsh?_i* (i* %a, i* %b, i* %c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:40,Testability,log,logic,40,"// Build the actual funnel shift rotate logic.; // In the comments, ""int"" is used interchangeably with ""vector of int; // elements"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:5,Usability,simpl,simple,5,// A simple binary addition of the shifted ints yields the final result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:44,Testability,log,logic,44,"// Build the actual unsigned multiplication logic with the overflow; // indication. Do unsigned multiplication Mul = A * B. Then check; // if unsigned division Div = Mul / A is not equal to B. If so,; // then overflow has happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:97,Usability,simpl,simply,97,"// Get a separate function - otherwise, we'd have to rework the CFG of the; // current one. Then simply replace the intrinsic uses with a call to the new; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp:98,Availability,redundant,redundant,98,// This required for .td selection patterns to work or we'd end up with RegClass; // checks being redundant as all the classes would be mapped to the same bank.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp:98,Safety,redund,redundant,98,// This required for .td selection patterns to work or we'd end up with RegClass; // checks being redundant as all the classes would be mapped to the same bank.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:490,Availability,redundant,redundant,490,"// Since SPIR-V cannot represent constant expression, constant expressions; // in LLVM IR need to be lowered to instructions. For each function,; // the constant expressions used by instructions of the function are replaced; // by instructions placed in the entry block since it dominates all other BBs.; // Each constant expression only needs to be lowered once in each function; // and all uses of it by instructions in that function are replaced by; // one instruction.; // TODO: remove redundant instructions for common subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:490,Safety,redund,redundant,490,"// Since SPIR-V cannot represent constant expression, constant expressions; // in LLVM IR need to be lowered to instructions. For each function,; // the constant expressions used by instructions of the function are replaced; // by instructions placed in the entry block since it dominates all other BBs.; // Each constant expression only needs to be lowered once in each function; // and all uses of it by instructions in that function are replaced by; // one instruction.; // TODO: remove redundant instructions for common subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:52,Usability,simpl,simple,52,// Check if all arguments have the same type - it's simple case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp:10,Modifiability,extend,extended,10,// Handle extended instruction sets from extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:24,Availability,avail,available,24,"// TODO: Initialise the available extensions, extended instruction sets; // based on the environment settings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:46,Modifiability,extend,extended,46,"// TODO: Initialise the available extensions, extended instruction sets; // based on the environment settings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:183,Testability,Log,Logical,183,"// TODO: this environment is not implemented in Triple, we need to decide; // how to standardize its support. For now, let's assume SPIR-V with physical; // addressing is OpenCL, and Logical addressing is Vulkan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:50,Testability,Log,Logical,50,"// TODO: this probably needs to be revisited:; // Logical SPIR-V has no pointer size, so any fixed pointer size would be; // wrong. The choice to default to 32 or 64 is just motivated by another; // memory model used for graphics: PhysicalStorageBuffer64. But it shouldn't; // mean anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:30,Deployability,Configurat,Configuration,30,// SPIR-V Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:30,Modifiability,Config,Configuration,30,// SPIR-V Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:108,Deployability,pipeline,pipeline,108,"// namespace; // We do not use physical registers, and maintain virtual registers throughout; // the entire pipeline, so return nullptr to disable register allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:168,Usability,Simpl,Simplify,168,"// Once legalized, we need to structurize the CFG to follow the spec.; // This is done through the following 8 steps.; // TODO(#75801): add the remaining steps.; // 1. Simplify loop for subsequent transformations. After this steps, loops; // have the following properties:; // - loops have a single entry edge (pre-header to loop header).; // - all loop exits are dominated by the loop pre-header.; // - loops have a single back-edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp:17,Usability,simpl,simple,17,// Otherwise use simple demangling to return the function name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h:101,Testability,log,logic,101,// Read the series of integer operands back as a null-terminated string using; // the reverse of the logic in addStringImm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h:117,Deployability,Update,Updates,117,"// Find def instruction for the given ConstReg, walking through; // spv_track_constant and ASSIGN_TYPE instructions. Updates ConstReg by def; // of OpConstant instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h:13,Security,Access,AccessQualifier,13,// namespace AccessQualifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h:143,Testability,log,logic,143,// Return a string representation of the operands from startIndex onwards.; // Templated to allow both MachineInstr and MCInst to use the same logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp:13,Integrability,interface,interface,13,"// Print the interface ID operands, skipping the name's string; // literal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp:91,Modifiability,variab,variable,91,// The last fixed operand along with any variadic operands that follow; // are part of the variable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:28,Integrability,Interface,Interface,28,"//==- SystemZ.h - Top-Level Interface for SystemZ representation -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM SystemZ backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for integer and floating-point; // comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for floating-point comparisons only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for arithmetical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:39,Testability,log,logical,39,// Condition-code mask assignments for logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for CS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for a completed SRST loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:50,Availability,MASK,MASK,50,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:39,Testability,TEST,TEST,39,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for TRANSACTION_BEGIN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for TRANSACTION_END.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for vector comparisons (and similar; // operations).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for Test Data Class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:39,Testability,Test,Test,39,// Condition-code mask assignments for Test Data Class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:3,Availability,Mask,Mask,3,// Mask assignments for PFD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:3,Availability,Mask,Mask,3,// Mask assignments for TDC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:175,Deployability,update,update,175,"// MI is an instruction that accepts an optional alignment hint,; // and which was already lowered to LoweredMI. If the alignment; // of the original memory operand is known, update LoweredMI to; // an instruction with the corresponding hint set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:6,Performance,load,loads,6,// MI loads the high part of a vector from memory. Return an instruction; // that uses replicating vector load Opcode to do the same thing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:106,Performance,load,load,106,// MI loads the high part of a vector from memory. Return an instruction; // that uses replicating vector load Opcode to do the same thing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:11,Deployability,patch,patchpoint,11,"// Lower a patchpoint of the form:; // [<def>], <id>, <numBytes>, <target>, <numArgs>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:28,Testability,log,logic,28,"// Language Environment DLL logic requires function descriptors, for; // imported functions, that are placed in the ADA to be 8 byte aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:16,Availability,mask,mask,16,// Add emit FPR mask flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:15,Availability,mask,mask,15,// Add emit VR mask flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:25,Availability,mask,masks,25,// Get saved GPR/FPR/VPR masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:18,Availability,mask,mask,18,// Emit saved FPR mask and offset to FPR save area (0x20 of flags 3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:6,Availability,Mask,Mask,6,"// AR Mask, unused currently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:17,Availability,mask,mask,17,// Emit saved VR mask to VR save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:40,Integrability,Interface,Interfaces,40,"// See z/OS Language Environment Vendor Interfaces v2r5, p.23, for; // complete list. Only the C runtime is supported by this backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h:13,Availability,avail,available,13,/// The next available displacement value. Incremented when new entries into; /// the ADA are created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:108,Security,access,accessing,108,// This version of AnalyzeCallOperands in the base class is not usable; // since we must provide a means of accessing ISD::OutputArg::IsFixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:64,Usability,usab,usable,64,// This version of AnalyzeCallOperands in the base class is not usable; // since we must provide a means of accessing ISD::OutputArg::IsFixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:99,Usability,simpl,simple,99,"// Handle i128 argument types. These need to be passed by implicit; // reference. This could be as simple as the following .td line:; // CCIfType<[i128], CCPassIndirect<i64>>,; // except that i128 is not a legal type, and therefore gets split by; // common code into a pair of i64 arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:54,Energy Efficiency,Allocate,Allocate,54,"// OK, we've collected all parts in the pending list. Allocate; // the location (register or stack slot) for the indirect pointer.; // (This duplicates the usual i64 calling convention rules.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:28,Availability,avail,available,28,"// Shadow next two GPRs, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:206,Energy Efficiency,allocate,allocated,206,"// For any C or C++ program, this should always be; // false, since it is illegal to have a function; // where the first argument is variadic. Therefore; // the first fixed argument should already have; // allocated GPR1 either through shadowing it or; // using it for parameter passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:24,Availability,avail,available,24,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:87,Availability,avail,available,87,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:179,Energy Efficiency,allocate,allocate,179,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h:174,Modifiability,variab,variables,174,"// end namespace SystemZCP; /// A SystemZ-specific constant pool value. At present, the only; /// defined constant pool values are module IDs or offsets of; /// thread-local variables (written x@TLSGD, x@TLSLDM, x@DTPOFF,; /// or x@NTPOFF).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h:3,Security,Access,Access,3,// Access SystemZ-specific fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:28,Performance,load,load,28,// Return true if this is a load and test which can be optimized the; // same way as compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:55,Performance,optimiz,optimized,55,// Return true if this is a load and test which can be optimized the; // same way as compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:37,Testability,test,test,37,// Return true if this is a load and test which can be optimized the; // same way as compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:28,Performance,load,load-and-test,28,"// If we during isel used a load-and-test as a compare with 0, the; // def operand is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:37,Testability,test,test,37,"// If we during isel used a load-and-test as a compare with 0, the; // def operand is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:79,Testability,test,tested,79,"// Return the source register of Compare, which is the unknown value; // being tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:71,Performance,load,load,71,"// Compare compares the result of MI against zero. If MI is a suitable load; // instruction and if CCUsers is a single conditional trap on zero, eliminate; // the load and convert the branch to a load-and-trap. Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:163,Performance,load,load,163,"// Compare compares the result of MI against zero. If MI is a suitable load; // instruction and if CCUsers is a single conditional trap on zero, eliminate; // the load and convert the branch to a load-and-trap. Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:196,Performance,load,load-and-trap,196,"// Compare compares the result of MI against zero. If MI is a suitable load; // instruction and if CCUsers is a single conditional trap on zero, eliminate; // the load and convert the branch to a load-and-trap. Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:49,Performance,load,load-and-trap,49,// The transformation is OK. Rebuild Branch as a load-and-trap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:14,Performance,load,load,14,"// If MI is a load instruction, try to convert it into a LOAD AND TEST.; // Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:57,Performance,LOAD,LOAD,57,"// If MI is a load instruction, try to convert it into a LOAD AND TEST.; // Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:66,Testability,TEST,TEST,66,"// If MI is a load instruction, try to convert it into a LOAD AND TEST.; // Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:20,Availability,mask,masks,20,// Try to adjust CC masks for the LOAD AND TEST opcode that could replace MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:34,Performance,LOAD,LOAD,34,// Try to adjust CC masks for the LOAD AND TEST opcode that could replace MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:43,Testability,TEST,TEST,43,// Try to adjust CC masks for the LOAD AND TEST opcode that could replace MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:51,Testability,log,logical,51,"// See if MI is an instruction with an equivalent ""logical"" opcode that can; // be used and replace MI. This is useful for EQ/NE comparisons where the; // ""nsw"" flag is missing since the ""logical"" opcode always sets CC to reflect; // the result being zero or non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:188,Testability,log,logical,188,"// See if MI is an instruction with an equivalent ""logical"" opcode that can; // be used and replace MI. This is useful for EQ/NE comparisons where the; // ""nsw"" flag is missing since the ""logical"" opcode always sets CC to reflect; // the result being zero or non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:400,Availability,failure,failure,400,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:31,Testability,test,testing,31,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:307,Testability,test,test,307,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:53,Testability,test,test,53,"// If the caller will change MI to use ConvOpc, only test whether; // ConvOpc is suitable; it is on the caller to set the MI flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:40,Testability,test,test,40,"// If the caller will not change MI, we test the MI flag here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:47,Availability,avail,available,47,// See which compare-style condition codes are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:305,Safety,predict,predict,305,"// Signed addition of immediate. If adding a positive immediate; // overflows, the result must be less than zero. If adding a negative; // immediate overflows, the result must be larger than zero (except in; // the special case of adding the minimum value of the result range, in; // which case we cannot predict whether the result is larger than or; // equal to zero).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:32,Availability,mask,masks,32,// All users are OK. Adjust the masks for MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:34,Testability,log,logical,34,"// Translate the CCMask into its ""logical"" value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Testability,Log,Logical,3,// Logical subtracts never set CC=0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Usability,Clear,Clear,3,// Clear any intervening kills of CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:10,Performance,optimiz,optimize,10,// Try to optimize cases where comparison instruction Compare is testing; // a value against zero. Return true on success and if Compare should be; // deleted as dead. CCUsers is the list of instructions that use the CC; // value produced by Compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:65,Testability,test,testing,65,// Try to optimize cases where comparison instruction Compare is testing; // a value against zero. Return true on success and if Compare should be; // deleted as dead. CCUsers is the list of instructions that use the CC; // value produced by Compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:81,Performance,load,load-and-trap,81,// Try to remove both MI and Compare by converting a branch to BRCT(G).; // or a load-and-trap instruction. We don't care in this case whether; // CC is modified between MI and Compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:122,Availability,redundant,redundant,122,// Try to fuse comparison instruction Compare into a later branch.; // Return true on success and if Compare is therefore redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:122,Safety,redund,redundant,122,// Try to fuse comparison instruction Compare into a later branch.; // Return true on success and if Compare is therefore redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:35,Availability,avail,available,35,"// Make sure that the operands are available at the branch.; // SrcReg2 is the register if the source operand is a register,; // 0 if the source operand is immediate, and the base register; // if the source operand is memory (index is not supported).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:19,Availability,mask,mask,19,"// Read the branch mask, target (if applicable), regmask (if applicable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Usability,Clear,Clear,3,// Clear out all current operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Usability,Clear,Clear,3,// Clear any intervening kills of SrcReg and SrcReg2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:282,Modifiability,refactor,refactored,282,"// Sort all objects for short/paired displacements, which should be; // sufficient as it seems like all frame objects typically are within the; // long displacement range. Sorting works by computing the ""density"" as; // Count / ObjectSize. The comparisons of two such fractions are refactored; // by multiplying both sides with A.ObjectSize * B.ObjectSize, in order to; // eliminate the (fp) divisions. A higher density object needs to go after; // in the list in order for it to end up lower on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:23,Modifiability,variab,variable,23,// Put all invalid and variable sized objects at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:52,Safety,safe,safe,52,"// All invalid items are sorted at the end, so it's safe to stop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,"// The ELF ABI requires us to allocate 160 bytes of stack space for the; // callee, with any outgoing stack arguments being placed above that. It; // seems better to make that area a permanent feature of the frame even if; // we're using a frame pointer. Similarly, 64-bit XPLINK requires 96 bytes; // of stack space for the register save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:41,Energy Efficiency,allocate,allocated,41,// Get the size of our stack frame to be allocated ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:82,Security,access,access,82,// ... and the maximum offset we may need to reach into the; // caller's frame to access the save area or stack arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:101,Energy Efficiency,allocate,allocated,101,"// In GHC calling convention C stack space, including the ABI-defined; // 160-byte base area, is (de)allocated by GHC itself. This stack space may; // be used by LLVM as spill slots for the tail recursive GHC functions. Thus; // do not allocate stack space here, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:236,Energy Efficiency,allocate,allocate,236,"// In GHC calling convention C stack space, including the ABI-defined; // 160-byte base area, is (de)allocated by GHC itself. This stack space may; // be used by LLVM as spill slots for the tail recursive GHC functions. Thus; // do not allocate stack space here, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate the ABI-defined 160-byte base area whenever; // we allocate stack space for our own use and whenever we call another; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:74,Energy Efficiency,allocate,allocate,74,// We need to allocate the ABI-defined 160-byte base area whenever; // we allocate stack space for our own use and whenever we call another; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:9,Energy Efficiency,allocate,allocate,9,// Don't allocate the incoming reg save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate StackSize bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a block of Size bytes on the stack and probe it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:70,Integrability,rout,routine,70,// Checks if the function is a potential candidate for being a XPLeaf routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:83,Integrability,rout,routine,83,"// If function calls other functions including alloca, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:66,Integrability,rout,routine,66,"// If the function has var Sized Objects, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:62,Integrability,rout,routine,62,"// If the function adjusts the stack, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:80,Integrability,rout,routine,80,"// If function modifies the stack pointer register, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:66,Integrability,rout,routine,66,"// If function modifies the ADA register, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:81,Integrability,rout,routine,81,"// If function modifies the return address register, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:70,Integrability,rout,routine,70,"// If the backchain pointer should be stored, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:158,Energy Efficiency,allocate,allocated,158,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:69,Integrability,rout,routine,69,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:140,Modifiability,variab,variables,140,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate StackSize bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:117,Modifiability,extend,extender,117,"// If the requested stack size is larger than the guard page, then we need; // to check if we need to call the stack extender. This requires adding a; // conditional branch, but splitting the prologue block is not possible at; // this point since it would invalidate the SaveBlocks / RestoreBlocks sets; // of PEI in the single block function case. Build a pseudo to be handled; // later by inlineStackProbe().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:95,Modifiability,extend,extender,95,"// Emit a compare of the stack pointer against the stack floor, and a call to; // the LE stack extender if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:1221,Deployability,update,updated,1221,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:437,Energy Efficiency,schedul,scheduler,437,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:490,Energy Efficiency,schedul,scheduling,490,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:543,Energy Efficiency,schedul,scheduling,543,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:590,Energy Efficiency,schedul,scheduling,590,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:760,Energy Efficiency,schedul,scheduled,760,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:980,Energy Efficiency,schedul,scheduling,980,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:1082,Energy Efficiency,schedul,scheduling,1082,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:1171,Energy Efficiency,schedul,scheduling,1171,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:42,Safety,Hazard,Hazard,42,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:403,Safety,hazard,hazard,403,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:66,Energy Efficiency,schedul,scheduler,66,// This is the limit of processor resource usage at which the; // scheduler should try to look for other instructions (not using the; // critical resource).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:40,Energy Efficiency,schedul,schedule,40,// A cracked instruction only fits into schedule if the current; // group is empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:3,Usability,Clear,Clear,3,// Clear CriticalResourceIdx if it is now below the threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:3,Deployability,Update,Update,3,// Update state with SU as the next scheduled unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:36,Energy Efficiency,schedul,scheduled,36,// Update state with SU as the next scheduled unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:6,Energy Efficiency,schedul,scheduling,6,"// If scheduling an SU that must begin a new decoder group, move on; // to next group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:45,Energy Efficiency,schedul,scheduled,45,"// If this is the first FPd op, it should be scheduled high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:1222,Deployability,update,updated,1222,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:438,Energy Efficiency,schedul,scheduler,438,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:491,Energy Efficiency,schedul,scheduling,491,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:544,Energy Efficiency,schedul,scheduling,544,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:591,Energy Efficiency,schedul,scheduling,591,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:761,Energy Efficiency,schedul,scheduled,761,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:981,Energy Efficiency,schedul,scheduling,981,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:1083,Energy Efficiency,schedul,scheduling,1083,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:1172,Energy Efficiency,schedul,scheduling,1172,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:42,Safety,Hazard,Hazard,42,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:404,Safety,hazard,hazard,404,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:67,Energy Efficiency,schedul,scheduling,67,/// SystemZHazardRecognizer maintains the state for one MBB during scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:60,Energy Efficiency,schedul,scheduled,60,/// True if an instruction with four reg operands have been scheduled into; /// the current decoder group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:286,Energy Efficiency,schedul,scheduled,286,"/// The tracking of resources here are quite similar to the common; /// code use of a critical resource. However, z13 differs in the way; /// that it has two processor sides which may be interesting to; /// model in the future (a work in progress).; /// Counters for the number of uops scheduled per processor; /// resource.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:65,Energy Efficiency,schedul,scheduler,65,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:43,Performance,queue,queue,43,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:84,Safety,avoid,avoid,84,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:105,Energy Efficiency,schedul,scheduled,105,/// LastFPdOpCycleIdx stores the numbeer returned by getCurrCycleIdx(); /// when a stalling operation is scheduled (which uses the FPd resource).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:32,Energy Efficiency,schedul,scheduled,32,/// A counter of decoder groups scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:4,Usability,Clear,Clear,4,/// Clear all counters for processor resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:110,Energy Efficiency,schedul,schedule,110,"/// With the goal of alternating processor sides for stalling (FPd); /// ops, return true if it seems good to schedule an FPd op next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:34,Energy Efficiency,schedul,scheduling,34,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:17,Performance,cache,cache,17,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:15,Energy Efficiency,schedul,scheduled,15,/// Wrap a non-scheduled instruction in an SU and emit it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:4,Integrability,Wrap,Wrap,4,/// Wrap a non-scheduled instruction in an SU and emit it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:212,Energy Efficiency,schedul,schedule,212,"// Cost functions used by SystemZPostRASchedStrategy while; // evaluating candidates.; /// Return the cost of decoder grouping for SU. If SU must start a; /// new decoder group, this is negative if this fits the schedule or; /// positive if it would mean ending a group prematurely. For normal; /// instructions this returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:185,Energy Efficiency,schedul,schedule,185,"/// Return the cost of SU in regards to processor resources usage.; /// A positive value means it would be better to wait with SU, while; /// a negative value means it would be good to schedule SU next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrBuilder.h:393,Security,expose,exposes,393,"//===-- SystemZInstrBuilder.h - Functions to aid building insts -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to handle SystemZ'isms in a clean way.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:12,Availability,mask,mask,12,// Return a mask with Count low bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:19,Performance,load,load,19,"// MI is a 128-bit load or store. Split it into two 64-bit loads or stores,; // each having the opcode given by NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:59,Performance,load,loads,59,"// MI is a 128-bit load or store. Split it into two 64-bit loads or stores,; // each having the opcode given by NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,Performance,load,load,11,// Get two load or store instructions. Use the original instruction for; // one of them and create a clone for the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Usability,Clear,Clear,3,// Clear the kill flags on the address registers in the first instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:185,Integrability,depend,depending,185,"// MI is a three-operand RIE-style pseudo instruction. Replace it with; // LowOpcodeK if the registers are both low GR32s, otherwise use a move; // followed by HighOpcode or LowOpcode, depending on whether the target; // is a high or low GR32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,Performance,load,load-on-condition,11,// MI is a load-on-condition pseudo instruction with a single register; // (source or destination) operand. Replace it with LowOpcode if the; // register is a low GR32 and HighOpcode if the register is a high GR32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:50,Modifiability,extend,extends,50,"// MI is an RR-style pseudo instruction that zero-extends the low Size bits; // of one GRX32 into another. Replace it with LowOpcode if both operands; // are low registers, otherwise use RISB[LH]G.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:16,Performance,load,load,16,"// EAR can only load the low subregister so us a shift for %a0 to produce; // the GR containing %a0 and %a1.; // ear <reg>, %a0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:15,Modifiability,extend,extending,15,"// Emit a zero-extending move from 32-bit GPR SrcReg to 32-bit GPR; // DestReg before MBBI in MBB. Use LowLowOpcode when both DestReg and SrcReg; // are low registers, otherwise use RISB[LH]G. Size is the number of bits; // taken from the low end of SrcReg (8 for LLCR, 16 for LLHR and 32 for LR).; // KillSrc is true if this move is the last use of SrcReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:21,Performance,load,load,21,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:82,Performance,load,loads,82,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:209,Performance,load,loads,209,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:14,Usability,simpl,simple,14,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:191,Usability,Simpl,SimpleBDXLoad,191,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:219,Usability,Simpl,SimpleBDXStore,219,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:149,Deployability,pipeline,pipeline,149,"// In this function we output 32-bit branches, which should always; // have enough range. They can be shortened and relaxed by later code; // in the pipeline, if desired.; // Shouldn't be a fall through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Safety,Avoid,Avoid,3,"// Avoid using conditional returns at the end of a loop (since then; // we'd need to emit an unconditional branch to the beginning anyway,; // making the loop body longer). This doesn't apply for low-probability; // loops (eg. compare-and-swap retry), so just decide based on branch; // probability instead of looping structure.; // However, since Compare and Trap instructions cost the same as a regular; // Compare instruction, we should allow the if conversion to convert this; // into a Conditional Compare regardless of the branch probability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,Safety,avoid,avoid,11,// For now avoid converting mutually-exclusive cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:60,Integrability,depend,dependencies,60,// For z13 we prefer LDR over LER to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:37,Safety,avoid,avoid,37,// For z13 we prefer LDR over LER to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:33,Performance,load,load,33,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:118,Performance,load,loads,118,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:26,Usability,simpl,simple,26,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:100,Usability,Simpl,SimpleBDXLoad,100,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:128,Usability,Simpl,SimpleBDXStore,128,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:20,Availability,avail,available,20,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:52,Performance,load,load,52,"// If we're spilling the source of an LDGR or LGDR, load the; // destination register instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:753,Availability,redundant,redundant,753,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:88,Performance,load,load,88,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:288,Performance,load,load,288,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:507,Performance,perform,performance,507,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:544,Safety,avoid,avoid,544,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:753,Safety,redund,redundant,753,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:217,Testability,log,logically,217,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:40,Usability,simpl,simple,40,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:81,Usability,simpl,simple,81,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:24,Performance,load,loads,24,// Handle conversion of loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:35,Usability,usab,usable,35,// Check if all other vregs have a usable allocation in the case of vector; // to FP conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:77,Energy Efficiency,allocate,allocated,77,// Constrain the register classes if converted from a vector opcode. The; // allocated regs are in an FP reg-class per previous check above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:171,Performance,load,load-and-test,171,"// On zEC12 we prefer to use RISBGN. But if there is a chance to; // actually use the condition code, we may turn it back into RISGB.; // Note that RISBG is not really a ""load-and-test"" instruction,; // but sets the same condition code values, so is OK to use here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:180,Testability,test,test,180,"// On zEC12 we prefer to use RISBGN. But if there is a chance to; // actually use the condition code, we may turn it back into RISGB.; // Note that RISBG is not really a ""load-and-test"" instruction,; // but sets the same condition code values, so is OK to use here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:27,Availability,mask,masks,27,// Reject trivial all-zero masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:14,Integrability,wrap,wrap-around,14,// Handle the wrap-around 1+0+1+ cases. Start then specifies the msb; // of the low 1s and End specifies the lsb of the high 1s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Deployability,Update,Update,3,// Update all CC users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:3,Availability,Mask,Masks,3,// Masks out the bits for the access model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:30,Security,access,access,30,// Masks out the bits for the access model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:53,Security,access,accesses,53,"// z/OS XPLink specific: classifies the types of; // accesses to the ADA (Associated Data Area).; // These enums contains values that overlap with the above MO_ enums,; // but that's fine since the above enums are used with ELF,; // while these values are used with z/OS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:37,Availability,mask,mask,37,// Return a version of comparison CC mask CCMask in which the LT and GT; // actions are swapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:104,Availability,mask,mask,104,"// Return true if MI is a conditional or unconditional branch.; // When returning true, set Cond to the mask of condition-code; // values on which the instruction will branch, and set Target; // to the operand that contains the branch target. This target; // can be a register or a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:11,Performance,load,load,11,// Get the load and store opcodes for a given register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:99,Performance,perform,perform,99,"// Opcode is the opcode of an instruction that has an address operand,; // and the caller wants to perform that instruction's operation on an; // address that has displacement Offset. Return the opcode of a suitable; // instruction (which might be Opcode itself) or 0 if no such instruction; // exists. MI may be passed in order to allow examination of physical; // register operands (i.e. if a VR32/64 reg ended up as an FP or Vector reg).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:18,Performance,load,load,18,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:46,Performance,LOAD,LOAD,46,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:55,Testability,TEST,TEST,55,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:96,Testability,test,testing,96,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:78,Availability,Mask,Mask,78,"// Return true if ROTATE AND ... SELECTED BITS can be used to select bits; // Mask of the R2 operand, given that only the low BitSize bits of Mask are; // significant. Set Start and End to the I3 and I4 operands if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:142,Availability,Mask,Mask,142,"// Return true if ROTATE AND ... SELECTED BITS can be used to select bits; // Mask of the R2 operand, given that only the low BitSize bits of Mask are; // significant. Set Start and End to the I3 and I4 operands if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:66,Deployability,update,update,66,// Try to find all CC users of the compare instruction (MBBI) and update; // all of them to maintain equivalent behavior after swapping the compare; // operands. Return false if not all users can be conclusively found and; // handled. The compare instruction is *not* changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:18,Performance,LOAD,LOAD,18,"// If Opcode is a LOAD opcode for with an associated LOAD AND TRAP; // operation exists, returh the opcode for the latter, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:53,Performance,LOAD,LOAD,53,"// If Opcode is a LOAD opcode for with an associated LOAD AND TRAP; // operation exists, returh the opcode for the latter, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:3,Performance,Perform,Perform,3,// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:105,Security,access,access,105,"// Sometimes, it is possible for the target to tell, even without; // aliasing information, that two MIs access different memory; // addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:182,Security,access,access,182,"// Sometimes, it is possible for the target to tell, even without; // aliasing information, that two MIs access different memory; // addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,Performance,load,load,31,// base+displacement+index for load and store operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,Performance,load,load,31,// base+displacement+index for load address operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:12,Availability,mask,mask,12,// Return a mask with Count low bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:247,Availability,Mask,Mask,247,"// Represents operands 2 to 5 of the ROTATE AND ... SELECTED BITS operation; // given by Opcode. The operands are: Input (R2), Start (I3), End (I4) and; // Rotate (I5). The combined operand value is effectively:; //; // (or (rotl Input, Rotate), ~Mask); //; // for RNSBG and:; //; // (and (rotl Input, Rotate), Mask); //; // otherwise. The output value has BitSize bits, although Input may be; // narrower (in which case the upper bits are don't care), or wider (in which; // case the result will be truncated as part of the operation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:311,Availability,Mask,Mask,311,"// Represents operands 2 to 5 of the ROTATE AND ... SELECTED BITS operation; // given by Opcode. The operands are: Input (R2), Start (I3), End (I4) and; // Rotate (I5). The combined operand value is effectively:; //; // (or (rotl Input, Rotate), ~Mask); //; // for RNSBG and:; //; // (and (rotl Input, Rotate), Mask); //; // otherwise. The output value has BitSize bits, although Input may be; // narrower (in which case the upper bits are don't care), or wider (in which; // case the result will be truncated as part of the operation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:32,Integrability,rout,routines,32,// PC-relative address matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:15,Integrability,rout,routines,15,// BD matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,Integrability,rout,routines,16,// MVI matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,Integrability,rout,routines,16,// BDX matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:63,Availability,Mask,Mask,63,// Try to update RxSBG so that only the bits of RxSBG.Input in Mask are used.; // Return true on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:10,Deployability,update,update,10,// Try to update RxSBG so that only the bits of RxSBG.Input in Mask are used.; // Return true on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:55,Performance,load,loaded,55,"// If Op0 is null, then Node is a constant that can be loaded using:; //; // (Opcode UpperVal LowerVal); //; // If Op0 is nonnull, then Node can be implemented using:; //; // (Opcode (Opcode Op0 UpperVal) LowerVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Performance,load,load,22,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:64,Usability,simpl,simple,64,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:18,Performance,Load,Load,18,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:37,Performance,load,loads,37,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:380,Safety,avoid,avoid,380,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:276,Testability,log,logically,276,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:18,Performance,load,load,18,"// N is a (store (load Y), X) pattern. Return true if it can use an MVC; // from Y to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Performance,load,load,22,"// N is a (store (op (load A[0]), (load A[1])), X) pattern. Return true; // if A[1 - I] == X and if N can use a block operation like NC from A[I]; // to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:35,Performance,load,load,35,"// N is a (store (op (load A[0]), (load A[1])), X) pattern. Return true; // if A[1 - I] == X and if N can use a block operation like NC from A[I]; // to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:23,Performance,load,load,23,// Return true if N (a load or a store) fullfills the alignment; // requirements for a PC-relative access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:99,Security,access,access,99,// Return true if N (a load or a store) fullfills the alignment; // requirements for a PC-relative access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:126,Performance,tune,tuned,126,"// We could consider forcing the displacement into a register and; // using it as an index, but it would need to be carefully tuned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:48,Performance,perform,performed,48,// Return true if Base + Disp + Index should be performed by LA(Y).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:115,Safety,avoid,avoids,115,// Always use LA if the displacement is small enough. It should always; // be no worse than AGHI (and better if it avoids a move).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:51,Modifiability,extend,extended,51,"// Prefer addition if the second operation is sign-extended, in the; // hope of using AGF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:90,Modifiability,extend,extend,90,"// Start out assuming that the address will need to be loaded separately,; // then try to extend it as much as we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:55,Performance,load,loaded,55,"// Start out assuming that the address will need to be loaded separately,; // then try to extend it as much as we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:250,Integrability,depend,depend,250,"// Insert a node into the DAG at least before Pos. This will reposition; // the node as needed, and will assign it a node ID that is <= Pos's ID.; // Note that this does *not* preserve the uniqueness of node IDs!; // The selection DAG must no longer depend on their uniqueness when this; // function is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:78,Security,access,access,78,// We can't tell here whether the index vector has the right type; // for the access; the caller needs to do that instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Availability,mask,mask,22,// We need a constant mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:56,Availability,mask,masks,56,// It's not an insertion of Op.getOperand(0) if the two masks overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:45,Availability,Mask,Mask,45,// Return true if any bits of (RxSBG.Input & Mask) are significant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,Availability,mask,mask,14,// Rotate the mask in the same way as RxSBG.Input is rotated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:97,Availability,mask,mask,97,"// If some bits of Input are already known zeros, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:144,Availability,mask,mask,144,"// If some bits of Input are already known zeros, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:96,Availability,mask,mask,96,"// If some bits of Input are already known ones, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:143,Availability,mask,mask,143,"// If some bits of Input are already known ones, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:18,Modifiability,extend,extended,18,// Bits above the extended operand are don't-care.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,Availability,mask,mask,16,// Restrict the mask to the extended operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:28,Modifiability,extend,extended,28,// Restrict the mask to the extended operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:58,Availability,mask,masked,58,// Check that the extension bits are don't-care (i.e. are masked out; // by the final mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:86,Availability,mask,mask,86,// Check that the extension bits are don't-care (i.e. are masked out; // by the final mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:25,Availability,mask,mask,25,"// Treat (srl X, count), mask) as (and (rotl X, size-count), ~0>>count),; // which is similar to SLL above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:168,Testability,log,logical,168,// The widening or narrowing is expected to be free.; // Counting widening or narrowing as a saved operation will result in; // preferring an R*SBG over a simple shift/logical instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:155,Usability,simpl,simple,155,// The widening or narrowing is expected to be free.; // Counting widening or narrowing as a saved operation will result in; // preferring an R*SBG over a simple shift/logical instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:20,Availability,avail,available,20,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:97,Integrability,wrap,wrapping,97,"// We can only use the 32-bit instructions if all source bits are; // in the low 32 bits without wrapping, both after rotation (because; // of the smaller range for Start and End) and before rotation; // (because the input value is truncated).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:350,Testability,log,logical,350,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:58,Usability,simpl,simple,58,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:337,Usability,simpl,simple,337,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Safety,avoid,avoid,22,// See whether we can avoid an AND in the first operand by converting; // ROSBG to RISBG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:20,Availability,avail,available,20,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:455,Safety,avoid,avoid,455,"// When we haven't passed in Op0, Upper will be a constant. In order to; // prevent folding back to the large immediate in `Or = getNode(...)` we run; // SelectCode first and end up with an opaque machine node. This means that; // we need to use a handle to keep track of Upper in case it gets CSE'd by; // SelectCode.; //; // Note that in the case where Op0 is passed in we could just call; // SelectCode(Upper) later, along with the SelectCode(Or), and avoid needing; // the handle at all, but it's fine to do it here.; //; // TODO: This is a pretty hacky way to do this. Can we do something that; // doesn't require a two paragraph explanation?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:85,Performance,load,load,85,// Check whether or not the chain ending in StoreNode is suitable for doing; // the {load; op; store} to modify transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,Performance,load,loaded,31,// Are there other uses of the loaded value than the operation?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:20,Modifiability,extend,extending,20,// Is the store non-extending and non-indexed?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:29,Modifiability,extend,extending,29,// Is the stored value a non-extending and non-indexed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:55,Performance,load,load,55,// Is the stored value a non-extending and non-indexed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:10,Performance,Load,LoadNode,10,// Return LoadNode by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:33,Performance,load,loaded,33,// Is store the only read of the loaded value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:47,Performance,load,load,47,// Is the address of the store the same as the load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:41,Performance,load,load,41,// Check if the chain is produced by the load or is a TokenFactor with; // the load output chain as an operand. Return InputChain by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:79,Performance,load,load,79,// Check if the chain is produced by the load or is a TokenFactor with; // the load output chain as an operand. Return InputChain by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:8,Performance,Load,Load,8,"// Drop Load, but keep its chain. No cycle check necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:12,Performance,Load,Load,12,// Check if Load is reachable from any of the nodes in the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:77,Performance,load,load,77,// Make a new TokenFactor with all the other input chains except; // for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:348,Integrability,rout,routine,348,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Performance,load,load,22,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:64,Usability,simpl,simple,64,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:23,Security,access,access,23,// Volatility stops an access from being decomposed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:39,Performance,load,load,39,// There's no chance of overlap if the load is invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,Security,access,access,14,// The memory access must have a proper alignment and no index register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:6,Security,access,access,6,// An access to GOT or the Constant Pool is aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:186,Performance,optimiz,optimize,186,"// If this is a 64-bit operation in which both 32-bit halves are nonzero,; // split the operation into two. If both operands here happen to be; // constant, leave this to common code to optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:69,Testability,log,logical,69,// Don't split the operation if we can match one of the combined; // logical operations provided by miscellaneous-extensions-3.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:21,Performance,load,load,21,"// Prefer to put any load first, so that it can be matched as a; // conditional load. Likewise for constants in range for LOCHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:80,Performance,load,load,80,"// Prefer to put any load first, so that it can be matched as a; // conditional load. Likewise for constants in range for LOCHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:30,Performance,LOAD,LOAD,30,// We want to avoid folding a LOAD into an ICMP node if as a result; // we would be forced to spill the condition code into a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,Safety,avoid,avoid,14,// We want to avoid folding a LOAD into an ICMP node if as a result; // we would be forced to spill the condition code into a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:140,Performance,load,load,140,"// If the actual instruction is a branch, the only thing that remains to be; // checked is whether the CCUser chain is a predecessor of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:127,Performance,load,load,127,"// Otherwise, the instruction may have multiple operands, and we need to; // verify that none of them are a predecessor of the load. This is exactly; // the same check that would be done by common code if the CC setter were; // glued to the CC user, so simply invoke that check here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:253,Usability,simpl,simply,253,"// Otherwise, the instruction may have multiple operands, and we need to; // verify that none of them are a predecessor of the load. This is exactly; // the same check that would be done by common code if the CC setter were; // glued to the CC user, so simply invoke that check here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:251,Testability,test,tests,251,"// Deal with cases where we can add a value to force the sign bit; // to contain the right value. Putting the bit in 31 means we can; // use SRL rather than RISBG(L), and also makes it easier to get a; // 0/-1 value, so it has priority over the other tests below.; //; // These sequences rely on the fact that the upper two bits of the; // IPM result are zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:36,Testability,test,testing,36,"// Next try inverting the value and testing a bit. 0/1 could be; // handled this way too, but we dealt with that case above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:35,Performance,optimiz,optimized,35,// The SHR/AND sequence should get optimized to an RISBG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:8,Modifiability,extend,extend,8,// Sign-extend from IPM.Bit using a pair of shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:36,Performance,load,loads,36,"// If we have conditional immediate loads, we always prefer; // using those over an IPM sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Availability,mask,mask,7,// The mask of CC values that Opcode can produce.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Availability,mask,mask,7,// The mask of CC values for which the original condition is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,Safety,safe,safely,50,// Return a version of MachineOperand that can be safely used before the; // final use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:57,Energy Efficiency,schedul,scheduling,57,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:113,Energy Efficiency,schedul,scheduler,113,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:230,Energy Efficiency,schedul,scheduler,230,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:40,Performance,latency,latency-oriented,40,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:96,Performance,latency,latency-oriented,96,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Performance,perform,performance,7,// For performance reasons we prefer 16-byte alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:59,Performance,load,loads,59,"// Lower ATOMIC_LOAD and ATOMIC_STORE into normal volatile loads and; // stores, putting a serialization instruction after the stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:70,Availability,avail,available,70,"// Lower ATOMIC_LOAD_SUB into ATOMIC_LOAD_ADD if LAA and LAAG are; // available, or if the operand is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Modifiability,extend,extending,38,// Likewise all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,load,loads,48,// Likewise all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect shifts/rotates by a scalar amount and convert them into; // V*_BY_SCALAR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Modifiability,extend,extended,18,// We can use the extended form of FI for other rounding operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Modifiability,enhance,enhancements,14,// The vector enhancements facility 1 has instructions for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,Modifiability,extend,extend,85,// Needed so that we don't try to implement f128 constant loads using; // a load-and-extend of a f80 constant (in cases where the constant; // would fit in an f80).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:58,Performance,load,loads,58,// Needed so that we don't try to implement f128 constant loads using; // a load-and-extend of a f80 constant (in cases where the constant; // would fit in an f80).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:76,Performance,load,load-and-extend,76,// Needed so that we don't try to implement f128 constant loads using; // a load-and-extend of a f80 constant (in cases where the constant; // would fit in an f80).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Modifiability,extend,extending,17,// We don't have extending load instruction on vector registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:27,Performance,load,load,27,// We don't have extending load instruction on vector registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:30,Performance,perform,perform,30,// Codes for which we want to perform some z-specific combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:53,Performance,load,load,53,// We want to use MVC in preference to even a single load/store pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:210,Modifiability,variab,variable,210,"// The main memset sequence is a byte store followed by an MVC.; // Two STC or MV..I stores win over that, but the kind of fused stores; // generated by target-independent code don't when the byte value is; // variable. E.g. ""STC <reg>;MHI <reg>,257;STH <reg>"" is not better; // than ""STC;MVC"". Handle the choice in target-specific code instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,Availability,MASK,MASK,34,// Try using VECTOR GENERATE BYTE MASK. This is the architecturally-; // preferred way of creating all-zero and all-one vectors so give it; // priority over other methods below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Availability,MASK,MASK,23,// Try VECTOR GENERATE MASK,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:248,Availability,mask,mask,248,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:272,Availability,MASK,MASK,272,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:237,Integrability,wrap,wraparound,237,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:175,Modifiability,extend,extended,175,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:158,Availability,mask,mask,158,// Now try assuming that any undefined bits between the first and; // last defined set bits are set. This increases the chances of; // using a non-wraparound mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:147,Integrability,wrap,wraparound,147,// Now try assuming that any undefined bits between the first and; // last defined set bits are set. This increases the chances of; // using a non-wraparound mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Performance,load,load,10,// We can load zero using LZ?R and negative zero using LZ?R;LC?BR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:49,Availability,avail,available,49,// Don't expand if there is a target instruction available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,Security,access,accesses,13,// Unaligned accesses should never be slower than the expanded version.; // We check specifically for aligned accesses in the few cases where; // they are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:110,Security,access,accesses,110,// Unaligned accesses should never be slower than the expanded version.; // We check specifically for aligned accesses in the few cases where; // they are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,Security,access,access,54,// Information about the addressing mode for a memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Performance,Load,Load,44,// Return the desired addressing mode for a Load which has only one use (in; // the same block) which is a Store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:25,Performance,Load,Load,25,// With vector support a Load->Store combination may be combined to either; // an MVC or vector operations and it seems to work best to allow the; // vector addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load->Store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load->Store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:69,Integrability,depend,dependencies,69,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:194,Performance,load,load,194,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:42,Safety,avoid,avoid,42,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:5,Performance,load,load,5,// A load which gets inserted into a vector element will be combined into a; // VLE type instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:31,Performance,load,loads,31,// Don't expand Op into scalar loads/stores in these cases:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:101,Integrability,depend,depends,101,"// We need to override the default register parsing for GPRs and FPRs; // because the interpretation depends on VT. The internal names of; // the registers are also different from the external names; // (F0D and F0S instead of F0, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:165,Performance,load,loads,165,"// Value is a value that has been passed to us in the location described by VA; // (and so has type VA.getLocVT()). Convert Value to VA.getValVT(), chaining; // any loads onto Chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:72,Testability,assert,assertion,72,"// If the argument has been promoted from a smaller type, insert an; // assertion to capture this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,Modifiability,extend,extend,65,"// If this is a short vector argument loaded from the stack,; // extend from i64 to full vector size and then bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Performance,load,loaded,38,"// If this is a short vector argument loaded from the stack,; // extend from i64 to full vector size and then bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; // from this parameter. Unpromoted ints and floats are; // passed as right-justified 8-byte values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:66,Performance,load,load,66,"// If the original argument was split (e.g. i128), we need; // to load all parts of it here (using the same address).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:47,Energy Efficiency,allocate,allocated,47,// ...and a similar frame index for the caller-allocated save area; // that will be used to store the incoming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Security,access,access,7,"// ADA access using Global value; // Note: for functions, address of descriptor is returned",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,Safety,detect,detected,62,"// We don't support GuaranteedTailCallOpt, only automatically-detected; // sibling calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the full stack space for a promoted (and split) argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Safety,detect,detect,38,// Special case that we cannot easily detect in RetCC_SystemZ since; // i128 may not be a legal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain and glue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:166,Availability,mask,mask,166,// Return true if Op is an intrinsic node with chain that returns the CC value; // as its only (other) argument. Provide the associated SystemZISD opcode and; // the mask of valid CC values if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:162,Availability,mask,mask,162,// Return true if Op is an intrinsic node without chain that returns the; // CC value as its final argument. Provide the associated SystemZISD; // opcode and the mask of valid CC values if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:124,Availability,mask,mask,124,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:314,Availability,mask,mask,314,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:230,Usability,clear,clear,230,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:77,Performance,load,load,77,"// For us to make any changes, it must a comparison between a single-use; // load and a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:32,Performance,load,load,32,// We must have an 8- or 16-bit load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Modifiability,extend,extending,23,// The load must be an extending one and the constant must be within the; // range of the unextended value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Performance,load,load,7,// The load must be an extending one and the constant must be within the; // range of the unextended value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:40,Modifiability,extend,extended,40,// Unsigned comparison between two sign-extended values is equivalent; // to unsigned comparison between two zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:114,Modifiability,extend,extended,114,// Unsigned comparison between two sign-extended values is equivalent; // to unsigned comparison between two zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the high bit of the byte is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the high bit of the byte is clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Usability,clear,clear,44,// Test whether the high bit of the byte is clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update the chain uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Performance,load,load,45,"// Return true if Op is either an unextended load, or a load suitable; // for integer register-memory comparisons of type ICmpType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:56,Performance,load,load,56,"// Return true if Op is either an unextended load, or a load suitable; // for integer register-memory comparisons of type ICmpType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:89,Performance,LOAD,LOAD,89,"// Always keep a floating-point constant second, since comparisons with; // zero can use LOAD TEST and comparisons with other constants make a; // natural memory operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:94,Testability,TEST,TEST,94,"// Always keep a floating-point constant second, since comparisons with; // zero can use LOAD TEST and comparisons with other constants make a; // natural memory operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,Performance,optimiz,optimize,65,// Never swap comparisons with zero since there are many ways to optimize; // those later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:51,Performance,load,loaded,51,// Also keep natural memory operands second if the loaded value is; // only used here. Several comparisons have memory forms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Performance,load,load,45,// Look for cases where Cmp0 is a single-use load and Cmp1 isn't.; // In that case we generally prefer the memory to be second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:19,Testability,test,tests,19,// Check whether C tests for equality between X and Y and whether X - Y; // or Y - X is also computed. In that case it's better to compare the; // result of the subtraction against zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:188,Performance,LOAD,LOAD,188,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:210,Performance,LOAD,LOAD,210,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:170,Safety,avoid,avoiding,170,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:197,Testability,TEST,TEST,197,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:8,Performance,optimiz,optimization,8,"// This optimization is invalid for strict comparisons, since FNEG; // does not raise any exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:78,Modifiability,extend,extended,78,"// Check whether C compares (shl X, 32) with 0 and whether X is; // also sign-extended. In that case it is better to test the result; // of the sign extension using LTGFR.; //; // This case is important because InstCombine transforms a comparison; // with (sext (trunc X)) into a comparison with (shl X, 32).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:117,Testability,test,test,117,"// Check whether C compares (shl X, 32) with 0 and whether X is; // also sign-extended. In that case it is better to test the result; // of the sign extension using LTGFR.; //; // This case is important because InstCombine transforms a comparison; // with (sext (trunc X)) into a comparison with (shl X, 32).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Modifiability,extend,extending,38,"// If C compares the truncation of an extending load, try to compare; // the untruncated value instead. This exposes more opportunities to; // reuse CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,load,load,48,"// If C compares the truncation of an extending load, try to compare; // the untruncated value instead. This exposes more opportunities to; // reuse CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:109,Security,expose,exposes,109,"// If C compares the truncation of an extending load, try to compare; // the untruncated value instead. This exposes more opportunities to; // reuse CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Availability,Mask,Mask,29,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:63,Availability,MASK,MASK,63,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:333,Availability,MASK,MASK,333,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:383,Availability,mask,mask,383,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,Testability,TEST,TEST,52,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:257,Testability,test,tested,257,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:322,Testability,TEST,TEST,322,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Availability,mask,mask,21,"// Check whether the mask is suitable for TMHH, TMHL, TMLH or TMLL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Availability,mask,masks,16,// Work out the masks for the lowest and highest bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:43,Availability,mask,mask,43,"// Check for equality comparisons with the mask, or the equivalent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,Availability,MASK,MASK,52,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:74,Deployability,Update,Update,74,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:41,Testability,TEST,TEST,41,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:25,Availability,MASK,MASK,25,// Use VECTOR TEST UNDER MASK for i128 operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Testability,TEST,TEST,14,// Use VECTOR TEST UNDER MASK for i128 operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,Availability,mask,mask,65,// Check whether the nonconstant input is an AND with a constant mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:75,Availability,mask,masked,75,// If the low N bits of Op1 are zero than the low N bits of Op0 can; // be masked off without changing the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:36,Availability,mask,mask,36,"// Check whether the combination of mask, comparison value and comparison; // type are suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,Availability,redundant,redundant,50,// See whether the comparison argument contains a redundant AND; // and remove it if so. This sometimes happens due to the generic; // BRCOND expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,Safety,redund,redundant,50,// See whether the comparison argument contains a redundant AND; // and remove it if so. This sometimes happens due to the generic; // BRCOND expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Testability,test,tests,28,// Return a Comparison that tests the condition-code result of intrinsic; // node Call against constant integer CC using comparison code Cond.; // Opcode is the opcode of the SystemZISD operation for the intrinsic; // and CCValid is the set of possible condition-code results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:58,Testability,test,tests,58,// Choose the type of comparison. Equality and inequality tests can; // use either signed or unsigned comparisons. The choice also doesn't; // matter if both sign bits are known to be clear. In those cases we; // want to give the main isel code the freedom to choose whichever; // form fits best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:184,Usability,clear,clear,184,// Choose the type of comparison. Equality and inequality tests can; // use either signed or unsigned comparisons. The choice also doesn't; // matter if both sign bits are known to be clear. In those cases we; // want to give the main isel code the freedom to choose whichever; // form fits best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Modifiability,extend,extending,45,// Implement a 32-bit *MUL_LOHI operation by extending both operands to; // 64 bits. Extend is the extension type to use. Store the high part; // in Hi and the low part in Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,Modifiability,Extend,Extend,85,// Implement a 32-bit *MUL_LOHI operation by extending both operands to; // 64 bits. Extend is the extension type to use. Store the high part; // in Hi and the low part in Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:161,Performance,perform,performs,161,"// Lower a binary operation that produces two VT results, one in each; // half of a GR128 pair. Op0 and Op1 are the VT operands to the operation,; // and Opcode performs the GR128 operation. Store the even register result; // in Even and the odd register result in Odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:81,Availability,mask,mask,81,"// Return an i32 value that is 1 if the CC value produced by CCReg is; // in the mask CCMask and 0 otherwise. CC is known to have a value; // in CCValid, so other values can be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:36,Modifiability,extend,extended,36,"// Return a v2f64 that contains the extended form of elements Start and Start+1; // of v4f32 value Op. If Chain is nonnull, return the strict form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:73,Modifiability,enhance,enhancements,73,"// There is no hardware support for v4f32 (unless we have the vector; // enhancements facility 1), so extend the vector into two v2f64s; // and compare those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:102,Modifiability,extend,extend,102,"// There is no hardware support for v4f32 (unless we have the vector; // enhancements facility 1), so extend the vector into two v2f64s; // and compare those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:92,Availability,mask,mask,92,"// Lower a vector comparison of type CC between CmpOp0 and CmpOp1, producing; // an integer mask of type VT. If Chain is nonnull, we have a strict; // floating-point comparison. If in addition IsSignaling is true, we have; // a strict signaling floating-point comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Testability,test,tests,10,// Handle tests for order using (or (ogt y x) (oge x y)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,Testability,test,tests,13,// Handle <> tests using (or (ogt y x) (ogt x y)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:111,Modifiability,extend,extended,111,"// Check for absolute and negative-absolute selections, including those; // where the comparison value is sign-extended (for LPGFR and LNGFR).; // This check supplements the one in DAGCombiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Performance,load,load,18,// Conservatively load a constant offset greater than 32 bits into a; // register below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Security,access,access,45,// The high part of the thread pointer is in access register 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Security,access,access,44,// The low part of the thread pointer is in access register 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load the GOT offset of the tls_index (module ID / per-symbol offset).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load the GOT offset of the module ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:46,Availability,redundant,redundant,46,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:46,Safety,redund,redundant,46,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:140,Security,access,accesses,140,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load the offset from the GOT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:47,Performance,load,load,47,// Force the offset into the constant pool and load it from there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Performance,load,load,15,// Use LARL to load the address of the table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Performance,load,load,15,// Use LARL to load the address of the constant pool entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Safety,detect,detect,29,// FIXME The frontend should detect this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Safety,detect,detect,29,// FIXME The frontend should detect this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:11,Performance,load,loads,11,"// Convert loads directly. This is normally done by DAGCombiner,; // but we need this case for bitcasts that are created during lowering; // and which are then lowered themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update the chain uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform a CopyFromReg from %GPR4 (stack pointer register). Chain and Glue; // to end of call in order to ensure it isn't broken up from the call; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Energy Efficiency,allocate,allocated,7,"// The allocated data lives above the 160 bytes allocated for the standard; // frame, plus any outgoing stack arguments. We don't know how much that; // amounts to yet, so emit a special ADJDYNALLOC placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Energy Efficiency,allocate,allocated,48,"// The allocated data lives above the 160 bytes allocated for the standard; // frame, plus any outgoing stack arguments. We don't know how much that; // amounts to yet, so emit a special ADJDYNALLOC placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:174,Performance,perform,performance,174,"// We use DSGF for 32-bit division. This means the first operand must; // always be 64-bit, and the second operand should be 32-bit whenever; // that is possible, to improve performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Availability,mask,masks,22,// Get the known-zero masks for each operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:91,Availability,mask,masks,91,// Check whether the high part is an AND that doesn't change the; // high 32 bits and just masks out low bits. We can skip it if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Availability,mask,mask,22,// Get the known-zero mask for the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:19,Performance,load,load,19,// Op is an atomic load. Lower it into a normal volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:57,Performance,load,load,57,// Op is an atomic load. Lower it into a normal volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,perform,performing,48,// We have to enforce sequential consistency by performing a; // serialization operation after the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Extend,Extend,3,"// Extend the source operand to 32 bits and prepare it for the inner loop.; // ATOMIC_SWAPW uses RISBG to rotate the field left, but all other; // operations require the source to be shifted in advance. (This shift; // can be folded if the source is constant.) For AND and NAND, the lower; // bits must be set, while for other opcodes they should be left clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:355,Usability,clear,clear,355,"// Extend the source operand to 32 bits and prepare it for the inner loop.; // ATOMIC_SWAPW uses RISBG to rotate the field left, but all other; // operations require the source to be shifted in advance. (This shift; // can be folded if the source is constant.) For AND and NAND, the lower; // bits must be set, while for other opcodes they should be left clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,Modifiability,extend,extend,34,// emitAtomicCmpSwapW() will zero extend the result (original value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:186,Deployability,update,updated,186,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:68,Performance,load,loads,68,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:238,Performance,load,loads,238,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:56,Performance,perform,perform,56,"// Says that SystemZISD operation Opcode can be used to perform the equivalent; // of a VPERM with permute vector Bytes. If Opcode takes three operands,; // Operand is the constant third operand, otherwise it is the number of; // bytes in each element of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Availability,mask,mask,15,"// Convert the mask of the given shuffle op into a byte-level mask,; // as if it had type vNi8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,Availability,mask,mask,62,"// Convert the mask of the given shuffle op into a byte-level mask,; // as if it had type vNi8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:114,Performance,perform,performed,114,"// Bytes is a VPERM-like permute vector, except that -1 is used for; // undefined bytes. Return true if it can be performed using VSLDB.; // When returning true, set StartIndex to the shift amount and OpNo0; // and OpNo1 to the VPERM operands that should be used as the first; // and second shift operand respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Performance,perform,performs,22,"// Create a node that performs P on operands Op0 and Op1, casting the; // operands to the appropriate type. The type of the result is determined by P.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,Availability,mask,mask,34,"// If the first byte is zero, use mask as first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:6,Availability,mask,mask,6,"// If mask contains a zero, use it by placing that vector first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:414,Modifiability,extend,extended,414,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:449,Performance,optimiz,optimized,449,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:251,Safety,Abort,Aborts,251,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:12,Availability,mask,mask,12,// Create a mask for just these two operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,Safety,avoid,avoid,54,// See if it would be better to reorganize NewMask to avoid using VPERM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Energy Efficiency,reduce,reduces,44,"// Only do this if removing the zero vector reduces the depth, otherwise; // the critical path will increase with the final unpack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend GPR scalars Op0 and Op1 to doublewords and return a v2i64; // vector for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:87,Safety,avoid,avoid,87,"// If one of the two inputs is undefined then replicate the other one,; // in order to avoid using another register unnecessarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:74,Performance,load,loaded,74,"// There are three cases here:; //; // - if the only defined element is a loaded one, the best sequence; // is a replicating load.; //; // - otherwise, if the only defined element is an i64 value, we will; // end up with the same VLVGP sequence regardless of whether we short-cut; // for replication or fall through to the later code.; //; // - otherwise, if the only defined element is an i32 or smaller value,; // we would need 2 instructions to replicate it: VLVGP followed by VREPx.; // This is only a win if the single defined element is used more than once.; // In other cases we're better off using a single VLVGx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:125,Performance,load,load,125,"// There are three cases here:; //; // - if the only defined element is a loaded one, the best sequence; // is a replicating load.; //; // - otherwise, if the only defined element is an i64 value, we will; // end up with the same VLVGP sequence regardless of whether we short-cut; // for replication or fall through to the later code.; //; // - otherwise, if the only defined element is an i32 or smaller value,; // we would need 2 instructions to replicate it: VLVGP followed by VREPx.; // This is only a win if the single defined element is used more than once.; // In other cases we're better off using a single VLVGx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Performance,load,loads,23,"// If all elements are loads, use VLREP/VLEs (below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid unnecessary undefs by reusing the other operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:91,Integrability,depend,dependency,91,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:200,Performance,load,load,200,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:237,Performance,load,load,237,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:77,Safety,avoid,avoid,77,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Performance,load,loading,16,// Fall back to loading it from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect SCALAR_TO_VECTOR conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:53,Availability,avail,available,53,// See whether the value we're splatting is directly available as a scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,Modifiability,variab,variable,13,// Check for variable splats.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:111,Availability,avail,available,111,"// See whether the shift vector is a splat represented as SHUFFLE_VECTOR,; // and the shift amount is directly available in a GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,perform,performing,48,// We have to enforce sequential consistency by performing a; // serialization operation after the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Usability,simpl,simplify,10,// Try to simplify an EXTRACT_VECTOR_ELT from a vector of type VecVT; // producing a result of type ResVT. Op is a possibly bitcast version; // of the input vector and Index is the index (based on type VecVT) that; // should be extracted. Return the new extraction if a simplification; // was possible or if Force is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:270,Usability,simpl,simplification,270,// Try to simplify an EXTRACT_VECTOR_ELT from a vector of type VecVT; // producing a result of type ResVT. Op is a possibly bitcast version; // of the input vector and Index is the index (based on type VecVT) that; // should be extracted. Return the new extraction if a simplification; // was possible or if Force is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Availability,mask,mask,28,// Get a VPERM-like permute mask and see whether the bytes covered; // by the extracted element are a contiguous sequence from one; // source operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Performance,optimiz,optimize,15,// We can only optimize this case if the BUILD_VECTOR elements are; // at least as wide as the extracted value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize vector operations in scalar value Op on the basis that Op; // is truncated to TruncVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:90,Performance,optimiz,optimize,90,"// Defer the creation of the bitcast from X to combineExtract,; // which might be able to optimize the extraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:19,Performance,load,load,19,// Replace an i128 load that is used solely to move its value into GPRs; // by separate loads of both halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:88,Performance,load,loads,88,// Replace an i128 load that is used solely to move its value into GPRs; // by separate loads of both halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each extraction as an independent load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Performance,load,load,45,// Rewrite each extraction as an independent load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Performance,load,load,22,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:174,Performance,load,load,174,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:308,Performance,load,loads,308,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:242,Safety,Avoid,Avoid,242,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update uses of the loaded Value while preserving old chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Performance,load,loaded,22,// Update uses of the loaded Value while preserving old chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the store with the new form of stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:194,Modifiability,extend,extend,194,"// Replicate a reg or immediate with VREP instead of scalar multiply or; // immediate load. It seems best to do this during the first DAGCombine as; // it is straight-forward to handle the zero-extend node in the initial; // DAG, and also not worry about the keeping the new MemVT legal (e.g. when; // extracting an i16 element from a v16i8 vector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:86,Performance,load,load,86,"// Replicate a reg or immediate with VREP instead of scalar multiply or; // immediate load. It seems best to do this during the first DAGCombine as; // it is straight-forward to handle the zero-extend node in the initial; // DAG, and also not worry about the keeping the new MemVT legal (e.g. when; // extracting an i16 element from a v16i8 vector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Modifiability,extend,extended,15,// Find a zero extended value and its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:25,Performance,LOAD,LOAD,25,// Combine element-swap (LOAD) into VLER,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:31,Performance,load,load,31,// Create the element-swapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:84,Performance,load,load,84,"// First, combine the VECTOR_SHUFFLE away. This makes the value produced; // by the load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Performance,load,load,21,"// Next, combine the load away, we give it a bogus result value but a real; // chain result. The result value is dead because the shuffle is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Usability,simpl,simplify,10,// Try to simplify a vector extraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:51,Safety,avoid,avoid,51,"// Insert an extension before type-legalization to avoid scalarization, e.g.:; // v2f64 = uint_to_fp v2i16; // =>; // v2f64 = uint_to_fp (v2i64 zero_extend v2i16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Performance,LOAD,LOAD,18,// Combine BSWAP (LOAD) into LRVH/LRV/LRVG/VLBR,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Performance,load,load,28,// Create the byte-swapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Performance,load,load,21,"// If this is an i16 load, insert the truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:75,Performance,load,load,75,"// First, combine the bswap away. This makes the value produced by the; // load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Performance,load,load,21,"// Next, combine the load away, we give it a bogus result value but a real; // chain result. The result value is dead because the bswap is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:64,Usability,simpl,simplifies,64,// Push BSWAP into a vector insertion if at least one side then simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,Usability,simpl,simplifies,62,// Push BSWAP into a vector shuffle if at least one side then simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:129,Availability,mask,masks,129,"// We have a SELECT_CCMASK or BR_CCMASK comparing the condition code; // set by the CCReg instruction using the CCValid / CCMask masks,; // If the CCReg instruction is itself a ICMP testing the condition; // code set by some other instruction, see whether we can directly; // use that condition code.; // Verify that we have an ICMP against some constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:182,Testability,test,testing,182,"// We have a SELECT_CCMASK or BR_CCMASK comparing the condition code; // set by the CCReg instruction using the CCValid / CCMask masks,; // If the CCReg instruction is itself a ICMP testing the condition; // code set by some other instruction, see whether we can directly; // use that condition code.; // Verify that we have an ICMP against some constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the case where CompareLHS is a SELECT_CCMASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Availability,mask,mask,38,// Verify that we have an appropriate mask for a EQ or NE comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Availability,mask,mask,28,// Compute the effective CC mask for the new branch or select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Deployability,update,updated,14,// Return the updated CCReg link.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the case where CompareRHS is (SRA (SHL (IPM))).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid introducing CC spills (because SRA would clobber CC).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Availability,mask,mask,28,// Compute the effective CC mask for the new branch or select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Deployability,update,updated,14,// Return the updated CCReg link.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,Availability,mask,masks,54,// Optimize away GET_CCMASK (SELECT_CCMASK) if the CC masks are compatible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away GET_CCMASK (SELECT_CCMASK) if the CC masks are compatible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Performance,LOAD,LOAD,10,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:100,Performance,load,load,100,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:84,Usability,simpl,simply,84,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Modifiability,extend,extends,17,// VECTOR UNPACK extends half the elements of the source vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL HIGH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL LOW,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Availability,mask,mask,45,"// Demand input element 0 or 1, given by the mask bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL HIGH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL LOW,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Modifiability,extend,extends,14,// VREPI sign extends the immedate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:9,Availability,down,down,9,// Round down to the stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:27,Deployability,update,update,27,// Should have kill-flag - update below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Modifiability,rewrite,rewrite,23,// Add this PHI to the rewrite table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:244,Availability,avail,available,244,"// Implement EmitInstrWithCustomInserter for pseudo CondStore* instruction MI.; // StoreOpcode is the store to use and Invert says whether the store should; // happen when the condition is false rather than true. If a STORE ON; // CONDITION is available, STOCOpcode is its opcode, otherwise it is 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:37,Performance,load,load,37,"// ISel pattern matching also adds a load memory operand of the same; // address, so take special care to find the storing memory operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:128,Performance,perform,performance,128,"// Use STOCOpcode if possible. We could use different store patterns in; // order to avoid matching the index register, but the performance trade-offs; // might be more complicated in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,Safety,avoid,avoid,85,"// Use STOCOpcode if possible. We could use different store patterns in; // order to avoid matching the index register, but the performance trade-offs; // might be more complicated in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:49,Testability,LOG,LOGICAL,49,"// StartMBB:; //; // Use VECTOR ELEMENT COMPARE [LOGICAL] to compare the high parts.; // Swap the inputs to get:; // CC 1 if high(Op0) > high(Op1); // CC 2 if high(Op0) < high(Op1); // CC 0 if high(Op0) == high(Op1); //; // If CC != 0, we'd done, so jump over the next instruction.; //; // VEC[L]G Op1, Op0; // JNE JoinMBB; // # fallthrough to HiEqMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:144,Integrability,depend,depend,144,"// HiEqMBB:; //; // Otherwise, use VECTOR COMPARE HIGH LOGICAL.; // Since we already know the high parts are equal, the CC; // result will only depend on the low parts:; // CC 1 if low(Op0) > low(Op1); // CC 3 if low(Op0) <= low(Op1); //; // VCHLGS Tmp, Op0, Op1; // # fallthrough to JoinMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:55,Testability,LOG,LOGICAL,55,"// HiEqMBB:; //; // Otherwise, use VECTOR COMPARE HIGH LOGICAL.; // Since we already know the high parts are equal, the CC; // result will only depend on the low parts:; // CC 1 if low(Op0) > low(Op1); // CC 3 if low(Op0) <= low(Op1); //; // VCHLGS Tmp, Op0, Op1; // # fallthrough to JoinMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:145,Performance,perform,performs,145,"// Implement EmitInstrWithCustomInserter for subword pseudo ATOMIC_LOADW_* or; // ATOMIC_SWAPW instruction MI. BinOpcode is the instruction that performs; // the binary operation elided by ""*"", or 0 for ATOMIC_SWAPW. Invert says; // whether the field should be inverted after performing BinOpcode (e.g. for; // NAND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:276,Performance,perform,performing,276,"// Implement EmitInstrWithCustomInserter for subword pseudo ATOMIC_LOADW_* or; // ATOMIC_SWAPW instruction MI. BinOpcode is the instruction that performs; // the binary operation elided by ""*"", or 0 for ATOMIC_SWAPW. Invert says; // whether the field should be inverted after performing BinOpcode (e.g. for; // NAND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the operation normally and then invert every bit of the field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:5,Usability,simpl,simply,5,// A simply binary operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:270,Availability,mask,mask,270,"// Implement EmitInstrWithCustomInserter for subword pseudo; // ATOMIC_LOADW_{,U}{MIN,MAX} instruction MI. CompareOpcode is the; // instruction that should be used to compare the current field with the; // minimum or maximum value. KeepOldMask is the BRC condition-code mask; // for when the current field should be kept.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:63,Deployability,Update,UpdateMBB,63,"// LoopMBB:; // %OldVal = phi [ %OrigVal, StartMBB ], [ %Dest, UpdateMBB ]; // %RotatedOldVal = RLL %OldVal, 0(%BitShift); // CompareOpcode %RotatedOldVal, %Src2; // BRC KeepOldMask, UpdateMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:183,Deployability,Update,UpdateMBB,183,"// LoopMBB:; // %OldVal = phi [ %OrigVal, StartMBB ], [ %Dest, UpdateMBB ]; // %RotatedOldVal = RLL %OldVal, 0(%BitShift); // CompareOpcode %RotatedOldVal, %Src2; // BRC KeepOldMask, UpdateMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:106,Deployability,Update,UpdateMBB,106,"// UseAltMBB:; // %RotatedAltVal = RISBG %RotatedOldVal, %Src2, 32, 31 + BitSize, 0; // # fall through to UpdateMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,UpdateMBB,3,"// UpdateMBB:; // %RotatedNewVal = PHI [ %RotatedOldVal, LoopMBB ],; // [ %RotatedAltVal, UseAltMBB ]; // %NewVal = RLL %RotatedNewVal, 0(%NegBitShift); // %Dest = CS %OldVal, %NewVal, Disp(%Base); // JNE LoopMBB; // # fall through to DoneMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:415,Performance,load,loaded,415,"// LoopMBB:; // %OldVal = phi [ %OrigOldVal, EntryBB ], [ %RetryOldVal, SetMBB ]; // %SwapVal = phi [ %OrigSwapVal, EntryBB ], [ %RetrySwapVal, SetMBB ]; // %OldValRot = RLL %OldVal, BitSize(%BitShift); // ^^ The low BitSize bits contain the field; // of interest.; // %RetrySwapVal = RISBG32 %SwapVal, %OldValRot, 32, 63-BitSize, 0; // ^^ Replace the upper 32-BitSize bits of the; // swap value with those that we loaded and rotated.; // %Dest = LL[CH] %OldValRot; // CR %Dest, %CmpVal; // JNE DoneMBB; // # Fall through to SetMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Usability,Clear,ClearEven,45,"// Emit an extension from a GR64 to a GR128. ClearEven is true; // if the high register of the GR128 value must be cleared or false if; // it's ""don't care"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:115,Usability,clear,cleared,115,"// Emit an extension from a GR64 to a GR128. ClearEven is true; // if the high register of the GR128 value must be cleared or false if; // it's ""don't care"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:353,Performance,optimiz,optimize,353,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:426,Safety,avoid,avoid,426,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:446,Safety,predict,prediction,446,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:27,Usability,clear,clear,27,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:71,Performance,perform,performs,71,// Decompose string pseudo-instruction MI into a loop that continually performs; // Opcode until CC != 3.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:287,Performance,load,load,287,"// LoopMBB:; // %This1Reg = phi [ %Start1Reg, StartMBB ], [ %End1Reg, LoopMBB ]; // %This2Reg = phi [ %Start2Reg, StartMBB ], [ %End2Reg, LoopMBB ]; // R0L = %CharReg; // %End1Reg, %End2Reg = CLST %This1Reg, %This2Reg -- uses R0L; // JO LoopMBB; // # fall through to DoneMBB; //; // The load of R0L can be hoisted by post-RA LICM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update TBEGIN instruction with final opcode and register clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:32,Performance,load,load-and-test,32,// Replace pseudo with a normal load-and-test that models the def as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:41,Testability,test,test,41,// Replace pseudo with a normal load-and-test that models the def as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Energy Efficiency,Allocate,Allocate,16,// LoopBodyMBB: Allocate and probe by means of a volatile compare.; // J LoopTestMBB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:33,Energy Efficiency,schedul,schedulers,33,"// This is only used by the isel schedulers, and is needed only to prevent; // compiler from crashing when list-ilp is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:53,Integrability,interface,interface,53,"//===-- SystemZISelLowering.h - SystemZ DAG lowering interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SystemZ uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- SystemZISelLowering.h - SystemZ DAG lowering interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SystemZ uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Integrability,Wrap,Wraps,3,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:46,Performance,load,loaded,46,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:75,Security,access,accesses,75,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:14,Availability,mask,mask,14,// Test under mask. The first operand is ANDed with the second operand; // and the condition codes are set on the result. The third operand is; // a boolean that is true if the condition codes need to distinguish; // between CCMASK_TM_MIXED_MSB_0 and CCMASK_TM_MIXED_MSB_1 (which the; // register forms do but the memory forms don't).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Testability,Test,Test,3,// Test under mask. The first operand is ANDed with the second operand; // and the condition codes are set on the result. The third operand is; // a boolean that is true if the condition codes need to distinguish; // between CCMASK_TM_MIXED_MSB_0 and CCMASK_TM_MIXED_MSB_1 (which the; // register forms do but the memory forms don't).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:110,Availability,mask,mask,110,"// Branches if a condition is true. Operand 0 is the chain operand;; // operand 1 is the 4-bit condition-code mask, with bit N in; // big-endian order meaning ""branch if CC=N""; operand 2 is the; // target block and operand 3 is the flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:65,Availability,mask,mask,65,// Selects between operand 0 and operand 1. Operand 2 is the; // mask of condition-code values for which operand 0 should be; // chosen over operand 1; it has the same form as BR_CCMASK.; // Operand 3 is the flag operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:82,Performance,perform,performed,82,"// For allocating stack space when using stack clash protector.; // Allocation is performed by block, and each block is probed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Integrability,Wrap,Wrappers,3,"// Wrappers around the ISD opcodes of the same name. The output is GR128.; // Input operands may be GR64 or GR32, depending on the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:114,Integrability,depend,depending,114,"// Wrappers around the ISD opcodes of the same name. The output is GR128.; // Input operands may be GR64 or GR32, depending on the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:80,Availability,mask,mask,80,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:168,Availability,mask,mask,168,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:281,Performance,optimiz,optimized,281,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:27,Testability,log,logic,27,"// Similar to MVC, but for logic operations (AND, OR, XOR).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:215,Availability,failure,failure,215,"// Use an SRST-based sequence to search a block of memory. The first; // operand is the end address, the second is the start, and the third; // is the character to search for. CC is set to 1 on success and 2; // on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:72,Availability,mask,mask,72,// Create a vector constant by replicating an element-sized RISBG-style mask.; // The first operand specifies the starting set bit and the second operand; // specifies the ending set bit. Both operands count from the MSB of the; // element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:189,Availability,mask,mask,189,"// Perform a general vector permute on vector operands 0 and 1.; // Each byte of operand 2 controls the corresponding byte of the result,; // in the same way as a byte-level VECTOR_SHUFFLE mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Performance,Perform,Perform,3,"// Perform a general vector permute on vector operands 0 and 1.; // Each byte of operand 2 controls the corresponding byte of the result,; // in the same way as a byte-level VECTOR_SHUFFLE mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:94,Modifiability,extend,extends,94,// Unpack the first half of vector operand 0 into double-sized elements.; // UNPACK_HIGH sign-extends and UNPACKL_HIGH zero-extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:124,Modifiability,extend,extends,124,// Unpack the first half of vector operand 0 into double-sized elements.; // UNPACK_HIGH sign-extends and UNPACKL_HIGH zero-extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Testability,Test,Test,3,// Test floating-point data class for vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Modifiability,Extend,Extend,3,// Extend the even f32 elements of vector operand 0 to produce a vector; // of f64 elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:80,Availability,mask,mask,80,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Testability,Test,Test,3,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:52,Testability,test,test,52,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:29,Integrability,Wrap,Wraps,29,// z/OS XPLINK ADA Entry; // Wraps a TargetGlobalAddress that should be loaded from a function's; // AssociatedData Area (ADA). Tha ADA is passed to the function by the; // caller in the XPLink ABI defined register R5.; // Operand 0: the GlobalValue/External Symbol; // Operand 1: the ADA register; // Operand 2: the offset (0 for the first and 8 for the second element in the; // function descriptor),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:72,Performance,load,loaded,72,// z/OS XPLINK ADA Entry; // Wraps a TargetGlobalAddress that should be loaded from a function's; // AssociatedData Area (ADA). Tha ADA is passed to the function by the; // caller in the XPLink ABI defined register R5.; // Operand 0: the GlobalValue/External Symbol; // Operand 1: the ADA register; // Operand 2: the offset (0 for the first and 8 for the second element in the; // function descriptor),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Integrability,Wrap,Wrappers,3,"// Wrappers around the inner loop of an 8- or 16-bit ATOMIC_SWAP or; // ATOMIC_LOAD_<op>.; //; // Operand 0: the address of the containing 32-bit-aligned field; // Operand 1: the second operand of <op>, in the high bits of an i32; // for everything except ATOMIC_SWAPW; // Operand 2: how many bits to rotate the i32 left to bring the first; // operand into the high bits; // Operand 3: the negative of operand 2, for rotating the other way; // Operand 4: the width of the field in bits (8 or 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:5,Integrability,wrap,wrapper,5,"// A wrapper around the inner loop of an ATOMIC_CMP_SWAP.; //; // Operand 0: the address of the containing 32-bit-aligned field; // Operand 1: the compare value, in the low bits of an i32; // Operand 2: the swap value, in the low bits of an i32; // Operand 3: how many bits to rotate the i32 left to bring the first; // operand into the high bits; // Operand 4: the negative of operand 2, for rotating the other way; // Operand 5: the width of the field in bits (8 or 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:18,Performance,load,load,18,"// 128-bit atomic load.; // Val, OUTCHAIN = ATOMIC_LOAD_128(INCHAIN, ptr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:17,Performance,load,load,17,// Byte swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:54,Performance,load,load,54,// Byte swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:20,Performance,load,load,20,// Element swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:57,Performance,load,load,57,// Element swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:111,Performance,load,load,111,// Prefetch from the second operand using the 4-bit control code in; // the first operand. The code is 1 for a load prefetch and 2 for; // a store prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:364,Energy Efficiency,efficient,efficient,364,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:288,Modifiability,extend,extend,288,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:298,Performance,load,load,298,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:47,Performance,load,loading,47,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:45,Availability,Mask,Mask,45,/// Determine which of the bits specified in Mask are known to be either; /// zero or one and return them in the KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:441,Modifiability,variab,variables,441,"//===-- SystemZLDCleanup.cpp - Clean up local-dynamic TLS accesses --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines multiple accesses to local-dynamic TLS variables so that; // the TLS base address for the module is only fetched once per execution path; // through the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:58,Security,access,accesses,58,"//===-- SystemZLDCleanup.cpp - Clean up local-dynamic TLS accesses --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines multiple accesses to local-dynamic TLS variables so that; // the TLS base address for the module is only fetched once per execution path; // through the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:411,Security,access,accesses,411,"//===-- SystemZLDCleanup.cpp - Clean up local-dynamic TLS accesses --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines multiple accesses to local-dynamic TLS variables so that; // the TLS base address for the module is only fetched once per execution path; // through the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:20,Security,access,accesses,20,// No point folding accesses if there isn't at least two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:674,Usability,simpl,simple,674,"//===-- SystemZLongBranch.cpp - Branch lengthening for SystemZ ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass makes sure that all branches are in range. There are several ways; // in which this could be done. One aggressive approach is to assume that all; // branches are in range and successively replace those that turn out not; // to be in range with a longer form (branch relaxation). A simple; // implementation is to continually walk through the function relaxing; // branches until no more changes are needed and a fixed point is reached.; // However, in the pathological worst case, this implementation is; // quadratic in the number of blocks; relaxing branch N can make branch N-1; // go out of range, which in turn can make branch N-2 go out of range,; // and so on.; //; // An alternative approach is to assume that all branches must be; // converted to their long forms, then reinstate the short forms of; // branches that, even under this pessimistic assumption, turn out to be; // in range (branch shortening). This too can be implemented as a function; // walk that is repeated until a fixed point is reached. In general,; // the result of shortening is not as good as that of relaxation, and; // shortening is also quadratic in the worst case; shortening branch N; // can bring branch N-1 in range of the short form, which in turn can do; // the same for branch N-2, and so on. The main advantage of shortening; // is that each walk through the function produces valid code, so it is; // possible to stop at any point after the first walk. The quadraticness; // could therefore be handled with a maximum pass count, although the; // question then becomes: what maximum count should be used?; //; // On",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:58,Deployability,Update,Update,58,// Position describes the state immediately before Block. Update Block; // accordingly and move Position to the end of the block's non-terminator; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:67,Deployability,Update,Update,67,// Position describes the state immediately before Terminator.; // Update Terminator accordingly and move Position past it.; // Assume that Terminator will be relaxed if AssumeRelaxed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:35,Security,access,access,35,"// Record the alignment, for quick access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineFunctionInfo.h:50,Modifiability,variab,variable,50,// Get and set the number of fixed (as opposed to variable) arguments; // that are passed in GPRs to this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:581,Availability,Avail,Available,581,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:43,Energy Efficiency,Schedul,Scheduler,43,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:418,Energy Efficiency,schedul,scheduling,418,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:497,Energy Efficiency,schedul,scheduling,497,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:728,Energy Efficiency,Schedul,Scheduler,728,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:53,Integrability,Interface,Interface,53,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:652,Performance,optimiz,optimize,652,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:821,Usability,learn,learn,821,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:74,Energy Efficiency,schedul,scheduler,74,// Try to find a single predecessor that would be interesting for the; // scheduler in the top-most region of MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:13,Safety,Hazard,HazardRec,13,"/// Create a HazardRec for MBB, save it in SchedStates and set HazardRec to; /// point to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:63,Safety,Hazard,HazardRec,63,"/// Create a HazardRec for MBB, save it in SchedStates and set HazardRec to; /// point to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:76,Energy Efficiency,schedul,scheduled,76,"// Try to take over the state from a single predecessor, if it has been; // scheduled. If this is not possible, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:73,Safety,predict,prediction,73,"// Emit incoming terminator(s). Be optimistic and assume that branch; // prediction will generally do ""the right thing"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:80,Integrability,depend,dependent,80,// Advance to first terminator. The successor block will handle terminators; // dependent on CFG layout (T/NT branch etc).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:10,Safety,hazard,hazard,10,// Delete hazard recognizers kept around for each MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:25,Energy Efficiency,schedul,schedule,25,// Pick the next node to schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:23,Availability,down,down,23,// Only scheduling top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:8,Energy Efficiency,schedul,scheduling,8,// Only scheduling top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:61,Availability,Avail,Available,61,// All nodes that are possible to schedule are stored in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:34,Energy Efficiency,schedul,schedule,34,// All nodes that are possible to schedule are stored in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:171,Energy Efficiency,schedul,schedule,171,"// Check the grouping cost. For a node that must begin / end a; // group, it is positive if it would do so prematurely, or negative; // if it would fit naturally into the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:18,Availability,Avail,Available,18,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:36,Deployability,update,update,36,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:43,Safety,Hazard,HazardRec,43,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:31,Availability,Avail,Available,31,// Put all released SUs in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:11,Deployability,release,released,11,// Put all released SUs in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:581,Availability,Avail,Available,581,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:42,Energy Efficiency,Schedul,Scheduler,42,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:418,Energy Efficiency,schedul,scheduling,418,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:497,Energy Efficiency,schedul,scheduling,497,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:728,Energy Efficiency,Schedul,Scheduler,728,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:52,Integrability,Interface,Interface,52,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:652,Performance,optimiz,optimize,652,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:821,Usability,learn,learn,821,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:62,Energy Efficiency,schedul,scheduling,62,/// A MachineSchedStrategy implementation for SystemZ post RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:79,Energy Efficiency,schedul,scheduled,79,"// A SchedModel is needed before any DAG is built while advancing past; // non-scheduled instructions, so it would not always be possible to call; // DAG->getSchedClass(SU).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:20,Availability,Avail,Available,20,// A sorter for the Available set that makes sure that SUs are considered; // in the best order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:15,Availability,avail,available,15,/// The set of available SUs to schedule next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:32,Energy Efficiency,schedul,schedule,32,/// The set of available SUs to schedule next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:60,Energy Efficiency,schedul,scheduler,60,"/// Maintain hazard recognizers for all blocks, so that the scheduler state; /// can be maintained past BB boundaries when appropariate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:13,Safety,hazard,hazard,13,"/// Maintain hazard recognizers for all blocks, so that the scheduler state; /// can be maintained past BB boundaries when appropariate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:52,Energy Efficiency,schedul,scheduler,52,/// Pointer to the HazardRecognizer that tracks the scheduler state for; /// the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:19,Safety,Hazard,HazardRecognizer,19,/// Pointer to the HazardRecognizer that tracks the scheduler state for; /// the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:4,Deployability,Update,Update,4,"/// Update the scheduler state by emitting (non-scheduled) instructions; /// up to, but not including, NextBegin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:15,Energy Efficiency,schedul,scheduler,15,"/// Update the scheduler state by emitting (non-scheduled) instructions; /// up to, but not including, NextBegin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:48,Energy Efficiency,schedul,scheduled,48,"/// Update the scheduler state by emitting (non-scheduled) instructions; /// up to, but not including, NextBegin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:31,Energy Efficiency,schedul,scheduling,31,/// Called for a region before scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:11,Energy Efficiency,schedul,scheduling,11,/// PostRA scheduling does not track pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:34,Availability,down,down,34,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:11,Energy Efficiency,schedul,scheduling,11,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:47,Energy Efficiency,schedul,scheduler,47,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:93,Energy Efficiency,schedul,scheduling,93,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:26,Energy Efficiency,schedul,schedule,26,"/// Pick the next node to schedule, or return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:4,Energy Efficiency,Schedul,ScheduleDAGMI,4,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:22,Energy Efficiency,schedul,scheduled,22,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:54,Safety,Hazard,HazardRec,54,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:71,Availability,Avail,Available,71,/// SU has had all predecessor dependencies resolved. Put it into; /// Available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:31,Integrability,depend,dependencies,31,/// SU has had all predecessor dependencies resolved. Put it into; /// Available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:34,Availability,down,down,34,"/// Currently only scheduling top-down, so this method is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:19,Energy Efficiency,schedul,scheduling,19,"/// Currently only scheduling top-down, so this method is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:36,Modifiability,Rewrite,Rewrite,36,/// Returns an instance of the Post Rewrite pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:11,Performance,load,load-register-on-condition,11,"// MI is a load-register-on-condition pseudo instruction. Replace it with; // LowOpcode if source and destination are both low GR32s and HighOpcode if; // source and destination are both high GR32s. Otherwise, a branch sequence; // is created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:80,Usability,simpl,simplify,80,"// If sources and destination aren't all high or all low, we may be able to; // simplify the operation by moving one of the sources to the destination; // first. But only if this doesn't clobber the other source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:13,Usability,simpl,simplification,13,"// Given the simplification above, we must already have a two-operand case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:42,Performance,perform,performs,42,// Replace MBBI by a branch sequence that performs a conditional move of; // operand 2 to the destination register. Operand 1 is expected to be the; // same register as the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:49,Availability,avail,available,49,"// Return true to make these hints the only regs available to; // RA. This may mean extra spilling but since the alternative is; // a jump sequence expansion of the LOCRMux, it is preferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:89,Performance,load,load,89,// Create an anchor point that is in range. Start at 0xffff so that; // can use LLILH to load the immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:3,Performance,Load,Load,3,// Load the offset into the scratch register and use it as an index.; // The scratch register then dies here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:3,Performance,Load,Load,3,// Load the anchor address into a scratch register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:3,Performance,Load,Load,3,// Load the high offset into the scratch register and use it as; // an index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:29,Safety,safe,safe,29,// Check if coalescing seems safe by finding the set of clobbered physreg; // pairs in the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h:17,Availability,mask,mask,17,/// \returns the mask of all the call preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:3,Modifiability,Variab,Variable,3,// Variable length,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:32,Modifiability,variab,variable,32,// Handle the special case of a variable length memset of 0 with XC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:224,Usability,clear,clears,224,"// Convert the current CC value into an integer that is 0 if CC == 0,; // greater than zero if CC == 1 and less than zero if CC >= 2.; // The sequence starts with IPM, which puts CC into bits 29 and 28; // of an integer and clears bits 30 and 31.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:36,Integrability,depend,depending,36,"// Now select between End and null, depending on whether the character; // was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:6,Performance,load,loads,6,// MI loads one word of a GPR using an IIxF instruction and LLIxL and LLIxH; // are the halfword immediate loads for the same word. Try to use one of them; // instead of IIxF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:107,Performance,load,loads,107,// MI loads one word of a GPR using an IIxF instruction and LLIxL and LLIxH; // are the halfword immediate loads for the same word. Try to use one of them; // instead of IIxF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:23,Usability,clear,clear,23,"// The new opcode will clear the other half of the GR64 reg, so; // cancel if that is live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:59,Integrability,depend,dependencies,59,// For z13 we prefer LDE over LE to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:36,Safety,avoid,avoid,36,// For z13 we prefer LDE over LE to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:9,Modifiability,variab,variable,9,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:56,Modifiability,variab,variable,56,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:171,Modifiability,variab,variable,171,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:223,Modifiability,variab,variable,223,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:9,Availability,Avail,AvailableExternallyLinkage,9,// check AvailableExternallyLinkage here as getKindForGlobal() asserts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:63,Testability,assert,asserts,63,// check AvailableExternallyLinkage here as getKindForGlobal() asserts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:7,Modifiability,variab,variable,7,// R/O variable with multiple of 2 byte alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:11,Security,access,accesses,11,// PC32DBL accesses require the low bit to be clear.; //; // FIXME: Explicitly check for functions: the datalayout is currently; // missing information about function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:46,Usability,clear,clear,46,// PC32DBL accesses require the low bit to be clear.; //; // FIXME: Explicitly check for functions: the datalayout is currently; // missing information about function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:169,Safety,detect,detect,169,"// For Medium and above, assume that the symbol is not within the 4GB range.; // Taking the address of locally-defined text would be OK, but that; // case isn't easy to detect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:127,Energy Efficiency,schedul,scheduler,127,"// True if the subtarget should run MachineScheduler after aggressive; // coalescing. This currently replaces the SelectionDAG scheduler with the; // ""source"" order scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:165,Energy Efficiency,schedul,scheduler,165,"// True if the subtarget should run MachineScheduler after aggressive; // coalescing. This currently replaces the SelectionDAG scheduler with the; // ""source"" order scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:28,Security,access,accessed,28,// Return true if GV can be accessed using LARL for reloc model RM; // and code model CM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:172,Modifiability,variab,variables,172,"// Make sure that global data has at least 16 bits of alignment by; // default, so that we can refer to it using LARL. We don't have any; // special requirements for stack variables though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:106,Testability,stub,stub,106,"// For SystemZ we define the models as follows:; //; // Small: BRASL can call any function and will use a stub if necessary.; // Locally-binding symbols will always be in range of LARL.; //; // Medium: BRASL can call any function and will use a stub if necessary.; // GOT slots and locally-defined text will always be in range; // of LARL, but other symbols might not be.; //; // Large: Equivalent to Medium for now.; //; // Kernel: Equivalent to Medium for now.; //; // This means that any PIC module smaller than 4GB meets the; // requirements of Small, so Small seems like the best default there.; //; // All symbols bind locally in a non-PIC module, so the choice is less; // obvious. There are two cases:; //; // - When creating an executable, PLTs and copy relocations allow; // us to treat external symbols as part of the executable.; // Any executable smaller than 4GB meets the requirements of Small,; // so that seems like the best default.; //; // - When creating JIT code, stubs will be in range of BRASL if the; // image is less than 4GB in size. GOT entries will likewise be; // in range of LARL. However, the JIT environment has no equivalent; // of copy relocs, so locally-binding data symbols might not be in; // the range of LARL. We need the Medium model in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:245,Testability,stub,stub,245,"// For SystemZ we define the models as follows:; //; // Small: BRASL can call any function and will use a stub if necessary.; // Locally-binding symbols will always be in range of LARL.; //; // Medium: BRASL can call any function and will use a stub if necessary.; // GOT slots and locally-defined text will always be in range; // of LARL, but other symbols might not be.; //; // Large: Equivalent to Medium for now.; //; // Kernel: Equivalent to Medium for now.; //; // This means that any PIC module smaller than 4GB meets the; // requirements of Small, so Small seems like the best default there.; //; // All symbols bind locally in a non-PIC module, so the choice is less; // obvious. There are two cases:; //; // - When creating an executable, PLTs and copy relocations allow; // us to treat external symbols as part of the executable.; // Any executable smaller than 4GB meets the requirements of Small,; // so that seems like the best default.; //; // - When creating JIT code, stubs will be in range of BRASL if the; // image is less than 4GB in size. GOT entries will likewise be; // in range of LARL. However, the JIT environment has no equivalent; // of copy relocs, so locally-binding data symbols might not be in; // the range of LARL. We need the Medium model in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:985,Testability,stub,stubs,985,"// For SystemZ we define the models as follows:; //; // Small: BRASL can call any function and will use a stub if necessary.; // Locally-binding symbols will always be in range of LARL.; //; // Medium: BRASL can call any function and will use a stub if necessary.; // GOT slots and locally-defined text will always be in range; // of LARL, but other symbols might not be.; //; // Large: Equivalent to Medium for now.; //; // Kernel: Equivalent to Medium for now.; //; // This means that any PIC module smaller than 4GB meets the; // requirements of Small, so Small seems like the best default there.; //; // All symbols bind locally in a non-PIC module, so the choice is less; // obvious. There are two cases:; //; // - When creating an executable, PLTs and copy relocations allow; // us to treat external symbols as part of the executable.; // Any executable smaller than 4GB meets the requirements of Small,; // so that seems like the best default.; //; // - When creating JIT code, stubs will be in range of BRASL if the; // image is less than 4GB in size. GOT entries will likewise be; // in range of LARL. However, the JIT environment has no equivalent; // of copy relocs, so locally-binding data symbols might not be in; // the range of LARL. We need the Medium model in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
