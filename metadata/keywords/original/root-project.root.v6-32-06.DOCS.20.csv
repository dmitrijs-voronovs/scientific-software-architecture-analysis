id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846019,Availability,mask,mask,846019," load instruction followed by a 'select' between the loaded and the passthru values, predicated on the same mask. However, using this intrinsic prevents exceptions on memory access to masked-off lanes. ::. %res = call <16 x float> @llvm.masked.load.v16f32.p0(ptr %ptr, i32 4, <16 x i1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846083,Availability,mask,masked,846083," passthru values, predicated on the same mask. However, using this intrinsic prevents exceptions on memory access to masked-off lanes. ::. %res = call <16 x float> @llvm.masked.load.v16f32.p0(ptr %ptr, i32 4, <16 x i1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846162,Availability,mask,mask,846162,"wever, using this intrinsic prevents exceptions on memory access to masked-off lanes. ::. %res = call <16 x float> @llvm.masked.load.v16f32.p0(ptr %ptr, i32 4, <16 x i1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic diffe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846244,Availability,mask,mask,846244," ::. %res = call <16 x float> @llvm.masked.load.v16f32.p0(ptr %ptr, i32 4, <16 x i1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar stor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846254,Availability,mask,mask,846254,"1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store se",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846339,Availability,mask,masked-off,846339,"1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store se",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846686,Availability,mask,mask,846686,"verloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846740,Availability,mask,mask,846740," floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846849,Availability,mask,masked,846849,"8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; ----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:847011,Availability,mask,masked,847011," ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:847396,Availability,mask,masked-off,847396,"ments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no me",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:847434,Availability,mask,masked,847434,"emory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:847506,Availability,mask,mask,847506,"for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:847705,Availability,mask,mask,847705,"eger value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848160,Availability,mask,mask,848160,"ches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848406,Availability,mask,masked,848406,"nes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The mas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848688,Availability,mask,masked,848688,"ct <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848762,Availability,mask,mask,848762," float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848822,Availability,mask,masked,848822,"atter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848905,Availability,mask,mask,848905,"intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848962,Availability,mask,masked,848962,"imilar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849031,Availability,mask,mask,849031,"_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849290,Availability,mask,mask,849290,"emory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849300,Availability,mask,mask,849300,"are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks wit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849385,Availability,mask,masked-off,849385,"are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks wit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849407,Availability,mask,masked-off,849407,"^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849757,Availability,mask,mask,849757,">); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x do",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849906,Availability,mask,masked-off,849906,"t>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:850103,Availability,mask,masked,850103,"m arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:850295,Availability,mask,masked,850295,"it for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:850664,Availability,mask,mask,850664," constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overload",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:850803,Availability,mask,masked,850803," number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:850949,Availability,mask,mask,850949,"or types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:851604,Availability,mask,masked,851604,"nt gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks. ::. %res = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> poison). ;; The gather with all-true mask is equivalent to the following instruction sequence; %ptr0 = extractelement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852018,Availability,mask,masked,852018,"telement <4 x ptr> %ptrs, i32 0; %ptr1 = extractelement <4 x ptr> %ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852109,Availability,mask,mask,852109,"%ptrs, i32 1; %ptr2 = extractelement <4 x ptr> %ptrs, i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852136,Availability,mask,masked,852136,", i32 2; %ptr3 = extractelement <4 x ptr> %ptrs, i32 3. %val0 = load double, ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852246,Availability,mask,mask,852246," ptr %ptr0, align 8; %val1 = load double, ptr %ptr1, align 8; %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""".",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852273,Availability,mask,masked,852273," %val2 = load double, ptr %ptr2, align 8; %val3 = load double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for wri",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852363,Availability,mask,mask,852363,"double, ptr %ptr3, align 8. %vec0 = insertelement <4 x double> poison, %val0, 0; %vec01 = insertelement <4 x double> %vec0, %val1, 1; %vec012 = insertelement <4 x double> %vec01, %val2, 2; %vec0123 = insertelement <4 x double> %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addre",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852576,Availability,mask,mask,852576," %vec012, %val3, 3. .. _int_mscatter:. '``llvm.masked.scatter.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852586,Availability,mask,mask,852586,"; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for exa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:852671,Availability,mask,masked-off,852671,"; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element. ::. declare void @llvm.masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for exa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853066,Availability,mask,mask,853066," <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853120,Availability,mask,mask,853120,"ter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853229,Availability,mask,masked,853229,">, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853422,Availability,mask,mask,853422,"ch element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853489,Availability,mask,masked,853489," as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853812,Availability,mask,masked,853812,"s, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effecti",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:854692,Availability,mask,mask,854692,"::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location pr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:854927,Availability,mask,mask,854927,"al0 = extractelement <8 x i32> %value, i32 0; %val1 = extractelement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855020,Availability,mask,masked,855020,"telement <8 x i32> %value, i32 1; ..; %val7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855062,Availability,mask,masked,855062,"7 = extractelement <8 x i32> %value, i32 7; %ptr0 = extractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001',",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855117,Availability,mask,masked,855117,"ractelement <8 x ptr> %ptrs, i32 0; %ptr1 = extractelement <8 x ptr> %ptrs, i32 1; ..; %ptr7 = extractelement <8 x ptr> %ptrs, i32 7; ;; Note: the order of the following stores is important when they overlap:; store i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855412,Availability,mask,mask,855412,"tore i32 %val0, ptr %ptr0, align 4; store i32 %val1, ptr %ptr1, align 4; ..; store i32 %val7, ptr %ptr7, align 4. Masked Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855449,Availability,mask,masked,855449,"Vector Expanding Load and Compressing Store Intrinsics; -------------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855497,Availability,mask,mask,855497,"-----------------------------------------------------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855554,Availability,mask,masked,855554,"------------. LLVM provides intrinsics for expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855600,Availability,mask,mask,855600,"expanding load and compressing store operations. Data selected from a vector according to a mask is stored in consecutive memory addresses (compressed store), and vice-versa (expanding load). These operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855777,Availability,mask,mask,855777,"hese operations effective map to ""if (cond.i) a[j++] = v.i"" and ""if (cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is des",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:855901,Availability,mask,mask,855901,"cond.i) v.i = a[j++]"" patterns, respectively. Note that when the mask starts with '1' bits followed by '0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addres",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:856021,Availability,mask,mask,856021,"0' bits, these operations are identical to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load <int_mload>`. .. _int_expandload:. '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding load",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:856040,Availability,mask,mask,856040,". '``llvm.masked.expandload.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:856188,Availability,mask,masked-off,856188,"intrinsic. Several values of integer, floating point or pointer data type are loaded from consecutive memory addresses and stored into the elements of a vector according to the mask. ::. declare <16 x float> @llvm.masked.expandload.v16f32 (ptr <ptr>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++]",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:856455,Availability,mask,mask,856455,"6 x i1> <mask>, <16 x float> <passthru>); declare <2 x i64> @llvm.masked.expandload.v2i64 (ptr <ptr>, <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1>",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:856603,Availability,mask,masked-off,856603,", <2 x i1> <mask>, <2 x i64> <passthru>). Overview:; """""""""""""""""". Reads a number of scalar values sequentially from memory location provided in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x do",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:856757,Availability,mask,masked,856757,"a vector. The '``mask``' holds a bit for each vector lane. The number of elements read from memory is equal to the number of '1' bits in the mask. The loaded elements are positioned in the destination vector according to the sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1>",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:857446,Availability,mask,masked,857446,"rand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:857560,Availability,mask,masked,857560,"-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858060,Availability,mask,mask,858060,"from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858189,Availability,mask,masked,858189,"size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from whi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858478,Availability,mask,mask,858478,"uble> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector element",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858557,Availability,mask,masked,858557,"masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compresssto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858625,Availability,mask,mask,858625," 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in me",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858652,Availability,mask,masked,858652,"ncreased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858725,Availability,mask,mask,858725,"ber of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and sto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858822,Availability,mask,mask,858822,"ll i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:858951,Availability,mask,mask,858951," sequence of conditional scalar load operations and shuffles.; If all mask elements are '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:859116,Availability,mask,mask,859116," '1', the intrinsic behavior is equivalent to the regular unmasked vector load. .. _int_compressstore:. '``llvm.masked.compressstore.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. A number of scalar values of integer, floating point or pointer data type are collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] !=",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:859397,Availability,mask,mask,859397,"e collected from an input vector and stored into adjacent memory addresses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:859435,Availability,mask,mask,859435,"resses. A mask defines which elements to collect from the vector. ::. declare void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the n",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:859543,Availability,mask,masked,859543,"void @llvm.masked.compressstore.v8i32 (<8 x i32> <value>, ptr <ptr>, <8 x i1> <mask>); declare void @llvm.masked.compressstore.v16f32 (<16 x float> <value>, ptr <ptr>, <16 x i1> <mask>). Overview:; """""""""""""""""". Selects elements from input vector '``value``' according to the '``mask``'. All selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %Mas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:860179,Availability,mask,masked,860179,"r, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:860330,Availability,mask,masked,860330,"e element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:861927,Availability,alive,alive,861927,"ef:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:862292,Availability,alive,alive,862292,". Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:862485,Availability,alive,alive,862485," argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-all",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:868610,Availability,down,downward,868610,"ability to; optimize FP code when the default behavior is used. If any FP operation in a function is constrained then they all must be; constrained. This is required for correct LLVM IR. Optimizations that; move code around can create miscompiles if mixing of constrained and normal; operations is done. The correct way to mix constrained and less constrained; operations is to use the rounding mode and exception handling metadata to; mark constrained intrinsics as having LLVM's default behavior. Each of these intrinsics corresponds to a normal floating-point operation. The; data arguments and the return value are the same as the corresponding FP; operation. The rounding mode argument is a metadata string specifying what; assumptions, if any, the optimizer can make when transforming constant; values. Some constrained FP intrinsics omit this argument. If required; by the intrinsic, this argument must be one of the following strings:. ::. ""round.dynamic""; ""round.tonearest""; ""round.downward""; ""round.upward""; ""round.towardzero""; ""round.tonearestaway"". If this argument is ""round.dynamic"" optimization passes must assume that the; rounding mode is unknown and may change at runtime. No transformations that; depend on rounding mode may be performed in this case. The other possible values for the rounding mode argument correspond to the; similarly named IEEE rounding modes. If the argument is any of these values; optimization passes may perform transformations as long as they are consistent; with the specified rounding mode. For example, 'x-0'->'x' is not a valid transformation if the rounding mode is; ""round.downward"" or ""round.dynamic"" because if the value of 'x' is +0 then; 'x-0' should evaluate to '-0' when rounding downward. However, this; transformation is legal for all other rounding modes. For values other than ""round.dynamic"" optimization passes may assume that the; actual runtime rounding mode (as defined in a target-specific manner) matches; the specified rounding mod",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:869243,Availability,down,downward,869243," corresponding FP; operation. The rounding mode argument is a metadata string specifying what; assumptions, if any, the optimizer can make when transforming constant; values. Some constrained FP intrinsics omit this argument. If required; by the intrinsic, this argument must be one of the following strings:. ::. ""round.dynamic""; ""round.tonearest""; ""round.downward""; ""round.upward""; ""round.towardzero""; ""round.tonearestaway"". If this argument is ""round.dynamic"" optimization passes must assume that the; rounding mode is unknown and may change at runtime. No transformations that; depend on rounding mode may be performed in this case. The other possible values for the rounding mode argument correspond to the; similarly named IEEE rounding modes. If the argument is any of these values; optimization passes may perform transformations as long as they are consistent; with the specified rounding mode. For example, 'x-0'->'x' is not a valid transformation if the rounding mode is; ""round.downward"" or ""round.dynamic"" because if the value of 'x' is +0 then; 'x-0' should evaluate to '-0' when rounding downward. However, this; transformation is legal for all other rounding modes. For values other than ""round.dynamic"" optimization passes may assume that the; actual runtime rounding mode (as defined in a target-specific manner) matches; the specified rounding mode, but this is not guaranteed. Using a specific; non-dynamic rounding mode which does not match the actual rounding mode at; runtime results in undefined behavior. The exception behavior argument is a metadata string describing the floating; point exception semantics that required for the intrinsic. This argument; must be one of the following strings:. ::. ""fpexcept.ignore""; ""fpexcept.maytrap""; ""fpexcept.strict"". If this argument is ""fpexcept.ignore"" optimization passes may assume that the; exception status flags will not be read and that floating-point exceptions will; be masked. This allows transformations to be performed th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:869356,Availability,down,downward,869356," metadata string specifying what; assumptions, if any, the optimizer can make when transforming constant; values. Some constrained FP intrinsics omit this argument. If required; by the intrinsic, this argument must be one of the following strings:. ::. ""round.dynamic""; ""round.tonearest""; ""round.downward""; ""round.upward""; ""round.towardzero""; ""round.tonearestaway"". If this argument is ""round.dynamic"" optimization passes must assume that the; rounding mode is unknown and may change at runtime. No transformations that; depend on rounding mode may be performed in this case. The other possible values for the rounding mode argument correspond to the; similarly named IEEE rounding modes. If the argument is any of these values; optimization passes may perform transformations as long as they are consistent; with the specified rounding mode. For example, 'x-0'->'x' is not a valid transformation if the rounding mode is; ""round.downward"" or ""round.dynamic"" because if the value of 'x' is +0 then; 'x-0' should evaluate to '-0' when rounding downward. However, this; transformation is legal for all other rounding modes. For values other than ""round.dynamic"" optimization passes may assume that the; actual runtime rounding mode (as defined in a target-specific manner) matches; the specified rounding mode, but this is not guaranteed. Using a specific; non-dynamic rounding mode which does not match the actual rounding mode at; runtime results in undefined behavior. The exception behavior argument is a metadata string describing the floating; point exception semantics that required for the intrinsic. This argument; must be one of the following strings:. ::. ""fpexcept.ignore""; ""fpexcept.maytrap""; ""fpexcept.strict"". If this argument is ""fpexcept.ignore"" optimization passes may assume that the; exception status flags will not be read and that floating-point exceptions will; be masked. This allows transformations to be performed that may change the; exception semantics of the original code. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:870199,Availability,mask,masked,870199,"ified rounding mode. For example, 'x-0'->'x' is not a valid transformation if the rounding mode is; ""round.downward"" or ""round.dynamic"" because if the value of 'x' is +0 then; 'x-0' should evaluate to '-0' when rounding downward. However, this; transformation is legal for all other rounding modes. For values other than ""round.dynamic"" optimization passes may assume that the; actual runtime rounding mode (as defined in a target-specific manner) matches; the specified rounding mode, but this is not guaranteed. Using a specific; non-dynamic rounding mode which does not match the actual rounding mode at; runtime results in undefined behavior. The exception behavior argument is a metadata string describing the floating; point exception semantics that required for the intrinsic. This argument; must be one of the following strings:. ::. ""fpexcept.ignore""; ""fpexcept.maytrap""; ""fpexcept.strict"". If this argument is ""fpexcept.ignore"" optimization passes may assume that the; exception status flags will not be read and that floating-point exceptions will; be masked. This allows transformations to be performed that may change the; exception semantics of the original code. For example, FP operations may be; speculatively executed in this case whereas they must not be for either of the; other possible values of this argument. If the exception behavior argument is ""fpexcept.maytrap"" optimization passes; must avoid transformations that may raise exceptions that would not have been; raised by the original code (such as speculatively executing FP operations), but; passes are not required to preserve all exceptions that are implied by the; original code. For example, exceptions may be potentially hidden by constant; folding. If the exception behavior argument is ""fpexcept.strict"" all transformations must; strictly preserve the floating-point exception semantics of the original code.; Any FP exception that would have been raised by the original code must be raised; by the transformed co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:891803,Availability,error,error,891803,"he specified value.; If the value is less than negative zero, a floating-point exception occurs; and the return value is architecture specific. '``llvm.experimental.constrained.pow``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.pow(<type> <op1>, <type> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.pow``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers of the; same type. The second argument specifies the power to which the first argument; should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power,; returning the same values as the libm ``pow`` functions would, and; handles error conditions in the same way. '``llvm.experimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. The; order of evaluation of multiplications is not defined. When a vector of; floating-point type is used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument is a 32-bit signed integer specifying the power to; which the first argument should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:894676,Availability,error,error,894676,"antics:; """""""""""""""""""". This function multiplies the first argument by 2 raised to the second; argument's power. If the first argument is NaN or infinite, the same; value is returned. If the result underflows a zero with the same sign; is returned. If the result overflows, the result is an infinity with; the same sign. '``llvm.experimental.constrained.sin``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.sin(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.sin``' intrinsic returns the sine of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return type are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the sine of the specified operand, returning the; same values as the libm ``sin`` functions would, and handles error; conditions in the same way. '``llvm.experimental.constrained.cos``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.cos(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.cos``' intrinsic returns the cosine of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return type are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the cosine of the specified operand, returning the; same values as the libm ``cos`` functions would, and handles error; conditions in the same way. '``llvm.experimental.constrained.exp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:895447,Availability,error,error,895447,"rs of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the sine of the specified operand, returning the; same values as the libm ``sin`` functions would, and handles error; conditions in the same way. '``llvm.experimental.constrained.cos``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.cos(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.cos``' intrinsic returns the cosine of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return type are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the cosine of the specified operand, returning the; same values as the libm ``cos`` functions would, and handles error; conditions in the same way. '``llvm.experimental.constrained.exp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.exp(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.exp``' intrinsic computes the base-e; exponential of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.exp2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.ex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:896187,Availability,error,error,896187," numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the cosine of the specified operand, returning the; same values as the libm ``cos`` functions would, and handles error; conditions in the same way. '``llvm.experimental.constrained.exp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.exp(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.exp``' intrinsic computes the base-e; exponential of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.exp2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.exp2(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.exp2``' intrinsic computes the base-2; exponential of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log(<type> <op1>,; meta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:896931,Availability,error,error,896931,"ment and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.exp2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.exp2(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.exp2``' intrinsic computes the base-2; exponential of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log``' intrinsic computes the base-e; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log10``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log10(<type> <op1>,; metad",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:897668,Availability,error,error,897668," argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log``' intrinsic computes the base-e; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log10``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log10(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log10``' intrinsic computes the base-10; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log10`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log2(<type> <op1>",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:898416,Availability,error,error,898416," and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log10``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log10(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log10``' intrinsic computes the base-10; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log10`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log2(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log2``' intrinsic computes the base-2; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.rint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.rint(<type> <op1>,; me",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:899158,Availability,error,error,899158,"ment and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log10`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log2(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log2``' intrinsic computes the base-2; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.rint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.rint(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.rint``' intrinsic returns the first; operand rounded to the nearest integer. It may raise an inexact floating-point; exception if the operand is not an integer. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``rint`` functions; would, and handles error conditions in the same way. The rounding mode is; described, not determined, by the rounding mode argument. The actual rounding; mode is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:899988,Availability,error,error,899988,"third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.rint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.rint(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.rint``' intrinsic returns the first; operand rounded to the nearest integer. It may raise an inexact floating-point; exception if the operand is not an integer. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``rint`` functions; would, and handles error conditions in the same way. The rounding mode is; described, not determined, by the rounding mode argument. The actual rounding; mode is determined by the runtime floating-point environment. The rounding; mode argument is only intended as information to the compiler. '``llvm.experimental.constrained.lrint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.lrint(<fptype> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.lrint``' intrinsic returns the first; operand rounded to the nearest integer. An inexact floating-point exception; will be raised if the operand is not an integer. An invalid exception is; raised if the result is too large to fit into a supported integer type,; and in this case the result is undefined. Arguments:; """""""""""""""""""". The first argument is a floating-point number. The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:901354,Availability,error,error,901354,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.lrint(<fptype> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.lrint``' intrinsic returns the first; operand rounded to the nearest integer. An inexact floating-point exception; will be raised if the operand is not an integer. An invalid exception is; raised if the result is too large to fit into a supported integer type,; and in this case the result is undefined. Arguments:; """""""""""""""""""". The first argument is a floating-point number. The return value is an; integer type. Not all types are supported on all targets. The supported; types are the same as the ``llvm.lrint`` intrinsic and the ``lrint``; libm functions. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``lrint`` functions; would, and handles error conditions in the same way. The rounding mode is described, not determined, by the rounding mode; argument. The actual rounding mode is determined by the runtime floating-point; environment. The rounding mode argument is only intended as information; to the compiler. If the runtime floating-point environment is using the default rounding mode; then the results will be the same as the llvm.lrint intrinsic. '``llvm.experimental.constrained.llrint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.llrint(<fptype> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.llrint``' intrinsic returns the first; operand rounded to the nearest integer. An inexact floating-point exception; will be raised if the operand is not an integer. An invalid exception is; raised if the result is too large to fit int",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:902868,Availability,error,error,902868,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.llrint(<fptype> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.llrint``' intrinsic returns the first; operand rounded to the nearest integer. An inexact floating-point exception; will be raised if the operand is not an integer. An invalid exception is; raised if the result is too large to fit into a supported integer type,; and in this case the result is undefined. Arguments:; """""""""""""""""""". The first argument is a floating-point number. The return value is an; integer type. Not all types are supported on all targets. The supported; types are the same as the ``llvm.llrint`` intrinsic and the ``llrint``; libm functions. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``llrint`` functions; would, and handles error conditions in the same way. The rounding mode is described, not determined, by the rounding mode; argument. The actual rounding mode is determined by the runtime floating-point; environment. The rounding mode argument is only intended as information; to the compiler. If the runtime floating-point environment is using the default rounding mode; then the results will be the same as the llvm.llrint intrinsic. '``llvm.experimental.constrained.nearbyint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.nearbyint(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.nearbyint``' intrinsic returns the first; operand rounded to the nearest integer. It will not raise an inexact; floating-point exception if the operand is not an integer. Arguments:; """""""""""""""""""". The first argument and the return ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:904110,Availability,error,error,904110,"ode argument is only intended as information; to the compiler. If the runtime floating-point environment is using the default rounding mode; then the results will be the same as the llvm.llrint intrinsic. '``llvm.experimental.constrained.nearbyint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.nearbyint(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.nearbyint``' intrinsic returns the first; operand rounded to the nearest integer. It will not raise an inexact; floating-point exception if the operand is not an integer. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``nearbyint`` functions; would, and handles error conditions in the same way. The rounding mode is; described, not determined, by the rounding mode argument. The actual rounding; mode is determined by the runtime floating-point environment. The rounding; mode argument is only intended as information to the compiler. '``llvm.experimental.constrained.maxnum``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.maxnum(<type> <op1>, <type> <op2>; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.maxnum``' intrinsic returns the maximum; of the two arguments. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers; of the same type. The third argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function follows the IEEE-754 semantics for maxNum. '``llvm.experimental.constrained.minnum``' Intrinsic; ^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:907708,Availability,error,error,907708,"rinsic returns the minimum; of the two arguments, propagating NaNs and treating -0.0 as less than +0.0. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers; of the same type. The third argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function follows semantics specified in the draft of IEEE 754-2018. '``llvm.experimental.constrained.ceil``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.ceil(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.ceil``' intrinsic returns the ceiling of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``ceil`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.floor``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.floor(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.floor``' intrinsic returns the floor of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``floor`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.round``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.round(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:908385,Availability,error,error,908385,"``' intrinsic returns the ceiling of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``ceil`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.floor``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.floor(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.floor``' intrinsic returns the floor of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``floor`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.round``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.round(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.round``' intrinsic returns the first; operand rounded to the nearest integer. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``round`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.roundeven``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.roundeven(<type> <op1>,; metadata <exception behavior>). Ove",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:909080,Availability,error,error,909080,"urns the floor of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``floor`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.round``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.round(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.round``' intrinsic returns the first; operand rounded to the nearest integer. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``round`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.roundeven``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.roundeven(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.roundeven``' intrinsic returns the first; operand rounded to the nearest integer in floating-point format, rounding; halfway cases to even (that is, to the nearest value that is an even integer),; regardless of the current rounding direction. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function implements IEEE-754 operation ``roundToIntegralTiesToEven``. It; also behaves in the same way as C standard function ``roundeven`` and can signal; the invalid operation except",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:911143,Availability,error,error,911143,"d``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.lround(<fptype> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.lround``' intrinsic returns the first; operand rounded to the nearest integer with ties away from zero. It will; raise an inexact floating-point exception if the operand is not an integer.; An invalid exception is raised if the result is too large to fit into a; supported integer type, and in this case the result is undefined. Arguments:; """""""""""""""""""". The first argument is a floating-point number. The return value is an; integer type. Not all types are supported on all targets. The supported; types are the same as the ``llvm.lround`` intrinsic and the ``lround``; libm functions. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``lround`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.llround``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.llround(<fptype> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.llround``' intrinsic returns the first; operand rounded to the nearest integer with ties away from zero. It will; raise an inexact floating-point exception if the operand is not an integer.; An invalid exception is raised if the result is too large to fit into a; supported integer type, and in this case the result is undefined. Arguments:; """""""""""""""""""". The first argument is a floating-point number. The return value is an; integer type. Not all types are supported on all targets. The supported; types are the same as the ``llvm.llround`` intrinsic and the ``llround``; libm functions. The second argument specifies the exception behavio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:912251,Availability,error,error,912251,"Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <inttype>; @llvm.experimental.constrained.llround(<fptype> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.llround``' intrinsic returns the first; operand rounded to the nearest integer with ties away from zero. It will; raise an inexact floating-point exception if the operand is not an integer.; An invalid exception is raised if the result is too large to fit into a; supported integer type, and in this case the result is undefined. Arguments:; """""""""""""""""""". The first argument is a floating-point number. The return value is an; integer type. Not all types are supported on all targets. The supported; types are the same as the ``llvm.llround`` intrinsic and the ``llround``; libm functions. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``llround`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.trunc``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.trunc(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.trunc``' intrinsic returns the first; operand rounded to the nearest integer not larger in magnitude than the; operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``trunc`` functions; would and handles error conditions in the same way. .. _int_experimental_noalias_scope_decl:. '``llvm.experimental.noalias.scope.decl``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.experimen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:912988,Availability,error,error,912988,"he supported; types are the same as the ``llvm.llround`` intrinsic and the ``llround``; libm functions. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``llround`` functions; would and handles error conditions in the same way. '``llvm.experimental.constrained.trunc``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.trunc(<type> <op1>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.trunc``' intrinsic returns the first; operand rounded to the nearest integer not larger in magnitude than the; operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``trunc`` functions; would and handles error conditions in the same way. .. _int_experimental_noalias_scope_decl:. '``llvm.experimental.noalias.scope.decl``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.experimental.noalias.scope.decl(metadata !id.scope.list). Overview:; """""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. Arguments:; """""""""""""""""""". The ``!id.scope.list`` argument is metadata that is a list of ``noalias``; metadata references. The format is identical to that required for ``noalias``; metadata. This list must have exactly one element. Semantics:; """""""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:923347,Availability,mask,mask,923347,"ating-point class |; +=======+======================+; | 0 | Signaling NaN |; +-------+----------------------+; | 1 | Quiet NaN |; +-------+----------------------+; | 2 | Negative infinity |; +-------+----------------------+; | 3 | Negative normal |; +-------+----------------------+; | 4 | Negative subnormal |; +-------+----------------------+; | 5 | Negative zero |; +-------+----------------------+; | 6 | Positive zero |; +-------+----------------------+; | 7 | Positive subnormal |; +-------+----------------------+; | 8 | Positive normal |; +-------+----------------------+; | 9 | Positive infinity |; +-------+----------------------+. Semantics:; """""""""""""""""""". The function checks if ``op`` belongs to any of the floating-point classes; specified by ``test``. If ``op`` is a vector, then the check is made element by; element. Each check yields an :ref:`i1 <t_integer>` result, which is ``true``,; if the element value satisfies the specified test. The argument ``test`` is a; bit mask where each bit specifies floating-point class to test. For example, the; value 0x108 makes test for normal value, - bits 3 and 8 in it are set, which; means that the function returns ``true`` if ``op`` is a positive or negative; normal value. The function never raises floating-point exceptions. The; function does not canonicalize its input value and does not depend; on the floating-point environment. If the floating-point environment; has a zeroing treatment of subnormal input values (such as indicated; by the ``""denormal-fp-math""`` attribute), a subnormal value will be; observed (will not be implicitly treated as zero). General Intrinsics; ------------------. This class of intrinsics is designed to be generic and has no specific; purpose. '``llvm.var.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.var.annotation(ptr <val>, ptr <str>, ptr <str>, i32 <int>). Overview:; """""""""""""""""". The '``llvm.var.annotation``' intrinsic. Arguments:; """"""""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:929266,Availability,failure,failure,929266,":; """""""""""""". ::. declare void @llvm.trap() cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.trap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to the target dependent trap instruction. If; the target does not have a trap instruction, this intrinsic will be; lowered to a call of the ``abort()`` function. '``llvm.debugtrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.debugtrap() nounwind. Overview:; """""""""""""""""". The '``llvm.debugtrap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:932681,Availability,avail,available,932681," i32 @llvm.objectsize.i32(ptr <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>); declare i64 @llvm.objectsize.i64(ptr <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>). Overview:; """""""""""""""""". The ``llvm.objectsize`` intrinsic is designed to provide information to the; optimizer to determine whether a) an operation (like memcpy) will overflow a; buffer that corresponds to an object, or b) that a runtime check for overflow; isn't necessary. An object in this context means an allocation of a specific; class, structure, array, or other object. Arguments:; """""""""""""""""""". The ``llvm.objectsize`` intrinsic takes four arguments. The first argument is a; pointer to or into the ``object``. The second argument determines whether; ``llvm.objectsize`` returns 0 (if true) or -1 (if false) when the object size is; unknown. The third argument controls how ``llvm.objectsize`` acts when ``null``; in address space 0 is used as its pointer argument. If it's ``false``,; ``llvm.objectsize`` reports 0 bytes available when given ``null``. Otherwise, if; the ``null`` is in a non-zero address space or if ``true`` is given for the; third argument of ``llvm.objectsize``, we assume its size is unknown. The fourth; argument to ``llvm.objectsize`` determines if the value should be evaluated at; runtime. The second, third, and fourth arguments only accept constants. Semantics:; """""""""""""""""""". The ``llvm.objectsize`` intrinsic is lowered to a value representing the size of; the object concerned. If the size cannot be determined, ``llvm.objectsize``; returns ``i32/i64 -1 or 0`` (depending on the ``min`` argument). '``llvm.expect``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.expect`` on any; integer bit width. ::. declare i1 @llvm.expect.i1(i1 <val>, i1 <expected_val>); declare i32 @llvm.expect.i32(i32 <val>, i32 <expected_val>); declare i64 @llvm.expect.i64(i64 <val>, i64 <expected_val>). Overview:; """""""""""""""""". The ``llvm.expect`` intrins",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:947372,Availability,avail,available,947372,"ion``.; Support for ``@llvm.experimental.guard`` is slowly being rephrased in; terms of this alternate. '``llvm.experimental.widenable.condition``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i1 @llvm.experimental.widenable.condition(). Overview:; """""""""""""""""". This intrinsic represents a ""widenable condition"" which is; boolean expressions with the following property: whether this; expression is `true` or `false`, the program is correct and; well-defined. Together with :ref:`deoptimization operand bundles <deopt_opbundles>`,; ``@llvm.experimental.widenable.condition`` allows frontends to; express guards or checks on optimistic assumptions made during; compilation and represent them as branch instructions on special; conditions. While this may appear similar in semantics to `undef`, it is very; different in that an invocation produces a particular, singular; value. It is also intended to be lowered late, and remain available; for specific optimizations and transforms that can benefit from its; special properties. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The intrinsic ``@llvm.experimental.widenable.condition()``; returns either `true` or `false`. For each evaluation of a call; to this intrinsic, the program must be valid and correct both if; it returns `true` and if it returns `false`. This allows; transformation passes to replace evaluations of this intrinsic; with either value whenever one is beneficial. When used in a branch condition, it allows us to choose between; two alternative correct solutions for the same problem, like; in example below:. .. code-block:: text. %cond = call i1 @llvm.experimental.widenable.condition(); br i1 %cond, label %solution_1, label %solution_2. label %fast_path:; ; Apply memory-consuming but fast solution for a task. label %slow_path:; ; Cheap in memory but slow solution. Whether the result of intrinsic's call is `true` or `false`,; it should be correct to pick either soluti",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:953990,Availability,mask,mask,953990,"tics:; """""""""""""""""""". This intrinsic generates no code. If its argument is known to be a; manifest compile-time constant value, then the intrinsic will be; converted to a constant true value. Otherwise, it will be converted to; a constant false value. In particular, note that if the argument is a constant expression; which refers to a global (the address of which _is_ a constant, but; not manifest during the compile), then the intrinsic evaluates to; false. The result also intentionally depends on the result of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; impli",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954284,Availability,mask,masks,954284,"ression; which refers to a global (the address of which _is_ a constant, but; not manifest during the compile), then the intrinsic evaluates to; false. The result also intentionally depends on the result of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954329,Availability,mask,mask,954329,"ression; which refers to a global (the address of which _is_ a constant, but; not manifest during the compile), then the intrinsic evaluates to; false. The result also intentionally depends on the result of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954613,Availability,mask,mask,954613,"not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954784,Availability,mask,masked,954784,"ter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954815,Availability,mask,mask,954815,"ter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954842,Availability,mask,masked,954842,"ter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:955117,Availability,mask,mask,955117,"s; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local global is not a constant, since it depends on; the calling thread. The `llvm.threadlocal.address` intrinsic returns the; address of the given thread local global in the calling thread. .. _int_vscale:. '``llvm.vscale``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 llvm.vscale.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:973065,Availability,robust,robust,973065,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These intrinsics are used to carry certain debuginfo together with; IR-level operations. For example, it may be desirable to; know the structure/union name and the original user-level field; indices. Such information got lost in IR GetElementPtr instruction; since the IR types are different from debugInfo types and unions; are converted to structs in IR. '``llvm.preserve.array.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,; i32 dim,; i32 index). Overview:; """""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic returns the getelementptr address; based on array base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:7694,Deployability,update,updated,7694,"s made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; represented by a pointer to a memory location (in this case, a pointer; to an array of char, and a pointer to a function), and have one of the; following :ref:`linkage types <linkage>`. .. _linkage:. Linkage Types; -------------. All Global Variables and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references can be updated. This; doesn't show up in any symbol table in the object file.; ``internal``; Similar to private, but the value shows as a local symbol; (``STB_LOCAL`` in the case of ELF) in the object file. This; corresponds to the notion of the '``static``' keyword in C.; ``available_externally``; Globals with ""``available_externally``"" linkage are never emitted into; the object file corresponding to the LLVM module. From the linker's; perspective, an ``available_externally`` global is equivalent to; an external declaration. They exist to allow inlining and other; optimizations to take place given knowledge of the definition of the; global, which is known to be somewhere outside the module. Globals; with ``available_externally`` linkage are allowed to be discarded at; will, and allow inlining and other optimizations. This linkage type is; only allowed on definitions, not declarations.; ``linkonce``; Globals with ""``linkonce``"" linkage are merged with other globa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15762,Deployability,patch,patching,15762,"tion>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a large register set before and after the; call in the caller. If the arguments are passed in callee-saved registers,; then they will be preserved by the callee across the call. This doesn't; apply for values returned in callee-saved register",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15815,Deployability,patch,patching,15815,"tion>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a large register set before and after the; call in the caller. If the arguments are passed in callee-saved registers,; then they will be preserved by the callee across the call. This doesn't; apply for values returned in callee-saved register",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:16046,Deployability,patch,patchpoint,16046,"e `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a large register set before and after the; call in the caller. If the arguments are passed in callee-saved registers,; then they will be preserved by the callee across the call. This doesn't; apply for values returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11 and return registers, if any. R11 can be used as a scratch register.; The treatment of floating-point registers (XMMs/YMMs) matches the OS's C; calling convention: on most platforms, they are not preserved and need to;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:27955,Deployability,release,release,27955,"emption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer types are a work in progress, and they should be; considered experimental at this time. LLVM IR optionally allows the frontend to denote pointers in certain address; spaces as ""non-integral"" via the :ref:`datalayout string<langref_datalayout>`.; Non-integral pointer types represent pointers that have an *unspecified* bitwise; representation; that is, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:74140,Deployability,patch,patching,74140,". define void @f() prefix i32 123 { ... }. The prefix data can be referenced as,. .. code-block:: llvm. %a = getelementptr inbounds i32, ptr @f, i32 -1; %b = load i32, ptr %a. Prefix data is laid out as if it were an initializer for a global variable; of the prefix data's type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular format. Specifically, it must begin with a sequence of; bytes which decode to a sequence of machine instructions, valid for the; module's target, which transfer control to the point immediately succeeding; the prologue data, without performing any other visible action. This allows; the inliner and other passes to reason about the semantics of the function; definition without needing to reason about the prologue data. Obviously this; makes the format of the prologue data highly target dependent. A trivial example of valid prologue data for the x86 architecture is ``i8 144``,; which encodes the ``nop`` instruction:. .. code-block:: text. define void @f() prologue i8 144 { ... }. Generally prologue data can be formed by encoding a relative branch instruction; which skips the metadata, as in this example of valid prologue data for the; x86_64 architecture, w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:96770,Deployability,patch,patchable-function,96770,"dural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:96961,Deployability,patch,patch,96961,"dural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97149,Deployability,patch,patchable,97149,"be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97192,Deployability,patch,patching,97192,"be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97714,Deployability,patch,patchable,97714,"le with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further apart than the size of the guard region to a previous; access of the stack. It takes one required string value, the name of; the stack probing function that will be called. If a function that has a ``""probe-stack""`` attribute is inlined into; a function with another ``""probe-stack""`` attribute, the resulting; function has the ``""probe-stack""`` attribute of the caller. If a; function that has a ``""probe-stack""`` attribute is inlined into a; function that has no ``""probe-stack""`` attribute at all, the resulting; f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97954,Deployability,patch,patching,97954,"er it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further apart than the size of the guard region to a previous; access of the stack. It takes one required string value, the name of; the stack probing function that will be called. If a function that has a ``""probe-stack""`` attribute is inlined into; a function with another ``""probe-stack""`` attribute, the resulting; function has the ``""probe-stack""`` attribute of the caller. If a; function that has a ``""probe-stack""`` attribute is inlined into a; function that has no ``""probe-stack""`` attribute at all, the resulting; function has the ``""probe-stack""`` attribute of the callee.; ``""stack-probe-size""``; This attribute controls the behavior of stack probes: either; the ``""probe-stack""`` attribute, or ABI-required stack probes, if any.; It defines the size of the guard region.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:102766,Deployability,canary,canary,102766,"will cause the caller to gain the attribute. This is intended; to provide a maximally conservative model where the code in a function; annotated with this attribute will always (even after inlining) end up; hardened.; ``speculatable``; This function attribute indicates that the function does not have any; effects besides calculating its result and does not have undefined behavior.; Note that ``speculatable`` is not enough to conclude that along any; particular execution path the number of calls to this function will not be; externally observable. This attribute is only valid on functions; and declarations, not on individual call sites. If a function is; incorrectly marked as speculatable and really does exhibit; undefined behavior, the undefined behavior may be observed even; if the call site is dead code. ``ssp``; This attribute indicates that the function should emit a stack; smashing protector. It is in the form of a ""canary"" --- a random value; placed on the stack before the local variables that's checked upon; return from the function to see if it has been overwritten. A; heuristic is used to determine if a function needs stack protectors; or not. The heuristic used will enable protectors for functions with:. - Character arrays larger than ``ssp-buffer-size`` (default 8).; - Aggregates containing character arrays larger than ``ssp-buffer-size``.; - Calls to alloca() with variable sizes or constant sizes greater than; ``ssp-buffer-size``. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard. If a function with an ``ssp`` attribute is inlined into a calling function,; the attribute is not carried over to the calling function. ``sspstrong``; This attribute indicates that the function should emit a stack smashing; protector. This attribute causes a strong heuristic to be used when; determining if a function needs stack protectors. The strong heuristic; will enable protectors f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:104708,Deployability,upgrade,upgraded,104708," emit a stack smashing; protector. This attribute causes a strong heuristic to be used when; determining if a function needs stack protectors. The strong heuristic; will enable protectors for functions with:. - Arrays of any size and type; - Aggregates containing an array of any size and type.; - Calls to alloca().; - Local variables that have had their address taken. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. This overrides the ``ssp`` function attribute. If a function with an ``sspstrong`` attribute is inlined into a calling; function which has an ``ssp`` attribute, the calling function's attribute; will be upgraded to ``sspstrong``. ``sspreq``; This attribute indicates that the function should *always* emit a stack; smashing protector. This overrides the ``ssp`` and ``sspstrong`` function; attributes. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. If a function with an ``sspreq`` attribute is inlined into a calling; function which has an ``ssp`` or ``sspstrong`` attribute, the calling; function's attribute will be upgraded to ``sspreq``. ``strictfp``; This attribute indicates that the fu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:105569,Deployability,upgrade,upgraded,105569,"rotector. This overrides the ``ssp`` function attribute. If a function with an ``sspstrong`` attribute is inlined into a calling; function which has an ``ssp`` attribute, the calling function's attribute; will be upgraded to ``sspstrong``. ``sspreq``; This attribute indicates that the function should *always* emit a stack; smashing protector. This overrides the ``ssp`` and ``sspstrong`` function; attributes. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. If a function with an ``sspreq`` attribute is inlined into a calling; function which has an ``ssp`` or ``sspstrong`` attribute, the calling; function's attribute will be upgraded to ``sspreq``. ``strictfp``; This attribute indicates that the function was called from a scope that; requires strict floating-point semantics. LLVM will not attempt any; optimizations that require assumptions about the floating-point rounding; mode or that might alter the state of floating-point status flags that; might otherwise be set or cleared by calling this function. LLVM will; not introduce any new floating-point instructions that may trap. .. _denormal_fp_math:. ``""denormal-fp-math""``; This indicates the denormal (subnormal) handling that may be; assumed for the default floating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instruc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:127767,Deployability,update,updated,127767,"cessary to pass; non-trivially copyable objects by value in a way that is compatible with MSVC; on some targets. There can be at most one ``""preallocated""`` operand bundle; attached to a call site and it must have exactly one bundle operand, which is; a token generated by ``@llvm.call.preallocated.setup``. A call with this; operand bundle should not adjust the stack before entering the function, as; that will have been done by one of the ``@llvm.call.preallocated.*`` intrinsics. .. code-block:: llvm. %foo = type { i64, i32 }. ... %t = call token @llvm.call.preallocated.setup(i32 1); %a = call ptr @llvm.call.preallocated.arg(token %t, i32 0) preallocated(%foo); ; initialize %b; call void @bar(i32 42, ptr preallocated(%foo) %a) [""preallocated""(token %t)]. .. _ob_gc_live:. GC Live Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""gc-live"" operand bundle is only valid on a :ref:`gc.statepoint <gc_statepoint>`; intrinsic. The operand bundle must contain every pointer to a garbage collected; object which potentially needs to be updated by the garbage collector. When lowered, any relocated value will be recorded in the corresponding; :ref:`stackmap entry <statepoint-stackmap-format>`. See the intrinsic description; for further details. ObjC ARC Attached Call Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ``""clang.arc.attachedcall""`` operand bundle on a call indicates the call is; implicitly followed by a marker instruction and a call to an ObjC runtime; function that uses the result of the call. The operand bundle takes a mandatory; pointer to the runtime function (``@objc_retainAutoreleasedReturnValue`` or; ``@objc_unsafeClaimAutoreleasedReturnValue``).; The return value of a call with this bundle is used by a call to; ``@llvm.objc.clang.arc.noop.use`` unless the called function's return type is; void, in which case the operand bundle is ignored. .. code-block:: llvm. ; The marker instruction and a runtime function call are inserted after the call; ; to @foo.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130813,Deployability,integrat,integrated,130813,".. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145292,Deployability,release,release,145292,"read from the place by the caller after this call; exits. .. code-block:: llvm. @glb = global ptr null; @glb2 = global ptr null; @glb3 = global ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:154591,Deployability,release,release,154591,"; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:154676,Deployability,release,release,154676,"t be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this globa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:154924,Deployability,release,release,154924,"der immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:155055,Deployability,release,release,155055,"same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncsc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:155155,Deployability,release,release,155155,"``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:155199,Deployability,release,release,155199,"``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:155427,Deployability,release,release,155427,"corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:206788,Deployability,integrat,integrated,206788,"of a special value. This value; represents the inline assembler as a template string (containing the; instructions to emit), a list of operand constraints (stored as a string), a; flag that indicates whether or not the inline asm expression has side effects,; and a flag indicating whether the function containing the asm needs to align its; stack conservatively. The template string supports argument substitution of the operands using ""``$``""; followed by a number, to indicate substitution of the given register/memory; location, as specified by the constraint string. ""``${NUM:MODIFIER}``"" may also; be used, where ``MODIFIER`` is a target-specific annotation for how to print the; operand (See :ref:`inline-asm-modifiers`). A literal ""``$``"" may be included by using ""``$$``"" in the template. To include; other special characters into the output, the usual ""``\XX``"" escapes may be; used, just as in other strings. Note that after template substitution, the; resulting assembly string is parsed by LLVM's integrated assembler unless it is; disabled -- even when emitting a ``.s`` file -- and thus must contain assembly; syntax known to LLVM. LLVM also supports a few more substitutions useful for writing inline assembly:. - ``${:uid}``: Expands to a decimal integer unique to this inline assembly blob.; This substitution is useful when declaring a local label. Many standard; compiler optimizations, such as inlining, may duplicate an inline asm blob.; Adding a blob-unique identifier ensures that the two labels will not conflict; during assembly. This is used to implement `GCC's %= special format; string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_.; - ``${:comment}``: Expands to the comment character of the current target's; assembly dialect. This is usually ``#``, but many targets use other strings,; such as ``;``, ``//``, or ``!``.; - ``${:private}``: Expands to the assembler private label prefix. Labels with; this prefix will not appear in the symbol table of the ass",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:239430,Deployability,update,update,239430,"y operand support. - ``D``: Print the second register of a two-register operand, or prints the; second word of a double-word memory operand. (On a big-endian system, ``D`` is; equivalent to ``L``, and on little-endian system, ``D`` is equivalent to; ``M``.); - ``w``: No effect. Provided for compatibility with GCC which requires this; modifier in order to print MSA registers (``W0-W31``) with the ``f``; constraint. NVPTX:. - ``r``: No effect. PowerPC:. - ``L``: Print the second register of a two-register operand. Requires that it; has been allocated consecutively to the first. .. FIXME: why is it restricted to consecutive ones? And there's; nothing that ensures that happens, is there?. - ``I``: Print the letter 'i' if the operand is an integer constant, otherwise; nothing. Used to print 'addi' vs 'add' instructions.; - ``y``: For a memory operand, prints formatter for a two-register X-form; instruction. (Currently always prints ``r0,OPERAND``).; - ``U``: Prints 'u' if the memory operand is an update form, and nothing; otherwise. (NOTE: LLVM does not support update form, so this will currently; always print nothing); - ``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM does; not support indexed form, so this will currently always print nothing). RISC-V:. - ``i``: Print the letter 'i' if the operand is not a register, otherwise print; nothing. Used to print 'addi' vs 'add' instructions, etc.; - ``z``: Print the register ``zero`` if an immediate zero, otherwise print; normally. Sparc:. - ``L``: Print the low-order register of a two-register operand.; - ``H``: Print the high-order register of a two-register operand.; - ``r``: No effect. SystemZ:. SystemZ implements only ``n``, and does *not* support any of the other; target-independent modifiers. X86:. - ``c``: Print an unadorned integer or symbol name. (The latter is; target-specific behavior for this typically target-independent modifier).; - ``A``: Print a register name with a '``*``' before it.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:239496,Deployability,update,update,239496,"e-word memory operand. (On a big-endian system, ``D`` is; equivalent to ``L``, and on little-endian system, ``D`` is equivalent to; ``M``.); - ``w``: No effect. Provided for compatibility with GCC which requires this; modifier in order to print MSA registers (``W0-W31``) with the ``f``; constraint. NVPTX:. - ``r``: No effect. PowerPC:. - ``L``: Print the second register of a two-register operand. Requires that it; has been allocated consecutively to the first. .. FIXME: why is it restricted to consecutive ones? And there's; nothing that ensures that happens, is there?. - ``I``: Print the letter 'i' if the operand is an integer constant, otherwise; nothing. Used to print 'addi' vs 'add' instructions.; - ``y``: For a memory operand, prints formatter for a two-register X-form; instruction. (Currently always prints ``r0,OPERAND``).; - ``U``: Prints 'u' if the memory operand is an update form, and nothing; otherwise. (NOTE: LLVM does not support update form, so this will currently; always print nothing); - ``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM does; not support indexed form, so this will currently always print nothing). RISC-V:. - ``i``: Print the letter 'i' if the operand is not a register, otherwise print; nothing. Used to print 'addi' vs 'add' instructions, etc.; - ``z``: Print the register ``zero`` if an immediate zero, otherwise print; normally. Sparc:. - ``L``: Print the low-order register of a two-register operand.; - ``H``: Print the high-order register of a two-register operand.; - ``r``: No effect. SystemZ:. SystemZ implements only ``n``, and does *not* support any of the other; target-independent modifiers. X86:. - ``c``: Print an unadorned integer or symbol name. (The latter is; target-specific behavior for this typically target-independent modifier).; - ``A``: Print a register name with a '``*``' before it.; - ``b``: Print an 8-bit register name (e.g. ``al``); do nothing on a memory; operand.; - ``h``: Print the upper 8-bit r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:246600,Deployability,update,updated,246600,"ata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata nodes recognized by the; optimizers and code generator is found below. .. _specialized-metadata:. Specialized Metadata Nodes; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Specialized metadata nodes are custom data structures in metadata (as opposed; to generic tuples). Their fields are labelled, and can be specified in any; order. These aren't inherently debug info centric, but currently all the specialized; metadata nodes are related to debug info. .. _DICompileUnit:. DICompileUnit; """""""""""""""""""""""""". ``DICompileUnit`` nodes represent a compile unit. The ``enums:``,; ``retainedTypes:``, ``globals:``, ``imports:`` and ``macros:`` fields are tuples; containing the debug info to be emitted along with the compile unit, regardless; of code optimizations (some nodes are only emitted if there are references to; them from instructions). The ``debugInfoForProfiling:`` field is a boolean; indicating whether or not line-table discriminators are updated to provide; more-accurate debug info for profiling results. .. code-block:: text. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang"",; isOptimized: true, flags: ""-O2"", runtimeVersion: 2,; splitDebugFilename: ""abc.debug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes us",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:295936,Deployability,pipeline,pipeline,295936," are; neither persistent for the same loop through transformations nor; necessarily unique to just one loop. '``llvm.loop.disable_nonforced``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables all optional loop transformations unless; explicitly instructed using other transformation metadata such as; ``llvm.loop.unroll.enable``. That is, no heuristic will try to determine; whether a transformation is profitable. The purpose is to avoid that the; loop is transformed to a different loop before an explicitly requested; (forced) transformation is applied. For instance, loop fusion can make; other transformations impossible. Mandatory loop canonicalizations such; as loop rotation are still applied. It is recommended to use this metadata in addition to any llvm.loop.*; transformation directive. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310989,Deployability,update,updated,310989,"^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345137,Deployability,update,update,345137,"optional ``Params`` is used by ``StackSafety`` and looks like:. .. code-block:: text. Params: ((Param)[, (Param)]*). where each ``Param`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:409208,Deployability,release,released,409208,"he; indices is that of ``elt``. Example:; """""""""""""""". .. code-block:: llvm. %agg1 = insertvalue {i32, float} undef, i32 1, 0 ; yields {i32 1, float undef}; %agg2 = insertvalue {i32, float} %agg1, float %val, 1 ; yields {i32 1, float %val}; %agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0 ; yields {i32 undef, {float %val}}. .. _memoryops:. Memory Access and Addressing Operations; ---------------------------------------. A key design point of an SSA-based representation is how it represents; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410721,Deployability,release,released,410721,"d; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413208,Deployability,release,release,413208,"atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:422567,Deployability,update,updated,422567,"can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. If ``<value>`` is; of scalar type then the number of bytes written does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:423862,Deployability,release,release,423862,"en writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:423970,Deployability,release,release,423970,"lled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; comp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424507,Deployability,release,release,424507,"^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-block:: text. fence acquire ; yields void; fence syncscope(""singlethread"") seq_cst ; yields void; fe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424745,Deployability,release,release,424745,"ment which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-block:: text. fence acquire ; yields void; fence syncscope(""singlethread"") seq_cst ; yields void; fence syncscope(""agent"") seq_cst ; yields void. .. _i_cmpxchg:. '``cmpxchg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. cmpxchg [weak] [volatile] ptr <pointer>, <ty> <cmp>, <ty> <new> [syncscope(""<target-scope>"")] <success ordering> <failure ordering>[, align <alignment>] ; y",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:426962,Deployability,release,release,426962," value. If they are; equal, it tries to store a new value into the memory. Arguments:; """""""""""""""""""". There are three arguments to the '``cmpxchg``' instruction: an address; to operate on, a value to compare to the value currently be at that; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the locatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:428374,Deployability,release,release,428374,"t. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the location is returned,; together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as ``weak`` then a spurious failure is; permitted: the operation may not write ``<new>`` even if the comparison; matched. If the cmpxchg operation is strong (the default), the i1 value is 1 if and only; if the value loaded equals ``cmp``. A successful ``cmpxchg`` is a read-modify-write instruction for the purpose of; identifying release sequences. A failed ``cmpxchg`` is equivalent to an atomic; load with an ordering parameter determined the second ordering parameter. Example:; """""""""""""""". .. code-block:: llvm. entry:; %orig = load atomic i32, ptr %ptr unordered, align 4 ; yields i32; br label %loop. loop:; %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]; %squared = mul i32 %cmp, %cmp; %val_success = cmpxchg ptr %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields { i32, i1 }; %value_loaded = extractvalue { i32, i1 } %val_success, 0; %success = extractvalue { i32, i1 } %val_success, 1; br i1 %success, label %done, label %loop. done:; ... .. _i_atomicrmw:. '``atomicrmw``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. atomicrmw [volatile] <operation> ptr <pointer>, <ty> <value> [syncscope(""<target-scope>"")] <ordering>[, align <alignment>] ; yields ty. Overview:; """""""""""""""""". The '``atomicrmw``' instruction is used to atomically modify memory. Argumen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:499719,Deployability,patch,patch,499719,"ic identifies writes of references to heap; locations, allowing garbage collector implementations that require write; barriers (such as generational or reference counting collectors). Arguments:; """""""""""""""""""". The first argument is the reference to store, the second is the start of; the object to store it to, and the third is the address of the field of; Obj to store to. If the runtime does not require a pointer to the; object, Obj may be null. Semantics:; """""""""""""""""""". The '``llvm.gcwrite``' intrinsic has the same semantics as a store; instruction, but may be replaced with substantially more complex code by; the garbage collector runtime, as needed. The '``llvm.gcwrite``'; intrinsic may only be used in a function which :ref:`specifies a GC; algorithm <gc>`. .. _gc_statepoint:. '``llvm.experimental.gc.statepoint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare token; @llvm.experimental.gc.statepoint(i64 <id>, i32 <num patch bytes>,; ptr elementtype(func_type) <target>,; i64 <#call args>, i64 <flags>,; ... (call parameters),; i64 0, i64 0). Overview:; """""""""""""""""". The statepoint intrinsic represents a call which is parse-able by the; runtime. Operands:; """""""""""""""""". The 'id' operand is a constant integer that is reported as the ID; field in the generated stackmap. LLVM does not interpret this; parameter in any way and its meaning is up to the statepoint user to; decide. Note that LLVM is free to duplicate code containing; statepoint calls, and this may transform IR that had a unique 'id' per; lexical call to statepoint to IR that does not. If 'num patch bytes' is non-zero then the call instruction; corresponding to the statepoint is not emitted and LLVM emits 'num; patch bytes' bytes of nops in its place. LLVM will emit code to; prepare the function arguments and retrieve the function return value; in accordance to the calling convention; the former before the nop; sequence and the latter after the nop sequence. It is expected that",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:500356,Deployability,patch,patch,500356,"nsic may only be used in a function which :ref:`specifies a GC; algorithm <gc>`. .. _gc_statepoint:. '``llvm.experimental.gc.statepoint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare token; @llvm.experimental.gc.statepoint(i64 <id>, i32 <num patch bytes>,; ptr elementtype(func_type) <target>,; i64 <#call args>, i64 <flags>,; ... (call parameters),; i64 0, i64 0). Overview:; """""""""""""""""". The statepoint intrinsic represents a call which is parse-able by the; runtime. Operands:; """""""""""""""""". The 'id' operand is a constant integer that is reported as the ID; field in the generated stackmap. LLVM does not interpret this; parameter in any way and its meaning is up to the statepoint user to; decide. Note that LLVM is free to duplicate code containing; statepoint calls, and this may transform IR that had a unique 'id' per; lexical call to statepoint to IR that does not. If 'num patch bytes' is non-zero then the call instruction; corresponding to the statepoint is not emitted and LLVM emits 'num; patch bytes' bytes of nops in its place. LLVM will emit code to; prepare the function arguments and retrieve the function return value; in accordance to the calling convention; the former before the nop; sequence and the latter after the nop sequence. It is expected that; the user will patch over the 'num patch bytes' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:500476,Deployability,patch,patch,500476,"nsic may only be used in a function which :ref:`specifies a GC; algorithm <gc>`. .. _gc_statepoint:. '``llvm.experimental.gc.statepoint``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare token; @llvm.experimental.gc.statepoint(i64 <id>, i32 <num patch bytes>,; ptr elementtype(func_type) <target>,; i64 <#call args>, i64 <flags>,; ... (call parameters),; i64 0, i64 0). Overview:; """""""""""""""""". The statepoint intrinsic represents a call which is parse-able by the; runtime. Operands:; """""""""""""""""". The 'id' operand is a constant integer that is reported as the ID; field in the generated stackmap. LLVM does not interpret this; parameter in any way and its meaning is up to the statepoint user to; decide. Note that LLVM is free to duplicate code containing; statepoint calls, and this may transform IR that had a unique 'id' per; lexical call to statepoint to IR that does not. If 'num patch bytes' is non-zero then the call instruction; corresponding to the statepoint is not emitted and LLVM emits 'num; patch bytes' bytes of nops in its place. LLVM will emit code to; prepare the function arguments and retrieve the function return value; in accordance to the calling convention; the former before the nop; sequence and the latter after the nop sequence. It is expected that; the user will patch over the 'num patch bytes' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:500763,Deployability,patch,patch,500763,"rameters),; i64 0, i64 0). Overview:; """""""""""""""""". The statepoint intrinsic represents a call which is parse-able by the; runtime. Operands:; """""""""""""""""". The 'id' operand is a constant integer that is reported as the ID; field in the generated stackmap. LLVM does not interpret this; parameter in any way and its meaning is up to the statepoint user to; decide. Note that LLVM is free to duplicate code containing; statepoint calls, and this may transform IR that had a unique 'id' per; lexical call to statepoint to IR that does not. If 'num patch bytes' is non-zero then the call instruction; corresponding to the statepoint is not emitted and LLVM emits 'num; patch bytes' bytes of nops in its place. LLVM will emit code to; prepare the function arguments and retrieve the function return value; in accordance to the calling convention; the former before the nop; sequence and the latter after the nop sequence. It is expected that; the user will patch over the 'num patch bytes' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call paramet",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:500783,Deployability,patch,patch,500783,"rameters),; i64 0, i64 0). Overview:; """""""""""""""""". The statepoint intrinsic represents a call which is parse-able by the; runtime. Operands:; """""""""""""""""". The 'id' operand is a constant integer that is reported as the ID; field in the generated stackmap. LLVM does not interpret this; parameter in any way and its meaning is up to the statepoint user to; decide. Note that LLVM is free to duplicate code containing; statepoint calls, and this may transform IR that had a unique 'id' per; lexical call to statepoint to IR that does not. If 'num patch bytes' is non-zero then the call instruction; corresponding to the statepoint is not emitted and LLVM emits 'num; patch bytes' bytes of nops in its place. LLVM will emit code to; prepare the function arguments and retrieve the function return value; in accordance to the calling convention; the former before the nop; sequence and the latter after the nop sequence. It is expected that; the user will patch over the 'num patch bytes' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call paramet",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:501173,Deployability,patch,patching,501173,"r to; decide. Note that LLVM is free to duplicate code containing; statepoint calls, and this may transform IR that had a unique 'id' per; lexical call to statepoint to IR that does not. If 'num patch bytes' is non-zero then the call instruction; corresponding to the statepoint is not emitted and LLVM emits 'num; patch bytes' bytes of nops in its place. LLVM will emit code to; prepare the function arguments and retrieve the function return value; in accordance to the calling convention; the former before the nop; sequence and the latter after the nop sequence. It is expected that; the user will patch over the 'num patch bytes' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:526697,Deployability,pipeline,pipeline,526697,"s without support, this; is lowered to a constant 0. Note that runtime support may be conditional on the privilege-level code is; running at and the host platform. '``llvm.clear_cache``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.clear_cache(ptr, ptr). Overview:; """""""""""""""""". The '``llvm.clear_cache``' intrinsic ensures visibility of modifications; in the specified range to the execution unit of the processor. On; targets with non-unified instruction and data cache, the implementation; flushes the instruction cache. Semantics:; """""""""""""""""""". On platforms with coherent instruction and data caches (e.g. x86), this; intrinsic is a nop. On platforms with non-coherent instruction and data; cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate; instructions or a system call, if cache flushing requires special; privileges. The default behavior is to emit a call to ``__clear_cache`` from the run; time library. This intrinsic does *not* empty the instruction pipeline. Modifications; of the current function are outside the scope of the intrinsic. '``llvm.instrprof.increment``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. These will be; lowered by the ``-instrprof`` pass to generate execution counts of a; program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source, and; the third is the number of counters associated with ``name``. It is an; error if ``hash``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:533339,Deployability,update,update,533339,"te MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:533482,Deployability,update,update,533482,"e of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:533636,Deployability,update,update,533636,"sed by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:534422,Deployability,update,update,534422," <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vecto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:534784,Deployability,update,update,534784,"e containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to det",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:534923,Deployability,update,update,534923,"nt is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vector",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:535078,Deployability,update,update,535078,"ack. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:535275,Deployability,update,updated,535275,"ndition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is the address of the condition bitmap, which contains a; value representing an executed MC/DC test vector. It is l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:535327,Deployability,update,update,535327," update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is the address of the condition bitmap, which contains a; value representing an executed MC/DC test vector. It is loaded and used as the; bit index of the test vector bitmap. Semantics:; """""""""""""""""""". This intrinsic represents the final operation of an MC/DC instrumentation; sequence and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:536496,Deployability,update,update,536496,"as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is the address of the condition bitmap, which contains a; value representing an executed MC/DC test vector. It is loaded and used as the; bit index of the test vector bitmap. Semantics:; """""""""""""""""""". This intrinsic represents the final operation of an MC/DC instrumentation; sequence and will cause the ``-instrprof`` pass to generate the code to; instrument an update of a function's global test vector bitmap to indicate that; a test vector has been executed. The global test vector bitmap can be consumed; by the ``llvm-profdata`` and ``llvm-cov`` tools. '``llvm.thread.pointer``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.thread.pointer(). Overview:; """""""""""""""""". The '``llvm.thread.pointer``' intrinsic returns the value of the thread; pointer. Semantics:; """""""""""""""""""". The '``llvm.thread.pointer``' intrinsic returns a pointer to the TLS area; for the current thread. The exact semantics of this value are target; specific: it may point to the start of TLS area, to the end, or somewhere; in the middle. Depending on the target, this intrinsic may read a register,; call a helper function, read from an alternate memory space, or perform; other operations necessary to locate the TLS area. Not all targets support; this intrinsic. '``llvm.call.preallocated.setup``' Intrinsic; ^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:620649,Deployability,pipeline,pipelines,620649,"a to i8; %b2 = sext i4 %b to i8; %mul = mul nsw nuw i8 %a2, %b2; %scale2 = trunc i32 %scale to i8; %r = ashr i8 %mul, i8 %scale2 ; this is for a target rounding down towards negative infinity; %result = trunc i8 %r to i4. The ``llvm.*div.fix`` family of intrinsic functions represents a division of; fixed point numbers through scaled integers. Fixed point division can be; represented as:. .. code-block:: llvm. %result call i4 @llvm.sdiv.fix.i4(i4 %a, i4 %b, i32 %scale). ; Expands to; %a2 = sext i4 %a to i8; %b2 = sext i4 %b to i8; %scale2 = trunc i32 %scale to i8; %a3 = shl i8 %a2, %scale2; %r = sdiv i8 %a3, %b2 ; this is for a target rounding towards zero; %result = trunc i8 %r to i4. For each of these functions, if the result cannot be represented exactly with; the provided scale, the result is rounded. Rounding is unspecified since; preferred rounding may vary for different targets. Rounding is specified; through a target hook. Different pipelines should legalize or optimize this; using the rounding specified by this hook if it is provided. Operations like; constant folding, instruction combining, KnownBits, and ValueTracking should; also use this hook, if provided, and not assume the direction of rounding. A; rounded result must always be within one unit of precision from the true; result. That is, the error between the returned result and the true result must; be less than 1/2^(scale). '``llvm.smul.fix.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.smul.fix``; on any integer bit width or vectors of integers. ::. declare i16 @llvm.smul.fix.i16(i16 %a, i16 %b, i32 %scale); declare i32 @llvm.smul.fix.i32(i32 %a, i32 %b, i32 %scale); declare i64 @llvm.smul.fix.i64(i64 %a, i64 %b, i32 %scale); declare <4 x i32> @llvm.smul.fix.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale). Overview; """""""""""""""""". The '``llvm.smul.fix``' family of intrinsic functions perform signed; fixed point multiplication on 2 arg",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:648009,Deployability,update,updated,648009,"o the loop. The; second i1 output controls entry to a while-loop. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.test.start.loop.iterations.*``' intrinsics do not perform any; arithmetic on their operand. It's a hint to the backend that can use this to; set up the hardware-loop count with a target specific instruction, usually a; move of this value to a special register or a hardware-loop instruction.; The result is a pair of the input and a conditional value of whether the; given count is not zero. '``llvm.loop.decrement.reg.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i32 @llvm.loop.decrement.reg.i32(i32, i32); declare i64 @llvm.loop.decrement.reg.i64(i64, i64). Overview:; """""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics are used to lower the loop; iteration counter and return an updated value that will be used in the next; loop test check. Arguments:; """""""""""""""""""". Both arguments must have identical integer types. The first operand is the; loop iteration counter. The second operand is the maximum number of elements; processed in an iteration. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics do an integer ``SUB`` of its; two operands, which is not allowed to wrap. They return the remaining number of; iterations still to be executed, and can be used together with a ``PHI``,; ``ICMP`` and ``BR`` to control the number of loop iterations executed. Any; optimisations are allowed to treat it is a ``SUB``, and it is supported by; SCEV, so it's the backends responsibility to handle cases where it may be; optimised. These intrinsics are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:649529,Deployability,update,updated,649529,"nd ``BR`` to control the number of loop iterations executed. Any; optimisations are allowed to treat it is a ``SUB``, and it is supported by; SCEV, so it's the backends responsibility to handle cases where it may be; optimised. These intrinsics are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.loop.decrement.i32(i32); declare i1 @llvm.loop.decrement.i64(i64). Overview:; """""""""""""""""". The HardwareLoops pass allows the loop decrement value to be specified with an; option. It defaults to a loop decrement value of 1, but it can be an unsigned; integer value provided by this option. The '``llvm.loop.decrement.*``'; intrinsics decrement the loop iteration counter with this value, and return a; false predicate if the loop should exit, and true otherwise.; This is emitted if the loop counter is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:861775,Deployability,pipeline,pipeline,861775,"lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """"""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863286,Deployability,pipeline,pipeline,863286,"fetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:941740,Deployability,patch,patchpoint,941740,"optimizations,; particularly reassociation,; between the argument and the expression that contains the argument.; It can be used to preserve the parentheses in the source language. Arguments:; """""""""""""""""""". The ``llvm.arithmetic.fence`` intrinsic takes only one argument.; The argument and the return value are floating-point numbers,; or vector floating-point numbers, of the same type. Semantics:; """""""""""""""""""". This intrinsic returns the value of its operand. The optimizer can optimize; the argument, but the optimizer cannot hoist any component of the operand; to the containing context, and the optimizer cannot move the calculation of; any expression in the containing context into the operand. '``llvm.donothing``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.donothing() nounwind memory(none). Overview:; """""""""""""""""". The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of only; three intrinsics (besides ``llvm.experimental.patchpoint`` and; ``llvm.experimental.gc.statepoint``) that can be called with an invoke; instruction. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic does nothing, and it's removed by optimizers and ignored; by codegen. '``llvm.experimental.deoptimize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare type @llvm.experimental.deoptimize(...) [ ""deopt""(...) ]. Overview:; """""""""""""""""". This intrinsic, together with :ref:`deoptimization operand bundles; <deopt_opbundles>`, allow frontends to express transfer of control and; frame-local state from the currently executing (typically more specialized,; hence faster) version of a function into another (typically more generic, hence; slower) version. In languages with a fully integrated managed runtime like Java and JavaScript; this intrinsic can be used to implement ""uncommon trap"" or ""side exit"" like; functionality. In unmanaged languages like C and C++, this intrinsic can be; used to represent the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:942525,Deployability,integrat,integrated,942525,"none). Overview:; """""""""""""""""". The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of only; three intrinsics (besides ``llvm.experimental.patchpoint`` and; ``llvm.experimental.gc.statepoint``) that can be called with an invoke; instruction. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic does nothing, and it's removed by optimizers and ignored; by codegen. '``llvm.experimental.deoptimize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare type @llvm.experimental.deoptimize(...) [ ""deopt""(...) ]. Overview:; """""""""""""""""". This intrinsic, together with :ref:`deoptimization operand bundles; <deopt_opbundles>`, allow frontends to express transfer of control and; frame-local state from the currently executing (typically more specialized,; hence faster) version of a function into another (typically more generic, hence; slower) version. In languages with a fully integrated managed runtime like Java and JavaScript; this intrinsic can be used to implement ""uncommon trap"" or ""side exit"" like; functionality. In unmanaged languages like C and C++, this intrinsic can be; used to represent the slow paths of specialized functions. Arguments:; """""""""""""""""""". The intrinsic takes an arbitrary number of arguments, whose meaning is; decided by the :ref:`lowering strategy<deoptimize_lowering>`. Semantics:; """""""""""""""""""". The ``@llvm.experimental.deoptimize`` intrinsic executes an attached; deoptimization continuation (denoted using a :ref:`deoptimization; operand bundle <deopt_opbundles>`) and returns the value returned by; the deoptimization continuation. Defining the semantic properties of; the continuation itself is out of scope of the language reference --; as far as LLVM is concerned, the deoptimization continuation can; invoke arbitrary side effects, including reading from and writing to; the entire heap. Deoptimization continuations expressed using ``""deopt""`` operand bundles always; continue execution to the end ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:944256,Deployability,update,updates,944256,"perties of; the continuation itself is out of scope of the language reference --; as far as LLVM is concerned, the deoptimization continuation can; invoke arbitrary side effects, including reading from and writing to; the entire heap. Deoptimization continuations expressed using ``""deopt""`` operand bundles always; continue execution to the end of the physical frame containing them, so all; calls to ``@llvm.experimental.deoptimize`` must be in ""tail position"":. - ``@llvm.experimental.deoptimize`` cannot be invoked.; - The call must immediately precede a :ref:`ret <i_ret>` instruction.; - The ``ret`` instruction must return the value produced by the; ``@llvm.experimental.deoptimize`` call if there is one, or void. Note that the above restrictions imply that the return type for a call to; ``@llvm.experimental.deoptimize`` will match the return type of its immediate; caller. The inliner composes the ``""deopt""`` continuations of the caller into the; ``""deopt""`` continuations present in the inlinee, and also updates calls to this; intrinsic to return directly from the frame of the function it inlined into. All declarations of ``@llvm.experimental.deoptimize`` must share the; same calling convention. .. _deoptimize_lowering:. Lowering:; """""""""""""""""". Calls to ``@llvm.experimental.deoptimize`` are lowered to calls to the; symbol ``__llvm_deoptimize`` (it is the frontend's responsibility to; ensure that this symbol is defined). The call arguments to; ``@llvm.experimental.deoptimize`` are lowered as if they were formal; arguments of the specified types, and not as varargs. '``llvm.experimental.guard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.experimental.guard(i1, ...) [ ""deopt""(...) ]. Overview:; """""""""""""""""". This intrinsic, together with :ref:`deoptimization operand bundles; <deopt_opbundles>`, allows frontends to express guards or checks on; optimistic assumptions made during compilation. The semantics of; ``@llvm.experimenta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:956647,Deployability,patch,patching,956647,"urn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local global is not a constant, since it depends on; the calling thread. The `llvm.threadlocal.address` intrinsic returns the; address of the given thread local global in the calling thread. .. _int_vscale:. '``llvm.vscale``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 llvm.vscale.i32(); declare i64 llvm.vscale.i64(). Overview:; """""""""""""""""". The ``llvm.vscale`` intrinsic returns the value for ``vscale`` in scalable; vectors such as ``<vscale x 16 x i8>``. Semantics:; """""""""""""""""""". ``vscale`` is a positive value that is constant throughout program; execution, but is unknown at compile time.; If the result value does not fit in the result type, then the result is; a :ref:`poison value <poisonvalues>`. Stack Map Intrinsics; --------------------. LLVM provides experimental intrinsics to support runtime patching; mechanisms commonly desired in dynamic language JITs. These intrinsics; are described in :doc:`StackMaps`. Element Wise Atomic Memory Intrinsics; -------------------------------------. These intrinsics are similar to the standard library memory intrinsics except; that they perform memory transfer as a sequence of atomic memory accesses. .. _int_memcpy_element_unordered_atomic:. '``llvm.memcpy.element.unordered.atomic``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memcpy.element.unordered.atomic`` on; any integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memcpy.element.unordered.atomic.p0.p0.i32(ptr <dest>,; ptr <src>,; i32 <len>,; i32 <element_size>); declare void @llvm.memcpy.element.unordered.atomic.p0.p0.i64(ptr <dest>,; ptr <src>,; i64 <len>,; i32 <element_size>). Overview:; """""""""""""""""". The '``llvm.memcpy.element.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:969509,Deployability,release,release,969509,"cs/AutomaticReferenceCounting.html#arc-runtime-objc-initweak>`_. '``llvm.objc.loadWeak``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.loadWeak(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_loadWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak>`_. '``llvm.objc.loadWeakRetained``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.loadWeakRetained(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_loadWeakRetained <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweakretained>`_. '``llvm.objc.moveWeak``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare void @llvm.objc.moveWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_moveWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-moveweak-id-dest-id-src>`_. '``llvm.objc.release``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare void @llvm.objc.release(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_release <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-release-id-value>`_. '``llvm.objc.retain``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retain(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retain <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain>`_. '``llvm.objc.retainAutorelease``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retainAutorelease(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retainAutorelease <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautorelease>`_. '``llvm.objc.retainAutoreleaseReturnValue``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retainAutor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:969612,Deployability,release,release,969612,"dWeak``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.loadWeak(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_loadWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak>`_. '``llvm.objc.loadWeakRetained``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.loadWeakRetained(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_loadWeakRetained <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweakretained>`_. '``llvm.objc.moveWeak``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare void @llvm.objc.moveWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_moveWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-moveweak-id-dest-id-src>`_. '``llvm.objc.release``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare void @llvm.objc.release(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_release <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-release-id-value>`_. '``llvm.objc.retain``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retain(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retain <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain>`_. '``llvm.objc.retainAutorelease``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retainAutorelease(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retainAutorelease <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautorelease>`_. '``llvm.objc.retainAutoreleaseReturnValue``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retainAutoreleaseReturnValue(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retainAuto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:969753,Deployability,release,release-id-value,969753," Lowers to a call to `objc_loadWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak>`_. '``llvm.objc.loadWeakRetained``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.loadWeakRetained(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_loadWeakRetained <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweakretained>`_. '``llvm.objc.moveWeak``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare void @llvm.objc.moveWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_moveWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-moveweak-id-dest-id-src>`_. '``llvm.objc.release``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare void @llvm.objc.release(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_release <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-release-id-value>`_. '``llvm.objc.retain``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retain(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retain <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain>`_. '``llvm.objc.retainAutorelease``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retainAutorelease(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retainAutorelease <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautorelease>`_. '``llvm.objc.retainAutoreleaseReturnValue``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.retainAutoreleaseReturnValue(ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_retainAutoreleaseReturnValue <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasereturnvalue>`_. '``llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:837,Energy Efficiency,power,powerful,837,"==============================; LLVM Language Reference Manual; ==============================. .. contents::; :local:; :depth: 3. Abstract; ========. This document is a reference manual for the LLVM assembly language. LLVM; is a Static Single Assignment (SSA) based representation that provides; type safety, low-level operations, flexibility, and the capability of; representing 'all' high-level languages cleanly. It is the common code; representation used throughout all phases of the LLVM compilation; strategy. Introduction; ============. The LLVM code representation is designed to be used in three different; forms: as an in-memory compiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:878,Energy Efficiency,efficient,efficient,878,"==============================; LLVM Language Reference Manual; ==============================. .. contents::; :local:; :depth: 3. Abstract; ========. This document is a reference manual for the LLVM assembly language. LLVM; is a Static Single Assignment (SSA) based representation that provides; type safety, low-level operations, flexibility, and the capability of; representing 'all' high-level languages cleanly. It is the common code; representation used throughout all phases of the LLVM compilation; strategy. Introduction; ============. The LLVM code representation is designed to be used in three different; forms: as an in-memory compiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:13184,Energy Efficiency,efficient,efficient,13184,"calling convention; is specified) matches the target C calling conventions. This calling; convention supports varargs function calls and tolerates some; mismatch in the declared prototype and implemented declaration of; the function (as does normal C).; ""``fastcc``"" - The fast calling convention; This calling convention attempts to make calls as fast as possible; (e.g. by passing things in registers). This calling convention; allows the target to use whatever tricks it wants to produce fast; code for the target, without having to conform to an externally; specified ABI (Application Binary Interface). `Tail calls can only; be optimized when this, the tailcc, the GHC or the HiPE convention is; used. <CodeGenerator.html#tail-call-optimization>`_ This calling; convention does not support varargs and requires the prototype of all; callees to exactly match the prototype of the function definition.; ""``coldcc``"" - The cold calling convention; This calling convention attempts to make code in the caller as; efficient as possible under the assumption that the call is not; commonly executed. As such, these calls often preserve all registers; so that the call does not break any live ranges in the caller side.; This calling convention does not support varargs and requires the; prototype of all callees to exactly match the prototype of the; function definition. Furthermore the inliner doesn't consider such function; calls for inlining.; ""``ghccc``"" - GHC convention; This calling convention has been implemented specifically for use by; the `Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_.; It passes everything in registers, going to extremes to achieve this; by disabling callee save registers. This calling convention should; not be used lightly but only for specific situations such as an; alternative to the *register pinning* performance technique often; used when implementing functional programming languages. At the; moment only X86, AArch64, and RISCV support this c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15970,Energy Efficiency,allocate,allocated,15970,"en implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a large register set before and after the; call in the caller. If the arguments are passed in callee-saved registers,; then they will be preserved by the callee across the call. This doesn't; apply for values returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11 and return registers, if any. R11 can be used as a sc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30429,Energy Efficiency,allocate,allocated,30429,"zer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34454,Energy Efficiency,power,power,34454,"ecified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:41967,Energy Efficiency,power,power,41967," temporary in that block will be ""%1"", etc. If a; numeric label is explicitly specified, it must match the numeric label that; would be used implicitly. The first basic block in a function is special in two ways: it is; immediately executed on entrance to the function, and it is not allowed; to have predecessor basic blocks (i.e. there can not be any branches to; the entry block of a function). Because the block can have no; predecessors, it also cannot have any :ref:`PHI nodes <i_phi>`. LLVM allows an explicit section to be specified for functions. If the; target supports it, it will emit functions to the section specified.; Additionally, the function can be placed in a COMDAT. An explicit alignment may be specified for a function. If not present,; or if the alignment is set to zero, the alignment of the function is set; by the target to whatever it feels convenient. If an explicit alignment; is specified, the function is forced to have at least that much; alignment. All alignments must be a power of 2. If the ``unnamed_addr`` attribute is given, the address is known to not; be significant and two identical functions can be merged. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. If an explicit address space is not given, it will default to the program; address space from the :ref:`datalayout string<langref_datalayout>`. .. _langref_aliases:. Aliases; -------. Aliases, unlike function or variables, don't create any new data. They; are just a new symbol and metadata for an existing position. Aliases have a name and an aliasee that is either a global value or a; constant expression. Aliases may have an optional :ref:`linkage type <linkage>`, an optional; :ref:`runtime preemption specifier <runtime_preemption_model>`, an optional; :ref:`visibility style <visibility>`, an optional :ref:`DLL storage class; <dllstorageclass>` and an optional :ref:`tls model <tls_model>`. Syntax::. @<Name> = [Linkage] [Preempt",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:55535,Energy Efficiency,allocate,allocate,55535,"address of outgoing stack arguments. An ``inalloca`` argument must; be a pointer to stack memory produced by an ``alloca`` instruction.; The alloca, or argument allocation, must also be tagged with the; inalloca keyword. Only the last argument may have the ``inalloca``; attribute, and that argument is guaranteed to be passed in memory. An argument allocation may be used by a call at most once because; the call may deallocate it. The ``inalloca`` attribute cannot be; used in conjunction with other attributes that affect argument; storage, like ``inreg``, ``nest``, ``sret``, or ``byval``. The; ``inalloca`` attribute also disables LLVM's implicit lowering of; large aggregate return values, which means that frontend authors; must lower them with ``sret`` pointers. When the call site is reached, the argument allocation must have; been the most recent stack allocation that is still live, or the; behavior is undefined. It is possible to allocate additional stack; space after an argument allocation and before its call site, but it; must be cleared off with :ref:`llvm.stackrestore; <int_stackrestore>`. The inalloca attribute requires a type argument, which must be the; same as the pointee type of the argument. See :doc:`InAlloca` for more information on how to use this; attribute. ``sret(<ty>)``; This indicates that the pointer parameter specifies the address of a; structure that is the return value of the function in the source; program. This pointer must be guaranteed by the caller to be valid:; loads and stores to the structure may be assumed by the callee not; to trap and to be properly aligned. This is not a valid attribute; for return values. The sret type argument specifies the in memory type, which must be; the same as the pointee type of the argument. .. _attr_elementtype:. ``elementtype(<ty>)``. The ``elementtype`` argument attribute can be used to specify a pointer; element type in a way that is compatible with `opaque pointers; <OpaquePointers.html>`__. The ``elem",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:59079,Energy Efficiency,allocate,allocated,59079,"unction, via pointer values not; *based* on the argument or return value. This guarantee only holds for; memory locations that are *modified*, by any means, during the execution of; the function. The attribute on a return value also has additional semantics; described below. The caller shares the responsibility with the callee for; ensuring that these requirements are met. For further details, please see; the discussion of the NoAlias response in :ref:`alias analysis <Must, May,; or No>`. Note that this definition of ``noalias`` is intentionally similar; to the definition of ``restrict`` in C99 for function arguments. For function return values, C99's ``restrict`` is not meaningful,; while LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias``; attribute on return values are stronger than the semantics of the attribute; when used on function arguments. On function return values, the ``noalias``; attribute indicates that the function acts like a system memory allocation; function, returning a pointer to allocated storage disjoint from the; storage for any other object accessible to the caller. .. _nocapture:. ``nocapture``; This indicates that the callee does not :ref:`capture <pointercapture>` the; pointer. This is not a valid attribute for return values.; This attribute applies only to the particular copy of the pointer passed in; this argument. A caller could pass two copies of the same pointer with one; being annotated nocapture and the other not, and the callee could validly; capture through the non annotated parameter. .. code-block:: llvm. define void @f(ptr nocapture %a, ptr %b) {; ; (capture %b); }. call void @f(ptr @glb, ptr @glb) ; well-defined. ``nofree``; This indicates that callee does not free the pointer argument. This is not; a valid attribute for return values. .. _nest:. ``nest``; This indicates that the pointer parameter can be excised using the; :ref:`trampoline intrinsics <int_trampoline>`. This is not a valid; attribute for return ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:68323,Energy Efficiency,allocate,allocated,68323,"tive zero | 32 |; +-------+----------------------+---------------+; | pzero | Positive zero | 64 |; +-------+----------------------+---------------+; | psub | Positive subnormal | 128 |; +-------+----------------------+---------------+; | pnorm | Positive normal | 256 |; +-------+----------------------+---------------+; | pinf | Positive infinity | 512 |; +-------+----------------------+---------------+. ``alignstack(<n>)``; This indicates the alignment that should be considered by the backend when; assigning this parameter to a stack slot during calling convention; lowering. The enforcement of the specified alignment is target-dependent,; as target-specific calling convention rules may override this value. This; attribute serves the purpose of carrying language specific alignment; information that is not mapped to base types in the backend (for example,; over-alignment specification through language attributes). ``allocalign``; The function parameter marked with this attribute is the alignment in bytes of the; newly allocated block returned by this function. The returned value must either have; the specified alignment or be the null pointer. The return value MAY be more aligned; than the requested alignment, but not less aligned. Invalid (e.g. non-power-of-2); alignments are permitted for the allocalign parameter, so long as the returned pointer; is null. This attribute may only be applied to integer parameters. ``allocptr``; The function parameter marked with this attribute is the pointer; that will be manipulated by the allocator. For a realloc-like; function the pointer will be invalidated upon success (but the; same address may be returned), for a free-like function the; pointer will always be invalidated. ``readnone``; This attribute indicates that the function does not dereference that; pointer argument, even though it may read or write the memory that the; pointer points to if accessed through other pointers. If a function reads from or writes to a readnone p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:68559,Energy Efficiency,power,power-of-,68559," | pinf | Positive infinity | 512 |; +-------+----------------------+---------------+. ``alignstack(<n>)``; This indicates the alignment that should be considered by the backend when; assigning this parameter to a stack slot during calling convention; lowering. The enforcement of the specified alignment is target-dependent,; as target-specific calling convention rules may override this value. This; attribute serves the purpose of carrying language specific alignment; information that is not mapped to base types in the backend (for example,; over-alignment specification through language attributes). ``allocalign``; The function parameter marked with this attribute is the alignment in bytes of the; newly allocated block returned by this function. The returned value must either have; the specified alignment or be the null pointer. The return value MAY be more aligned; than the requested alignment, but not less aligned. Invalid (e.g. non-power-of-2); alignments are permitted for the allocalign parameter, so long as the returned pointer; is null. This attribute may only be applied to integer parameters. ``allocptr``; The function parameter marked with this attribute is the pointer; that will be manipulated by the allocator. For a realloc-like; function the pointer will be invalidated upon success (but the; same address may be returned), for a free-like function the; pointer will always be invalidated. ``readnone``; This attribute indicates that the function does not dereference that; pointer argument, even though it may read or write the memory that the; pointer points to if accessed through other pointers. If a function reads from or writes to a readnone pointer argument, the; behavior is undefined. ``readonly``; This attribute indicates that the function does not write through this; pointer argument, even though it may write to the memory that the pointer; points to. If a function writes to a readonly pointer argument, the behavior is; undefined. ``writeonly``; This at",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:77639,Energy Efficiency,power,power,77639,"ack=4 }. ; Target-dependent attributes:; attributes #1 = { ""no-sse"" }. ; Function @f has attributes: alwaysinline, alignstack=4, and ""no-sse"".; define void @f() #0 #1 { ... }. .. _fnattrs:. Function Attributes; -------------------. Function attributes are set to communicate additional information about; a function. Function attributes are considered to be part of the; function, not of the function type, so functions with different function; attributes can have the same function type. Function attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses.; ``""alloc-family""=""FAMILY""``; This indicates which ""family"" an allocator function is part of. To avoid; collisions, the family name should match the mangled name of the primary; allocator function, that is ""malloc"" for malloc/calloc/realloc/free,; ""_Znwm"" for ``::operator::new`` and ``::operator::delete``, and; ""_ZnwmSt11align_val_t"" for aligned ``::operator::new`` and; ``::operator::delete``. Matching malloc/realloc/free calls within a family; can be optimized, but mismatched ones will be left alone.; ``allockind(""KIND"")``; Describes the behavior of an allocation function. The KIND string contains comma; separated entries from the following options:. * ""alloc"": the function returns a new block of memory or null.; * ""realloc"": the function returns a new block of memory or null. If the; result is non-null the memory contents from the start of the block up to; the smaller of the original allocation size and the new allocation size; will match that ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:78920,Energy Efficiency,allocate,allocated,78920,"e``, and; ""_ZnwmSt11align_val_t"" for aligned ``::operator::new`` and; ``::operator::delete``. Matching malloc/realloc/free calls within a family; can be optimized, but mismatched ones will be left alone.; ``allockind(""KIND"")``; Describes the behavior of an allocation function. The KIND string contains comma; separated entries from the following options:. * ""alloc"": the function returns a new block of memory or null.; * ""realloc"": the function returns a new block of memory or null. If the; result is non-null the memory contents from the start of the block up to; the smaller of the original allocation size and the new allocation size; will match that of the ``allocptr`` argument and the ``allocptr``; argument is invalidated, even if the function returns the same address.; * ""free"": the function frees the block of memory specified by ``allocptr``.; Functions marked as ""free"" ``allockind`` must return void.; * ""uninitialized"": Any newly-allocated memory (either a new block from; a ""alloc"" function or the enlarged capacity from a ""realloc"" function); will be uninitialized.; * ""zeroed"": Any newly-allocated memory (either a new block from a ""alloc""; function or the enlarged capacity from a ""realloc"" function) will be; zeroed.; * ""aligned"": the function returns memory aligned according to the; ``allocalign`` parameter. The first three options are mutually exclusive, and the remaining options; describe more details of how the function behaves. The remaining options; are invalid for ""free""-type functions.; ``allocsize(<EltSizeParam>[, <NumEltsParam>])``; This attribute indicates that the annotated function will always return at; least a given number of bytes (or null). Its arguments are zero-indexed; parameter numbers; if one argument is provided, then it's assumed that at; least ``CallSite.Args[EltSizeParam]`` bytes will be available at the; returned pointer. If two are provided, then it's assumed that; ``CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]`` bytes are;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:79081,Energy Efficiency,allocate,allocated,79081,"d, but mismatched ones will be left alone.; ``allockind(""KIND"")``; Describes the behavior of an allocation function. The KIND string contains comma; separated entries from the following options:. * ""alloc"": the function returns a new block of memory or null.; * ""realloc"": the function returns a new block of memory or null. If the; result is non-null the memory contents from the start of the block up to; the smaller of the original allocation size and the new allocation size; will match that of the ``allocptr`` argument and the ``allocptr``; argument is invalidated, even if the function returns the same address.; * ""free"": the function frees the block of memory specified by ``allocptr``.; Functions marked as ""free"" ``allockind`` must return void.; * ""uninitialized"": Any newly-allocated memory (either a new block from; a ""alloc"" function or the enlarged capacity from a ""realloc"" function); will be uninitialized.; * ""zeroed"": Any newly-allocated memory (either a new block from a ""alloc""; function or the enlarged capacity from a ""realloc"" function) will be; zeroed.; * ""aligned"": the function returns memory aligned according to the; ``allocalign`` parameter. The first three options are mutually exclusive, and the remaining options; describe more details of how the function behaves. The remaining options; are invalid for ""free""-type functions.; ``allocsize(<EltSizeParam>[, <NumEltsParam>])``; This attribute indicates that the annotated function will always return at; least a given number of bytes (or null). Its arguments are zero-indexed; parameter numbers; if one argument is provided, then it's assumed that at; least ``CallSite.Args[EltSizeParam]`` bytes will be available at the; returned pointer. If two are provided, then it's assumed that; ``CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]`` bytes are; available. The referenced parameters must be integer types. No assumptions; are made about the contents of the returned block of memory.; ``alwaysinline``; This",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:89873,Energy Efficiency,allocate,allocated,89873,"`` call may still; be an inlining candidate, provided that the call is not; duplicated by inlining. That implies that the function has; internal linkage and only has one call site, so the original; call is dead after inlining.; ``nofree``; This function attribute indicates that the function does not, directly or; transitively, call a memory-deallocation function (``free``, for example); on a memory allocation which existed before the call. As a result, uncaptured pointers that are known to be dereferenceable; prior to a call to a function with the ``nofree`` attribute are still; known to be dereferenceable after the call. The capturing condition is; necessary in environments where the function might communicate the; pointer to another thread which then deallocates the memory. Alternatively,; ``nosync`` would ensure such communication cannot happen and even captured; pointers cannot be freed by the function. A ``nofree`` function is explicitly allowed to free memory which it; allocated or (if not ``nosync``) arrange for another thread to free; memory on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:91154,Energy Efficiency,reduce,reduces,91154,"ing-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``nonlazybind``; This attribute suppresses lazy symbol binding for the function. This; may make calls to the function faster, at the cost of extra program; startup time if the function is not called during program startup.; ``noprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. It; also blocks inlining if the caller and callee have different values of this; attribute.; ``skipprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. This; attribute does not restrict inlining, so instrumented instruction could end; up in this function.; ``noredzone``; This attribute indicates that the code generator should not us",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:96600,Energy Efficiency,reduce,reduce,96600,"e is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requir",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108549,Energy Efficiency,reduce,reduce,108549,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:111090,Energy Efficiency,power,power-of-two,111090,"equirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked together with differing values.; ``vscale_range(<min>[, <max>])``; This function attribute indicates `vscale` is a power-of-two within a; specified range. `min` must be a power-of-two that is greater than 0. When; specified, `max` must be a power-of-two greater-than-or-equal to `min` or 0; to signify an unbounded maximum. The syntax `vscale_range(<val>)` can be; used to set both `min` and `max` to the same value. Functions that don't; include this attribute make no assumptions about the value of `vscale`.; ``""nooutline""``; This attribute indicates that outlining passes should not modify the; function. Call Site Attributes; ----------------------. In addition to function attributes the following call site only; attributes are supported:. ``vector-function-abi-variant``; This attribute can be attached to a :ref:`call <i_call>` to list; the vector functions associated to the function. Notice that the; attribute cannot be attached to a :ref:`invoke <i_invoke>` or a; :ref:`callbr <i_callbr>` instruction. The attribute consists of a; comma separated list of mangled names. The order ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:111146,Energy Efficiency,power,power-of-two,111146,"nce, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked together with differing values.; ``vscale_range(<min>[, <max>])``; This function attribute indicates `vscale` is a power-of-two within a; specified range. `min` must be a power-of-two that is greater than 0. When; specified, `max` must be a power-of-two greater-than-or-equal to `min` or 0; to signify an unbounded maximum. The syntax `vscale_range(<val>)` can be; used to set both `min` and `max` to the same value. Functions that don't; include this attribute make no assumptions about the value of `vscale`.; ``""nooutline""``; This attribute indicates that outlining passes should not modify the; function. Call Site Attributes; ----------------------. In addition to function attributes the following call site only; attributes are supported:. ``vector-function-abi-variant``; This attribute can be attached to a :ref:`call <i_call>` to list; the vector functions associated to the function. Notice that the; attribute cannot be attached to a :ref:`invoke <i_invoke>` or a; :ref:`callbr <i_callbr>` instruction. The attribute consists of a; comma separated list of mangled names. The order of the list does; not imply preference (it is logically a set). The compiler is free; to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:111216,Energy Efficiency,power,power-of-two,111216,"ate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked together with differing values.; ``vscale_range(<min>[, <max>])``; This function attribute indicates `vscale` is a power-of-two within a; specified range. `min` must be a power-of-two that is greater than 0. When; specified, `max` must be a power-of-two greater-than-or-equal to `min` or 0; to signify an unbounded maximum. The syntax `vscale_range(<val>)` can be; used to set both `min` and `max` to the same value. Functions that don't; include this attribute make no assumptions about the value of `vscale`.; ``""nooutline""``; This attribute indicates that outlining passes should not modify the; function. Call Site Attributes; ----------------------. In addition to function attributes the following call site only; attributes are supported:. ``vector-function-abi-variant``; This attribute can be attached to a :ref:`call <i_call>` to list; the vector functions associated to the function. Notice that the; attribute cannot be attached to a :ref:`invoke <i_invoke>` or a; :ref:`callbr <i_callbr>` instruction. The attribute consists of a; comma separated list of mangled names. The order of the list does; not imply preference (it is logically a set). The compiler is free; to pick any listed vector function of its choosing. The syntax for the mangled names i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:125150,Energy Efficiency,power,power-of-two,125150," example:. .. code-block:: llvm. call void @llvm.assume(i1 true) [""align""(ptr %val, i32 8)]. allows the optimizer to assume that at location of call to; :ref:`llvm.assume <int_assume>` ``%val`` has an alignment of at least 8. .. code-block:: llvm. call void @llvm.assume(i1 %cond) [""cold""(), ""nonnull""(ptr %val)]. allows the optimizer to assume that the :ref:`llvm.assume <int_assume>`; call location is cold and that ``%val`` may not be null. Just like for the argument of :ref:`llvm.assume <int_assume>`, if any of the; provided guarantees are violated at runtime the behavior is undefined. While attributes expect constant arguments, assume operand bundles may be; provided a dynamic value, for example:. .. code-block:: llvm. call void @llvm.assume(i1 true) [""align""(ptr %val, i32 %align)]. If the operand bundle value violates any requirements on the attribute value,; the behavior is undefined, unless one of the following exceptions applies:. * ``""align""`` operand bundles may specify a non-power-of-two alignment; (including a zero alignment). If this is the case, then the pointer value; must be a null pointer, otherwise the behavior is undefined. In addition to allowing operand bundles encoding function and parameter; attributes, an assume operand bundle my also encode a ``separate_storage``; operand bundle. This has the form:. .. code-block:: llvm. separate_storage(<val1>, <val2>)``. This indicates that no pointer :ref:`based <pointeraliasing>` on one of its; arguments can alias any pointer based on the other. Even if the assumed property can be encoded as a boolean value, like; ``nonnull``, using operand bundles to express the property can still have; benefits:. * Attributes that can be expressed via operand bundles are directly the; property that the optimizer uses and cares about. Encoding attributes as; operand bundles removes the need for an instruction sequence that represents; the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the; optimizer to deduc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:136473,Energy Efficiency,efficient,efficiently,136473,": GOFF mangling: Private symbols get a ``@`` prefix.; * ``m``: Mips mangling: Private symbols get a ``$`` prefix.; * ``o``: Mach-O mangling: Private symbols get ``L`` prefix. Other; symbols get a ``_`` prefix.; * ``x``: Windows x86 COFF mangling: Private symbols get the usual prefix.; Regular C symbols get a ``_`` prefix. Functions with ``__stdcall``,; ``__fastcall``, and ``__vectorcall`` have custom mangling that appends; ``@N`` where N is the number of bytes used to pass parameters. C++ symbols; starting with ``?`` are not mangled in any way.; * ``w``: Windows COFF mangling: Similar to ``x``, except that normal C; symbols do not receive a ``_`` prefix.; * ``a``: XCOFF mangling: Private symbols get a ``L..`` prefix.; ``n<size1>:<size2>:<size3>...``; This specifies a set of native integer widths for the target CPU in; bits. For example, it might contain ``n32`` for 32-bit PowerPC,; ``n32:64`` for PowerPC 64, or ``n8:16:32:64`` for X86-64. Elements of; this set are considered to support most general arithmetic operations; efficiently.; ``ni:<address space0>:<address space1>:<address space2>...``; This specifies pointer types with the specified address spaces; as :ref:`Non-Integral Pointer Type <nointptrtype>` s. The ``0``; address space cannot be specified as non-integral. On every specification that takes a ``<abi>:<pref>``, specifying the; ``<pref>`` alignment is optional. If omitted, the preceding ``:``; should be omitted too and ``<pref>`` will be equal to ``<abi>``. When constructing the data layout for a given target, LLVM starts with a; default set of specifications which are then (possibly) overridden by; the specifications in the ``datalayout`` keyword. The default; specifications are given in this list:. - ``e`` - little endian; - ``p:64:64:64`` - 64-bit pointers with 64-bit alignment.; - ``p[n]:64:64:64`` - Other address spaces are assumed to be the; same as the default address space.; - ``S0`` - natural stack alignment is unspecified; - ``i1:8:8`` - i1 is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140348,Energy Efficiency,allocate,allocated,140348,"gref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done thro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:141908,Energy Efficiency,allocate,allocated,141908,"; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the vector-of-pointers-typed operand; of the ``getelementptr``.; - The result value of a ``bitcast`` is *based*",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:142247,Energy Efficiency,allocate,allocated,142247,"`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the vector-of-pointers-typed operand; of the ``getelementptr``.; - The result value of a ``bitcast`` is *based* on the operand of the; ``bitcast``.; - A pointer value formed by an ``inttoptr`` is *based* on all pointer; values that contribute (directly or indirectly) to the computation of; the pointer's value.; - The ""*based* on"" relationship is transitive. Note that this definition of *""based""* is intentionally similar to the; definition of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:142372,Energy Efficiency,allocate,allocated,142372,"-------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the vector-of-pointers-typed operand; of the ``getelementptr``.; - The result value of a ``bitcast`` is *based* on the operand of the; ``bitcast``.; - A pointer value formed by an ``inttoptr`` is *based* on all pointer; values that contribute (directly or indirectly) to the computation of; the pointer's value.; - The ""*based* on"" relationship is transitive. Note that this definition of *""based""* is intentionally similar to the; definition of *""based""* in C99, though it is slightly weaker. LLVM IR does not associate types with memory. The result type of a; ``load`` merely indicates the size and al",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:169323,Energy Efficiency,reduce,reduced,169323," simple type that simply specifies an; arbitrary bit width for the integer type desired. Any bit width from 1; bit to 2\ :sup:`23`\ (about 8 million) can be specified. :Syntax:. ::. iN. The number of bits the integer will occupy is specified by the ``N``; value. Examples:; *********. +----------------+------------------------------------------------+; | ``i1`` | a single-bit integer. |; +----------------+------------------------------------------------+; | ``i32`` | a 32-bit integer. |; +----------------+------------------------------------------------+; | ``i1942652`` | a really big integer of over 1 million bits. |; +----------------+------------------------------------------------+. .. _t_floating:. Floating-Point Types; """""""""""""""""""""""""""""""""""""""". .. list-table::; :header-rows: 1. * - Type; - Description. * - ``half``; - 16-bit floating-point value. * - ``bfloat``; - 16-bit ""brain"" floating-point value (7-bit significand). Provides the; same number of exponent bits as ``float``, so that it matches its dynamic; range, but with greatly reduced precision. Used in Intel's AVX-512 BF16; extensions and Arm's ARMv8.6-A extensions, among others. * - ``float``; - 32-bit floating-point value. * - ``double``; - 64-bit floating-point value. * - ``fp128``; - 128-bit floating-point value (113-bit significand). * - ``x86_fp80``; - 80-bit floating-point value (X87). * - ``ppc_fp128``; - 128-bit floating-point value (two 64-bits). The binary format of half, float, double, and fp128 correspond to the; IEEE-754-2008 specifications for binary16, binary32, binary64, and binary128; respectively. X86_amx Type; """""""""""""""""""""""". :Overview:. The x86_amx type represents a value held in an AMX tile register on an x86; machine. The operations allowed on it are quite limited. Only few intrinsics; are allowed: stride load and store, zero and dot product. No instruction is; allowed for this type. There are no arguments, arrays, pointers, vectors; or constants of this type. :Syntax:. ::. x86_amx. X86_mm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:180910,Energy Efficiency,allocate,allocated,180910,"-------------------------------+; | ``[41 x i32]`` | Array of 41 32-bit integer values. |; +------------------+--------------------------------------+; | ``[4 x i8]`` | Array of 4 8-bit integer values. |; +------------------+--------------------------------------+. Here are some examples of multidimensional arrays:. +-----------------------------+----------------------------------------------------------+; | ``[3 x [4 x i32]]`` | 3x4 array of 32-bit integer values. |; +-----------------------------+----------------------------------------------------------+; | ``[12 x [10 x float]]`` | 12x10 array of single precision floating-point values. |; +-----------------------------+----------------------------------------------------------+; | ``[2 x [3 x [4 x i16]]]`` | 2x3x4 array of 16-bit integer values. |; +-----------------------------+----------------------------------------------------------+. There is no restriction on indexing beyond the end of the array implied; by a static type (though there are restrictions on indexing beyond the; bounds of an allocated object in some cases). This means that; single-dimension 'variable sized array' addressing can be implemented in; LLVM with a zero length array type. An implementation of 'pascal style; arrays' in LLVM could use the type ""``{ i32, [0 x float]}``"", for; example. .. _t_struct:. Structure Type; """""""""""""""""""""""""""". :Overview:. The structure type is used to represent a collection of data members; together in memory. The elements of a structure may be any type that has; a size. Structures in memory are accessed using '``load``' and '``store``' by; getting a pointer to a field with the '``getelementptr``' instruction.; Structures in registers are accessed using the '``extractvalue``' and; '``insertvalue``' instructions. Structures may optionally be ""packed"" structures, which indicate that; the alignment of the struct is one byte, and that there is no padding; between the elements. In non-packed structs, padding between field",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:211207,Energy Efficiency,allocate,allocate,211207,"gnstack``' keyword second, the '``inteldialect``' keyword; third and the '``unwind``' keyword last. Inline Asm Constraint String; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The constraint list is a comma-separated string, each element containing one or; more constraint codes. For each element in the constraint list an appropriate register or memory; operand will be chosen, and it will be made available to assembly template; string expansion as ``$0`` for the first constraint in the list, ``$1`` for the; second, etc. There are three different types of constraints, which are distinguished by a; prefix symbol in front of the constraint code: Output, Input, and Clobber. The; constraints must always be given in that order: outputs first, then inputs, then; clobbers. They cannot be intermingled. There are also three different categories of constraint codes:. - Register constraint. This is either a register class, or a fixed physical; register. This kind of constraint will allocate a register, and if necessary,; bitcast the argument or result to the appropriate type.; - Memory constraint. This kind of constraint is for use with an instruction; taking a memory operand. Different constraints allow for different addressing; modes used by the target.; - Immediate value constraint. This kind of constraint is for an integer or other; immediate value which can be rendered directly into an instruction. The; various target-specific constraints allow the selection of a value in the; proper range for the instruction you wish to use it with. Output constraints; """""""""""""""""""""""""""""""""""". Output constraints are specified by an ""``=``"" prefix (e.g. ""``=r``""). This; indicates that the assembly will write to this operand, and the operand will; then be made available as a return value of the ``asm`` expression. Output; constraints do not consume an argument from the call instruction. (Except, see; below about indirect outputs). Normally, it is expected that no output locations are written to by the assembly; e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:214271,Energy Efficiency,allocate,allocates,214271," may also ""tie""; themselves to an output constraint, by providing an integer as the constraint; string. Tied inputs still consume an argument from the call instruction, and; take up a position in the asm template numbering as is usual -- they will simply; be constrained to always use the same register as the output they've been tied; to. For example, a constraint string of ""``=r,0``"" says to assign a register for; output, and use that register as an input as well (it being the 0'th; constraint). It is permitted to tie an input to an ""early-clobber"" output. In that case, no; *other* input may share the same register as the input tied to the early-clobber; (even when the other input has the same value). You may only tie an input to an output which has a register constraint, not a; memory constraint. Only a single input may be tied to an output. There is also an ""interesting"" feature which deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably bet",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:215205,Energy Efficiency,allocate,allocated,215205,"hich deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). Thi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:216439,Energy Efficiency,allocate,allocate,216439,"is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). This is most typically used for memory constraint, e.g. ""``=*m``"", to pass the; address of a variable as a value. It is also possible to use an indirect *register* constraint, but only on output; (e.g. ""``=*r``""). This will cause LLVM to allocate a register for an output; value normally, and then, separately emit a store to the address provided as; input, after the provided inline asm. (It's not clear what value this; functionality provides, compared to writing the store explicitly after the asm; statement, and it can only produce worse code, since it bypasses many; optimization passes. I would recommend not using it.). Call arguments for indirect constraints must have pointer type and must specify; the :ref:`elementtype <attr_elementtype>` attribute to indicate the pointer; element type. Clobber constraints; """""""""""""""""""""""""""""""""""""". A clobber constraint is indicated by a ""``~``"" prefix. A clobber does not; consume an input operand, nor generate an output. Clobbers cannot use any of the; general constraint code letters -- they may use only explicit register; constraints, e.g. ""``~{eax}``"". The one exception is that a clobber string of; ""``~{memory}``"" indicates that the assembly writes to arbitrary undeclared; memory locations -- not only the memory pointed to by a declared indirect; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:225197,Energy Efficiency,power,power,225197,"to two ""A"" constants.; - ``DB``: A 64-bit constant that can be split into two ""B"" constants. All ARM modes:. - ``Q``, ``Um``, ``Un``, ``Uq``, ``Us``, ``Ut``, ``Uv``, ``Uy``: Memory address; operand. Treated the same as operand ``m``, at the moment.; - ``Te``: An even general-purpose 32-bit integer register: ``r0,r2,...,r12,r14``; - ``To``: An odd general-purpose 32-bit integer register: ``r1,r3,...,r11``. ARM and ARM's Thumb2 mode:. - ``j``: An immediate integer between 0 and 65535 (valid for ``MOVW``); - ``I``: An immediate integer valid for a data-processing instruction.; - ``J``: An immediate integer between -4095 and 4095.; - ``K``: An immediate integer whose bitwise inverse is valid for a; data-processing instruction. (Can be used with template modifier ""``B``"" to; print the inverted value).; - ``L``: An immediate integer whose negation is valid for a data-processing; instruction. (Can be used with template modifier ""``n``"" to print the negated; value).; - ``M``: A power of two or an integer between 0 and 32.; - ``N``: Invalid immediate constraint.; - ``O``: Invalid immediate constraint.; - ``r``: A general-purpose 32-bit integer register (``r0-r15``).; - ``l``: In Thumb2 mode, low 32-bit GPR registers (``r0-r7``). In ARM mode, same; as ``r``.; - ``h``: In Thumb2 mode, a high 32-bit GPR register (``r8-r15``). In ARM mode,; invalid.; - ``w``: A 32, 64, or 128-bit floating-point/SIMD register in the ranges; ``s0-s31``, ``d0-d31``, or ``q0-q15``, respectively.; - ``t``: A 32, 64, or 128-bit floating-point/SIMD register in the ranges; ``s0-s31``, ``d0-d15``, or ``q0-q7``, respectively.; - ``x``: A 32, 64, or 128-bit floating-point/SIMD register in the ranges; ``s0-s15``, ``d0-d7``, or ``q0-q3``, respectively. ARM's Thumb1 mode:. - ``I``: An immediate integer between 0 and 255.; - ``J``: An immediate integer between -255 and -1.; - ``K``: An immediate integer between 0 and 255, with optional left-shift by; some amount.; - ``L``: An immediate integer between -7 and 7.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:229727,Energy Efficiency,power,power,229727,"iven subtarget (details vary).; - ``r``, ``d``, ``y``: A 32 or 64-bit GPR register.; - ``f``: A 32 or 64-bit FPU register (``F0-F31``), or a 128-bit MSA register; (``W0-W31``). In the case of MSA registers, it is recommended to use the ``w``; argument modifier for compatibility with GCC.; - ``c``: A 32-bit or 64-bit GPR register suitable for indirect jump (always; ``25``).; - ``l``: The ``lo`` register, 32 or 64-bit.; - ``x``: Invalid. NVPTX:. - ``b``: A 1-bit integer register.; - ``c`` or ``h``: A 16-bit integer register.; - ``r``: A 32-bit integer register.; - ``l`` or ``N``: A 64-bit integer register.; - ``f``: A 32-bit float register.; - ``d``: A 64-bit float register. PowerPC:. - ``I``: An immediate signed 16-bit integer.; - ``J``: An immediate unsigned 16-bit integer, shifted left 16 bits.; - ``K``: An immediate unsigned 16-bit integer.; - ``L``: An immediate signed 16-bit integer, shifted left 16 bits.; - ``M``: An immediate integer greater than 31.; - ``N``: An immediate integer that is an exact power of 2.; - ``O``: The immediate integer constant 0.; - ``P``: An immediate integer constant whose negation is a signed 16-bit; constant.; - ``es``, ``o``, ``Q``, ``Z``, ``Zy``: A memory address operand, currently; treated the same as ``m``.; - ``r``: A 32 or 64-bit integer register.; - ``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is:; ``R1-R31``).; - ``f``: A 32 or 64-bit float register (``F0-F31``),; - ``v``: For ``4 x f32`` or ``4 x f64`` types, a 128-bit altivec vector; register (``V0-V31``). - ``y``: Condition register (``CR0-CR7``).; - ``wc``: An individual CR bit in a CR register.; - ``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full VSX; register set (overlapping both the floating-point and vector register files).; - ``ws``: A 32 or 64-bit floating-point register, from the full VSX register; set. RISC-V:. - ``A``: An address operand (using a general-purpose register, without an; offset).; - ``I``: A 12-bit signed integ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:234047,Energy Efficiency,allocate,allocates,234047,"64, it is all of the integer registers.; - ``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit; ``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` registers.; - ``r`` or ``l``: An 8, 16, 32, or 64-bit integer register.; - ``R``: An 8, 16, 32, or 64-bit ""legacy"" integer register -- one which has; existed since i386, and can be accessed without the REX prefix.; - ``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register.; - ``y``: A 64-bit MMX register, if MMX is enabled.; - ``v``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector; operand in a SSE register. If AVX is also enabled, can also be a 256-bit; vector operand in an AVX register. If AVX-512 is also enabled, can also be a; 512-bit vector operand in an AVX512 register. Otherwise, an error.; - ``Ws``: A symbolic reference with an optional constant addend or a label; reference.; - ``x``: The same as ``v``, except that when AVX-512 is enabled, the ``x`` code; only allocates into the first 16 AVX-512 registers, while the ``v`` code; allocates into any of the 32 AVX-512 registers.; - ``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error.; - ``A``: Special case: allocates EAX first, then EDX, for a single operand (in; 32-bit mode, a 64-bit integer operand will get split into two registers). It; is not recommended to use this constraint, as in 64-bit mode, the 64-bit; operand will get allocated only to RAX -- if two 32-bit operands are needed,; you're better off splitting it yourself, before passing it to the asm; statement. XCore:. - ``r``: A 32-bit integer register. .. _inline-asm-modifiers:. Asm template argument modifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In the asm template string, modifiers can be used on the operand reference, like; ""``${0:n}``"". The modifiers are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:234116,Energy Efficiency,allocate,allocates,234116,"64, it is all of the integer registers.; - ``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit; ``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` registers.; - ``r`` or ``l``: An 8, 16, 32, or 64-bit integer register.; - ``R``: An 8, 16, 32, or 64-bit ""legacy"" integer register -- one which has; existed since i386, and can be accessed without the REX prefix.; - ``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register.; - ``y``: A 64-bit MMX register, if MMX is enabled.; - ``v``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector; operand in a SSE register. If AVX is also enabled, can also be a 256-bit; vector operand in an AVX register. If AVX-512 is also enabled, can also be a; 512-bit vector operand in an AVX512 register. Otherwise, an error.; - ``Ws``: A symbolic reference with an optional constant addend or a label; reference.; - ``x``: The same as ``v``, except that when AVX-512 is enabled, the ``x`` code; only allocates into the first 16 AVX-512 registers, while the ``v`` code; allocates into any of the 32 AVX-512 registers.; - ``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error.; - ``A``: Special case: allocates EAX first, then EDX, for a single operand (in; 32-bit mode, a 64-bit integer operand will get split into two registers). It; is not recommended to use this constraint, as in 64-bit mode, the 64-bit; operand will get allocated only to RAX -- if two 32-bit operands are needed,; you're better off splitting it yourself, before passing it to the asm; statement. XCore:. - ``r``: A 32-bit integer register. .. _inline-asm-modifiers:. Asm template argument modifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In the asm template string, modifiers can be used on the operand reference, like; ""``${0:n}``"". The modifiers are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:234259,Energy Efficiency,allocate,allocates,234259,"ister.; - ``R``: An 8, 16, 32, or 64-bit ""legacy"" integer register -- one which has; existed since i386, and can be accessed without the REX prefix.; - ``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register.; - ``y``: A 64-bit MMX register, if MMX is enabled.; - ``v``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector; operand in a SSE register. If AVX is also enabled, can also be a 256-bit; vector operand in an AVX register. If AVX-512 is also enabled, can also be a; 512-bit vector operand in an AVX512 register. Otherwise, an error.; - ``Ws``: A symbolic reference with an optional constant addend or a label; reference.; - ``x``: The same as ``v``, except that when AVX-512 is enabled, the ``x`` code; only allocates into the first 16 AVX-512 registers, while the ``v`` code; allocates into any of the 32 AVX-512 registers.; - ``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error.; - ``A``: Special case: allocates EAX first, then EDX, for a single operand (in; 32-bit mode, a 64-bit integer operand will get split into two registers). It; is not recommended to use this constraint, as in 64-bit mode, the 64-bit; operand will get allocated only to RAX -- if two 32-bit operands are needed,; you're better off splitting it yourself, before passing it to the asm; statement. XCore:. - ``r``: A 32-bit integer register. .. _inline-asm-modifiers:. Asm template argument modifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In the asm template string, modifiers can be used on the operand reference, like; ""``${0:n}``"". The modifiers are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Target-independent:. - ``c``: Print an immediate integer constant unadorned, without; the target-specific immediate punctuation (e.g. no ``$`` prefix).; - ``n``: Negate and pr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:234485,Energy Efficiency,allocate,allocated,234485,"udo-register.; - ``y``: A 64-bit MMX register, if MMX is enabled.; - ``v``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector; operand in a SSE register. If AVX is also enabled, can also be a 256-bit; vector operand in an AVX register. If AVX-512 is also enabled, can also be a; 512-bit vector operand in an AVX512 register. Otherwise, an error.; - ``Ws``: A symbolic reference with an optional constant addend or a label; reference.; - ``x``: The same as ``v``, except that when AVX-512 is enabled, the ``x`` code; only allocates into the first 16 AVX-512 registers, while the ``v`` code; allocates into any of the 32 AVX-512 registers.; - ``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error.; - ``A``: Special case: allocates EAX first, then EDX, for a single operand (in; 32-bit mode, a 64-bit integer operand will get split into two registers). It; is not recommended to use this constraint, as in 64-bit mode, the 64-bit; operand will get allocated only to RAX -- if two 32-bit operands are needed,; you're better off splitting it yourself, before passing it to the asm; statement. XCore:. - ``r``: A 32-bit integer register. .. _inline-asm-modifiers:. Asm template argument modifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In the asm template string, modifiers can be used on the operand reference, like; ""``${0:n}``"". The modifiers are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Target-independent:. - ``c``: Print an immediate integer constant unadorned, without; the target-specific immediate punctuation (e.g. no ``$`` prefix).; - ``n``: Negate and print immediate integer constant unadorned, without the; target-specific immediate punctuation (e.g. no ``$`` prefix).; - ``l``: Print as an unadorned label, without the target-specific label; punct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:237322,Energy Efficiency,allocate,allocated,237322,"e integer constant.; - ``M``: Print as a register set suitable for ldm/stm. Also prints *all*; register operands subsequent to the specified one (!), so use carefully.; - ``Q``: Print the low-order register of a register-pair, or the low-order; register of a two-register operand.; - ``R``: Print the high-order register of a register-pair, or the high-order; register of a two-register operand.; - ``H``: Print the second register of a register-pair. (On a big-endian system,; ``H`` is equivalent to ``Q``, and on little-endian system, ``H`` is equivalent; to ``R``.). .. FIXME: H doesn't currently support printing the second register; of a two-register operand. - ``e``: Print the low doubleword register of a NEON quad register.; - ``f``: Print the high doubleword register of a NEON quad register.; - ``m``: Print the base register of a memory operand without the ``[`` and ``]``; adornment. Hexagon:. - ``L``: Print the second register of a two-register operand. Requires that it; has been allocated consecutively to the first. .. FIXME: why is it restricted to consecutive ones? And there's; nothing that ensures that happens, is there?. - ``I``: Print the letter 'i' if the operand is an integer constant, otherwise; nothing. Used to print 'addi' vs 'add' instructions. LoongArch:. - ``z``: Print $zero register if operand is zero, otherwise print it normally. MSP430:. No additional modifiers. MIPS:. - ``X``: Print an immediate integer as hexadecimal; - ``x``: Print the low 16 bits of an immediate integer as hexadecimal.; - ``d``: Print an immediate integer as decimal.; - ``m``: Subtract one and print an immediate integer as decimal.; - ``z``: Print $0 if an immediate zero, otherwise print normally.; - ``L``: Print the low-order register of a two-register operand, or prints the; address of the low-order word of a double-word memory operand. .. FIXME: L seems to be missing memory operand support. - ``M``: Print the high-order register of a two-register operand, or prints the; addre",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:238968,Energy Efficiency,allocate,allocated,238968,".; - ``z``: Print $0 if an immediate zero, otherwise print normally.; - ``L``: Print the low-order register of a two-register operand, or prints the; address of the low-order word of a double-word memory operand. .. FIXME: L seems to be missing memory operand support. - ``M``: Print the high-order register of a two-register operand, or prints the; address of the high-order word of a double-word memory operand. .. FIXME: M seems to be missing memory operand support. - ``D``: Print the second register of a two-register operand, or prints the; second word of a double-word memory operand. (On a big-endian system, ``D`` is; equivalent to ``L``, and on little-endian system, ``D`` is equivalent to; ``M``.); - ``w``: No effect. Provided for compatibility with GCC which requires this; modifier in order to print MSA registers (``W0-W31``) with the ``f``; constraint. NVPTX:. - ``r``: No effect. PowerPC:. - ``L``: Print the second register of a two-register operand. Requires that it; has been allocated consecutively to the first. .. FIXME: why is it restricted to consecutive ones? And there's; nothing that ensures that happens, is there?. - ``I``: Print the letter 'i' if the operand is an integer constant, otherwise; nothing. Used to print 'addi' vs 'add' instructions.; - ``y``: For a memory operand, prints formatter for a two-register X-form; instruction. (Currently always prints ``r0,OPERAND``).; - ``U``: Prints 'u' if the memory operand is an update form, and nothing; otherwise. (NOTE: LLVM does not support update form, so this will currently; always print nothing); - ``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM does; not support indexed form, so this will currently always print nothing). RISC-V:. - ``i``: Print the letter 'i' if the operand is not a register, otherwise print; nothing. Used to print 'addi' vs 'add' instructions, etc.; - ``z``: Print the register ``zero`` if an immediate zero, otherwise print; normally. Sparc:. - ``L``: Print the low",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:252981,Energy Efficiency,allocate,allocated,252981,"9; DW_TAG_union_type = 23. For ``DW_TAG_array_type``, the ``elements:`` should be :ref:`subrange; descriptors <DISubrange>`, each representing the range of subscripts at that; level of indexing. The ``DIFlagVector`` flag to ``flags:`` indicates that an; array type is a native packed vector. The optional ``dataLocation`` is a; DIExpression that describes how to get from an object's address to the actual; raw data, if they aren't equivalent. This is only supported for array types,; particularly to describe Fortran arrays, which have an array descriptor in; addition to the array data. Alternatively it can also be DIVariable which; has the address of the actual raw data. The Fortran language supports pointer; arrays which can be attached to actual arrays, this attachment between pointer; and pointee is called association. The optional ``associated`` is a; DIExpression that describes whether the pointer array is currently associated.; The optional ``allocated`` is a DIExpression that describes whether the; allocatable array is currently allocated. The optional ``rank`` is a; DIExpression that describes the rank (number of dimensions) of fortran assumed; rank array (rank is known at runtime). For ``DW_TAG_enumeration_type``, the ``elements:`` should be :ref:`enumerator; descriptors <DIEnumerator>`, each representing the definition of an enumeration; value for the set. All enumeration type descriptors are collected in the; ``enums:`` field of the :ref:`compile unit <DICompileUnit>`. For ``DW_TAG_structure_type``, ``DW_TAG_class_type``, and; ``DW_TAG_union_type``, the ``elements:`` should be :ref:`derived types; <DIDerivedType>` with ``tag: DW_TAG_member``, ``tag: DW_TAG_inheritance``, or; ``tag: DW_TAG_friend``; or :ref:`subprograms <DISubprogram>` with; ``isDefinition: false``. .. _DISubrange:. DISubrange; """""""""""""""""""". ``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of; :ref:`DICompositeType`. - ``count: -1`` indicates an empty array.; - ``count: !",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:253070,Energy Efficiency,allocate,allocated,253070,"9; DW_TAG_union_type = 23. For ``DW_TAG_array_type``, the ``elements:`` should be :ref:`subrange; descriptors <DISubrange>`, each representing the range of subscripts at that; level of indexing. The ``DIFlagVector`` flag to ``flags:`` indicates that an; array type is a native packed vector. The optional ``dataLocation`` is a; DIExpression that describes how to get from an object's address to the actual; raw data, if they aren't equivalent. This is only supported for array types,; particularly to describe Fortran arrays, which have an array descriptor in; addition to the array data. Alternatively it can also be DIVariable which; has the address of the actual raw data. The Fortran language supports pointer; arrays which can be attached to actual arrays, this attachment between pointer; and pointee is called association. The optional ``associated`` is a; DIExpression that describes whether the pointer array is currently associated.; The optional ``allocated`` is a DIExpression that describes whether the; allocatable array is currently allocated. The optional ``rank`` is a; DIExpression that describes the rank (number of dimensions) of fortran assumed; rank array (rank is known at runtime). For ``DW_TAG_enumeration_type``, the ``elements:`` should be :ref:`enumerator; descriptors <DIEnumerator>`, each representing the definition of an enumeration; value for the set. All enumeration type descriptors are collected in the; ``enums:`` field of the :ref:`compile unit <DICompileUnit>`. For ``DW_TAG_structure_type``, ``DW_TAG_class_type``, and; ``DW_TAG_union_type``, the ``elements:`` should be :ref:`derived types; <DIDerivedType>` with ``tag: DW_TAG_member``, ``tag: DW_TAG_inheritance``, or; ``tag: DW_TAG_friend``; or :ref:`subprograms <DISubprogram>` with; ``isDefinition: false``. .. _DISubrange:. DISubrange; """""""""""""""""""". ``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of; :ref:`DICompositeType`. - ``count: -1`` indicates an empty array.; - ``count: !",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:284101,Energy Efficiency,efficient,efficient,284101,"{!4, !1}. ; Some scope lists:; !5 = !{!4} ; A list containing only scope !4; !6 = !{!4, !3, !2}; !7 = !{!3}. ; These two instructions don't alias:; %0 = load float, ptr %c, align 4, !alias.scope !5; store float %0, ptr %arrayidx.i, align 4, !noalias !5. ; These two instructions also don't alias (for domain !1, the set of scopes; ; in the !alias.scope equals that in the !noalias list):; %2 = load float, ptr %c, align 4, !alias.scope !5; store float %2, ptr %arrayidx.i2, align 4, !noalias !6. ; These two instructions may alias (for domain !0, the set of scopes in; ; the !noalias list is not a superset of, or equal to, the scopes in the; ; !alias.scope list):; %2 = load float, ptr %c, align 4, !alias.scope !6; store float %0, ptr %arrayidx.i, align 4, !noalias !7. '``fpmath``' Metadata; ^^^^^^^^^^^^^^^^^^^^^. ``fpmath`` metadata may be attached to any instruction of floating-point; type. It can be used to express the maximum acceptable error in the; result of that instruction, in ULPs, thus potentially allowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a real number that lies between two finite consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-point numbers; nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``. The metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:324622,Energy Efficiency,allocate,allocated,324622,"entry in the assembly. Indirect calls with the :ref:`kcfi operand; bundle<ob_kcfi>` will emit a check that compares the type identifier to the; metadata. Example:. .. code-block:: text. define dso_local i32 @f() !kcfi_type !0 {; ret i32 0; }; !0 = !{i32 12345678}. Clang emits ``kcfi_type`` metadata nodes for address-taken functions with; ``-fsanitize=kcfi``. .. _md_memprof:. '``memprof``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``memprof`` metadata is used to record memory profile data on heap; allocation calls. Multiple context-sensitive profiles can be represented; with a single ``memprof`` metadata attachment. Example:. .. code-block:: text. %call = call ptr @_Znam(i64 10), !memprof !0, !callsite !5; !0 = !{!1, !3}; !1 = !{!2, !""cold""}; !2 = !{i64 4854880825882961848, i64 1905834578520680781}; !3 = !{!4, !""notcold""}; !4 = !{i64 4854880825882961848, i64 -6528110295079665978}; !5 = !{i64 4854880825882961848}. Each operand in the ``memprof`` metadata attachment describes the profiled; behavior of memory allocated by the associated allocation for a given context.; In the above example, there were 2 profiled contexts, one allocating memory; that was typically cold and one allocating memory that was typically not cold. The format of the metadata describing a context specific profile (e.g.; ``!1`` and ``!3`` above) requires a first operand that is a metadata node; describing the context, followed by a list of string metadata tags describing; the profile behavior (e.g. ``cold`` and ``notcold``) above. The metadata nodes; describing the context (e.g. ``!2`` and ``!4`` above) are unique ids; corresponding to callsites, which can be matched to associated IR calls via; :ref:`callsite metadata<md_callsite>`. In practice these ids are formed via; a hash of the callsite's debug info, and the associated call may be in a; different module. The contexts are listed in order from leaf-most call (the; allocation itself) to the outermost callsite context required for uniquely; identify",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:335985,Energy Efficiency,efficient,efficient,335985," metadata section specifies that the module was; compiled with a ``wchar_t`` width of 4 bytes, and the underlying type of an; enum is the smallest type which can represent all of its values::. !llvm.module.flags = !{!0, !1}; !0 = !{i32 1, !""short_wchar"", i32 1}; !1 = !{i32 1, !""short_enum"", i32 0}. Stack Alignment Metadata; ------------------------. Changes the default stack alignment from the target ABI's implicit default; stack alignment. Takes an i32 value in bytes. It is considered an error to link; two modules together with different values for this metadata. For example:. !llvm.module.flags = !{!0}; !0 = !{i32 1, !""override-stack-alignment"", i32 8}. This will change the stack alignment to 8B. Embedded Objects Names Metadata; ===============================. Offloading compilations need to embed device code into the host section table to; create a fat binary. This metadata node references each global that will be; embedded in the module. The primary use for this is to make referencing these; globals more efficient in the IR. The metadata references nodes containing; pointers to the global to be embedded followed by the section name it will be; stored at::. !llvm.embedded.objects = !{!0}; !0 = !{ptr @object, !"".section""}. Automatic Linker Flags Named Metadata; =====================================. Some targets support embedding of flags to the linker inside individual object; files. Typically this is used in conjunction with language extensions which; allow source files to contain linker command line options, and have these; automatically be transmitted to the linker via object files. These flags are encoded in the IR using named metadata with the name; ``!llvm.linker.options``. Each operand is expected to be a metadata node; which should be a list of other metadata nodes, each of which should be a; list of metadata strings defining linker options. For example, the following metadata section specifies two separate sets of; linker options, presumably to link agai",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:392105,Energy Efficiency,efficient,efficient,392105," instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point remainder of the two operands.; This is the same output as a libm '``fmod``' function, but without any; possibility of setting ``errno``. The remainder has the same sign as the; dividend.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = frem float 4.0, %var ; yields float:result = 4.0 % %var. .. _bitwiseops:. Bitwise Binary Operations; -------------------------. Bitwise binary operators are used to do various forms of bit-twiddling; in a program. They are generally very efficient instructions and can; commonly be strength reduced from other instructions. They require two; operands of the same type, execute an operation on them, and produce a; single value. The resulting value is the same type as its operands. .. _i_shl:. '``shl``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shl <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nsw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``shl``' instruction returns the first operand shifted to the left; a specified number of bits. Arguments:; """""""""""""""""""". Both arguments to the '``shl``' instruction must be the same; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type.; '``op2``' is treated as an unsigned value. Semantics:; """""""""""""""""""". The value produced is ``op1`` \* 2\ :sup:`op2` mod 2\ :sup:`n`,; where ``n`` is the width of the result. If ``op2`` is (staticall",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:392158,Energy Efficiency,reduce,reduced,392158," instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point remainder of the two operands.; This is the same output as a libm '``fmod``' function, but without any; possibility of setting ``errno``. The remainder has the same sign as the; dividend.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = frem float 4.0, %var ; yields float:result = 4.0 % %var. .. _bitwiseops:. Bitwise Binary Operations; -------------------------. Bitwise binary operators are used to do various forms of bit-twiddling; in a program. They are generally very efficient instructions and can; commonly be strength reduced from other instructions. They require two; operands of the same type, execute an operation on them, and produce a; single value. The resulting value is the same type as its operands. .. _i_shl:. '``shl``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shl <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nsw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``shl``' instruction returns the first operand shifted to the left; a specified number of bits. Arguments:; """""""""""""""""""". Both arguments to the '``shl``' instruction must be the same; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type.; '``op2``' is treated as an unsigned value. Semantics:; """""""""""""""""""". The value produced is ``op1`` \* 2\ :sup:`op2` mod 2\ :sup:`n`,; where ``n`` is the width of the result. If ``op2`` is (staticall",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:408808,Energy Efficiency,allocate,allocate,408808,"ices indicating the position at which to insert the value in a; similar manner as indices in a '``extractvalue``' instruction. The value; to insert must have the same type as the value identified by the; indices. Semantics:; """""""""""""""""""". The result is an aggregate of the same type as ``val``. Its value is; that of ``val`` except that the value at the position specified by the; indices is that of ``elt``. Example:; """""""""""""""". .. code-block:: llvm. %agg1 = insertvalue {i32, float} undef, i32 1, 0 ; yields {i32 1, float undef}; %agg2 = insertvalue {i32, float} %agg1, float %val, 1 ; yields {i32 1, float %val}; %agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0 ; yields {i32 undef, {float %val}}. .. _memoryops:. Memory Access and Addressing Operations; ---------------------------------------. A key design point of an SSA-based representation is how it represents; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:409114,Energy Efficiency,allocate,allocates,409114,"he; indices is that of ``elt``. Example:; """""""""""""""". .. code-block:: llvm. %agg1 = insertvalue {i32, float} undef, i32 1, 0 ; yields {i32 1, float undef}; %agg2 = insertvalue {i32, float} %agg1, float %val, 1 ; yields {i32 1, float %val}; %agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0 ; yields {i32 undef, {float %val}}. .. _memoryops:. Memory Access and Addressing Operations; ---------------------------------------. A key design point of an SSA-based representation is how it represents; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:409325,Energy Efficiency,allocate,allocated,409325,"tvalue {i32, float} %agg1, float %val, 1 ; yields {i32 1, float %val}; %agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0 ; yields {i32 undef, {float %val}}. .. _memoryops:. Memory Access and Addressing Operations; ---------------------------------------. A key design point of an SSA-based representation is how it represents; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:409472,Energy Efficiency,allocate,allocates,409472,"Access and Addressing Operations; ---------------------------------------. A key design point of an SSA-based representation is how it represents; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:409674,Energy Efficiency,allocate,allocated,409674,"; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410450,Energy Efficiency,allocate,allocated,410450,"nstruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410488,Energy Efficiency,allocate,allocated,410488,"runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:411088,Energy Efficiency,allocate,allocated,411088,"any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_n",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413481,Energy Efficiency,power,power,413481," !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address spac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414210,Energy Efficiency,efficient,efficient,414210,"gument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:417313,Energy Efficiency,power,power,417313,"to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:420565,Energy Efficiency,power,power,420565,"re two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The type of the ``<pointer>`` operand must be a; pointer to the :ref:`first class <t_firstclass>` type of the ``<value>``; operand. If the ``store`` is marked as ``volatile``, then the optimizer is not; allowed to modify the number or order of execution of this ``store`` with other; :ref:`volatile operations <volatile>`. Only values of :ref:`first class; <t_firstclass>` types of known size (i.e. not containing an :ref:`opaque; structural type <t_opaque>`) can be stored. If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address sp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421296,Energy Efficiency,efficient,efficient,421296,"ment. The; ``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generato",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:426326,Energy Efficiency,power,power,426326,"nt. Example:; """""""""""""""". .. code-block:: text. fence acquire ; yields void; fence syncscope(""singlethread"") seq_cst ; yields void; fence syncscope(""agent"") seq_cst ; yields void. .. _i_cmpxchg:. '``cmpxchg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. cmpxchg [weak] [volatile] ptr <pointer>, <ty> <cmp>, <ty> <new> [syncscope(""<target-scope>"")] <success ordering> <failure ordering>[, align <alignment>] ; yields { ty, i1 }. Overview:; """""""""""""""""". The '``cmpxchg``' instruction is used to atomically modify memory. It; loads a value in memory and compares it to a given value. If they are; equal, it tries to store a new value into the memory. Arguments:; """""""""""""""""""". There are three arguments to the '``cmpxchg``' instruction: an address; to operate on, a value to compare to the value currently be at that; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:429795,Energy Efficiency,power,power,429795,"uared acq_rel monotonic ; yields { i32, i1 }; %value_loaded = extractvalue { i32, i1 } %val_success, 0; %success = extractvalue { i32, i1 } %val_success, 1; br i1 %success, label %done, label %loop. done:; ... .. _i_atomicrmw:. '``atomicrmw``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. atomicrmw [volatile] <operation> ptr <pointer>, <ty> <value> [syncscope(""<target-scope>"")] <ordering>[, align <alignment>] ; yields ty. Overview:; """""""""""""""""". The '``atomicrmw``' instruction is used to atomically modify memory. Arguments:; """""""""""""""""""". There are three arguments to the '``atomicrmw``' instruction: an; operation to apply, an address whose value to modify, an argument to the; operation. The operation must be one of the following keywords:. - xchg; - add; - sub; - and; - nand; - or; - xor; - max; - min; - umax; - umin; - fadd; - fsub; - fmax; - fmin; - uinc_wrap; - udec_wrap. For most of these operations, the type of '<value>' must be an integer; type whose bit width is a power of two greater than or equal to eight; and less than or equal to a target-specific size limit. For xchg, this; may also be a floating point or a pointer type with the same size constraints; as integers. For fadd/fsub/fmax/fmin, this must be a floating point type. The; type of the '``<pointer>``' operand must be a pointer to that type. If; the ``atomicrmw`` is marked as ``volatile``, then the optimizer is not; allowed to modify the number or order of execution of this; ``atomicrmw`` with other :ref:`volatile operations <volatile>`. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instruction",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436971,Energy Efficiency,allocate,allocated,436971," i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The suc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:437322,Energy Efficiency,allocate,allocated,437322,"xtended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; ap",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:437376,Energy Efficiency,allocate,allocated,437376,"xtended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; ap",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438127,Energy Efficiency,allocate,allocated,438127,"ointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or stor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438525,Energy Efficiency,allocate,allocated,438525," being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or store would access memory outside of the bounds of; the element selected by the index marked as ``inrange``. The result of a; pointer comparison or ``ptrtoint`` (including ``ptrtoint``-like operations; involving memory) involving a pointer derived from a ``getelementptr`` with; the ``inrange`` keyword is undefined, with the exception of comparisons; in the case where both operands are in the range of the element selected; by the ``in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438713,Energy Efficiency,allocate,allocated,438713,"nse (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or store would access memory outside of the bounds of; the element selected by the index marked as ``inrange``. The result of a; pointer comparison or ``ptrtoint`` (including ``ptrtoint``-like operations; involving memory) involving a pointer derived from a ``getelementptr`` with; the ``inrange`` keyword is undefined, with the exception of comparisons; in the case where both operands are in the range of the element selected; by the ``inrange`` keyword, inclusive of the address one past the end of; that element. Note that the ``inrange`` keyword is currently only allowed; in constant ``getelementptr`` expressions. The getelementptr instruction is often confusing. For some more insight; into how it works, see :doc:`the getelemen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438785,Energy Efficiency,allocate,allocated,438785,"nse (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or store would access memory outside of the bounds of; the element selected by the index marked as ``inrange``. The result of a; pointer comparison or ``ptrtoint`` (including ``ptrtoint``-like operations; involving memory) involving a pointer derived from a ``getelementptr`` with; the ``inrange`` keyword is undefined, with the exception of comparisons; in the case where both operands are in the range of the element selected; by the ``inrange`` keyword, inclusive of the address one past the end of; that element. Note that the ``inrange`` keyword is currently only allowed; in constant ``getelementptr`` expressions. The getelementptr instruction is often confusing. For some more insight; into how it works, see :doc:`the getelemen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:498063,Energy Efficiency,allocate,allocated,498063,"t. Arguments:; """""""""""""""""""". The first argument specifies the address of a stack object that contains; the root pointer. The second pointer (which must be either a constant or; a global value address) contains the meta-data to be associated with the; root. Semantics:; """""""""""""""""""". At runtime, a call to this intrinsic stores a null pointer into the; ""ptrloc"" location. At compile-time, the code generator generates; information to allow the runtime to find the pointer at GC safe points.; The '``llvm.gcroot``' intrinsic may only be used in a function which; :ref:`specifies a GC algorithm <gc>`. .. _int_gcread:. '``llvm.gcread``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.gcread(ptr %ObjPtr, ptr %Ptr). Overview:; """""""""""""""""". The '``llvm.gcread``' intrinsic identifies reads of references from heap; locations, allowing garbage collector implementations that require read; barriers. Arguments:; """""""""""""""""""". The second argument is the address to read from, which should be an; address allocated from the garbage collector. The first object is a; pointer to the start of the referenced object, if needed by the language; runtime (otherwise null). Semantics:; """""""""""""""""""". The '``llvm.gcread``' intrinsic has the same semantics as a load; instruction, but may be replaced with substantially more complex code by; the garbage collector runtime, as needed. The '``llvm.gcread``'; intrinsic may only be used in a function which :ref:`specifies a GC; algorithm <gc>`. .. _int_gcwrite:. '``llvm.gcwrite``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.gcwrite(ptr %P1, ptr %Obj, ptr %P2). Overview:; """""""""""""""""". The '``llvm.gcwrite``' intrinsic identifies writes of references to heap; locations, allowing garbage collector implementations that require write; barriers (such as generational or reference counting collectors). Arguments:; """""""""""""""""""". The first argument is the reference to store, the second is the start of; the object to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:515085,Energy Efficiency,allocate,allocated,515085,"tcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It is zero-indexed. Semantics:; """""""""""""""""""". These intrinsics allow a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with Windows SEH Asynchrous Exception option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile stores. '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:520360,Energy Efficiency,allocate,allocated,520360,"nd x86_64). Significant amount of; work is needed to support other registers and even more so, allocatable; registers. .. _int_stacksave:. '``llvm.stacksave``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stacksave.p0(); declare ptr addrspace(5) @llvm.stacksave.p5(). Overview:; """""""""""""""""". The '``llvm.stacksave``' intrinsic is used to remember the current state; of the function stack, for use with; :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for; implementing language features like scoped automatic variable sized; arrays in C99. Semantics:; """""""""""""""""""". This intrinsic returns an opaque pointer value that can be passed to; :ref:`llvm.stackrestore <int_stackrestore>`. When an; ``llvm.stackrestore`` intrinsic is executed with a value saved from; ``llvm.stacksave``, it effectively restores the state of the stack to; the state it was in when the ``llvm.stacksave`` intrinsic executed. In; practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack; that were allocated after the ``llvm.stacksave`` was executed. The; address space should typically be the; :ref:`alloca address space <alloca_addrspace>`. .. _int_stackrestore:. '``llvm.stackrestore``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackrestore.p0(ptr %ptr); declare void @llvm.stackrestore.p5(ptr addrspace(5) %ptr). Overview:; """""""""""""""""". The '``llvm.stackrestore``' intrinsic is used to restore the state of; the function stack to the state it was in when the corresponding; :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is; useful for implementing language features like scoped automatic; variable sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:522057,Energy Efficiency,allocate,allocated,522057," sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.get.dynamic.area.offset.i32(); declare i64 @llvm.get.dynamic.area.offset.i64(). Overview:; """""""""""""""""". The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to; get the offset from native stack pointer to the address of the most; recent dynamic alloca on the caller's stack. These intrinsics are; intended for use in combination with; :ref:`llvm.stacksave <int_stacksave>` to get a; pointer to the most recent dynamic alloca. This is useful, for example,; for AddressSanitizer's stack unpoisoning routines. Semantics:; """""""""""""""""""". These intrinsics return a non-negative integer value that can be used to; get the address of the most recent dynamic alloca, allocated by :ref:`alloca <i_alloca>`; on the caller's stack. In particular, for targets where stack grows downwards,; adding this offset to the native stack pointer would get the address of the most; recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more; complicated, because subtracting this value from stack pointer would get the address; one past the end of the most recent dynamic alloca. Although for most targets `llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; returns just a zero, for others, such as PowerPC and PowerPC64, it returns a; compile-time-known constant value. The return value type of :ref:`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; must match the target's default address space's (address space 0) pointer type. '``llvm.prefetch``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.prefetch(ptr <address>, i32 <rw>, i32 <locality>, i32 <cache t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:530224,Energy Efficiency,efficient,efficient,530224,"imestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a; timestamp representing when this function was executed for the first time. '``llvm.instrprof.cover``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.cover(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.cover``' intrinsic is used to implement coverage; instrumentation. Arguments:; """"""""""""""""""""; The arguments are the same as the first four arguments of; '``llvm.instrprof.increment``'. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the sam",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:537782,Energy Efficiency,allocate,allocated,537782,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.thread.pointer(). Overview:; """""""""""""""""". The '``llvm.thread.pointer``' intrinsic returns the value of the thread; pointer. Semantics:; """""""""""""""""""". The '``llvm.thread.pointer``' intrinsic returns a pointer to the TLS area; for the current thread. The exact semantics of this value are target; specific: it may point to the start of TLS area, to the end, or somewhere; in the middle. Depending on the target, this intrinsic may read a register,; call a helper function, read from an alternate memory space, or perform; other operations necessary to locate the TLS area. Not all targets support; this intrinsic. '``llvm.call.preallocated.setup``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare token @llvm.call.preallocated.setup(i32 %num_args). Overview:; """""""""""""""""". The '``llvm.call.preallocated.setup``' intrinsic returns a token which can; be used with a call's ``""preallocated""`` operand bundle to indicate that; certain arguments are allocated and initialized before the call. Semantics:; """""""""""""""""""". The '``llvm.call.preallocated.setup``' intrinsic returns a token which is; associated with at most one call. The token can be passed to; '``@llvm.call.preallocated.arg``' to get a pointer to get that; corresponding argument. The token must be the parameter to a; ``""preallocated""`` operand bundle for the corresponding call. Nested calls to '``llvm.call.preallocated.setup``' are allowed, but must; be properly nested. e.g. :: code-block:: llvm. %t1 = call token @llvm.call.preallocated.setup(i32 0); %t2 = call token @llvm.call.preallocated.setup(i32 0); call void foo() [""preallocated""(token %t2)]; call void foo() [""preallocated""(token %t1)]. is allowed, but not. :: code-block:: llvm. %t1 = call token @llvm.call.preallocated.setup(i32 0); %t2 = call token @llvm.call.preallocated.setup(i32 0); call void foo() [""preallocated""(token %t1)]; call void foo() [""preallocated""(token %",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:540635,Energy Efficiency,allocate,allocated,540635,"all. The type is used in the case that an; ``llvm.call.preallocated.setup`` does not have a corresponding call (e.g. due; to DCE), where otherwise we cannot know how large the arguments are. It is undefined behavior if this is called with a token from an; '``llvm.call.preallocated.setup``' if another; '``llvm.call.preallocated.setup``' has already been called or if the; preallocated call corresponding to the '``llvm.call.preallocated.setup``'; has already been called. .. _int_call_preallocated_teardown:. '``llvm.call.preallocated.teardown``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.call.preallocated.teardown(token %setup_token). Overview:; """""""""""""""""". The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack; created by a '``llvm.call.preallocated.setup``'. Semantics:; """""""""""""""""""". The token argument must be a '``llvm.call.preallocated.setup``'. The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack; allocated by the corresponding '``llvm.call.preallocated.setup``'. Exactly; one of this or the preallocated call must be called to prevent stack leaks.; It is undefined behavior to call both a '``llvm.call.preallocated.teardown``'; and the preallocated call for a given '``llvm.call.preallocated.setup``'. For example, if the stack is allocated for a preallocated call by a; '``llvm.call.preallocated.setup``', then an initializer function called on an; allocated argument throws an exception, there should be a; '``llvm.call.preallocated.teardown``' in the exception handler to prevent; stack leaks. Following the nesting rules in '``llvm.call.preallocated.setup``', nested; calls to '``llvm.call.preallocated.setup``' and; '``llvm.call.preallocated.teardown``' are allowed but must be properly; nested. Example:; """""""""""""""". .. code-block:: llvm. %cs = call token @llvm.call.preallocated.setup(i32 1); %x = call ptr @llvm.call.preallocated.arg(token %cs, i32 0) preallocated(i32); invoke void @cons",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:540970,Energy Efficiency,allocate,allocated,540970,"ady been called or if the; preallocated call corresponding to the '``llvm.call.preallocated.setup``'; has already been called. .. _int_call_preallocated_teardown:. '``llvm.call.preallocated.teardown``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.call.preallocated.teardown(token %setup_token). Overview:; """""""""""""""""". The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack; created by a '``llvm.call.preallocated.setup``'. Semantics:; """""""""""""""""""". The token argument must be a '``llvm.call.preallocated.setup``'. The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack; allocated by the corresponding '``llvm.call.preallocated.setup``'. Exactly; one of this or the preallocated call must be called to prevent stack leaks.; It is undefined behavior to call both a '``llvm.call.preallocated.teardown``'; and the preallocated call for a given '``llvm.call.preallocated.setup``'. For example, if the stack is allocated for a preallocated call by a; '``llvm.call.preallocated.setup``', then an initializer function called on an; allocated argument throws an exception, there should be a; '``llvm.call.preallocated.teardown``' in the exception handler to prevent; stack leaks. Following the nesting rules in '``llvm.call.preallocated.setup``', nested; calls to '``llvm.call.preallocated.setup``' and; '``llvm.call.preallocated.teardown``' are allowed but must be properly; nested. Example:; """""""""""""""". .. code-block:: llvm. %cs = call token @llvm.call.preallocated.setup(i32 1); %x = call ptr @llvm.call.preallocated.arg(token %cs, i32 0) preallocated(i32); invoke void @constructor(ptr %x) to label %conta unwind label %contb; conta:; call void @foo1(ptr preallocated(i32) %x) [""preallocated""(token %cs)]; ret void; contb:; %s = catchswitch within none [label %catch] unwind to caller; catch:; %p = catchpad within %s []; call void @llvm.call.preallocated.teardown(token %cs); ret void. Standard C/C++ Library Intrinsics",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:541089,Energy Efficiency,allocate,allocated,541089,"n called. .. _int_call_preallocated_teardown:. '``llvm.call.preallocated.teardown``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.call.preallocated.teardown(token %setup_token). Overview:; """""""""""""""""". The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack; created by a '``llvm.call.preallocated.setup``'. Semantics:; """""""""""""""""""". The token argument must be a '``llvm.call.preallocated.setup``'. The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack; allocated by the corresponding '``llvm.call.preallocated.setup``'. Exactly; one of this or the preallocated call must be called to prevent stack leaks.; It is undefined behavior to call both a '``llvm.call.preallocated.teardown``'; and the preallocated call for a given '``llvm.call.preallocated.setup``'. For example, if the stack is allocated for a preallocated call by a; '``llvm.call.preallocated.setup``', then an initializer function called on an; allocated argument throws an exception, there should be a; '``llvm.call.preallocated.teardown``' in the exception handler to prevent; stack leaks. Following the nesting rules in '``llvm.call.preallocated.setup``', nested; calls to '``llvm.call.preallocated.setup``' and; '``llvm.call.preallocated.teardown``' are allowed but must be properly; nested. Example:; """""""""""""""". .. code-block:: llvm. %cs = call token @llvm.call.preallocated.setup(i32 1); %x = call ptr @llvm.call.preallocated.arg(token %cs, i32 0) preallocated(i32); invoke void @constructor(ptr %x) to label %conta unwind label %contb; conta:; call void @foo1(ptr preallocated(i32) %x) [""preallocated""(token %cs)]; ret void; contb:; %s = catchswitch within none [label %catch] unwind to caller; catch:; %p = catchpad within %s []; call void @llvm.call.preallocated.teardown(token %cs); ret void. Standard C/C++ Library Intrinsics; ---------------------------------. LLVM provides intrinsics for a few important standard C/C++ library; functions. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:542267,Energy Efficiency,efficient,efficient,542267,"xception handler to prevent; stack leaks. Following the nesting rules in '``llvm.call.preallocated.setup``', nested; calls to '``llvm.call.preallocated.setup``' and; '``llvm.call.preallocated.teardown``' are allowed but must be properly; nested. Example:; """""""""""""""". .. code-block:: llvm. %cs = call token @llvm.call.preallocated.setup(i32 1); %x = call ptr @llvm.call.preallocated.arg(token %cs, i32 0) preallocated(i32); invoke void @constructor(ptr %x) to label %conta unwind label %contb; conta:; call void @foo1(ptr preallocated(i32) %x) [""preallocated""(token %cs)]; ret void; contb:; %s = catchswitch within none [label %catch] unwind to caller; catch:; %p = catchpad within %s []; call void @llvm.call.preallocated.teardown(token %cs); ret void. Standard C/C++ Library Intrinsics; ---------------------------------. LLVM provides intrinsics for a few important standard C/C++ library; functions. These intrinsics allow source-language front-ends to pass; information about the alignment of the pointer arguments to the code; generator, providing opportunity for more efficient code generation. .. _int_abs:. '``llvm.abs.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.abs`` on any; integer bit width or any vector of integer elements. ::. declare i32 @llvm.abs.i32(i32 <src>, i1 <is_int_min_poison>); declare <4 x i32> @llvm.abs.v4i32(<4 x i32> <src>, i1 <is_int_min_poison>). Overview:; """""""""""""""""". The '``llvm.abs``' family of intrinsic functions returns the absolute value; of an argument. Arguments:; """""""""""""""""""". The first argument is the value for which the absolute value is to be returned.; This argument may be of any integer type or a vector with integer element type.; The return type must match the first argument type. The second argument must be a constant and is a flag to indicate whether the; result value of the '``llvm.abs``' intrinsic is a; :ref:`poison value <poisonvalues>` if the argument is statically or d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558006,Energy Efficiency,power,power,558006,"rt.f128(fp128 %Val); declare ppc_fp128 @llvm.sqrt.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.sqrt``' intrinsics return the square root of the specified value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sqrt``' function but without; trapping or setting ``errno``. For types specified by IEEE-754, the result; matches a conforming libm implementation. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.powi.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. No",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558066,Energy Efficiency,power,power,558066,"c_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.sqrt``' intrinsics return the square root of the specified value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sqrt``' function but without; trapping or setting ``errno``. For types specified by IEEE-754, the result; matches a conforming libm implementation. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.powi.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558130,Energy Efficiency,power,power,558130,"nsics return the square root of the specified value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sqrt``' function but without; trapping or setting ``errno``. For types specified by IEEE-754, the result; matches a conforming libm implementation. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.powi.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558189,Energy Efficiency,power,power,558189,":; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sqrt``' function but without; trapping or setting ``errno``. For types specified by IEEE-754, the result; matches a conforming libm implementation. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.powi.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double %Val); declare x86_fp80 @llvm.sin.f80(x86_fp80 %Val); declare ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558259,Energy Efficiency,power,power,558259,"g-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sqrt``' function but without; trapping or setting ``errno``. For types specified by IEEE-754, the result; matches a conforming libm implementation. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.powi.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double %Val); declare x86_fp80 @llvm.sin.f80(x86_fp80 %Val); declare fp128 @llvm.sin.f128(fp128 %Val); declare ppc_fp128 @ll",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558395,Energy Efficiency,power,power,558395," '``sqrt``' function but without; trapping or setting ``errno``. For types specified by IEEE-754, the result; matches a conforming libm implementation. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.powi.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double %Val); declare x86_fp80 @llvm.sin.f80(x86_fp80 %Val); declare fp128 @llvm.sin.f128(fp128 %Val); declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.sin.*``' intrinsics return the sine of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558619,Energy Efficiency,power,power,558619,"i.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double %Val); declare x86_fp80 @llvm.sin.f80(x86_fp80 %Val); declare fp128 @llvm.sin.f128(fp128 %Val); declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.sin.*``' intrinsics return the sine of the operand. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sin``' function but without; trapping or setting ``errno``. When specified with the fast-m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558669,Energy Efficiency,power,power,558669,"i.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.powi`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double %Val); declare x86_fp80 @llvm.sin.f80(x86_fp80 %Val); declare fp128 @llvm.sin.f128(fp128 %Val); declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.sin.*``' intrinsics return the sine of the operand. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sin``' function but without; trapping or setting ``errno``. When specified with the fast-m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:558759,Energy Efficiency,power,power,558759,"y; floating-point or vector of floating-point type. Not all targets support; all types however. Generally, the only supported type for the exponent is the one matching; with the C type ``int``. ::. declare float @llvm.powi.f32.i32(float %Val, i32 %power); declare double @llvm.powi.f64.i16(double %Val, i16 %power); declare x86_fp80 @llvm.powi.f80.i32(x86_fp80 %Val, i32 %power); declare fp128 @llvm.powi.f128.i32(fp128 %Val, i32 %power); declare ppc_fp128 @llvm.powi.ppcf128.i32(ppc_fp128 %Val, i32 %power). Overview:; """""""""""""""""". The '``llvm.powi.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. The order of evaluation of; multiplications is not defined. When a vector of floating-point type is; used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The second argument is an integer power, and the first is a value to; raise to that power. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.sin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sin`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.sin.f32(float %Val); declare double @llvm.sin.f64(double %Val); declare x86_fp80 @llvm.sin.f80(x86_fp80 %Val); declare fp128 @llvm.sin.f128(fp128 %Val); declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.sin.*``' intrinsics return the sine of the operand. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``sin``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.cos.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:561276,Energy Efficiency,power,power,561276,"rn the cosine of the operand. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``cos``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. '``llvm.pow.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.pow`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.pow.f32(float %Val, float %Power); declare double @llvm.pow.f64(double %Val, double %Power); declare x86_fp80 @llvm.pow.f80(x86_fp80 %Val, x86_fp80 %Power); declare fp128 @llvm.pow.f128(fp128 %Val, fp128 %Power); declare ppc_fp128 @llvm.pow.ppcf128(ppc_fp128 %Val, ppc_fp128 Power). Overview:; """""""""""""""""". The '``llvm.pow.*``' intrinsics return the first operand raised to the; specified (positive or negative) power. Arguments:; """""""""""""""""""". The arguments and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``pow``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. .. _int_exp:. '``llvm.exp.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.exp`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.exp.f32(float %Val); declare double @llvm.exp.f64(double %Val); declare x86_fp80 @llvm.exp.f80(x86_fp80 %Val); declare fp128 @llvm.exp.f128(fp128 %Val); declare ppc_fp128 @llvm.exp.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.exp.*``' intrinsics compute the base-e exponential of the specified; value. Arguments:; """"""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:565522,Energy Efficiency,power,power,565522,"nsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.ldexp`` on any; floating point or vector of floating point type. Not all targets support; all types however. ::. declare float @llvm.ldexp.f32.i32(float %Val, i32 %Exp); declare double @llvm.ldexp.f64.i32(double %Val, i32 %Exp); declare x86_fp80 @llvm.ldexp.f80.i32(x86_fp80 %Val, i32 %Exp); declare fp128 @llvm.ldexp.f128.i32(fp128 %Val, i32 %Exp); declare ppc_fp128 @llvm.ldexp.ppcf128.i32(ppc_fp128 %Val, i32 %Exp); declare <2 x float> @llvm.ldexp.v2f32.v2i32(<2 x float> %Val, <2 x i32> %Exp). Overview:; """""""""""""""""". The '``llvm.ldexp.*``' intrinsics perform the ldexp function. Arguments:; """""""""""""""""""". The first argument and the return value are :ref:`floating-point; <t_floating>` or :ref:`vector <t_vector>` of floating-point values of; the same type. The second argument is an integer with the same number; of elements. Semantics:; """""""""""""""""""". This function multiplies the first argument by 2 raised to the second; argument's power. If the first argument is NaN or infinite, the same; value is returned. If the result underflows a zero with the same sign; is returned. If the result overflows, the result is an infinity with; the same sign. .. _int_frexp:. '``llvm.frexp.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.frexp`` on any; floating point or vector of floating point type. Not all targets support; all types however. ::. declare { float, i32 } @llvm.frexp.f32.i32(float %Val); declare { double, i32 } @llvm.frexp.f64.i32(double %Val); declare { x86_fp80, i32 } @llvm.frexp.f80.i32(x86_fp80 %Val); declare { fp128, i32 } @llvm.frexp.f128.i32(fp128 %Val); declare { ppc_fp128, i32 } @llvm.frexp.ppcf128.i32(ppc_fp128 %Val); declare { <2 x float>, <2 x i32> } @llvm.frexp.v2f32.v2i32(<2 x float> %Val). Overview:; """""""""""""""""". The '``llvm.frexp.*``' intrinsics perform the frexp function. Arguments:; """""""""""""""""""". T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:566988,Energy Efficiency,power,power,566988,"eclare { float, i32 } @llvm.frexp.f32.i32(float %Val); declare { double, i32 } @llvm.frexp.f64.i32(double %Val); declare { x86_fp80, i32 } @llvm.frexp.f80.i32(x86_fp80 %Val); declare { fp128, i32 } @llvm.frexp.f128.i32(fp128 %Val); declare { ppc_fp128, i32 } @llvm.frexp.ppcf128.i32(ppc_fp128 %Val); declare { <2 x float>, <2 x i32> } @llvm.frexp.v2f32.v2i32(<2 x float> %Val). Overview:; """""""""""""""""". The '``llvm.frexp.*``' intrinsics perform the frexp function. Arguments:; """""""""""""""""""". The argument is a :ref:`floating-point <t_floating>` or; :ref:`vector <t_vector>` of floating-point values. Returns two values; in a struct. The first struct field matches the argument type, and the; second field is an integer or a vector of integer values with the same; number of elements as the argument. Semantics:; """""""""""""""""""". This intrinsic splits a floating point value into a normalized; fractional component and integral exponent. For a non-zero argument, returns the argument multiplied by some power; of two such that the absolute value of the returned value is in the; range [0.5, 1.0), with the same sign as the argument. The second; result is an integer such that the first result raised to the power of; the second result is the input argument. If the argument is a zero, returns a zero with the same sign and a 0; exponent. If the argument is a NaN, a NaN is returned and the returned exponent; is unspecified. If the argument is an infinity, returns an infinity with the same sign; and an unspecified exponent. .. _int_log:. '``llvm.log.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log.f32(float %Val); declare double @llvm.log.f64(double %Val); declare x86_fp80 @llvm.log.f80(x86_fp80 %Val); declare fp128 @llvm.log.f128(fp128 %Val); declare ppc_fp128 @llvm.log.ppcf128(ppc_fp128 %Val). Overview:;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:567192,Energy Efficiency,power,power,567192," { fp128, i32 } @llvm.frexp.f128.i32(fp128 %Val); declare { ppc_fp128, i32 } @llvm.frexp.ppcf128.i32(ppc_fp128 %Val); declare { <2 x float>, <2 x i32> } @llvm.frexp.v2f32.v2i32(<2 x float> %Val). Overview:; """""""""""""""""". The '``llvm.frexp.*``' intrinsics perform the frexp function. Arguments:; """""""""""""""""""". The argument is a :ref:`floating-point <t_floating>` or; :ref:`vector <t_vector>` of floating-point values. Returns two values; in a struct. The first struct field matches the argument type, and the; second field is an integer or a vector of integer values with the same; number of elements as the argument. Semantics:; """""""""""""""""""". This intrinsic splits a floating point value into a normalized; fractional component and integral exponent. For a non-zero argument, returns the argument multiplied by some power; of two such that the absolute value of the returned value is in the; range [0.5, 1.0), with the same sign as the argument. The second; result is an integer such that the first result raised to the power of; the second result is the input argument. If the argument is a zero, returns a zero with the same sign and a 0; exponent. If the argument is a NaN, a NaN is returned and the returned exponent; is unspecified. If the argument is an infinity, returns an infinity with the same sign; and an unspecified exponent. .. _int_log:. '``llvm.log.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log.f32(float %Val); declare double @llvm.log.f64(double %Val); declare x86_fp80 @llvm.log.f80(x86_fp80 %Val); declare fp128 @llvm.log.f128(fp128 %Val); declare ppc_fp128 @llvm.log.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.log.*``' intrinsics compute the base-e logarithm of the specified; value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:590265,Energy Efficiency,efficient,efficient,590265," any; floating-point type or vector of floating-point type. Not all targets; support all types however. ::. declare i64 @llvm.llrint.i64.f32(float %Val); declare i64 @llvm.llrint.i64.f64(double %Val); declare i64 @llvm.llrint.i64.f80(float %Val); declare i64 @llvm.llrint.i64.f128(double %Val); declare i64 @llvm.llrint.i64.ppcf128(double %Val). Overview:; """""""""""""""""". The '``llvm.llrint.*``' intrinsics return the operand rounded to the nearest; integer. Arguments:; """""""""""""""""""". The argument is a floating-point number and the return value is an integer; type. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``llrint`` functions; would, but without setting errno. If the rounded value is too large to; be stored in the result type, the return value is a non-deterministic; value (equivalent to `freeze poison`). Bit Manipulation Intrinsics; ---------------------------. LLVM provides intrinsics for a few important bit manipulation; operations. These allow efficient code generation for some algorithms. .. _int_bitreverse:. '``llvm.bitreverse.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic function. You can use bitreverse on any; integer type. ::. declare i16 @llvm.bitreverse.i16(i16 <id>); declare i32 @llvm.bitreverse.i32(i32 <id>); declare i64 @llvm.bitreverse.i64(i64 <id>); declare <4 x i32> @llvm.bitreverse.v4i32(<4 x i32> <id>). Overview:; """""""""""""""""". The '``llvm.bitreverse``' family of intrinsics is used to reverse the; bitpattern of an integer value or vector of integer values; for example; ``0b10110110`` becomes ``0b01101101``. Semantics:; """""""""""""""""""". The ``llvm.bitreverse.iN`` intrinsic returns an iN value that has bit; ``M`` in the input moved to bit ``N-M-1`` in the output. The vector; intrinsics, such as ``llvm.bitreverse.v4i32``, operate on a per-element; basis and the element order is not affected. .. _int_bswap:. '``llvm.bswap.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:594466,Energy Efficiency,efficient,efficiently,594466,"^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any; integer bit width, or any vector whose elements are integers. Not all; targets support all bit widths or vector types, however. ::. declare i8 @llvm.ctlz.i8 (i8 <src>, i1 <is_zero_poison>); declare <2 x i37> @llvm.ctlz.v2i37(<2 x i37> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.ctlz``' family of intrinsic functions counts the number of; leading zeros in a variable. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.ctlz``' intrinsic counts the leading (most significant); zeros in a variable, or within each element of the vector. If; ``src == 0`` then the result is the size in bits of the type of ``src``; if ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.ctlz(i32 2) = 30``. .. _int_cttz:. '``llvm.cttz.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.cttz`` on any; integer bit width, or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:595909,Energy Efficiency,efficient,efficiently,595909,"ntrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.cttz`` on any; integer bit width, or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.cttz``' intrinsic counts the trailing (least significant); zeros in a variable, or within each element of a vector. If ``src == 0``; then the result is the size in bits of the type of ``src`` if; ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.cttz(2) = 1``. .. _int_overflow:. .. _int_fshl:. '``llvm.fshl.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.fshl`` on any; integer bit width or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.fshl.i8 (i8 %a, i8 %b, i8 %c); declare i64 @llvm.fshl.i64(i64 %a, i64 %b, i64 %c); declare <2 x i32> @llvm.fshl.v2i32(<2 x i32> %a, <2 x i32> %b, <2 x i32> %c). Overview:; """""""""""""""""". The '``llvm.fshl``' family of intrinsic functions performs a funnel shift left:; the first two v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:641689,Energy Efficiency,efficient,efficient,641689,"ts of a NaN must be conserved, with two exceptions.; First, environments which use only a single canonical representation of NaN; must perform said canonicalization. Second, SNaNs must be quieted per the; usual methods. The canonicalization operation may be optimized away if:. - The input is known to be canonical. For example, it was produced by a; floating-point operation that is required by the standard to be canonical.; - The result is consumed only by (or fused with) other floating-point; operations. That is, the bits of the floating-point value are not examined. .. _int_fmuladd:. '``llvm.fmuladd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.fmuladd.f32(float %a, float %b, float %c); declare double @llvm.fmuladd.f64(double %a, double %b, double %c). Overview:; """""""""""""""""". The '``llvm.fmuladd.*``' intrinsic functions represent multiply-add; expressions that can be fused if the code generator determines that (a) the; target instruction set has support for a fused operation, and (b) that the; fused operation is more efficient than the equivalent, separate pair of mul; and add instructions. Arguments:; """""""""""""""""""". The '``llvm.fmuladd.*``' intrinsics each take three arguments: two; multiplicands, a and b, and an addend c. Semantics:; """""""""""""""""""". The expression:. ::. %0 = call float @llvm.fmuladd.f32(%a, %b, %c). is equivalent to the expression a \* b + c, except that it is unspecified; whether rounding will be performed between the multiplication and addition; steps. Fusion is not guaranteed, even if the target platform supports it.; If a fused multiply-add is required, the corresponding; :ref:`llvm.fma <int_fma>` intrinsic function should be used instead.; This never sets errno, just as '``llvm.fma.*``'. Examples:; """""""""""""""""". .. code-block:: llvm. %r2 = call float @llvm.fmuladd.f32(float %a, float %b, float %c) ; yields float:r2 = (a * b) + c. Hardware-Loop Intrinsics; ------------------------. LLVM support several intrinsi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:650400,Energy Efficiency,reduce,reduce,650400,"value, and return a; false predicate if the loop should exit, and true otherwise.; This is emitted if the loop counter is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:650516,Energy Efficiency,reduce,reduce,650516,"er is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:650573,Energy Efficiency,reduce,reduce,650573,"controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. O",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:650646,Energy Efficiency,reduce,reduce,650646,"s the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the oper",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:650951,Energy Efficiency,reduce,reduce,650951," result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:651071,Energy Efficiency,reduce,reduce,651071,"---------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:651154,Energy Efficiency,reduce,reduce,651154,"following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:651252,Energy Efficiency,reduce,reduce,651252,"ration across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fadd:. '``llvm.vector.reduce.fadd.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point; ``ADD`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vecto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:652472,Energy Efficiency,reduce,reduce,652472,"et, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(doubl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:652574,Energy Efficiency,reduce,reduce,652574,"therwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:652699,Energy Efficiency,reduce,reduce,652699,"duction. That is, the reduction begins with; the start value and performs an fadd operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:652815,Energy Efficiency,reduce,reduce,652815,"asing; vector element indices. See the following pseudocode:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:652872,Energy Efficiency,reduce,reduce,652872,"de:. ::. float sequential_fadd(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. O",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:652945,Energy Efficiency,reduce,reduce,652945,"_value; for i = 0 to length(input_vector); result = result + input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the oper",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:653250,Energy Efficiency,reduce,reduce,653250,"ctor of floating-point values. To ignore the start value, negative zero (``-0.0``) can be used, as it is; the neutral value of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:653370,Energy Efficiency,reduce,reduce,653370,"lue of floating point addition. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:653453,Energy Efficiency,reduce,reduce,653453,"at @llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:653551,Energy Efficiency,reduce,reduce,653551," float @llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_mul:. '``llvm.vector.reduce.mul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.mul.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmul:. '``llvm.vector.reduce.fmul.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a); declare double @llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point; ``MUL`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. If the intrinsic call has the 'reassoc' flag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vecto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:654766,Energy Efficiency,reduce,reduce,654766,"lag set, then the reduction will not; preserve the associativity of an equivalent scalarized counterpart. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scala",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:654867,Energy Efficiency,reduce,reduce,654867,"art. Otherwise; the reduction will be *sequential*, thus implying that the operation respects; the associativity of a scalarized reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argumen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:654992,Energy Efficiency,reduce,reduce,654992,"zed reduction. That is, the reduction begins with; the start value and performs an fmul operation with consecutively increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:655108,Energy Efficiency,reduce,reduce,655108," increasing; vector element indices. See the following pseudocode:. ::. float sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32>",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:655181,Energy Efficiency,reduce,reduce,655181,"loat sequential_fmul(start_value, input_vector); result = start_value; for i = 0 to length(input_vector); result = result * input_vector[i]; return result. Arguments:; """"""""""""""""""""; The first argument to this intrinsic is a scalar start value for the reduction.; The type of the start value matches the element-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:655483,Energy Efficiency,reduce,reduce,655483,"lement-type of the vector input.; The second argument must be a vector of floating-point values. To ignore the start value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrins",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:655597,Energy Efficiency,reduce,reduce,655597,"rt value, one (``1.0``) can be used, as it is the neutral; value of floating point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:655669,Energy Efficiency,reduce,reduce,655669,"ting point multiplication. Examples:; """""""""""""""""". ::. %unord = call reassoc float @llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction; %ord = call float @llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction. .. _int_vector_reduce_and:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:655970,Energy Efficiency,reduce,reduce,655970,"d:. '``llvm.vector.reduce.and.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:656086,Energy Efficiency,reduce,reduce,656086,"e i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:656159,Energy Efficiency,reduce,reduce,656159,"The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_or:. '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.redu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:656463,Energy Efficiency,reduce,reduce,656463,". '``llvm.vector.reduce.or.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:656581,Energy Efficiency,reduce,reduce,656581,"@llvm.vector.reduce.or.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:656655,Energy Efficiency,reduce,reduce,656655,"lvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction; of a vector, returning the result as a scalar. The return type matches the; element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_xor:. '``llvm.vector.reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:656967,Energy Efficiency,reduce,reduce,656967,"reduce.xor.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:657085,Energy Efficiency,reduce,reduce,657085,"duce.xor.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:657159,Energy Efficiency,reduce,reduce,657159,"uce.xor.*``' intrinsics do a bitwise ``XOR``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smax:. '``llvm.vector.reduce.smax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:657471,Energy Efficiency,reduce,reduce,657471,".*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``ll",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:657589,Energy Efficiency,reduce,reduce,657589,".v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:657663,Energy Efficiency,reduce,reduce,657663,".*``' intrinsics do a signed integer; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_smin:. '``llvm.vector.reduce.smin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:657978,Energy Efficiency,reduce,reduce,657978,"`' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.smin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:658096,Energy Efficiency,reduce,reduce,658096,"i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:658170,Energy Efficiency,reduce,reduce,658170,"`' intrinsics do a signed integer; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umax:. '``llvm.vector.reduce.umax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:658485,Energy Efficiency,reduce,reduce,658485,"Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:658605,Energy Efficiency,reduce,reduce,658605,"4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an ov",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:658668,Energy Efficiency,reduce,reduce,658668,"max.*``' intrinsics do an unsigned; integer ``MAX`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:658745,Energy Efficiency,reduce,reduce,658745,"turning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_umin:. '``llvm.vector.reduce.umin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned; integer ``MIN`` reduction of a vector, returning the result as a scalar. The; return type matches the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of integer values. .. _int_vector_reduce_fmax:. '``llvm.vector.reduce.fmax.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmin.v2f64(<2 x dou",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:659507,Energy Efficiency,reduce,reduce,659507,"c; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.vector.reduce.fmax.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmin.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:659660,Energy Efficiency,reduce,reduce,659660,"ctor.reduce.fmax.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmin.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:659723,Energy Efficiency,reduce,reduce,659723,"The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmin.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:659800,Energy Efficiency,reduce,reduce,659800,"eduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maxnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with maximum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmin:. '``llvm.vector.reduce.fmin.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmin.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fma",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:660566,Energy Efficiency,reduce,reduce,660566,"^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmin.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmin.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. de",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:660727,Energy Efficiency,reduce,reduce,660727,"fmin.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:660794,Energy Efficiency,reduce,reduce,660794,"or.reduce.fmin.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point; ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:660875,Energy Efficiency,reduce,reduce,660875,", returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minnum.*``'; intrinsic. That is, the result will always be a number unless all elements of; the vector are NaN. For a vector with minimum element magnitude 0.0 and; containing both +0.0 and -0.0 elements, the sign of the result is unspecified. If the intrinsic call has the ``nnan`` fast-math flag, then the operation can; assume that NaNs are not present in the input vector. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:661434,Energy Efficiency,reduce,reduce,661434,"""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fmaximum:. '``llvm.vector.reduce.fmaximum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minimum.*``'; intrinsic. That is, this intrinsic propagates NaNs and -0.0 is considered less; than +0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. '``llvm.vector.insert``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. ; Insert fixed type into scalable type; declare <vscale x 4 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:661595,Energy Efficiency,reduce,reduce,661595,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minimum.*``'; intrinsic. That is, this intrinsic propagates NaNs and -0.0 is considered less; than +0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. '``llvm.vector.insert``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. ; Insert fixed type into scalable type; declare <vscale x 4 x float> @llvm.vector.insert.nxv4f32.v4f32(<vscale x 4 x float> %vec, <4 x float> %subvec, i64 <idx>); declare <vscale x 2 x double> @llvm.vector.insert.nxv2f64.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:661662,Energy Efficiency,reduce,reduce,661662,"is is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fmaximum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minimum.*``'; intrinsic. That is, this intrinsic propagates NaNs and -0.0 is considered less; than +0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. '``llvm.vector.insert``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. ; Insert fixed type into scalable type; declare <vscale x 4 x float> @llvm.vector.insert.nxv4f32.v4f32(<vscale x 4 x float> %vec, <4 x float> %subvec, i64 <idx>); declare <vscale x 2 x double> @llvm.vector.insert.nxv2f64.v2f64(<vscale x 2 x double> %vec, <2 x double> %subvec, i64 <idx>).",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:661743,Energy Efficiency,reduce,reduce,661743,"32(<4 x float> %a); declare double @llvm.vector.reduce.fmaximum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point; ``MAX`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.maximum.*``'; intrinsic. That is, this intrinsic propagates NaNs and +0.0 is considered; greater than -0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. .. _int_vector_reduce_fminimum:. '``llvm.vector.reduce.fminimum.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float> %a); declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point; ``MIN`` reduction of a vector, returning the result as a scalar. The return type; matches the element-type of the vector input. This instruction has the same comparison semantics as the '``llvm.minimum.*``'; intrinsic. That is, this intrinsic propagates NaNs and -0.0 is considered less; than +0.0. If any element of the vector is a NaN, the result is NaN. Arguments:; """"""""""""""""""""; The argument to this intrinsic must be a vector of floating-point values. '``llvm.vector.insert``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. ; Insert fixed type into scalable type; declare <vscale x 4 x float> @llvm.vector.insert.nxv4f32.v4f32(<vscale x 4 x float> %vec, <4 x float> %subvec, i64 <idx>); declare <vscale x 2 x double> @llvm.vector.insert.nxv2f64.v2f64(<vscale x 2 x double> %vec, <2 x double> %subvec, i64 <idx>). ; Insert scalable type into scalable type; declare <vscale x 4 x float> @llvm.ve",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:688422,Energy Efficiency,allocate,allocated,688422," Level; Debugging <SourceLevelDebugging.html#format-common-intrinsics>`_; document. Exception Handling Intrinsics; -----------------------------. The LLVM exception handling intrinsics (which all start with; ``llvm.eh.`` prefix), are described in the `LLVM Exception; Handling <ExceptionHandling.html#format-common-intrinsics>`_ document. Pointer Authentication Intrinsics; ---------------------------------. The LLVM pointer authentication intrinsics (which all start with; ``llvm.ptrauth.`` prefix), are described in the `Pointer Authentication; <PointerAuth.html#intrinsics>`_ document. .. _int_trampoline:. Trampoline Intrinsics; ---------------------. These intrinsics make it possible to excise one parameter, marked with; the :ref:`nest <nest>` attribute, from a function. The result is a; callable function pointer lacking the nest parameter - the caller does; not need to provide a value for it. Instead, the value to use is stored; in advance in a ""trampoline"", a block of memory usually allocated on the; stack, which also contains code to splice the nest value into the; argument list. This is used to implement the GCC nested function address; extension. For example, if the function is ``i32 f(ptr nest %c, i32 %x, i32 %y)``; then the resulting function pointer has signature ``i32 (i32, i32)``.; It can be created as follows:. .. code-block:: llvm. %tramp = alloca [10 x i8], align 4 ; size and alignment only correct for X86; call ptr @llvm.init.trampoline(ptr %tramp, ptr @f, ptr %nval); %fp = call ptr @llvm.adjust.trampoline(ptr %tramp). The call ``%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to; ``%val = call i32 %f(ptr %nval, i32 %x, i32 %y)``. .. _int_it:. '``llvm.init.trampoline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.init.trampoline(ptr <tramp>, ptr <func>, ptr <nval>). Overview:; """""""""""""""""". This fills the memory pointed to by ``tramp`` with executable code,; turning it into a trampoline. Arguments:; """"""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:747156,Energy Efficiency,efficient,efficient,747156,"4 x float> @llvm.fma(<4 x float> %a, <4 x float> %b, <4 x float> %c); %also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> poison. .. _int_vp_fmuladd:. '``llvm.vp.fmuladd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x float> @llvm.vp.fmuladd.v16f32 (<16 x float> <left_op>, <16 x float> <middle_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x float> @llvm.vp.fmuladd.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <middle_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>); declare <256 x double> @llvm.vp.fmuladd.v256f64 (<256 x double> <left_op>, <256 x double> <middle_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point multiply-add of two vectors of floating-point values; that can be fused if code generator determines that (a) the target instruction; set has support for a fused operation, and (b) that the fused operation is more; efficient than the equivalent, separate pair of mul and add instructions. Arguments:; """""""""""""""""""". The first three operands and the result have the same vector of floating-point; type. The fourth operand is the vector mask and has the same number of elements; as the result vector type. The fifth operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fmuladd``' intrinsic performs floating-point multiply-add (:ref:`llvm.fuladd <int_fmuladd>`); of the first, second, and third vector operand on each enabled lane. The result; on disabled lanes is a :ref:`poison value <poisonvalues>`. The operation is; performed in the default floating-point environment. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x float> @llvm.vp.fmuladd.v4f32(<4 x float> %a, <4 x float> %b, <4 x float> %c, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:748274,Energy Efficiency,reduce,reduce,748274,"s and the result have the same vector of floating-point; type. The fourth operand is the vector mask and has the same number of elements; as the result vector type. The fifth operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fmuladd``' intrinsic performs floating-point multiply-add (:ref:`llvm.fuladd <int_fmuladd>`); of the first, second, and third vector operand on each enabled lane. The result; on disabled lanes is a :ref:`poison value <poisonvalues>`. The operation is; performed in the default floating-point environment. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x float> @llvm.vp.fmuladd.v4f32(<4 x float> %a, <4 x float> %b, <4 x float> %c, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = call <4 x float> @llvm.fmuladd(<4 x float> %a, <4 x float> %b, <4 x float> %c); %also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> poison. .. _int_vp_reduce_add:. '``llvm.vp.reduce.add.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.add.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.add.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``ADD`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:748417,Energy Efficiency,reduce,reduce,748417,"e result vector type. The fifth operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fmuladd``' intrinsic performs floating-point multiply-add (:ref:`llvm.fuladd <int_fmuladd>`); of the first, second, and third vector operand on each enabled lane. The result; on disabled lanes is a :ref:`poison value <poisonvalues>`. The operation is; performed in the default floating-point environment. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x float> @llvm.vp.fmuladd.v4f32(<4 x float> %a, <4 x float> %b, <4 x float> %c, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = call <4 x float> @llvm.fmuladd(<4 x float> %a, <4 x float> %b, <4 x float> %c); %also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> poison. .. _int_vp_reduce_add:. '``llvm.vp.reduce.add.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.add.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.add.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``ADD`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:748530,Energy Efficiency,reduce,reduce,748530,"The '``llvm.vp.fmuladd``' intrinsic performs floating-point multiply-add (:ref:`llvm.fuladd <int_fmuladd>`); of the first, second, and third vector operand on each enabled lane. The result; on disabled lanes is a :ref:`poison value <poisonvalues>`. The operation is; performed in the default floating-point environment. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x float> @llvm.vp.fmuladd.v4f32(<4 x float> %a, <4 x float> %b, <4 x float> %c, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = call <4 x float> @llvm.fmuladd(<4 x float> %a, <4 x float> %b, <4 x float> %c); %also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> poison. .. _int_vp_reduce_add:. '``llvm.vp.reduce.add.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.add.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.add.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``ADD`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:749309,Energy Efficiency,reduce,reduce,749309,"^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.add.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.add.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``ADD`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:749392,Energy Efficiency,reduce,reduce,749392," declare i32 @llvm.vp.reduce.add.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.add.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``ADD`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:749838,Energy Efficiency,reduce,reduce,749838,"the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:750151,Energy Efficiency,reduce,reduce,750151," same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vect",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:750264,Energy Efficiency,reduce,reduce,750264,"n. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` reduction; (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:750411,Energy Efficiency,reduce,reduce,750411,"_reduce_add>`) of the vector operand; ``val`` on each enabled lane, adding it to the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD``; reduction (:r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:750532,Energy Efficiency,reduce,reduce,750532,"nes are treated as containing the neutral value ``0`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is equal; to ``start_value``. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer; %reduction = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a); %also.r = add i32 %reduction, %start. .. _int_vp_reduce_fadd:. '``llvm.vp.reduce.fadd.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD``; reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the; vector operand ``val`` on each enabled lane, adding it to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:751340,Energy Efficiency,reduce,reduce,751340,"""""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD``; reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the; vector operand ``val`` on each enabled lane, adding it to the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:751431,Energy Efficiency,reduce,reduce,751431," <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``ADD`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD``; reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the; vector operand ``val`` on each enabled lane, adding it to the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %mask",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:751872,Energy Efficiency,reduce,reduce,751872,"ch must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD``; reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the; vector operand ``val`` on each enabled lane, adding it to the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_mul:. '``llvm.vp.reduce.mul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:752032,Energy Efficiency,reduce,reduce,752032," floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD``; reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the; vector operand ``val`` on each enabled lane, adding it to the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_mul:. '``llvm.vp.reduce.mul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:752386,Energy Efficiency,reduce,reduce,752386,"int ``ADD``; reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the; vector operand ``val`` on each enabled lane, adding it to the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_mul:. '``llvm.vp.reduce.mul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:752477,Energy Efficiency,reduce,reduce,752477,"ctor operand ``val`` on each enabled lane, adding it to the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_mul:. '``llvm.vp.reduce.mul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:752620,Energy Efficiency,reduce,reduce,752620,"; ``-0.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_mul:. '``llvm.vp.reduce.mul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:752733,Energy Efficiency,reduce,reduce,752733," be equal to ``start_value``. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fadd; <int_vector_reduce_fadd>`) for more detail on the semantics of the reduction. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>; %also.r = call float @llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_mul:. '``llvm.vp.reduce.mul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:753512,Energy Efficiency,reduce,reduce,753512,"^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:753595,Energy Efficiency,reduce,reduce,753595," declare i32 @llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``MUL`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:754037,Energy Efficiency,reduce,reduce,754037," of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first op",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:754363,Energy Efficiency,reduce,reduce,754363,"ber of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vect",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:754476,Energy Efficiency,reduce,reduce,754476,"ics:; """""""""""""""""""". The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` reduction; (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:754623,Energy Efficiency,reduce,reduce,754623,"ul>`) of the vector operand ``val``; on each enabled lane, multiplying it by the scalar ``start_value``. Disabled; lanes are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL``; reduction (:r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:754744,Energy Efficiency,reduce,reduce,754744,"are treated as containing the neutral value ``1`` (i.e. having no effect; on the reduction operation). If the vector length is zero, the result is the; start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>; %reduction = call i32 @llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a); %also.r = mul i32 %reduction, %start. .. _int_vp_reduce_fmul:. '``llvm.vp.reduce.fmul.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL``; reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the; vector operand ``val`` on each enabled lane, multiplying i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:755552,Energy Efficiency,reduce,reduce,755552,"""""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL``; reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the; vector operand ``val`` on each enabled lane, multiplying it by the scalar; `start_value``. Disabled lanes are treated as containing the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:755643,Energy Efficiency,reduce,reduce,755643," <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>); declare double @llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MUL`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL``; reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the; vector operand ``val`` on each enabled lane, multiplying it by the scalar; `start_value``. Disabled lanes are treated as containing the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:756090,Energy Efficiency,reduce,reduce,756090,"t be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL``; reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the; vector operand ``val`` on each enabled lane, multiplying it by the scalar; `start_value``. Disabled lanes are treated as containing the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_and:. '``llvm.vp.reduce.and.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` red",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:756233,Energy Efficiency,reduce,reduce,756233,"a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL``; reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the; vector operand ``val`` on each enabled lane, multiplying it by the scalar; `start_value``. Disabled lanes are treated as containing the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_and:. '``llvm.vp.reduce.and.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:756583,Energy Efficiency,reduce,reduce,756583,"the floating-point ``MUL``; reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the; vector operand ``val`` on each enabled lane, multiplying it by the scalar; `start_value``. Disabled lanes are treated as containing the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_and:. '``llvm.vp.reduce.and.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:756674,Energy Efficiency,reduce,reduce,756674,"l>`) of the; vector operand ``val`` on each enabled lane, multiplying it by the scalar; `start_value``. Disabled lanes are treated as containing the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_and:. '``llvm.vp.reduce.and.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:756817,Energy Efficiency,reduce,reduce,756817,"g the neutral value; ``1.0`` (i.e. having no effect on the reduction operation). If no lanes are; enabled, the resulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_and:. '``llvm.vp.reduce.and.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:756930,Energy Efficiency,reduce,reduce,756930,"sulting value will be equal to the starting value. To ignore the start value, the neutral value can be used. See the unpredicated version (:ref:`llvm.vector.reduce.fmul; <int_vector_reduce_fmul>`) for more detail on the semantics. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>; %also.r = call float @llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a). .. _int_vp_reduce_and:. '``llvm.vp.reduce.and.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the vector operand; ``val`` on each enabled lane, performing an '``and``' of that with with the; scala",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:757709,Energy Efficiency,reduce,reduce,757709,"^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the vector operand; ``val`` on each enabled lane, performing an '``and``' of that with with the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:757792,Energy Efficiency,reduce,reduce,757792," declare i32 @llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``AND`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the vector operand; ``val`` on each enabled lane, performing an '``and``' of that with with the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm.vp.reduce.or.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:758276,Energy Efficiency,reduce,reduce,758276," integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the vector operand; ``val`` on each enabled lane, performing an '``and``' of that with with the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm.vp.reduce.or.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:758606,Energy Efficiency,reduce,reduce,758606,"urth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the vector operand; ``val`` on each enabled lane, performing an '``and``' of that with with the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm.vp.reduce.or.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:758717,Energy Efficiency,reduce,reduce,758717,"`' intrinsic performs the integer ``AND`` reduction; (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the vector operand; ``val`` on each enabled lane, performing an '``and``' of that with with the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm.vp.reduce.or.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:758859,Energy Efficiency,reduce,reduce,758859," each enabled lane, performing an '``and``' of that with with the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm.vp.reduce.or.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`)",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:758971,Energy Efficiency,reduce,reduce,758971,"eated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a); %also.r = and i32 %reduction, %start. .. _int_vp_reduce_or:. '``llvm.vp.reduce.or.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_va",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:759748,Energy Efficiency,reduce,reduce,759748,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:759829,Energy Efficiency,reduce,reduce,759829,". ::. declare i32 @llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``OR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:760287,Energy Efficiency,reduce,reduce,760287,"ion, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:760612,Energy Efficiency,reduce,reduce,760612,"ts as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:760722,Energy Efficiency,reduce,reduce,760722,""""""""""""". The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction; (:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:760865,Energy Efficiency,reduce,reduce,760865,"he vector operand; ``val`` on each enabled lane, performing an '``or``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:760978,Energy Efficiency,reduce,reduce,760978," Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a); %also.r = or i32 %reduction, %start. .. _int_vp_reduce_xor:. '``llvm.vp.reduce.xor.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the vector operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:761757,Energy Efficiency,reduce,reduce,761757,"^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the vector operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:761840,Energy Efficiency,reduce,reduce,761840," declare i32 @llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated integer ``XOR`` reduction of a vector and a scalar starting value,; returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the vector operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overlo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:762301,Energy Efficiency,reduce,reduce,762301,"which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the vector operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the st",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:762627,Energy Efficiency,reduce,reduce,762627,"the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the vector operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:762740,Energy Efficiency,reduce,reduce,762740,"he '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` reduction; (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the vector operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:762885,Energy Efficiency,reduce,reduce,762885,"or operand; ``val`` on each enabled lane, performing an '``xor``' of that with the scalar; ``start_value``. Disabled lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:762999,Energy Efficiency,reduce,reduce,762999,"ed lanes are treated as containing the neutral value; ``0`` (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a); %also.r = xor i32 %reduction, %start. .. _int_vp_reduce_smax:. '``llvm.vp.reduce.smax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:763786,Energy Efficiency,reduce,reduce,763786,"^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:763877,Energy Efficiency,reduce,reduce,763877,"m.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smin:. '``llvm.vp.reduce.smin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:764343,Energy Efficiency,reduce,reduce,764343," a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smin:. '``llvm.vp.reduce.smin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:764672,Energy Efficiency,reduce,reduce,764672,"and. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smin:. '``llvm.vp.reduce.smin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:764805,Energy Efficiency,reduce,reduce,764805,"ic performs the signed-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smin:. '``llvm.vp.reduce.smin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:764950,Energy Efficiency,reduce,reduce,764950,"h enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smin:. '``llvm.vp.reduce.smin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:765064,Energy Efficiency,reduce,reduce,765064,"aining the; neutral value ``INT_MIN`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>; %reduction = call i8 @llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smax.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_smin:. '``llvm.vp.reduce.smin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the; vector operand ``val`` on each enabled lane, and taking the minimum of that and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:765851,Energy Efficiency,reduce,reduce,765851,"^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the; vector operand ``val`` on each enabled lane, and taking the minimum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:765942,Energy Efficiency,reduce,reduce,765942,"m.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated signed-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the; vector operand ``val`` on each enabled lane, and taking the minimum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. '``llvm.vp.reduce.umax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:766408,Energy Efficiency,reduce,reduce,766408," a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the; vector operand ``val`` on each enabled lane, and taking the minimum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. '``llvm.vp.reduce.umax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The fi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:766733,Energy Efficiency,reduce,reduce,766733,"operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the; vector operand ``val`` on each enabled lane, and taking the minimum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. '``llvm.vp.reduce.umax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:766866,Energy Efficiency,reduce,reduce,766866,"rinsic performs the signed-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the; vector operand ``val`` on each enabled lane, and taking the minimum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. '``llvm.vp.reduce.umax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:767011,Energy Efficiency,reduce,reduce,767011," each enabled lane, and taking the minimum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. '``llvm.vp.reduce.umax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:767125,Energy Efficiency,reduce,reduce,767125,"containing the; neutral value ``INT_MAX`` (i.e. having no effect on the reduction operation).; If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i8 @llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>; %reduction = call i8 @llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a); %also.r = call i8 @llvm.smin.i8(i8 %reduction, i8 %start). .. _int_vp_reduce_umax:. '``llvm.vp.reduce.umax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:767914,Energy Efficiency,reduce,reduce,767914,"^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_um",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:768007,Energy Efficiency,reduce,reduce,768007,".reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_umin:. '``llvm.vp.reduce.umin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:768468,Energy Efficiency,reduce,reduce,768468," be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_umin:. '``llvm.vp.reduce.umin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """"""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:768795,Energy Efficiency,reduce,reduce,768795," operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_umin:. '``llvm.vp.reduce.umin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vecto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:768934,Energy Efficiency,reduce,reduce,768934,"c performs the unsigned-integer ``MAX``; reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) of the; vector operand ``val`` on each enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_umin:. '``llvm.vp.reduce.umin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:769079,Energy Efficiency,reduce,reduce,769079,"ch enabled lane, and taking the maximum of that and; the scalar ``start_value``. Disabled lanes are treated as containing the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_umin:. '``llvm.vp.reduce.umin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:769193,Energy Efficiency,reduce,reduce,769193,"taining the; neutral value ``0`` (i.e. having no effect on the reduction operation). If the; vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>; %reduction = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umax.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_umin:. '``llvm.vp.reduce.umin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:769982,Energy Efficiency,reduce,reduce,769982,"^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). ..",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:770075,Energy Efficiency,reduce,reduce,770075,".reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>); declare i16 @llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_fmax:. '``llvm.vp.reduce.fmax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:770550,Energy Efficiency,reduce,reduce,770550,"integer type equal to the result type. The second operand is the vector on; which the reduction is performed and must be a vector of integer values whose; element type is the result/start type. The third operand is the vector mask and; is a vector of boolean values with the same number of elements as the vector; operand. The fourth operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_fmax:. '``llvm.vp.reduce.fmax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arg",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:770881,Energy Efficiency,reduce,reduce,770881,"th operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_fmax:. '``llvm.vp.reduce.fmax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:771020,Energy Efficiency,reduce,reduce,771020,"igned-integer ``MIN``; reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_fmax:. '``llvm.vp.reduce.fmax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explici",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:771167,Energy Efficiency,reduce,reduce,771167,"ing the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value ``UINT_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_fmax:. '``llvm.vp.reduce.fmax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX``; reduction (",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:771290,Energy Efficiency,reduce,reduce,771290,"_MAX``, or ``-1`` (i.e. having no effect on the reduction; operation). If the vector length is zero, the result is the start value. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call i32 @llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>; %reduction = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a); %also.r = call i32 @llvm.umin.i32(i32 %reduction, i32 %start). .. _int_vp_reduce_fmax:. '``llvm.vp.reduce.fmax.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX``; reduction (:ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>`) of the; vector operand ``val`` on each enabled lane, taking the ma",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:772098,Energy Efficiency,reduce,reduce,772098,"""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX``; reduction (:ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>`) of the; vector operand ``val`` on each enabled lane, taking the maximum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``-QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the smallest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``-Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:772189,Energy Efficiency,reduce,reduce,772189,"start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MAX`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX``; reduction (:ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>`) of the; vector operand ``val`` on each enabled lane, taking the maximum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``-QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the smallest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``-Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:772906,Energy Efficiency,reduce,reduce,772906,"vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX``; reduction (:ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>`) of the; vector operand ``val`` on each enabled lane, taking the maximum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``-QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the smallest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``-Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.maxnum.f32(float %reduction, float %start). .. _int_vp_reduce_fmin:. '``llvm.vp.reduce.fmin.*``'",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:773388,Energy Efficiency,reduce,reduce,773388,"al; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``-QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the smallest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``-Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.maxnum.f32(float %reduction, float %start). .. _int_vp_reduce_fmin:. '``llvm.vp.reduce.fmin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:773745,Energy Efficiency,reduce,reduce,773745,"e; result type. If only ``nnan`` is set then the neutral value is ``-Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.maxnum.f32(float %reduction, float %start). .. _int_vp_reduce_fmin:. '``llvm.vp.reduce.fmin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third ope",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:773894,Energy Efficiency,reduce,reduce,773894,"m.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.maxnum.f32(float %reduction, float %start). .. _int_vp_reduce_fmin:. '``llvm.vp.reduce.fmin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explici",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:774041,Energy Efficiency,reduce,reduce,774041,"; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.maxnum.f32(float %reduction, float %start). .. _int_vp_reduce_fmin:. '``llvm.vp.reduce.fmin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN``; reduction (",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:774164,Energy Efficiency,reduce,reduce,774164,"` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.maxnum.f32(float %reduction, float %start). .. _int_vp_reduce_fmin:. '``llvm.vp.reduce.fmin.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN``; reduction (:ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>`) of the; vector operand ``val`` on each enabled lane, taking the mi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:774972,Energy Efficiency,reduce,reduce,774972,"""""""""; This is an overloaded intrinsic. ::. declare float @llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN``; reduction (:ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``+QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the largest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``+Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the; '``llvm.minnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:775063,Energy Efficiency,reduce,reduce,775063,"start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>); declare double @llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Predicated floating-point ``MIN`` reduction of a vector and a scalar starting; value, returning the result as a scalar. Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN``; reduction (:ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``+QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the largest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``+Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the; '``llvm.minnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:775779,Energy Efficiency,reduce,reduce,775779," vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN``; reduction (:ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``+QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the largest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``+Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the; '``llvm.minnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmin.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmin.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.minnum.f32(float %reduction, float %start). .. _int_get_active_lane_mask:. '``llvm.get.active.la",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:776261,Energy Efficiency,reduce,reduce,776261,"ral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``+QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the largest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``+Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the; '``llvm.minnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmin.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmin.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.minnum.f32(float %reduction, float %start). .. _int_get_active_lane_mask:. '``llvm.get.active.lane.mask.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <4 x i1> @llvm.get.active.lane.mask.v4i1.i32(i32 %base, i32 %n); declare <8 x i1> @llvm.get.active.lane.mask.v8i1.i64(i64 %base, i64 %n); declare <16 x i1> @llvm.get.active.lane.mask.v16i1.i64(i64 %base, i64 %n); declare <vscale x 16 x i1> @llvm.get.active.lane.mask.nxv16i1.i64(i64 %base, i64 %n). Overview:; """""""""""""""""". Create a mask representing ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:776618,Energy Efficiency,reduce,reduce,776618,"e; result type. If only ``nnan`` is set then the neutral value is ``+Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the; '``llvm.minnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmin.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated as though %mask were false for those lanes. %masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>; %reduction = call float @llvm.vector.reduce.fmin.v4f32(<4 x float> %masked.a); %also.r = call float @llvm.minnum.f32(float %reduction, float %start). .. _int_get_active_lane_mask:. '``llvm.get.active.lane.mask.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <4 x i1> @llvm.get.active.lane.mask.v4i1.i32(i32 %base, i32 %n); declare <8 x i1> @llvm.get.active.lane.mask.v8i1.i64(i64 %base, i64 %n); declare <16 x i1> @llvm.get.active.lane.mask.v16i1.i64(i64 %base, i64 %n); declare <vscale x 16 x i1> @llvm.get.active.lane.mask.nxv16i1.i64(i64 %base, i64 %n). Overview:; """""""""""""""""". Create a mask representing active and inactive vector lanes. Arguments:; """""""""""""""""""". Both operands have the same scalar integer type. The result is a vector with; the i1 element type. Semantics:; """""""""""""""""""". The '``llvm.get.active.lane.mask.*``' intrinsics are semantically equivalent; to:. ::. %m[i] = icmp ult (%base + i), %n. where ``%m`` is a vector (mask) of active/inactive lane",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:844178,Energy Efficiency,power,power,844178,"^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data is a vector of any integer, floating-point or pointer data type. ::. declare <16 x float> @llvm.masked.load.v16f32.p0(ptr <ptr>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.load.v2f64.p0(ptr <ptr>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); ;; The data is a vector of pointers; declare <8 x ptr> @llvm.masked.load.v8p0.p0(ptr <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. The second operand is the alignment of the source location. It must be a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the base pointer and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.load``' intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar load operations.; The result of this operation is equivalent to a regular vector load instruction followed by a 'select' between the loaded and the passthru values, predicated on the same mask. However, using this intrinsic prevents exceptions on mem",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:846629,Energy Efficiency,power,power,846629,"^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:849701,Energy Efficiency,power,power,849701,"v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be 0 or a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.; The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:853009,Energy Efficiency,power,power,853009,".masked.scatter.v8i32.v8p0 (<8 x i32> <value>, <8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.scatter.v16f32.v16p1(<16 x float> <value>, <16 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <16 x i1> <mask>); declare void @llvm.masked.scatter.v4p0.v4p0 (<4 x ptr> <value>, <4 x ptr> <ptrs>, i32 <alignment>, <4 x i1> <mask>). Overview:; """""""""""""""""". Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. It must be 0 or a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. ::. ;; This instruction unconditionally stores data vector in multiple addresses; call @llvm.masked.scatter.v8i32.v8p0(<8 x i32> %value, <8 x ptr> %ptrs, i32 4, <8 x i1> <true, true, .. true>). ;; It is equivalent to a list of scalar stores; %val0 = extractelement <8 x i32> %value, i32 0; %val1 = e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:861534,Energy Efficiency,allocate,allocated,861534,"pop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:861692,Energy Efficiency,allocate,allocated,861692,"lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """"""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:861825,Energy Efficiency,allocate,allocated,861825,"lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """"""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:862376,Energy Efficiency,allocate,allocated,862376," argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-all",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863065,Energy Efficiency,allocate,allocated,863065," returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is va",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863203,Energy Efficiency,allocate,allocated,863203,"fetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863336,Energy Efficiency,allocate,allocated,863336,"fetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863446,Energy Efficiency,allocate,allocated,863446,"ls all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:867462,Energy Efficiency,monitor,monitored,867462,"invariant.group.p0(ptr <ptr>). Overview:; """""""""""""""""". The '``llvm.strip.invariant.group``' intrinsic can be used when an invariant; established by ``invariant.group`` metadata no longer holds, to obtain a new pointer; value that does not carry the invariant information. It is an experimental; intrinsic, which means that its semantics might change in the future. Arguments:; """""""""""""""""""". The ``llvm.strip.invariant.group`` takes only one argument, which is a pointer; to the memory. Semantics:; """""""""""""""""""". Returns another pointer that aliases its argument but which has no associated; ``invariant.group`` metadata.; It does not read any memory and can be speculated. .. _constrainedfp:. Constrained Floating-Point Intrinsics; -------------------------------------. These intrinsics are used to provide special handling of floating-point; operations when specific rounding mode or floating-point exception behavior is; required. By default, LLVM optimization passes assume that the rounding mode is; round-to-nearest and that floating-point exceptions will not be monitored.; Constrained FP intrinsics are used to support non-default rounding modes and; accurately preserve exception behavior without compromising LLVM's ability to; optimize FP code when the default behavior is used. If any FP operation in a function is constrained then they all must be; constrained. This is required for correct LLVM IR. Optimizations that; move code around can create miscompiles if mixing of constrained and normal; operations is done. The correct way to mix constrained and less constrained; operations is to use the rounding mode and exception handling metadata to; mark constrained intrinsics as having LLVM's default behavior. Each of these intrinsics corresponds to a normal floating-point operation. The; data arguments and the return value are the same as the corresponding FP; operation. The rounding mode argument is a metadata string specifying what; assumptions, if any, the optimizer can make when tr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:888061,Energy Efficiency,efficient,efficient,888061,"m.experimental.constrained.fcmp``' will only raise an exception; if either operand is a SNAN. The signaling comparison operation; performed by '``llvm.experimental.constrained.fcmps``' will raise an; exception if either operand is a NAN (QNAN or SNAN). Such an exception; does not preclude a result being produced (e.g. exception might only; set a flag), therefore the distinction between ordered and unordered; comparisons is also relevant for the; '``llvm.experimental.constrained.fcmps``' intrinsic. '``llvm.experimental.constrained.fmuladd``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.fmuladd(<type> <op1>, <type> <op2>,; <type> <op3>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fmuladd``' intrinsic represents; multiply-add expressions that can be fused if the code generator determines; that (a) the target instruction set has support for a fused operation,; and (b) that the fused operation is more efficient than the equivalent,; separate pair of mul and add instructions. Arguments:; """""""""""""""""""". The first three arguments to the '``llvm.experimental.constrained.fmuladd``'; intrinsic must be floating-point or vector of floating-point values.; All three arguments must have identical types. The fourth and fifth arguments specify the rounding mode and exception behavior; as described above. Semantics:; """""""""""""""""""". The expression:. ::. %0 = call float @llvm.experimental.constrained.fmuladd.f32(%a, %b, %c,; metadata <rounding mode>,; metadata <exception behavior>). is equivalent to the expression:. ::. %0 = call float @llvm.experimental.constrained.fmul.f32(%a, %b,; metadata <rounding mode>,; metadata <exception behavior>); %1 = call float @llvm.experimental.constrained.fadd.f32(%0, %c,; metadata <rounding mode>,; metadata <exception behavior>). except that it is unspecified whether rounding will be performed betw",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:891294,Energy Efficiency,power,power,891294,"perimental.constrained.sqrt``' intrinsic returns the square root; of the specified value, returning the same value as the libm '``sqrt``'; functions would, but without setting ``errno``. Arguments:; """""""""""""""""""". The first argument and the return type are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the nonnegative square root of the specified value.; If the value is less than negative zero, a floating-point exception occurs; and the return value is architecture specific. '``llvm.experimental.constrained.pow``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.pow(<type> <op1>, <type> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.pow``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers of the; same type. The second argument specifies the power to which the first argument; should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power,; returning the same values as the libm ``pow`` functions would, and; handles error conditions in the same way. '``llvm.experimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second op",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:891482,Energy Efficiency,power,power,891482,"st argument and the return type are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the nonnegative square root of the specified value.; If the value is less than negative zero, a floating-point exception occurs; and the return value is architecture specific. '``llvm.experimental.constrained.pow``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.pow(<type> <op1>, <type> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.pow``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers of the; same type. The second argument specifies the power to which the first argument; should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power,; returning the same values as the libm ``pow`` functions would, and; handles error conditions in the same way. '``llvm.experimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. The; order of evaluation of multiplications is not defined. When a vector of; floating-point type is used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The first argument and the r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:891719,Energy Efficiency,power,power,891719,"he specified value.; If the value is less than negative zero, a floating-point exception occurs; and the return value is architecture specific. '``llvm.experimental.constrained.pow``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.pow(<type> <op1>, <type> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.pow``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers of the; same type. The second argument specifies the power to which the first argument; should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power,; returning the same values as the libm ``pow`` functions would, and; handles error conditions in the same way. '``llvm.experimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. The; order of evaluation of multiplications is not defined. When a vector of; floating-point type is used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument is a 32-bit signed integer specifying the power to; which the first argument should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:892241,Energy Efficiency,power,power,892241," intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. Arguments:; """""""""""""""""""". The first two arguments and the return value are floating-point numbers of the; same type. The second argument specifies the power to which the first argument; should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power,; returning the same values as the libm ``pow`` functions would, and; handles error conditions in the same way. '``llvm.experimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. The; order of evaluation of multiplications is not defined. When a vector of; floating-point type is used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument is a 32-bit signed integer specifying the power to; which the first argument should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.experimental.constrained.ldexp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type0>; @llvm.experimental.constrained.ldexp(<type0> <op1>, <type1> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.exper",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:892611,Energy Efficiency,power,power,892611,"; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power,; returning the same values as the libm ``pow`` functions would, and; handles error conditions in the same way. '``llvm.experimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. The; order of evaluation of multiplications is not defined. When a vector of; floating-point type is used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument is a 32-bit signed integer specifying the power to; which the first argument should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.experimental.constrained.ldexp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type0>; @llvm.experimental.constrained.ldexp(<type0> <op1>, <type1> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.ldexp``' performs the ldexp function. Arguments:; """""""""""""""""""". The first argument and the return value are :ref:`floating-point; <t_floating>` or :ref:`vector <t_vector>` of floating-point values of; the same type. The second argument is an integer with the same number; of elements. The third and fourth arguments specify the rounding mode and exception; behavior as ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:892848,Energy Efficiency,power,power,892848,"perimental.constrained.powi``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.powi``' intrinsic returns the first operand; raised to the (positive or negative) power specified by the second operand. The; order of evaluation of multiplications is not defined. When a vector of; floating-point type is used, the second argument remains a scalar integer value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument is a 32-bit signed integer specifying the power to; which the first argument should be raised. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.experimental.constrained.ldexp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type0>; @llvm.experimental.constrained.ldexp(<type0> <op1>, <type1> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.ldexp``' performs the ldexp function. Arguments:; """""""""""""""""""". The first argument and the return value are :ref:`floating-point; <t_floating>` or :ref:`vector <t_vector>` of floating-point values of; the same type. The second argument is an integer with the same number; of elements. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function multiplies the first argument by 2 raised to the second; argument's power. If the first argument is NaN or infinite, the same; value is returned. If the result underflows a zero with the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:893729,Energy Efficiency,power,power,893729,"ents specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the first value raised to the second power with an; unspecified sequence of rounding operations. '``llvm.experimental.constrained.ldexp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type0>; @llvm.experimental.constrained.ldexp(<type0> <op1>, <type1> <op2>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.ldexp``' performs the ldexp function. Arguments:; """""""""""""""""""". The first argument and the return value are :ref:`floating-point; <t_floating>` or :ref:`vector <t_vector>` of floating-point values of; the same type. The second argument is an integer with the same number; of elements. The third and fourth arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function multiplies the first argument by 2 raised to the second; argument's power. If the first argument is NaN or infinite, the same; value is returned. If the result underflows a zero with the same sign; is returned. If the result overflows, the result is an infinity with; the same sign. '``llvm.experimental.constrained.sin``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.sin(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.sin``' intrinsic returns the sine of the; first operand. Arguments:; """""""""""""""""""". The first argument and the return type are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the sine of the specified operand, returning the; same values as the libm ``sin`` functions would, and handles error; conditio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:958454,Energy Efficiency,power,power,958454," i32 <element_size>); declare void @llvm.memcpy.element.unordered.atomic.p0.p0.i64(ptr <dest>,; ptr <src>,; i64 <len>,; i32 <element_size>). Overview:; """""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic is a specialization of the; '``llvm.memcpy.*``' intrinsic. It differs in that the ``dest`` and ``src`` are treated; as arrays with elements that are exactly ``element_size`` bytes, and the copy between; buffers uses a sequence of :ref:`unordered atomic <ordering>` load/store operations; that are a positive integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the :ref:`@llvm.memcpy <int_memcpy>`; intrinsic, with the added constraint that ``len`` is required to be a positive integer; multiple of the ``element_size``. If ``len`` is not a positive integer multiple of; ``element_size``, then the behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no greater than; target-specific atomic access size limit. For each of the input pointers ``align`` parameter attribute must be specified. It; must be a power of two no less than the ``element_size``. Caller guarantees that; both the source and destination pointers are aligned to that boundary. Semantics:; """""""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic copies ``len`` bytes of; memory from the source location to the destination location. These locations are not; allowed to overlap. The memory copy is performed as a sequence of load/store operations; where each access is guaranteed to be a multiple of ``element_size`` bytes wide and; aligned at an ``element_size`` boundary. The order of the copy is unspecified. The same value may be read from the source; buffer many times, but only one write is issued to the destination buffer per; element. It is well defined to have concurrent reads and writes to both source and; destination provided those reads and writes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:958620,Energy Efficiency,power,power,958620,"emcpy.element.unordered.atomic.*``' intrinsic is a specialization of the; '``llvm.memcpy.*``' intrinsic. It differs in that the ``dest`` and ``src`` are treated; as arrays with elements that are exactly ``element_size`` bytes, and the copy between; buffers uses a sequence of :ref:`unordered atomic <ordering>` load/store operations; that are a positive integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the :ref:`@llvm.memcpy <int_memcpy>`; intrinsic, with the added constraint that ``len`` is required to be a positive integer; multiple of the ``element_size``. If ``len`` is not a positive integer multiple of; ``element_size``, then the behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no greater than; target-specific atomic access size limit. For each of the input pointers ``align`` parameter attribute must be specified. It; must be a power of two no less than the ``element_size``. Caller guarantees that; both the source and destination pointers are aligned to that boundary. Semantics:; """""""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic copies ``len`` bytes of; memory from the source location to the destination location. These locations are not; allowed to overlap. The memory copy is performed as a sequence of load/store operations; where each access is guaranteed to be a multiple of ``element_size`` bytes wide and; aligned at an ``element_size`` boundary. The order of the copy is unspecified. The same value may be read from the source; buffer many times, but only one write is issued to the destination buffer per; element. It is well defined to have concurrent reads and writes to both source and; destination provided those reads and writes are unordered atomic when specified. This intrinsic does not provide any additional ordering guarantees over those; provided by a set of unordered loads from the source locati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:961548,Energy Efficiency,power,power,961548,"ement_size>); declare void @llvm.memmove.element.unordered.atomic.p0.p0.i64(ptr <dest>,; ptr <src>,; i64 <len>,; i32 <element_size>). Overview:; """""""""""""""""". The '``llvm.memmove.element.unordered.atomic.*``' intrinsic is a specialization; of the '``llvm.memmove.*``' intrinsic. It differs in that the ``dest`` and; ``src`` are treated as arrays with elements that are exactly ``element_size``; bytes, and the copy between buffers uses a sequence of; :ref:`unordered atomic <ordering>` load/store operations that are a positive; integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the; :ref:`@llvm.memmove <int_memmove>` intrinsic, with the added constraint that; ``len`` is required to be a positive integer multiple of the ``element_size``.; If ``len`` is not a positive integer multiple of ``element_size``, then the; behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no; greater than a target-specific atomic access size limit. For each of the input pointers the ``align`` parameter attribute must be; specified. It must be a power of two no less than the ``element_size``. Caller; guarantees that both the source and destination pointers are aligned to that; boundary. Semantics:; """""""""""""""""""". The '``llvm.memmove.element.unordered.atomic.*``' intrinsic copies ``len`` bytes; of memory from the source location to the destination location. These locations; are allowed to overlap. The memory copy is performed as a sequence of load/store; operations where each access is guaranteed to be a multiple of ``element_size``; bytes wide and aligned at an ``element_size`` boundary. The order of the copy is unspecified. The same value may be read from the source; buffer many times, but only one write is issued to the destination buffer per; element. It is well defined to have concurrent reads and writes to both source; and destination provided those reads and wri",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:961720,Energy Efficiency,power,power,961720,"nt.unordered.atomic.*``' intrinsic is a specialization; of the '``llvm.memmove.*``' intrinsic. It differs in that the ``dest`` and; ``src`` are treated as arrays with elements that are exactly ``element_size``; bytes, and the copy between buffers uses a sequence of; :ref:`unordered atomic <ordering>` load/store operations that are a positive; integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the; :ref:`@llvm.memmove <int_memmove>` intrinsic, with the added constraint that; ``len`` is required to be a positive integer multiple of the ``element_size``.; If ``len`` is not a positive integer multiple of ``element_size``, then the; behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no; greater than a target-specific atomic access size limit. For each of the input pointers the ``align`` parameter attribute must be; specified. It must be a power of two no less than the ``element_size``. Caller; guarantees that both the source and destination pointers are aligned to that; boundary. Semantics:; """""""""""""""""""". The '``llvm.memmove.element.unordered.atomic.*``' intrinsic copies ``len`` bytes; of memory from the source location to the destination location. These locations; are allowed to overlap. The memory copy is performed as a sequence of load/store; operations where each access is guaranteed to be a multiple of ``element_size``; bytes wide and aligned at an ``element_size`` boundary. The order of the copy is unspecified. The same value may be read from the source; buffer many times, but only one write is issued to the destination buffer per; element. It is well defined to have concurrent reads and writes to both source; and destination provided those reads and writes are unordered atomic when; specified. This intrinsic does not provide any additional ordering guarantees over those; provided by a set of unordered loads from the source location",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:964678,Energy Efficiency,power,power,964678,"2 <len>,; i32 <element_size>); declare void @llvm.memset.element.unordered.atomic.p0.i64(ptr <dest>,; i8 <value>,; i64 <len>,; i32 <element_size>). Overview:; """""""""""""""""". The '``llvm.memset.element.unordered.atomic.*``' intrinsic is a specialization of the; '``llvm.memset.*``' intrinsic. It differs in that the ``dest`` is treated as an array; with elements that are exactly ``element_size`` bytes, and the assignment to that array; uses uses a sequence of :ref:`unordered atomic <ordering>` store operations; that are a positive integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the :ref:`@llvm.memset <int_memset>`; intrinsic, with the added constraint that ``len`` is required to be a positive integer; multiple of the ``element_size``. If ``len`` is not a positive integer multiple of; ``element_size``, then the behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no greater than; target-specific atomic access size limit. The ``dest`` input pointer must have the ``align`` parameter attribute specified. It; must be a power of two no less than the ``element_size``. Caller guarantees that; the destination pointer is aligned to that boundary. Semantics:; """""""""""""""""""". The '``llvm.memset.element.unordered.atomic.*``' intrinsic sets the ``len`` bytes of; memory starting at the destination location to the given ``value``. The memory is; set with a sequence of store operations where each access is guaranteed to be a; multiple of ``element_size`` bytes wide and aligned at an ``element_size`` boundary. The order of the assignment is unspecified. Only one write is issued to the; destination buffer per element. It is well defined to have concurrent reads and; writes to the destination provided those reads and writes are unordered atomic; when specified. This intrinsic does not provide any additional ordering guarantees over those; provided by a set of ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:964846,Energy Efficiency,power,power,964846,"lvm.memset.element.unordered.atomic.*``' intrinsic is a specialization of the; '``llvm.memset.*``' intrinsic. It differs in that the ``dest`` is treated as an array; with elements that are exactly ``element_size`` bytes, and the assignment to that array; uses uses a sequence of :ref:`unordered atomic <ordering>` store operations; that are a positive integer multiple of the ``element_size`` in size. Arguments:; """""""""""""""""""". The first three arguments are the same as they are in the :ref:`@llvm.memset <int_memset>`; intrinsic, with the added constraint that ``len`` is required to be a positive integer; multiple of the ``element_size``. If ``len`` is not a positive integer multiple of; ``element_size``, then the behaviour of the intrinsic is undefined. ``element_size`` must be a compile-time constant positive power of two no greater than; target-specific atomic access size limit. The ``dest`` input pointer must have the ``align`` parameter attribute specified. It; must be a power of two no less than the ``element_size``. Caller guarantees that; the destination pointer is aligned to that boundary. Semantics:; """""""""""""""""""". The '``llvm.memset.element.unordered.atomic.*``' intrinsic sets the ``len`` bytes of; memory starting at the destination location to the given ``value``. The memory is; set with a sequence of store operations where each access is guaranteed to be a; multiple of ``element_size`` bytes wide and aligned at an ``element_size`` boundary. The order of the assignment is unspecified. Only one write is issued to the; destination buffer per element. It is well defined to have concurrent reads and; writes to the destination provided those reads and writes are unordered atomic; when specified. This intrinsic does not provide any additional ordering guarantees over those; provided by a set of unordered stores to the destination. Lowering:; """""""""""""""""". In the most general case call to the '``llvm.memset.element.unordered.atomic.*``' is; lowered to a call to the symbol `",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:23543,Integrability,depend,depends,23543,"et address is passed in X15.; ""``cc <n>``"" - Numbered convention; Any calling convention may be specified by number, allowing; target-specific calling conventions to be used. Target specific; calling conventions start at 64. More calling conventions can be added/defined on an as-needed basis, to; support Pascal conventions or any other well-known target-independent; convention. .. _visibilitystyles:. Visibility Styles; -----------------. All Global Variables and Functions have one of the following visibility; styles:. ""``default``"" - Default style; On targets that use the ELF object file format, default visibility; means that the declaration is visible to other modules and, in; shared libraries, means that the declared entity may be overridden.; On Darwin, default visibility means that the declaration is visible; to other modules. On XCOFF, default visibility means no explicit; visibility bit will be set and whether the symbol is visible; (i.e ""exported"") to other modules depends primarily on export lists; provided to the linker. Default visibility corresponds to ""external; linkage"" in the language.; ""``hidden``"" - Hidden style; Two declarations of an object with hidden visibility refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25341,Integrability,interface,interface,25341,"ageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:28563,Integrability,depend,dependent,28563,"---------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer types are a work in progress, and they should be; considered experimental at this time. LLVM IR optionally allows the frontend to denote pointers in certain address; spaces as ""non-integral"" via the :ref:`datalayout string<langref_datalayout>`.; Non-integral pointer types represent pointers that have an *unspecified* bitwise; representation; that is, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29076,Integrability,depend,depends,29076,"tptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer types are a work in progress, and they should be; considered experimental at this time. LLVM IR optionally allows the frontend to denote pointers in certain address; spaces as ""non-integral"" via the :ref:`datalayout string<langref_datalayout>`.; Non-integral pointer types represent pointers that have an *unspecified* bitwise; representation; that is, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29366,Integrability,rout,routines,29366,"l"" via the :ref:`datalayout string<langref_datalayout>`.; Non-integral pointer types represent pointers that have an *unspecified* bitwise; representation; that is, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Globa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:47883,Integrability,depend,depending,47883," COFF COMDAT where a function will only be selected if; the COMDAT key's section is the largest:. .. code-block:: text. $foo = comdat largest; @foo = global i32 2, comdat($foo). define void @bar() comdat($foo) {; ret void; }. In a COFF object file, this will create a COMDAT section with selection kind; ``IMAGE_COMDAT_SELECT_LARGEST`` containing the contents of the ``@foo`` symbol; and another COMDAT section with selection kind; ``IMAGE_COMDAT_SELECT_ASSOCIATIVE`` which is associated with the first COMDAT; section and contains the contents of the ``@bar`` symbol. As a syntactic sugar the ``$name`` can be omitted if the name is the same as; the global name:. .. code-block:: llvm. $foo = comdat any; @foo = global i32 2, comdat; @bar = global i32 3, comdat($foo). There are some restrictions on the properties of the global object.; It, or an alias to it, must have the same name as the COMDAT group when; targeting COFF.; The contents and size of this object may be used during link-time to determine; which COMDAT groups get selected depending on the selection kind.; Because the name of the object must match the name of the COMDAT group, the; linkage of the global object must not be local; local symbols can get renamed; if a collision occurs in the symbol table. The combined use of COMDATS and section attributes may yield surprising results.; For example:. .. code-block:: llvm. $foo = comdat any; $bar = comdat any; @g1 = global i32 42, section ""sec"", comdat($foo); @g2 = global i32 42, section ""sec"", comdat($bar). From the object file perspective, this requires the creation of two sections; with the same name. This is necessary because both globals belong to different; COMDAT groups and COMDATs, at the object file level, are represented by; sections. Note that certain IR constructs like global variables and functions may; create COMDATs in the object file in addition to any which are specified using; COMDAT IR. This arises when the code generator is configured to emit globals",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:51133,Integrability,depend,dependent,51133,"are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a special target-dependent fashion while emitting code for; a function call or return (usually, by putting it in a register as; opposed to memory, though some targets use it to distinguish between; two different kinds of registers). Use of this attribute is; target-specific.; ``byval(<ty>)``; This indicates that the pointer parameter should really be passed by; value to the function. The attribute implies that a hidden copy of; the pointee is made between the caller and the callee, so the callee; is unable to modify the value in the caller. This attribute is only; valid on LLVM pointer arguments. It is generally used to pass; structs and arrays by value, but is also valid on pointers to; scalars. The copy is considered to belong to the caller not the; callee (for example, ``readonly`` functions should not write to; ``byval`` parameters). This is not a valid attribute for return; values. The byval type argument indicates the in-memory value type, and; must be the same as the pointee type of the argument. The byval attribute also supports specifying an alignm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:65841,Integrability,depend,depend,65841,"ass:. ``nofpclass(<test mask>)``; This attribute applies to parameters and return values with; floating-point and vector of floating-point types, as well as; arrays of such types. The test mask has the same format as the; second argument to the :ref:`llvm.is.fpclass <llvm.is.fpclass>`,; and indicates which classes of floating-point values are not; permitted for the value. For example a bitmask of 3 indicates; the parameter may not be a NaN. If the value is a floating-point class indicated by the; ``nofpclass`` test mask, a :ref:`poison value <poisonvalues>` is; passed or returned instead. .. code-block:: text; :caption: The following invariants hold. @llvm.is.fpclass(nofpclass(test_mask) %x, test_mask) => false; @llvm.is.fpclass(nofpclass(test_mask) %x, ~test_mask) => true; nofpclass(all) => poison; .. In textual IR, various string names are supported for readability; and can be combined. For example ``nofpclass(nan pinf nzero)``; evaluates to a mask of 547. This does not depend on the floating-point environment. For; example, a function parameter marked ``nofpclass(zero)`` indicates; no zero inputs. If this is applied to an argument in a function; marked with :ref:`\""denormal-fp-math\"" <denormal_fp_math>`; indicating zero treatment of input denormals, it does not imply the; value cannot be a denormal value which would compare equal to 0. .. table:: Recognized test mask names. +-------+----------------------+---------------+; | Name | floating-point class | Bitmask value |; +=======+======================+===============+; | nan | Any NaN | 3 |; +-------+----------------------+---------------+; | inf | +/- infinity | 516 |; +-------+----------------------+---------------+; | norm | +/- normal | 26 |; +-------+----------------------+---------------+; | sub | +/- subnormal | 144 |; +-------+----------------------+---------------+; | zero | +/- 0 | 96 |; +-------+----------------------+---------------+; | all | All values | 1023 |; +-------+----------------------+-----",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:67926,Integrability,depend,dependent,67926,"-----+; | qnan | Quiet NaN | 2 |; +-------+----------------------+---------------+; | ninf | Negative infinity | 4 |; +-------+----------------------+---------------+; | nnorm | Negative normal | 8 |; +-------+----------------------+---------------+; | nsub | Negative subnormal | 16 |; +-------+----------------------+---------------+; | nzero | Negative zero | 32 |; +-------+----------------------+---------------+; | pzero | Positive zero | 64 |; +-------+----------------------+---------------+; | psub | Positive subnormal | 128 |; +-------+----------------------+---------------+; | pnorm | Positive normal | 256 |; +-------+----------------------+---------------+; | pinf | Positive infinity | 512 |; +-------+----------------------+---------------+. ``alignstack(<n>)``; This indicates the alignment that should be considered by the backend when; assigning this parameter to a stack slot during calling convention; lowering. The enforcement of the specified alignment is target-dependent,; as target-specific calling convention rules may override this value. This; attribute serves the purpose of carrying language specific alignment; information that is not mapped to base types in the backend (for example,; over-alignment specification through language attributes). ``allocalign``; The function parameter marked with this attribute is the alignment in bytes of the; newly allocated block returned by this function. The returned value must either have; the specified alignment or be the null pointer. The return value MAY be more aligned; than the requested alignment, but not less aligned. Invalid (e.g. non-power-of-2); alignments are permitted for the allocalign parameter, so long as the returned pointer; is null. This attribute may only be applied to integer parameters. ``allocptr``; The function parameter marked with this attribute is the pointer; that will be manipulated by the allocator. For a realloc-like; function the pointer will be invalidated upon success (but the; same ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:71199,Integrability,depend,depend,71199,"omically) loaded and stored back on entry to the function. This implies that it's possible to introduce spurious stores on entry to; the function without introducing traps or data races. This does not; necessarily hold throughout the whole function, as the pointer may escape; to a different thread during the execution of the function. See also the; :ref:`atomic optimization guide <Optimization outside atomic>`. The ""other attributes"" that imply dereferenceability are; ``dereferenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:74755,Integrability,depend,dependent,74755,"ata. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular format. Specifically, it must begin with a sequence of; bytes which decode to a sequence of machine instructions, valid for the; module's target, which transfer control to the point immediately succeeding; the prologue data, without performing any other visible action. This allows; the inliner and other passes to reason about the semantics of the function; definition without needing to reason about the prologue data. Obviously this; makes the format of the prologue data highly target dependent. A trivial example of valid prologue data for the x86 architecture is ``i8 144``,; which encodes the ``nop`` instruction:. .. code-block:: text. define void @f() prologue i8 144 { ... }. Generally prologue data can be formed by encoding a relative branch instruction; which skips the metadata, as in this example of valid prologue data for the; x86_64 architecture, where the first two bytes encode ``jmp .+10``:. .. code-block:: text. %0 = type <{ i8, i8, ptr }>. define void @f() prologue %0 <{ i8 235, i8 8, ptr @md}> { ... }. A function may have prologue data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _personalityfn:. Personality Function; --------------------. The ``personality`` attribute permits functions to specify what function; to use for exception handling. .. _attrgrp:. Attribute Groups; ----------------. Attri",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:76647,Integrability,depend,dependent,76647,"g. .. _attrgrp:. Attribute Groups; ----------------. Attribute groups are groups of attributes that are referenced by objects within; the IR. They are important for keeping ``.ll`` files readable, because a lot of; functions will use the same set of attributes. In the degenerative case of a; ``.ll`` file that corresponds to a single ``.c`` file, the single attribute; group will capture the important command line flags used to build that file. An attribute group is a module-level object. To use an attribute group, an; object references the attribute group's ID (e.g. ``#37``). An object may refer; to more than one attribute group. In that situation, the attributes from the; different groups are merged. Here is an example of attribute groups for a function that should always be; inlined, has a stack alignment of 4, and which shouldn't use SSE instructions:. .. code-block:: llvm. ; Target-independent attributes:; attributes #0 = { alwaysinline alignstack=4 }. ; Target-dependent attributes:; attributes #1 = { ""no-sse"" }. ; Function @f has attributes: alwaysinline, alignstack=4, and ""no-sse"".; define void @f() #0 #1 { ... }. .. _fnattrs:. Function Attributes; -------------------. Function attributes are set to communicate additional information about; a function. Function attributes are considered to be part of the; function, not of the function type, so functions with different function; attributes can have the same function type. Function attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:81669,Integrability,depend,depending,81669,"eights, basic blocks post-dominated by a cold; function call are also considered to be cold; and, thus, given low; weight. .. _attr_convergent:. ``convergent``; This attribute indicates that this function is convergent.; When it appears on a call/invoke, the convergent attribute; indicates that we should treat the call as though we’re calling a; convergent function. This is particularly useful on indirect; calls; without this we may treat such calls as though the target; is non-convergent. See :doc:`ConvergentOperations` for further details. It is an error to call :ref:`llvm.experimental.convergence.entry; <llvm.experimental.convergence.entry>` from a function that; does not have this attribute.; ``disable_sanitizer_instrumentation``; When instrumenting code with sanitizers, it can be important to skip certain; functions to ensure no instrumentation is applied to them. This attribute is not always similar to absent ``sanitize_<name>``; attributes: depending on the specific sanitizer, code can be inserted into; functions regardless of the ``sanitize_<name>`` attribute to prevent false; positive reports. ``disable_sanitizer_instrumentation`` disables all kinds of instrumentation,; taking precedence over the ``sanitize_<name>`` attributes and other compiler; flags.; ``""dontcall-error""``; This attribute denotes that an error diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``""dontcall-warn""``; This attribute denotes that a warning diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:84539,Integrability,depend,depends,84539,"n is a hot spot of the program; execution. The function will be optimized more aggressively and will be; placed into special subsection of the text section to improving locality. When profile feedback is enabled, this attribute has the precedence over; the profile information. By marking a function ``hot``, users can work; around the cases where the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the call-site or; function. It allows specifying the possible access kinds (``none``,; ``read``, ``write``, or ``readwrite``) for the possible memory location; kinds (``argmem``, ``inaccessiblemem``, as well as a default). It is best; understood by example:. - ``memory(none)``: Does not access any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86043,Integrability,depend,dependencies,86043,"cess any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``opt",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:93550,Integrability,synchroniz,synchronize,93550,", hence through a return instruction. This produces undefined; behavior at runtime if the function ever does dynamically return. Annotated; functions may still raise an exception, i.a., ``nounwind`` is not implied.; ``norecurse``; This function attribute indicates that the function does not call itself; either directly or indirectly down any possible call path. This produces; undefined behavior at runtime if the function ever does recurse. .. _langref_willreturn:. ``willreturn``; This function attribute indicates that a call of this function will; either exhibit undefined behavior or comes back and continues execution; at a point in the existing call stack that includes the current invocation.; Annotated functions may still raise an exception, i.a., ``nounwind`` is not implied.; If an invocation of an annotated function does not return control back; to a point in the call stack, the behavior is undefined.; ``nosync``; This function attribute indicates that the function does not communicate; (synchronize) with another thread through memory or other well-defined means.; Synchronization is considered possible in the presence of `atomic` accesses; that enforce an order, thus not ""unordered"" and ""monotonic"", `volatile` accesses,; as well as `convergent` function calls. Note that `convergent` operations can involve communication that is; considered to be not through memory and does not necessarily imply an; ordering between threads for the purposes of the memory model. Therefore,; an operation can be both `convergent` and `nosync`. If a `nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:94128,Integrability,synchroniz,synchronize,94128,"ack and continues execution; at a point in the existing call stack that includes the current invocation.; Annotated functions may still raise an exception, i.a., ``nounwind`` is not implied.; If an invocation of an annotated function does not return control back; to a point in the call stack, the behavior is undefined.; ``nosync``; This function attribute indicates that the function does not communicate; (synchronize) with another thread through memory or other well-defined means.; Synchronization is considered possible in the presence of `atomic` accesses; that enforce an order, thus not ""unordered"" and ""monotonic"", `volatile` accesses,; as well as `convergent` function calls. Note that `convergent` operations can involve communication that is; considered to be not through memory and does not necessarily imply an; ordering between threads for the purposes of the memory model. Therefore,; an operation can be both `convergent` and `nosync`. If a `nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behav",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97018,Integrability,depend,depends,97018,"this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:107146,Integrability,depend,depend,107146,"ating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instructions. For compatibility with older; bitcode, if the second value is omitted, both input and output; modes will assume the same mode. If this is attribute is not specified, the default is ``""ieee,ieee""``. If the output mode is ``""preserve-sign""``, or ``""positive-zero""``,; denormal outputs may be flushed to zero by standard floating-point; operations. It is not mandated that flushing to zero occurs, but if; a denormal output is flushed to zero, it must respect the sign; mode. Not all targets support all modes. If the mode is ``""dynamic""``, the behavior is derived from the; dynamic state of the floating-point environment. Transformations; which depend on the behavior of denormal values should not be; performed. While this indicates the expected floating point mode the function; will be executed with, this does not make any attempt to ensure; the mode is consistent. User or platform code is expected to set; the floating point mode appropriately before function entry. If the input mode is ``""preserve-sign""``, or ``""positive-zero""``,; a floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:109992,Integrability,synchroniz,synchronization,109992,"les; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicates that the ShadowCallStack checks are enabled for; the function. The instrumentation checks that the return address for the; function has not changed between the function prolog and epilog. It is; currently x86_64-specific. .. _langref_mustprogress:. ``mustprogress``; This attribute indicates that the function is required to return, unwind,; or interact with the environment in an observable way e.g. via a volatile; memory access, I/O, or other synchronization. The ``mustprogress``; attribute is intended to model the requirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:110424,Integrability,contract,contract,110424," is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicates that the ShadowCallStack checks are enabled for; the function. The instrumentation checks that the return address for the; function has not changed between the function prolog and epilog. It is; currently x86_64-specific. .. _langref_mustprogress:. ``mustprogress``; This attribute indicates that the function is required to return, unwind,; or interact with the environment in an observable way e.g. via a volatile; memory access, I/O, or other synchronization. The ``mustprogress``; attribute is intended to model the requirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked together with differing values.; ``vscale_range(<min>[, <max>])``; This function attribute indicates `vscale` is a power-of-two within a; specified range. `min` must be a power-of-two that is greater than 0. When; specified, `max` must be a power-of-two greater-than-or-equal to `min` or 0; to signify an unbounded maximum. The syntax `vscale_range(<val>)` can be; used to set both `min` and `max` to the same value. Functions that don't; in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:117845,Integrability,depend,depend,117845,"ndles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are conceptually a part of the ``call`` (or ``invoke``), not the; callee being dispatched to. Operand bundles are a generic mechanism intended to support; runtime-introspection-like functionality for managed languages. While; the exact semantics of an operand bundle depend on the bundle tag,; there are certain limitations to how much the presence of an operand; bundle can influence the semantics of a program. These restrictions; are described as the semantics of an ""unknown"" operand bundle. As; long as the behavior of an operand bundle is describable within these; restrictions, LLVM does not need to have special knowledge of the; operand bundle to not miscompile programs containing it. - The bundle operands for an unknown operand bundle escape in unknown; ways before control is transferred to the callee or invokee.; - Calls and invokes with operand bundles have unknown read / write; effect on the heap on entry and exit (even if the call target specifies; a ``memory`` attribute), unless they're overridden with; callsite specific attributes.; - An operand bundle at a call site cannot change the implementation; of the called function. Inter-procedural optimizations work as; usual as long as they take into account the first two properties. More specific types of operand bundles are described below.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130813,Integrability,integrat,integrated,130813,".. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145145,Integrability,synchroniz,synchronization,145145," pointer that outlives the call.; To be precise, a pointer is captured if one or more of the following conditions; hold:. 1. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be read from the place by the caller after this call; exits. .. code-block:: llvm. @glb = global ptr null; @glb2 = global ptr null; @glb3 = global ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145424,Integrability,depend,depends,145424,"lobal ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile ope",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:146276,Integrability,synchroniz,synchronization,146276,"tore atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have differen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:148679,Integrability,contract,contract,148679,"ecessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens-before* partial order as the least partial order; that. - Is a superset of single-thread program order, and; - When ``a`` *synchronizes-with* ``b``, includes an edge from ``a`` to; ``b``. *Synchronizes-with* pairs are introduced by platform-specific; techniques, like pthread locks, thread creation, thread joining,; etc., and by atomic instructions. (See also :ref:`Atomic Memory Ordering; Constraints <ordering>`). Note that program order does not introduce *happens-before* edges; be",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:149290,Integrability,synchroniz,synchronizes-with,149290,"stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens-before* partial order as the least partial order; that. - Is a superset of single-thread program order, and; - When ``a`` *synchronizes-with* ``b``, includes an edge from ``a`` to; ``b``. *Synchronizes-with* pairs are introduced by platform-specific; techniques, like pthread locks, thread creation, thread joining,; etc., and by atomic instructions. (See also :ref:`Atomic Memory Ordering; Constraints <ordering>`). Note that program order does not introduce *happens-before* edges; between a thread and signals executing inside that thread. Every (defined) read operation (load instructions, memcpy, atomic; loads/read-modify-writes, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; writ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:150589,Integrability,depend,dependent,150589,"dering>`). Note that program order does not introduce *happens-before* edges; between a thread and signals executing inside that thread. Every (defined) read operation (load instructions, memcpy, atomic; loads/read-modify-writes, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like normal memory. It does not generally provide cross-thread; synchronization.); - Otherwise, if there is no write to the same byte that happens before; R\ :sub:`byte`, R\ :sub:`byte` returns ``undef`` for that byte.; - Otherwise, if R\ :sub:`byte` may see exactly one write,; R\ :sub:`byte` returns the value written by that write.; - Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:150814,Integrability,synchroniz,synchronization,150814,"es, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like normal memory. It does not generally provide cross-thread; synchronization.); - Otherwise, if there is no write to the same byte that happens before; R\ :sub:`byte`, R\ :sub:`byte` returns ``undef`` for that byte.; - Otherwise, if R\ :sub:`byte` may see exactly one write,; R\ :sub:`byte` returns the value written by that write.; - Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152551,Integrability,synchroniz,synchronize,152551,"f bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:154544,Integrability,synchroniz,synchronizes-with,154544,"; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:154830,Integrability,synchroniz,synchronizes-with,154830,"t be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this globa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:156125,Integrability,synchroniz,synchronizes,156125,"Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is target; dependent if it *synchronizes with* and participates in the seq\_cst total; orderings of other operations. Otherwise, an atomic operation that is not marked ``syncscope(""singlethread"")``; or ``syncscope(""<target-scope>"")`` *synchronizes with* and participates in the; seq\_cst total orderings of other operations that are not marked; ``syncscope(""singlethread"")`` or ``syncscope(""<target-scope>"")``. .. _floatenv:. Floating-Point Environment; --------------------------. The default LLVM floating-point environment assumes that traps are disabled and; status flags are not observable. Therefore, floating-point math operations do; not have side effects and may be speculated freely. Results assume the; round-to-nearest rounding ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:156394,Integrability,synchroniz,synchronization,156394,"t only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is target; dependent if it *synchronizes with* and participates in the seq\_cst total; orderings of other operations. Otherwise, an atomic operation that is not marked ``syncscope(""singlethread"")``; or ``syncscope(""<target-scope>"")`` *synchronizes with* and participates in the; seq\_cst total orderings of other operations that are not marked; ``syncscope(""singlethread"")`` or ``syncscope(""<target-scope>"")``. .. _floatenv:. Floating-Point Environment; --------------------------. The default LLVM floating-point environment assumes that traps are disabled and; status flags are not observable. Therefore, floating-point math operations do; not have side effects and may be speculated freely. Results assume the; round-to-nearest rounding mode, and subnormals are assumed to be preserved. Running LLVM code in an environment where these assumptions are not met can lead; to undefined behavior. The ``strictfp`` and ``denormal-fp-math`` attributes as; well as :ref:`Constrained Floating",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:156436,Integrability,depend,dependent,156436,"t only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is target; dependent if it *synchronizes with* and participates in the seq\_cst total; orderings of other operations. Otherwise, an atomic operation that is not marked ``syncscope(""singlethread"")``; or ``syncscope(""<target-scope>"")`` *synchronizes with* and participates in the; seq\_cst total orderings of other operations that are not marked; ``syncscope(""singlethread"")`` or ``syncscope(""<target-scope>"")``. .. _floatenv:. Floating-Point Environment; --------------------------. The default LLVM floating-point environment assumes that traps are disabled and; status flags are not observable. Therefore, floating-point math operations do; not have side effects and may be speculated freely. Results assume the; round-to-nearest rounding mode, and subnormals are assumed to be preserved. Running LLVM code in an environment where these assumptions are not met can lead; to undefined behavior. The ``strictfp`` and ``denormal-fp-math`` attributes as; well as :ref:`Constrained Floating",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:156453,Integrability,synchroniz,synchronizes,156453,"t only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is target; dependent if it *synchronizes with* and participates in the seq\_cst total; orderings of other operations. Otherwise, an atomic operation that is not marked ``syncscope(""singlethread"")``; or ``syncscope(""<target-scope>"")`` *synchronizes with* and participates in the; seq\_cst total orderings of other operations that are not marked; ``syncscope(""singlethread"")`` or ``syncscope(""<target-scope>"")``. .. _floatenv:. Floating-Point Environment; --------------------------. The default LLVM floating-point environment assumes that traps are disabled and; status flags are not observable. Therefore, floating-point math operations do; not have side effects and may be speculated freely. Results assume the; round-to-nearest rounding mode, and subnormals are assumed to be preserved. Running LLVM code in an environment where these assumptions are not met can lead; to undefined behavior. The ``strictfp`` and ``denormal-fp-math`` attributes as; well as :ref:`Constrained Floating",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:156660,Integrability,synchroniz,synchronizes,156660,"s to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is target; dependent if it *synchronizes with* and participates in the seq\_cst total; orderings of other operations. Otherwise, an atomic operation that is not marked ``syncscope(""singlethread"")``; or ``syncscope(""<target-scope>"")`` *synchronizes with* and participates in the; seq\_cst total orderings of other operations that are not marked; ``syncscope(""singlethread"")`` or ``syncscope(""<target-scope>"")``. .. _floatenv:. Floating-Point Environment; --------------------------. The default LLVM floating-point environment assumes that traps are disabled and; status flags are not observable. Therefore, floating-point math operations do; not have side effects and may be speculated freely. Results assume the; round-to-nearest rounding mode, and subnormals are assumed to be preserved. Running LLVM code in an environment where these assumptions are not met can lead; to undefined behavior. The ``strictfp`` and ``denormal-fp-math`` attributes as; well as :ref:`Constrained Floating-Point Intrinsics <constrainedfp>` can be used; to weaken LLVM's assumptions and ensure defined behavior in non-default; floating-point environments; see their respective documentation for details. .. _floatnan:. Behavior of Floating-Point NaN values; --------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:159277,Integrability,depend,depend,159277," purpose of this section, ``bitcast`` as well as the following operations; are not ""floating-point math operations"": ``fneg``, ``llvm.fabs``, and; ``llvm.copysign``. These operations act directly on the underlying bit; representation and never change anything except possibly for the sign bit. For floating-point math operations, unless specified otherwise, the following; rules apply when a NaN value is returned: the result has a non-deterministic; sign; the quiet bit and payload are non-deterministically chosen from the; following set of options:. - The quiet bit is set and the payload is all-zero. (""Preferred NaN"" case); - The quiet bit is set and the payload is copied from any input operand that is; a NaN. (""Quieting NaN propagation"" case); - The quiet bit and payload are copied from any input operand that is a NaN.; (""Unchanged NaN propagation"" case); - The quiet bit is set and the payload is picked from a target-specific set of; ""extra"" possible NaN payloads. The set can depend on the input operand values.; This set is empty on x86 and ARM, but can be non-empty on other architectures.; (For instance, on wasm, if any input NaN does not have the preferred all-zero; payload or any input NaN is an SNaN, then this set contains all possible; payloads; otherwise, it is empty. On SPARC, this set consists of the all-one; payload.). In particular, if all input NaNs are quiet (or if there are no input NaNs), then; the output NaN is definitely quiet. Signaling NaN outputs can only occur if they; are provided as an input value. For example, ""fmul SNaN, 1.0"" may be simplified; to SNaN rather than QNaN. Similarly, if all input NaNs are preferred (or if; there are no input NaNs) and the target does not have any ""extra"" NaN payloads,; then the output NaN is guaranteed to be preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this shou",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162560,Integrability,contract,contract,162560," <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>`` is a comma-separated list of; indexes that are assigned to the referenced value's u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162593,Integrability,contract,contraction,162593," <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>`` is a comma-separated list of; indexes that are assigned to the referenced value's u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162740,Integrability,contract,contractions,162740,"all <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>`` is a comma-separated list of; indexes that are assigned to the referenced value's uses. The referenced; value's use-list is immediately sorted by these indexes. Use-list directives may appear at function scope or global",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:175438,Integrability,depend,depends,175438,"ltiple primitive data are; operated in parallel using a single instruction (SIMD). A vector type; requires a size (number of elements), an underlying primitive data type,; and a scalable property to represent vectors where the exact hardware; vector length is unknown at compile time. Vector types are considered; :ref:`first class <t_firstclass>`. :Memory Layout:. In general vector elements are laid out in memory in the same way as; :ref:`array types <t_array>`. Such an analogy works fine as long as the vector; elements are byte sized. However, when the elements of the vector aren't byte; sized it gets a bit more complicated. One way to describe the layout is by; describing what happens when a vector such as <N x iM> is bitcasted to an; integer type with N*M bits, and then following the rules for storing such an; integer to memory. A bitcast from a vector type to a scalar integer type will see the elements; being packed together (without padding). The order in which elements are; inserted in the integer depends on endianness. For little endian element zero; is put in the least significant bits of the integer, and for big endian; element zero is put in the most significant bits. Using a vector such as ``<i4 1, i4 2, i4 3, i4 5>`` as an example, together; with the analogy that we can replace a vector store by a bitcast followed by; an integer store, we get this for big endian:. .. code-block:: llvm. %val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16. ; Bitcasting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal value 0x1235. store i16 %val, ptr %ptr. ; In memory the content will be (8-bit addressing):; ;; ; [%ptr + 0]: 00010010 (0x12); ; [%ptr + 1]: 00110101 (0x35). The same example for little endian:. .. code-block:: llvm. %val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16. ; Bitcasting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal val",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:177380,Integrability,depend,dependent,177380,"sting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal value 0x5321. store i16 %val, ptr %ptr. ; In memory the content will be (8-bit addressing):; ;; ; [%ptr + 0]: 00100001 (0x21); ; [%ptr + 1]: 01010011 (0x53). When ``<N*M>`` isn't evenly divisible by the byte size the exact memory layout; is unspecified (just like it is for an integral type of the same size). This; is because different targets could put the padding at different positions when; the type size is smaller than the type's store size. :Syntax:. ::. < <# elements> x <elementtype> > ; Fixed-length vector; < vscale x <# elements> x <elementtype> > ; Scalable vector. The number of elements is a constant integer value larger than 0;; elementtype may be any integer, floating-point or pointer type. Vectors; of size zero are not allowed. For scalable vectors, the total number of; elements is a constant multiple (called vscale) of the specified number; of elements; vscale is a positive integer that is unknown at compile time; and the same hardware-dependent constant for all scalable vectors at run; time. The size of a specific scalable vector type is thus constant within; IR, even if the exact size in bytes cannot be determined until run time. :Examples:. +------------------------+----------------------------------------------------+; | ``<4 x i32>`` | Vector of 4 32-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<8 x float>`` | Vector of 8 32-bit floating-point values. |; +------------------------+----------------------------------------------------+; | ``<2 x i64>`` | Vector of 2 64-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<4 x ptr>`` | Vector of 4 pointers |; +------------------------+----------------------------------------------------+; | ``<vscale x 4 x i32>`` | Vector with a multiple of 4 32-bit integer values. |; +----",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:191826,Integrability,depend,depending,191826,"; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Undefined values are useful because they indicate to the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:196081,Integrability,depend,depend,196081,"n arbitrary value,; we are allowed to assume that it could be zero. Since a divide by zero; has *undefined behavior*, we are allowed to assume that the operation; does not execute at all. This allows us to delete the divide and all; code after it. Because the undefined operation ""can't happen"", the; optimizer can assume that it occurs in dead code. .. code-block:: text. a: store undef -> %X; b: store %X -> undef; Safe:; a: <deleted> (if the stored value in %X is provably not poison); b: unreachable. A store *of* an undefined value can be assumed to not have any effect;; we can assume that the value is overwritten with bits that happen to; match what was already there. This argument is only valid if the stored value; is provably not ``poison``. However, a store *to* an undefined; location could clobber arbitrary memory, therefore, it has undefined; behavior. Branching on an undefined value is undefined behavior.; This explains optimizations that depend on branch conditions to construct; predicates, such as Correlated Value Propagation and Global Value Numbering.; In case of switch instruction, the branch condition should be frozen, otherwise; it is undefined behavior. .. code-block:: llvm. Unsafe:; br undef, BB1, BB2 ; UB. %X = and i32 undef, 255; switch %X, label %ret [ .. ] ; UB. store undef, ptr %ptr; %X = load ptr %ptr ; %X is undef; switch i8 %X, label %ret [ .. ] ; UB. Safe:; %X = or i8 undef, 255 ; always 255; switch i8 %X, label %ret [ .. ] ; Well-defined. %X = freeze i1 undef; br %X, BB1, BB2 ; Well-defined (non-deterministic jump). .. _poisonvalues:. Poison Values; -------------. A poison value is a result of an erroneous operation.; In order to facilitate speculative execution, many instructions do not; invoke immediate undefined behavior when provided with illegal operands,; and return a poison value instead.; The string '``poison``' can be used anywhere a constant is expected, and; operations such as :ref:`add <i_add>` with the ``nsw`` flag can produce; a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:201912,Integrability,depend,depending,201912,", but that is target specific. .. _dso_local_equivalent:. DSO Local Equivalent; --------------------. ``dso_local_equivalent @func``. A '``dso_local_equivalent``' constant represents a function which is; functionally equivalent to a given function, but is always defined in the; current linkage unit. The resulting pointer has the same type as the underlying; function. The resulting pointer is permitted, but not required, to be different; from a pointer to the function, and it may have different values in different; translation units. The target function may not have ``extern_weak`` linkage. ``dso_local_equivalent`` can be implemented as such:. - If the function has local linkage, hidden visibility, or is; ``dso_local``, ``dso_local_equivalent`` can be implemented as simply a pointer; to the function.; - ``dso_local_equivalent`` can be implemented with a stub that tail-calls the; function. Many targets support relocations that resolve at link time to either; a function or a stub for it, depending on if the function is defined within the; linkage unit; LLVM will use this when available. (This is commonly called a; ""PLT stub"".) On other targets, the stub may need to be emitted explicitly. This can be used wherever a ``dso_local`` instance of a function is needed without; needing to explicitly make the original function ``dso_local``. An instance where; this can be used is for static offset calculations between a function and some other; ``dso_local`` symbol. This is especially useful for the Relative VTables C++ ABI,; where dynamic relocations for function pointers in VTables can be replaced with; static relocations for offsets between the VTable and virtual functions which; may not be ``dso_local``. This is currently only supported for ELF binary formats. .. _no_cfi:. No CFI; ------. ``no_cfi @func``. With `Control-Flow Integrity (CFI); <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_, a '``no_cfi``'; constant represents a function reference that does not get ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:206788,Integrability,integrat,integrated,206788,"of a special value. This value; represents the inline assembler as a template string (containing the; instructions to emit), a list of operand constraints (stored as a string), a; flag that indicates whether or not the inline asm expression has side effects,; and a flag indicating whether the function containing the asm needs to align its; stack conservatively. The template string supports argument substitution of the operands using ""``$``""; followed by a number, to indicate substitution of the given register/memory; location, as specified by the constraint string. ""``${NUM:MODIFIER}``"" may also; be used, where ``MODIFIER`` is a target-specific annotation for how to print the; operand (See :ref:`inline-asm-modifiers`). A literal ""``$``"" may be included by using ""``$$``"" in the template. To include; other special characters into the output, the usual ""``\XX``"" escapes may be; used, just as in other strings. Note that after template substitution, the; resulting assembly string is parsed by LLVM's integrated assembler unless it is; disabled -- even when emitting a ``.s`` file -- and thus must contain assembly; syntax known to LLVM. LLVM also supports a few more substitutions useful for writing inline assembly:. - ``${:uid}``: Expands to a decimal integer unique to this inline assembly blob.; This substitution is useful when declaring a local label. Many standard; compiler optimizations, such as inlining, may duplicate an inline asm blob.; Adding a blob-unique identifier ensures that the two labels will not conflict; during assembly. This is used to implement `GCC's %= special format; string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_.; - ``${:comment}``: Expands to the comment character of the current target's; assembly dialect. This is usually ``#``, but many targets use other strings,; such as ``;``, ``//``, or ``!``.; - ``${:private}``: Expands to the assembler private label prefix. Labels with; this prefix will not appear in the symbol table of the ass",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:230959,Integrability,depend,depending,230959,"d the same as ``m``.; - ``r``: A 32 or 64-bit integer register.; - ``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is:; ``R1-R31``).; - ``f``: A 32 or 64-bit float register (``F0-F31``),; - ``v``: For ``4 x f32`` or ``4 x f64`` types, a 128-bit altivec vector; register (``V0-V31``). - ``y``: Condition register (``CR0-CR7``).; - ``wc``: An individual CR bit in a CR register.; - ``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full VSX; register set (overlapping both the floating-point and vector register files).; - ``ws``: A 32 or 64-bit floating-point register, from the full VSX register; set. RISC-V:. - ``A``: An address operand (using a general-purpose register, without an; offset).; - ``I``: A 12-bit signed integer immediate operand.; - ``J``: A zero integer immediate operand.; - ``K``: A 5-bit unsigned integer immediate operand.; - ``f``: A 32- or 64-bit floating-point register (requires F or D extension).; - ``r``: A 32- or 64-bit general-purpose register (depending on the platform; ``XLEN``).; - ``vr``: A vector register. (requires V extension).; - ``vm``: A vector register for masking operand. (requires V extension). Sparc:. - ``I``: An immediate 13-bit signed integer.; - ``r``: A 32-bit integer register.; - ``f``: Any floating-point register on SparcV8, or a floating-point; register in the ""low"" half of the registers on SparcV9.; - ``e``: Any floating-point register. (Same as ``f`` on SparcV8.). SystemZ:. - ``I``: An immediate unsigned 8-bit integer.; - ``J``: An immediate unsigned 12-bit integer.; - ``K``: An immediate signed 16-bit integer.; - ``L``: An immediate signed 20-bit integer.; - ``M``: An immediate integer 0x7fffffff.; - ``Q``: A memory address operand with a base address and a 12-bit immediate; unsigned displacement.; - ``R``: A memory address operand with a base address, a 12-bit immediate; unsigned displacement, and an index register.; - ``S``: A memory address operand with a base address and a 20-bit immediate;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:241739,Integrability,wrap,wrap,241739,"; - ``q``: Print the 64-bit register name (e.g. ``rax``), if 64-bit registers are; available, otherwise the 32-bit register name; do nothing on a memory operand.; - ``n``: Negate and print an unadorned integer, or, for operands other than an; immediate integer (e.g. a relocatable symbol expression), print a '-' before; the operand. (The behavior for relocatable symbol expressions is a; target-specific behavior for this typically target-independent modifier); - ``H``: Print a memory reference with additional offset +8.; - ``p``: Print a raw symbol name (without syntax-specific prefixes).; - ``P``: Print a memory reference used as the argument of a call instruction or; used with explicit base reg and index reg as its offset. So it can not use; additional regs to present the memory reference. (E.g. omit ``(rip)``, even; though it's PC-relative.). XCore:. No additional modifiers. Inline Asm Metadata; ^^^^^^^^^^^^^^^^^^^. The call instructions that wrap inline asm nodes may have a; ""``!srcloc``"" MDNode attached to it that contains a list of constant; integers. If present, the code generator will use the integer as the; location cookie value when report errors through the ``LLVMContext``; error reporting mechanisms. This allows a front-end to correlate backend; errors that occur with inline asm back to the source code that produced; it. For example:. .. code-block:: llvm. call void asm sideeffect ""something bad"", """"(), !srcloc !42; ...; !42 = !{ i32 1234567 }. It is up to the front-end to make sense of the magic numbers it places; in the IR. If the MDNode contains multiple constants, the code generator; will use the one that corresponds to the line of the asm that the error; occurs on. .. _metadata:. Metadata; ========. LLVM IR allows metadata to be attached to instructions and global objects in the; program that can convey extra information about the code to the optimizers and; code generator. One example application of metadata is source-level; debug information. There a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:285513,Integrability,wrap,wrap,285513,"e metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which cause",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:295885,Integrability,depend,depends,295885," are; neither persistent for the same loop through transformations nor; necessarily unique to just one loop. '``llvm.loop.disable_nonforced``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables all optional loop transformations unless; explicitly instructed using other transformation metadata such as; ``llvm.loop.unroll.enable``. That is, no heuristic will try to determine; whether a transformation is profitable. The purpose is to avoid that the; loop is transformed to a different loop before an explicitly requested; (forced) transformation is applied. For instance, loop fusion can make; other transformations impossible. Mandatory loop canonicalizations such; as loop rotation are still applied. It is recommended to use this metadata in addition to any llvm.loop.*; transformation directive. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:296700,Integrability,depend,dependencies,296700,"ve. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an interleave count to the loop interleaver.; The first operand is the string ``llvm.loop.interleave.count`` and the; second operand is an integer specifying the interleave count. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.interleave.count"", i32 4}. Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving; multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0; then the interleave count will be determined automatically. '``llvm.loop.vectorize.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables vectorization for the loop. The; first operand is the string ``llvm.loop.vectorize.enable`` and the second operand; is a bit. If the bit operand value is 1 vectorization is enabled. A value of; 0 d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307738,Integrability,depend,dependencies,307738,"re; can be multiple inner remainder loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307807,Integrability,depend,dependencies,307807,"ta>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isol",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:308511,Integrability,depend,dependencies,308511,". '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isolated loops with unsafe; memory dependencies will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_fallback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:308827,Integrability,depend,dependencies,308827,"unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isolated loops with unsafe; memory dependencies will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_fallback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311607,Integrability,depend,dependence,311607,"since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_access",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311996,Integrability,depend,dependency,311996,"e updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312457,Integrability,depend,dependences,312457,"`llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312711,Integrability,depend,dependence,312711,"ns that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; .",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:314788,Integrability,synchroniz,synchronization,314788,".access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.mustprogress`` metadata indicates that this loop is required to; terminate, unwind, or interact with the environment in an observable way e.g.; via a volatile memory access, I/O, or other synchronization. If such a loop is; not found to interact with the environment in an observable way, the loop may; be removed. This corresponds to the ``mustprogress`` function attribute. '``irr_loop``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^. ``irr_loop`` metadata may be attached to the terminator instruction of a basic; block that's an irreducible loop header (note that an irreducible loop has more; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreducible loop; header, the behavior is undefined. The intent of this metadata is to improve the; accuracy of the block frequency propagation. For example, in the code below, the; block ``header0`` may have a loop header weight (relative to the other headers of; the irreducible loop) of 100:. .. code-block:: llvm. header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop heade",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:337990,Integrability,depend,depend,337990,"libz`` and the ``Cocoa``; framework::. !0 = !{ !""-lz"" }; !1 = !{ !""-framework"", !""Cocoa"" }; !llvm.linker.options = !{ !0, !1 }. The metadata encoding as lists of lists of options, as opposed to a collapsed; list of options, is chosen so that the IR encoding can use multiple option; strings to specify e.g., a single library, while still having that specifier be; preserved as an atomic element that can be recognized by a target specific; assembly writer or object file emitter. Each individual option is required to be either a valid option for the target's; linker, or an option that is reserved by the target specific assembly writer or; object file emitter. No other aspect of these options is defined by the IR. Dependent Libs Named Metadata; =============================. Some targets support embedding of strings into object files to indicate; a set of libraries to add to the link. Typically this is used in conjunction; with language extensions which allow source files to explicitly declare the; libraries they depend on, and have these automatically be transmitted to the; linker via object files. The list is encoded in the IR using named metadata with the name; ``!llvm.dependent-libraries``. Each operand is expected to be a metadata node; which should contain a single string operand. For example, the following metadata section contains two library specifiers::. !0 = !{!""a library specifier""}; !1 = !{!""another library specifier""}; !llvm.dependent-libraries = !{ !0, !1 }. Each library specifier will be handled independently by the consuming linker.; The effect of the library specifiers are defined by the consuming linker. .. _summary:. ThinLTO Summary; ===============. Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_; causes the building of a compact summary of the module that is emitted into; the bitcode. The summary is emitted into the LLVM assembly and identified; in syntax by a caret ('``^``'). The summary is parsed into a bitcode output, along wit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:338152,Integrability,depend,dependent-libraries,338152,"collapsed; list of options, is chosen so that the IR encoding can use multiple option; strings to specify e.g., a single library, while still having that specifier be; preserved as an atomic element that can be recognized by a target specific; assembly writer or object file emitter. Each individual option is required to be either a valid option for the target's; linker, or an option that is reserved by the target specific assembly writer or; object file emitter. No other aspect of these options is defined by the IR. Dependent Libs Named Metadata; =============================. Some targets support embedding of strings into object files to indicate; a set of libraries to add to the link. Typically this is used in conjunction; with language extensions which allow source files to explicitly declare the; libraries they depend on, and have these automatically be transmitted to the; linker via object files. The list is encoded in the IR using named metadata with the name; ``!llvm.dependent-libraries``. Each operand is expected to be a metadata node; which should contain a single string operand. For example, the following metadata section contains two library specifiers::. !0 = !{!""a library specifier""}; !1 = !{!""another library specifier""}; !llvm.dependent-libraries = !{ !0, !1 }. Each library specifier will be handled independently by the consuming linker.; The effect of the library specifiers are defined by the consuming linker. .. _summary:. ThinLTO Summary; ===============. Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_; causes the building of a compact summary of the module that is emitted into; the bitcode. The summary is emitted into the LLVM assembly and identified; in syntax by a caret ('``^``'). The summary is parsed into a bitcode output, along with the Module; IR, via the ""``llvm-as``"" tool. Tools that parse the Module IR for the purposes; of optimization (e.g. ""``clang -x ir``"" and ""``opt``""), will ignore the; summary entries (just as th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:338424,Integrability,depend,dependent-libraries,338424,"tter. Each individual option is required to be either a valid option for the target's; linker, or an option that is reserved by the target specific assembly writer or; object file emitter. No other aspect of these options is defined by the IR. Dependent Libs Named Metadata; =============================. Some targets support embedding of strings into object files to indicate; a set of libraries to add to the link. Typically this is used in conjunction; with language extensions which allow source files to explicitly declare the; libraries they depend on, and have these automatically be transmitted to the; linker via object files. The list is encoded in the IR using named metadata with the name; ``!llvm.dependent-libraries``. Each operand is expected to be a metadata node; which should contain a single string operand. For example, the following metadata section contains two library specifiers::. !0 = !{!""a library specifier""}; !1 = !{!""another library specifier""}; !llvm.dependent-libraries = !{ !0, !1 }. Each library specifier will be handled independently by the consuming linker.; The effect of the library specifiers are defined by the consuming linker. .. _summary:. ThinLTO Summary; ===============. Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_; causes the building of a compact summary of the module that is emitted into; the bitcode. The summary is emitted into the LLVM assembly and identified; in syntax by a caret ('``^``'). The summary is parsed into a bitcode output, along with the Module; IR, via the ""``llvm-as``"" tool. Tools that parse the Module IR for the purposes; of optimization (e.g. ""``clang -x ir``"" and ""``opt``""), will ignore the; summary entries (just as they currently ignore summary entries in a bitcode; input file). Eventually, the summary will be parsed into a ModuleSummaryIndex object under; the same conditions where summary index is currently built from bitcode.; Specifically, tools that test the Thin Link portion of a ThinL",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:341172,Integrability,depend,depend,341172," path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:370904,Integrability,rout,routine,370904,"erminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet that contains the; ``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet,; this operand may be the token ``none``. The ``default`` argument is the label of another basic block beginning with; either a ``cleanuppad`` or ``catchswitch`` instruction. This unwind destination; must be a legal target with respect to the ``parent`` links, as described in; the `exception handling documentation\ <ExceptionHandling.html#wineh-constraints>`_. The ``handlers`` are a nonempty list of successor blocks that each begin with a; :ref:`catchpad <i_catchpad>` instruction. Semantics:; """""""""""""""""""". Executing this instruction transfers control to one of the successors in; ``handlers``, if appropriate, or continues to unwind via the unwind label if; present. The ``catchswitch`` is both a terminator and a ""pad"" instruction, meaning that; it must ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:423788,Integrability,synchroniz,synchronizes-with,423788,"f bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` seman",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424001,Integrability,synchroniz,synchronizes,424001,"lled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; comp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424373,Integrability,depend,dependency,424373,"oad i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424572,Integrability,synchroniz,synchronize-with,424572,"`' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-block:: text. fence acquire ; yields void; fence syncscope(""singlethread"") seq_cst ; yields void; fence syncscope(""agent"") seq_cst ; yields void. .. _i_cmpxchg:. '``cmpxchg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:426820,Integrability,synchroniz,synchronizes,426820,""""""""""""". The '``cmpxchg``' instruction is used to atomically modify memory. It; loads a value in memory and compares it to a given value. If they are; equal, it tries to store a new value into the memory. Arguments:; """""""""""""""""""". There are three arguments to the '``cmpxchg``' instruction: an address; to operate on, a value to compare to the value currently be at that; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is rea",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:432046,Integrability,wrap,wraparound,432046," the location is returned. The modification is specified by the; operation argument:. - xchg: ``*ptr = val``; - add: ``*ptr = *ptr + val``; - sub: ``*ptr = *ptr - val``; - and: ``*ptr = *ptr & val``; - nand: ``*ptr = ~(*ptr & val)``; - or: ``*ptr = *ptr | val``; - xor: ``*ptr = *ptr ^ val``; - max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison); - min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison); - umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison); - umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison); - fadd: ``*ptr = *ptr + val`` (using floating point arithmetic); - fsub: ``*ptr = *ptr - val`` (using floating point arithmetic); - fmax: ``*ptr = maxnum(*ptr, val)`` (match the `llvm.maxnum.*`` intrinsic); - fmin: ``*ptr = minnum(*ptr, val)`` (match the `llvm.minnum.*`` intrinsic); - uinc_wrap: ``*ptr = (*ptr u>= val) ? 0 : (*ptr + 1)`` (increment value with wraparound to zero when incremented above input value); - udec_wrap: ``*ptr = ((*ptr == 0) || (*ptr u> val)) ? val : (*ptr - 1)`` (decrement with wraparound to input value when decremented below zero). Example:; """""""""""""""". .. code-block:: llvm. %old = atomicrmw add ptr %ptr, i32 1 acquire ; yields i32. .. _i_getelementptr:. '``getelementptr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = getelementptr <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr inbounds <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr <ty>, <N x ptr> <ptrval>, [inrange] <vector index type> <idx>. Overview:; """""""""""""""""". The '``getelementptr``' instruction is used to get the address of a; subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs; address calculation only and does not access memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The sec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:432192,Integrability,wrap,wraparound,432192," the location is returned. The modification is specified by the; operation argument:. - xchg: ``*ptr = val``; - add: ``*ptr = *ptr + val``; - sub: ``*ptr = *ptr - val``; - and: ``*ptr = *ptr & val``; - nand: ``*ptr = ~(*ptr & val)``; - or: ``*ptr = *ptr | val``; - xor: ``*ptr = *ptr ^ val``; - max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison); - min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison); - umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison); - umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison); - fadd: ``*ptr = *ptr + val`` (using floating point arithmetic); - fsub: ``*ptr = *ptr - val`` (using floating point arithmetic); - fmax: ``*ptr = maxnum(*ptr, val)`` (match the `llvm.maxnum.*`` intrinsic); - fmin: ``*ptr = minnum(*ptr, val)`` (match the `llvm.minnum.*`` intrinsic); - uinc_wrap: ``*ptr = (*ptr u>= val) ? 0 : (*ptr + 1)`` (increment value with wraparound to zero when incremented above input value); - udec_wrap: ``*ptr = ((*ptr == 0) || (*ptr u> val)) ? val : (*ptr - 1)`` (decrement with wraparound to input value when decremented below zero). Example:; """""""""""""""". .. code-block:: llvm. %old = atomicrmw add ptr %ptr, i32 1 acquire ; yields i32. .. _i_getelementptr:. '``getelementptr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = getelementptr <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr inbounds <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr <ty>, <N x ptr> <ptrval>, [inrange] <vector index type> <idx>. Overview:; """""""""""""""""". The '``getelementptr``' instruction is used to get the address of a; subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs; address calculation only and does not access memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The sec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:433345,Integrability,depend,dependent,433345,". .. _i_getelementptr:. '``getelementptr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = getelementptr <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr inbounds <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr <ty>, <N x ptr> <ptrval>, [inrange] <vector index type> <idx>. Overview:; """""""""""""""""". The '``getelementptr``' instruction is used to get the address of a; subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs; address calculation only and does not access memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The second argument is always a pointer or a vector of pointers, and is the; base address to start from. The remaining arguments are indices; that indicate which of the elements of the aggregate object are indexed.; The interpretation of each index is dependent on the type being indexed; into. The first index always indexes the pointer value given as the; second argument, the second index indexes a value of the type pointed to; (not necessarily the value directly pointed to, since the first index; can be non-zero), etc. The first type indexed into must be a pointer; value, subsequent types can be arrays, vectors, and structs. Note that; subsequent types being indexed into can never be pointers, since that; would require loading the pointer before continuing calculation. The type of each index argument depends on the type it is indexing into.; When indexing into a (optionally packed) structure, only ``i32`` integer; **constants** are allowed (when using a vector of indices they must all; be the **same** ``i32`` integer constant). When indexing into an array,; pointer or vector, integers of any width are allowed, and they are not; required to be constant. These integers are treated as signed values; where relevant. For example, let's co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:433906,Integrability,depend,depends,433906,"memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The second argument is always a pointer or a vector of pointers, and is the; base address to start from. The remaining arguments are indices; that indicate which of the elements of the aggregate object are indexed.; The interpretation of each index is dependent on the type being indexed; into. The first index always indexes the pointer value given as the; second argument, the second index indexes a value of the type pointed to; (not necessarily the value directly pointed to, since the first index; can be non-zero), etc. The first type indexed into must be a pointer; value, subsequent types can be arrays, vectors, and structs. Note that; subsequent types being indexed into can never be pointers, since that; would require loading the pointer before continuing calculation. The type of each index argument depends on the type it is indexing into.; When indexing into a (optionally packed) structure, only ``i32`` integer; **constants** are allowed (when using a vector of indices they must all; be the **same** ``i32`` integer constant). When indexing into an array,; pointer or vector, integers of any width are allowed, and they are not; required to be constant. These integers are treated as signed values; where relevant. For example, let's consider a C code fragment and how it gets compiled; to LLVM:. .. code-block:: c. struct RT {; char A;; int B[10][20];; char C;; };; struct ST {; int X;; double Y;; struct RT Z;; };. int *foo(struct ST *s) {; return &s[1].Z.B[5][13];; }. The LLVM code generated by Clang is approximately:. .. code-block:: llvm. %struct.RT = type { i8, [10 x [20 x i32]], i8 }; %struct.ST = type { i32, double, %struct.RT }. define ptr @foo(ptr %s) {; entry:; %arrayidx = getelementptr inbounds %struct.ST, ptr %s, i64 1, i32 2, i32 1, i64 5, i64 13; ret ptr %arrayidx; }. Semantics",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436599,Integrability,wrap,wrapping,436599,"perfectly legal to index partially through a structure,; returning a pointer to an inner element. Because of this, the LLVM code; for the given testcase is equivalent to:. .. code-block:: llvm. define ptr @foo(ptr %s) {; %t1 = getelementptr %struct.ST, ptr %s, i32 1; %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2; %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:437717,Integrability,wrap,wrap,437717,"utside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no al",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:437861,Integrability,wrap,wrap,437861," by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438063,Integrability,wrap,wrap,438063,"ointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or stor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438222,Integrability,wrap,wrap,438222,"on value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or store would access memory outside of the bounds of; the element selected by the index marked as ``inrange``. The result of a; pointer comparison or ``ptrtoint`` (including ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:455033,Integrability,depend,depending,455033,"^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = inttoptr <ty> <value> to <ty2>[, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>] ; yields ty2. Overview:; """""""""""""""""". The '``inttoptr``' instruction converts an integer ``value`` to a; pointer type, ``ty2``. Arguments:; """""""""""""""""""". The '``inttoptr``' instruction takes an :ref:`integer <t_integer>` value to; cast, and a type to cast it to, which must be a :ref:`pointer <t_pointer>`; type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata. Semantics:; """""""""""""""""""". The '``inttoptr``' instruction converts ``value`` to type ``ty2`` by; applying either a zero extension or a truncation depending on the size; of the integer ``value``. If ``value`` is larger than the size of a; pointer then a truncation is done. If ``value`` is smaller than the size; of a pointer then a zero extension is done. If they are the same size,; nothing is done (*no-op cast*). Example:; """""""""""""""". .. code-block:: llvm. %X = inttoptr i32 255 to ptr ; yields zero extension on 64-bit architecture; %Y = inttoptr i32 255 to ptr ; yields no-op on 32-bit architecture; %Z = inttoptr i64 0 to ptr ; yields truncation on 32-bit architecture; %Z = inttoptr <4 x i32> %G to <4 x ptr>; yields truncation of vector G to four pointers. .. _i_bitcast:. '``bitcast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = bitcast <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``bitcast``' instruction converts ``value`` to type ``ty2`` without; changing any bits. Arguments:; """""""""""""""""""". The '``bitcast``' instruction takes a value to ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:457505,Integrability,depend,depends,457505,"ics:; """""""""""""""""""". The '``bitcast``' instruction converts ``value`` to type ``ty2``. It; is always a *no-op cast* because no bits change with this; conversion. The conversion is done as if the ``value`` had been stored; to memory and read back as type ``ty2``. Pointer (or vector of; pointers) types may only be converted to other pointer (or vector of; pointers) types with the same address space through this instruction.; To convert pointers to other types, use the :ref:`inttoptr <i_inttoptr>`; or :ref:`ptrtoint <i_ptrtoint>` instructions first. There is a caveat for bitcasts involving vector types in relation to; endianness. For example ``bitcast <2 x i8> <value> to i16`` puts element zero; of the vector in the least significant bits of the i16 for little-endian while; element zero ends up in the most significant bits for big-endian. Example:; """""""""""""""". .. code-block:: text. %X = bitcast i8 255 to i8 ; yields i8 :-1; %Y = bitcast i32* %x to i16* ; yields i16*:%x; %Z = bitcast <2 x i32> %V to i64; ; yields i64: %V (depends on endianness); %Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>. .. _i_addrspacecast:. '``addrspacecast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = addrspacecast <pty> <ptrval> to <pty2> ; yields pty2. Overview:; """""""""""""""""". The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in; address space ``n`` to type ``pty2`` in address space ``m``. Arguments:; """""""""""""""""""". The '``addrspacecast``' instruction takes a pointer or vector of pointer value; to cast and a pointer type to cast it to, which must have a different; address space. Semantics:; """""""""""""""""""". The '``addrspacecast``' instruction converts the pointer value; ``ptrval`` to type ``pty2``. It can be a *no-op cast* or a complex; value modification, depending on the target and the address space; pair. Pointer conversions within the same address space must be; performed with the ``bitcast`` instruction. Note that if the add",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:458300,Integrability,depend,depending,458300,"ant bits for big-endian. Example:; """""""""""""""". .. code-block:: text. %X = bitcast i8 255 to i8 ; yields i8 :-1; %Y = bitcast i32* %x to i16* ; yields i16*:%x; %Z = bitcast <2 x i32> %V to i64; ; yields i64: %V (depends on endianness); %Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>. .. _i_addrspacecast:. '``addrspacecast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = addrspacecast <pty> <ptrval> to <pty2> ; yields pty2. Overview:; """""""""""""""""". The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in; address space ``n`` to type ``pty2`` in address space ``m``. Arguments:; """""""""""""""""""". The '``addrspacecast``' instruction takes a pointer or vector of pointer value; to cast and a pointer type to cast it to, which must have a different; address space. Semantics:; """""""""""""""""""". The '``addrspacecast``' instruction converts the pointer value; ``ptrval`` to type ``pty2``. It can be a *no-op cast* or a complex; value modification, depending on the target and the address space; pair. Pointer conversions within the same address space must be; performed with the ``bitcast`` instruction. Note that if the address; space conversion produces a dereferenceable result then both result; and operand refer to the same memory location. The conversion must; have no side effects, and must not capture the value of the pointer. If the source is :ref:`poison <poisonvalues>`, the result is; :ref:`poison <poisonvalues>`. If the source is not :ref:`poison <poisonvalues>`, and both source and; destination are :ref:`integral pointers <nointptrtype>`, and the; result pointer is dereferenceable, the cast is assumed to be; reversible (i.e. casting the result back to the original address space; should yield the original bit pattern). Example:; """""""""""""""". .. code-block:: llvm. %X = addrspacecast ptr %x to ptr addrspace(1); %Y = addrspacecast ptr addrspace(1) %y to ptr addrspace(2); %Z = addrspacecast <4 x ptr> %z to <4 x ptr addrspace(3",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:483747,Integrability,rout,routine,483747," - A landing pad block must have a '``landingpad``' instruction as its; first non-PHI instruction.; - There can be only one '``landingpad``' instruction within the landing; pad block.; - A basic block that is not a landing pad block may not include a; '``landingpad``' instruction. Example:; """""""""""""""". .. code-block:: llvm. ;; A landing pad which can catch an integer.; %res = landingpad { ptr, i32 }; catch ptr @_ZTIi; ;; A landing pad that is a cleanup.; %res = landingpad { ptr, i32 }; cleanup; ;; A landing pad which can catch an integer and can only throw a double.; %res = landingpad { ptr, i32 }; catch ptr @_ZTIi; filter [1 x ptr] [ptr @_ZTId]. .. _i_catchpad:. '``catchpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchpad within <catchswitch> [<args>*]. Overview:; """""""""""""""""". The '``catchpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; begins a catch handler --- one where a personality routine attempts to transfer; control to catch an exception. Arguments:; """""""""""""""""""". The ``catchswitch`` operand must always be a token produced by a; :ref:`catchswitch <i_catchswitch>` instruction in a predecessor block. This; ensures that each ``catchpad`` has exactly one predecessor block, and it always; terminates in a ``catchswitch``. The ``args`` correspond to whatever information the personality routine; requires to know if this is an appropriate handler for the exception. Control; will transfer to the ``catchpad`` if this is the first appropriate handler for; the exception. The ``resultval`` has the type :ref:`token <t_token>` and is used to match the; ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and other nested EH; pads. Semantics:; """""""""""""""""""". When the call stack is being unwound due to an exception being thrown, the; exception is compared against the ``args``. If it doesn't match, control will; not reach the ``catchpad`` instruction. The re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:484153,Integrability,rout,routine,484153," pad that is a cleanup.; %res = landingpad { ptr, i32 }; cleanup; ;; A landing pad which can catch an integer and can only throw a double.; %res = landingpad { ptr, i32 }; catch ptr @_ZTIi; filter [1 x ptr] [ptr @_ZTId]. .. _i_catchpad:. '``catchpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchpad within <catchswitch> [<args>*]. Overview:; """""""""""""""""". The '``catchpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; begins a catch handler --- one where a personality routine attempts to transfer; control to catch an exception. Arguments:; """""""""""""""""""". The ``catchswitch`` operand must always be a token produced by a; :ref:`catchswitch <i_catchswitch>` instruction in a predecessor block. This; ensures that each ``catchpad`` has exactly one predecessor block, and it always; terminates in a ``catchswitch``. The ``args`` correspond to whatever information the personality routine; requires to know if this is an appropriate handler for the exception. Control; will transfer to the ``catchpad`` if this is the first appropriate handler for; the exception. The ``resultval`` has the type :ref:`token <t_token>` and is used to match the; ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and other nested EH; pads. Semantics:; """""""""""""""""""". When the call stack is being unwound due to an exception being thrown, the; exception is compared against the ``args``. If it doesn't match, control will; not reach the ``catchpad`` instruction. The representation of ``args`` is; entirely target and personality function-specific. Like the :ref:`landingpad <i_landingpad>` instruction, the ``catchpad``; instruction must be the first non-phi of its parent basic block. The meaning of the tokens produced and consumed by ``catchpad`` and other ""pad""; instructions is described in the; `Windows exception handling documentation\ <ExceptionHandling.html#wineh>`_. When a ``catchpad`` ha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:486035,Integrability,rout,routine,486035,"r ""pad""; instructions is described in the; `Windows exception handling documentation\ <ExceptionHandling.html#wineh>`_. When a ``catchpad`` has been ""entered"" but not yet ""exited"" (as; described in the `EH documentation\ <ExceptionHandling.html#wineh-constraints>`_),; it is undefined behavior to execute a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; that does not carry an appropriate :ref:`""funclet"" bundle <ob_funclet>`. Example:; """""""""""""""". .. code-block:: text. dispatch:; %cs = catchswitch within none [label %handler0] unwind to caller; ;; A catch block which can catch an integer.; handler0:; %tok = catchpad within %cs [ptr @_ZTIi]. .. _i_cleanuppad:. '``cleanuppad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = cleanuppad within <parent> [<args>*]. Overview:; """""""""""""""""". The '``cleanuppad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a cleanup block --- one where a personality routine attempts to; transfer control to run cleanup actions.; The ``args`` correspond to whatever additional; information the :ref:`personality function <personalityfn>` requires to; execute the cleanup.; The ``resultval`` has the type :ref:`token <t_token>` and is used to; match the ``cleanuppad`` to corresponding :ref:`cleanuprets <i_cleanupret>`.; The ``parent`` argument is the token of the funclet that contains the; ``cleanuppad`` instruction. If the ``cleanuppad`` is not inside a funclet,; this operand may be the token ``none``. Arguments:; """""""""""""""""""". The instruction takes a list of arbitrary values which are interpreted; by the :ref:`personality function <personalityfn>`. Semantics:; """""""""""""""""""". When the call stack is being unwound due to an exception being thrown,; the :ref:`personality function <personalityfn>` transfers control to the; ``cleanuppad`` with the aid of the personality-specific arguments.; As with calling conventions, how the personality functio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:490387,Integrability,depend,depend,490387,"allows an intrinsic; function which accepts multiple arguments, but needs all of them to be; of the same type, to only be overloaded with respect to a single; argument or the result. Overloaded intrinsics will have the names of its overloaded argument; types encoded into its function name, each preceded by a period. Only; those types which are overloaded result in a name suffix. Arguments; whose type is matched against another type do not. For example, the; ``llvm.ctpop`` function can take an integer of any width and returns an; integer of exactly the same integer width. This leads to a family of; functions such as ``i8 @llvm.ctpop.i8(i8 %val)`` and; ``i29 @llvm.ctpop.i29(i29 %val)``. Only one type, the return type, is; overloaded, and only one type suffix is required. Because the argument's; type is matched against the return type, it does not require its own; name suffix. :ref:`Unnamed types <t_opaque>` are encoded as ``s_s``. Overloaded intrinsics; that depend on an unnamed type in one of its overloaded argument types get an; additional ``.<number>`` suffix. This allows differentiating intrinsics with; different unnamed types as arguments. (For example:; ``llvm.ssa.copy.p0s_s.2(%42*)``) The number is tracked in the LLVM module and; it ensures unique names in the module. While linking together two modules, it is; still possible to get a name clash. In that case one of the names will be; changed by getting a new number. For target developers who are defining intrinsics for back-end code; generation, any intrinsic overloads based solely the distinction between; integer or floating point types should not be relied upon for correct; code generation. In such cases, the recommended approach for target; maintainers when defining intrinsics is to create separate integer and; FP intrinsics rather than rely on overloading. For example, if different; codegen is required for ``llvm.target.foo(<4 x i32>)`` and; ``llvm.target.foo(<4 x float>)`` then these should be split into; d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:493551,Integrability,depend,dependent,493551,"; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for; subsequent use by ``va_arg``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list`` element to which the argument points, so that the next call; to ``va_arg`` will produce the first variable argument passed to the; function. Unlike the C ``va_start`` macro, this intrinsic does not need; to know the last argument of the function as the compiler can figure; that out. '``llvm.va_end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_end(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been; initialized previously with ``llvm.va_start`` or ``llvm.va_copy``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` to destroy. Semantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:494366,Integrability,depend,dependent,494366,"` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list`` element to which the argument points, so that the next call; to ``va_arg`` will produce the first variable argument passed to the; function. Unlike the C ``va_start`` macro, this intrinsic does not need; to know the last argument of the function as the compiler can figure; that out. '``llvm.va_end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_end(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been; initialized previously with ``llvm.va_start`` or ``llvm.va_copy``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` to destroy. Semantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_copy(ptr <destarglist>, ptr <srcarglist>). Overview:; """""""""""""""""". The '``llvm.va_copy``' intrinsic copies the current argument position; from the source argument list to the destination argument list. Arguments:; """""""""""""""""""". The first argument is a pointer to a ``va_list`` element to initialize.; The second argument is a pointer to a ``va_list`` element to copy from. Semantics:; """""""""""""""""""". The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro; available in C. In a target-dependent way, it copies the source; ``va_list`` element into the destination ``va_list`` element. This; intrinsic is necessary because the `` llvm.va_start`` intrinsic may be; arbitrarily complex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:495204,Integrability,depend,dependent,495204,"mantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_copy(ptr <destarglist>, ptr <srcarglist>). Overview:; """""""""""""""""". The '``llvm.va_copy``' intrinsic copies the current argument position; from the source argument list to the destination argument list. Arguments:; """""""""""""""""""". The first argument is a pointer to a ``va_list`` element to initialize.; The second argument is a pointer to a ``va_list`` element to copy from. Semantics:; """""""""""""""""""". The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro; available in C. In a target-dependent way, it copies the source; ``va_list`` element into the destination ``va_list`` element. This; intrinsic is necessary because the `` llvm.va_start`` intrinsic may be; arbitrarily complex and require, for example, memory allocation. Accurate Garbage Collection Intrinsics; --------------------------------------. LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_; (GC) requires the frontend to generate code containing appropriate intrinsic; calls and select an appropriate GC strategy which knows how to lower these; intrinsics in a manner which is appropriate for the target collector. These intrinsics allow identification of :ref:`GC roots on the; stack <int_gcroot>`, as well as garbage collector implementations that; require :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers.; Frontends for type-safe garbage collected languages should generate; these intrinsics to make use of the LLVM garbage collectors. For more; details, see `Garbage Collection with LLVM <GarbageCollection.html>`_.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:515703,Integrability,inject,injected,515703," a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with Windows SEH Asynchrous Exception option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile stores. '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.scope.begin(); declare void @llvm.seh.scope.end(). Overview:; """""""""""""""""". The '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' intrinsics mark; the boundary of a CPP object lifetime for Windows SEH Asynchrous Exception; Handling (MSVC option -EHa). Semantics:; """""""""""""""""""". LLVM's ordinary exception-handling representation associates EH cleanups and; handlers only with ``invoke``s, which normally correspond only to call sites. To; support arbitrary faulting instructions, it must be possible to recover the current; EH scope for any in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:521898,Integrability,rout,routines,521898,"he corresponding; :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is; useful for implementing language features like scoped automatic; variable sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.get.dynamic.area.offset.i32(); declare i64 @llvm.get.dynamic.area.offset.i64(). Overview:; """""""""""""""""". The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to; get the offset from native stack pointer to the address of the most; recent dynamic alloca on the caller's stack. These intrinsics are; intended for use in combination with; :ref:`llvm.stacksave <int_stacksave>` to get a; pointer to the most recent dynamic alloca. This is useful, for example,; for AddressSanitizer's stack unpoisoning routines. Semantics:; """""""""""""""""""". These intrinsics return a non-negative integer value that can be used to; get the address of the most recent dynamic alloca, allocated by :ref:`alloca <i_alloca>`; on the caller's stack. In particular, for targets where stack grows downwards,; adding this offset to the native stack pointer would get the address of the most; recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more; complicated, because subtracting this value from stack pointer would get the address; one past the end of the most recent dynamic alloca. Although for most targets `llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; returns just a zero, for others, such as PowerPC and PowerPC64, it returns a; compile-time-known constant value. The return value type of :ref:`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; must match the target's default address space's (address space 0) pointer type. '``llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531810,Integrability,rout,routine,531810," pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:547961,Integrability,depend,depend,547961,"y.p0.p0.i32(ptr <dest>, ptr <src>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memcpy.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the; source location to the destination location. Note that, unlike the standard libc function, the ``llvm.memcpy.*``; intrinsics do not return a value, takes extra isvolatile; arguments and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is an integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source; location to the destination location, which must either be equal or; non-overlapping. It copies ""len"" bytes of memory over. If the argument is known; to be aligned to some boundary, this can be specified as an attribute on the; argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be well-defined,; otherwise the behavior is undefined. .. _int_memcpy_inline:. '``llvm.memcpy.inline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memcpy.inline`` on any; integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memcpy.inline.p0.p0",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:550044,Integrability,depend,depend,550044,".inline.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memcpy.inline.*``' intrinsics copy a block of memory from the; source location to the destination location and guarantees that no external; functions are called. Note that, unlike the standard libc function, the ``llvm.memcpy.inline.*``; intrinsics do not return a value, takes extra isvolatile; arguments and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is a constant integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy.inline`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memcpy.inline.*``' intrinsics copy a block of memory from the; source location to the destination location, which are not allowed to; overlap. It copies ""len"" bytes of memory over. If the argument is known; to be aligned to some boundary, this can be specified as an attribute on; the argument.; The behavior of '``llvm.memcpy.inline.*``' is equivalent to the behavior of; '``llvm.memcpy.*``', but the generated code is guaranteed not to call any; external functions. .. _int_memmove:. '``llvm.memmove``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.memmove on any integer; bit width and for different address space. Not all targets support all; bit widths however. ::. declare void @llvm.memmove.p0.p0.i32(ptr <dest>, ptr <src>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memmove.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Ov",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:551992,Integrability,depend,depend,551992," <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memmove.*``' intrinsics move a block of memory from the; source location to the destination location. It is similar to the; '``llvm.memcpy``' intrinsic but allows the two memory locations to; overlap. Note that, unlike the standard libc function, the ``llvm.memmove.*``; intrinsics do not return a value, takes an extra isvolatile; argument and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is an integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memmove`` call; is a :ref:`volatile operation <volatile>`. The detailed access behavior is; not very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memmove.*``' intrinsics copy a block of memory from the; source location to the destination location, which may overlap. It; copies ""len"" bytes of memory over. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be well-defined,; otherwise the behavior is undefined. .. _int_memset:. '``llvm.memset.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.memset on any integer; bit width and for different address spaces. However, not all targets; support all bit widths. ::. declare void @llvm.memset.p0.i32(ptr <dest>, i8 <val>,; i32 <len>, i1 <isvolatile>); decla",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:553914,Integrability,depend,depend,553914," @llvm.memset.p0.i32(ptr <dest>, i8 <val>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memset.p0.i64(ptr <dest>, i8 <val>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memset.*``' intrinsics fill a block of memory with a; particular byte value. Note that, unlike the standard libc function, the ``llvm.memset``; intrinsic does not return a value and takes an extra volatile; argument. Also, the destination can be in an arbitrary address space. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination to fill, the second; is the byte value with which to fill it, the third argument is an; integer argument specifying the number of bytes to fill, and the fourth; is a boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memset`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memset.*``' intrinsics fill ""len"" bytes of memory starting; at the destination location. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, ``<dest>`` should be well-defined, otherwise the; behavior is undefined. .. _int_memset_inline:. '``llvm.memset.inline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memset.inline`` on any; integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memset.inline.p0.p0i8.i32(ptr <dest>, i8 <val>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memset.inline.p0.p0.i64(ptr <dest>, i8 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:555864,Integrability,depend,depend,555864,"void @llvm.memset.inline.p0.p0.i64(ptr <dest>, i8 <val>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memset.inline.*``' intrinsics fill a block of memory with a; particular byte value and guarantees that no external functions are called. Note that, unlike the standard libc function, the ``llvm.memset.inline.*``; intrinsics do not return a value, take an extra isvolatile argument and the; pointer can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination to fill, the second; is the byte value with which to fill it, the third argument is a constant; integer argument specifying the number of bytes to fill, and the fourth; is a boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first argument. If the ``isvolatile`` parameter is ``true``, the ``llvm.memset.inline`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memset.inline.*``' intrinsics fill ""len"" bytes of memory starting; at the destination location. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. ``len`` must be a constant expression.; If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, ``<dest>`` should be well-defined, otherwise the; behavior is undefined. The behavior of '``llvm.memset.inline.*``' is equivalent to the behavior of; '``llvm.memset.*``', but the generated code is guaranteed not to call any; external functions. .. _int_sqrt:. '``llvm.sqrt.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any; floating-point or vector of floating-point type. Not all targets support;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:639474,Integrability,protocol,protocol,639474,"anonicalize.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.canonicalize.f32(float %a); declare double @llvm.canonicalize.f64(double %b). Overview:; """""""""""""""""". The '``llvm.canonicalize.*``' intrinsic returns the platform specific canonical; encoding of a floating-point number. This canonicalization is useful for; implementing certain numeric primitives such as frexp. The canonical encoding is; defined by IEEE-754-2008 to be:. ::. 2.1.8 canonical encoding: The preferred encoding of a floating-point; representation in a format. Applied to declets, significands of finite; numbers, infinities, and NaNs, especially in decimal formats. This operation can also be considered equivalent to the IEEE-754-2008; conversion of a floating-point value to the same format. NaNs are handled; according to section 6.2. Examples of non-canonical encodings:. - x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are; converted to a canonical representation per hardware-specific protocol.; - Many normal decimal floating-point numbers have non-canonical alternative; encodings.; - Some machines, like GPUs or ARMv7 NEON, do not support subnormal values.; These are treated as non-canonical encodings of zero and will be flushed to; a zero of the same sign by this operation. Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with; default exception handling must signal an invalid exception, and produce a; quiet NaN result. This function should always be implementable as multiplication by 1.0, provided; that the compiler does not constant fold the operation. Likewise, division by; 1.0 and ``llvm.minnum(x, x)`` are possible implementations. Addition with; -0.0 is also sufficient provided that the rounding mode is not -Infinity. ``@llvm.canonicalize`` must preserve the equality relation. That is:. - ``(@llvm.canonicalize(x) == x)`` is equivalent to ``(x == x)``; - ``(@llvm.canonicalize(x) == @llvm.canonicalize(y))`` is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:648415,Integrability,wrap,wrap,648415,"this to; set up the hardware-loop count with a target specific instruction, usually a; move of this value to a special register or a hardware-loop instruction.; The result is a pair of the input and a conditional value of whether the; given count is not zero. '``llvm.loop.decrement.reg.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i32 @llvm.loop.decrement.reg.i32(i32, i32); declare i64 @llvm.loop.decrement.reg.i64(i64, i64). Overview:; """""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics are used to lower the loop; iteration counter and return an updated value that will be used in the next; loop test check. Arguments:; """""""""""""""""""". Both arguments must have identical integer types. The first operand is the; loop iteration counter. The second operand is the maximum number of elements; processed in an iteration. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics do an integer ``SUB`` of its; two operands, which is not allowed to wrap. They return the remaining number of; iterations still to be executed, and can be used together with a ``PHI``,; ``ICMP`` and ``BR`` to control the number of loop iterations executed. Any; optimisations are allowed to treat it is a ``SUB``, and it is supported by; SCEV, so it's the backends responsibility to handle cases where it may be; optimised. These intrinsics are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.loop.decrement.i32(i32); declare i1 @llvm.loop.decrement.i64(i64). Overview:; """""""""""""""""". The HardwareLoops pass allows the loop decrement value to be specified with an; option. It defaults to a loop decrement value of 1, but it can be an unsigned; integer value provided by this option. The '``llvm.loop.decrement.*``'; intrinsics decrement the loop i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:649945,Integrability,wrap,wrap,649945,"nstructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.loop.decrement.i32(i32); declare i1 @llvm.loop.decrement.i64(i64). Overview:; """""""""""""""""". The HardwareLoops pass allows the loop decrement value to be specified with an; option. It defaults to a loop decrement value of 1, but it can be an unsigned; integer value provided by this option. The '``llvm.loop.decrement.*``'; intrinsics decrement the loop iteration counter with this value, and return a; false predicate if the loop should exit, and true otherwise.; This is emitted if the loop counter is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:674447,Integrability,depend,depends,674447,":; """""""""""""""""""". None. '``llvm.experimental.get.vector.length``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.experimental.get.vector.length.i32(i32 %cnt, i32 immarg %vf, i1 immarg %scalable); declare i32 @llvm.experimental.get.vector.length.i64(i64 %cnt, i32 immarg %vf, i1 immarg %scalable). Overview:; """""""""""""""""". The '``llvm.experimental.get.vector.length.*``' intrinsics take a number of; elements to process and returns how many of the elements can be processed; with the requested vectorization factor. Arguments:; """""""""""""""""""". The first argument is an unsigned value of any scalar integer type and specifies; the total number of elements to be processed. The second argument is an i32; immediate for the vectorization factor. The third argument indicates if the; vectorization factor should be multiplied by vscale. Semantics:; """""""""""""""""""". Returns a positive i32 value (explicit vector length) that is unknown at compile; time and depends on the hardware specification.; If the result value does not fit in the result type, then the result is; a :ref:`poison value <poisonvalues>`. This intrinsic is intended to be used by loop vectorization with VP intrinsics; in order to get the number of elements to process on each loop iteration. The; result should be used to decrease the count for the next iteration until the; count reaches zero. If the count is larger than the number of lanes in the type described by the; last 2 arguments, this intrinsic may return a value less than the number of; lanes implied by the type. The result will be at least as large as the result; will be on any later loop iteration. This intrinsic will only return 0 if the input count is also 0. A non-zero input; count will produce a non-zero result. Matrix Intrinsics; -----------------. Operations on matrixes requiring shape information (like number of rows/columns; or the memory layout) can be expressed using the matrix",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:690005,Integrability,depend,dependent,690005,"%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to; ``%val = call i32 %f(ptr %nval, i32 %x, i32 %y)``. .. _int_it:. '``llvm.init.trampoline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.init.trampoline(ptr <tramp>, ptr <func>, ptr <nval>). Overview:; """""""""""""""""". This fills the memory pointed to by ``tramp`` with executable code,; turning it into a trampoline. Arguments:; """""""""""""""""""". The ``llvm.init.trampoline`` intrinsic takes three arguments, all; pointers. The ``tramp`` argument must point to a sufficiently large and; sufficiently aligned block of memory; this memory is written to by the; intrinsic. Note that the size and the alignment are target-specific -; LLVM currently provides no portable way of determining them, so a; front-end that generates this intrinsic needs to have some; target-specific knowledge. The ``func`` argument must hold a function. Semantics:; """""""""""""""""""". The block of memory pointed to by ``tramp`` is filled with target; dependent code, turning it into a function. Then ``tramp`` needs to be; passed to :ref:`llvm.adjust.trampoline <int_at>` to get a pointer which can; be :ref:`bitcast (to a new function) and called <int_trampoline>`. The new; function's signature is the same as that of ``func`` with any arguments; marked with the ``nest`` attribute removed. At most one such ``nest``; argument is allowed, and it must be of pointer type. Calling the new; function is equivalent to calling ``func`` with the same argument list,; but with ``nval`` used for the missing ``nest`` argument. If, after; calling ``llvm.init.trampoline``, the memory pointed to by ``tramp`` is; modified, then the effect of any later call to the returned function; pointer is undefined. .. _int_at:. '``llvm.adjust.trampoline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.adjust.trampoline(ptr <tramp>). Overview:; """""""""""""""""". This performs any required machine-specific adjustment ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:694488,Integrability,depend,depending,694488,"true>, <vscale x 4 x i64> <on_false>, i32 <evl>). Overview:; """""""""""""""""". The '``llvm.vp.select``' intrinsic is used to choose one value based on a; condition vector, without IR-level branching. Arguments:; """""""""""""""""""". The first operand is a vector of ``i1`` and indicates the condition. The; second operand is the value that is selected where the condition vector is; true. The third operand is the value that is selected where the condition; vector is false. The vectors must be of the same size. The fourth operand is; the explicit vector length. #. The optional ``fast-math flags`` marker indicates that the select has one or; more :ref:`fast-math flags <fastmath>`. These are optimization hints to; enable otherwise unsafe floating-point optimizations. Fast-math flags are; only valid for selects that return a floating-point scalar or vector type,; or an array (nested to any depth) of floating-point scalar or vector types. Semantics:; """""""""""""""""""". The intrinsic selects lanes from the second and third operand depending on a; condition vector. All result lanes at positions greater or equal than ``%evl`` are undefined.; For all lanes below ``%evl`` where the condition vector is true the lane is; taken from the second operand. Otherwise, the lane is taken from the third; operand. Example:; """""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.select.v4i32(<4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false, i32 %evl). ;;; Expansion.; ;; Any result is legal on lanes at and above %evl.; %also.r = select <4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false. .. _int_vp_merge:. '``llvm.vp.merge.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.merge.v16i32 (<16 x i1> <condition>, <16 x i32> <on_true>, <16 x i32> <on_false>, i32 <pivot>); declare <vscale x 4 x i64> @llvm.vp.merge.nxv4i64 (<vscale x 4 x i1> <condition>, <vscale x 4 x i64> <on_true>, <vscale x 4 x i64> <on_false>, i32 <piv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:696458,Integrability,depend,depending,696458,"> <on_false>, i32 <pivot>). Overview:; """""""""""""""""". The '``llvm.vp.merge``' intrinsic is used to choose one value based on a; condition vector and an index operand, without IR-level branching. Arguments:; """""""""""""""""""". The first operand is a vector of ``i1`` and indicates the condition. The; second operand is the value that is merged where the condition vector is true.; The third operand is the value that is selected where the condition vector is; false or the lane position is greater equal than the pivot. The fourth operand; is the pivot. #. The optional ``fast-math flags`` marker indicates that the merge has one or; more :ref:`fast-math flags <fastmath>`. These are optimization hints to; enable otherwise unsafe floating-point optimizations. Fast-math flags are; only valid for merges that return a floating-point scalar or vector type,; or an array (nested to any depth) of floating-point scalar or vector types. Semantics:; """""""""""""""""""". The intrinsic selects lanes from the second and third operand depending on a; condition vector and pivot value. For all lanes where the condition vector is true and the lane position is less; than ``%pivot`` the lane is taken from the second operand. Otherwise, the lane; is taken from the third operand. Example:; """""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.merge.v4i32(<4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false, i32 %pivot). ;;; Expansion.; ;; Lanes at and above %pivot are taken from %on_false; %atfirst = insertelement <4 x i32> undef, i32 %pivot, i32 0; %splat = shufflevector <4 x i32> %atfirst, <4 x i32> poison, <4 x i32> zeroinitializer; %pivotmask = icmp ult <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> %splat; %mergemask = and <4 x i1> %cond, <4 x i1> %pivotmask; %also.r = select <4 x i1> %mergemask, <4 x i32> %on_true, <4 x i32> %on_false. .. _int_vp_add:. '``llvm.vp.add.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:772536,Integrability,depend,dependent,772536," Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX``; reduction (:ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>`) of the; vector operand ``val`` on each enabled lane, taking the maximum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``-QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the smallest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``-Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the; '``llvm.maxnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:775410,Integrability,depend,dependent,775410," Arguments:; """""""""""""""""""". The first operand is the start value of the reduction, which must be a scalar; floating-point type equal to the result type. The second operand is the vector; on which the reduction is performed and must be a vector of floating-point; values whose element type is the result/start type. The third operand is the; vector mask and is a vector of boolean values with the same number of elements; as the vector operand. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN``; reduction (:ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>`) of the; vector operand ``val`` on each enabled lane, taking the minimum of that and the; scalar ``start_value``. Disabled lanes are treated as containing the neutral; value (i.e. having no effect on the reduction operation). If the vector length; is zero, the result is the start value. The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If no; flags are set, the neutral value is ``+QNAN``. If ``nnan`` and ``ninf`` are; both set, then the neutral value is the largest floating-point value for the; result type. If only ``nnan`` is set then the neutral value is ``+Infinity``. This instruction has the same comparison semantics as the; :ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the; '``llvm.minnum.*``' intrinsic). That is, the result will always be a number; unless all elements of the vector and the starting value are ``NaN``. For a; vector with maximum element magnitude ``0.0`` and containing both ``+0.0`` and; ``-0.0`` elements, the sign of the result is unspecified. To ignore the start value, the neutral value can be used. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call float @llvm.vp.reduce.fmin.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl); ; %r is equivalent to %also.r, where lanes greater than or equal to %evl; ; are treated a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:816110,Integrability,depend,depending,816110,"or_length>); declare <vscale x 4 x ptr> @llvm.vp.inttoptr.nxv4p0.nxv4i32 (<vscale x 4 x i32> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>); declare <256 x ptr> @llvm.vp.inttoptr.v256p0.v256i32 (<256 x i32> <op>, <256 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.inttoptr``' intrinsic converts its integer value to the point; return type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.inttoptr``' intrinsic takes a value to cast as its first operand; , which must be a vector of :ref:`integer <t_integer>` type, and a type to cast; it to return type, which must be a vector of pointers type.; The second operand is the vector mask. The return type, the value to cast, and; the vector mask have the same number of elements.; The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.inttoptr``' intrinsic converts ``value`` to return type by; applying either a zero extension or a truncation depending on the size of the; integer ``value``. If ``value`` is larger than the size of a pointer, then a; truncation is done. If ``value`` is smaller than the size of a pointer, then a; zero extension is done. If they are the same size, nothing is done (*no-op cast*).; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x ptr> @llvm.vp.inttoptr.v4p0i32.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = inttoptr <4 x i32> %a to <4 x ptr>; %also.r = select <4 x i1> %mask, <4 x ptr> %t, <4 x ptr> poison. .. _int_vp_fcmp:. '``llvm.vp.fcmp.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i1> @llvm.vp.fcmp.v16f32(<16 x float> <left_op>, <16 x float> <right_op>, metadata",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:857017,Integrability,depend,dependency,857017,"he sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:859872,Integrability,depend,dependences,859872," selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:868835,Integrability,depend,depend,868835,"eate miscompiles if mixing of constrained and normal; operations is done. The correct way to mix constrained and less constrained; operations is to use the rounding mode and exception handling metadata to; mark constrained intrinsics as having LLVM's default behavior. Each of these intrinsics corresponds to a normal floating-point operation. The; data arguments and the return value are the same as the corresponding FP; operation. The rounding mode argument is a metadata string specifying what; assumptions, if any, the optimizer can make when transforming constant; values. Some constrained FP intrinsics omit this argument. If required; by the intrinsic, this argument must be one of the following strings:. ::. ""round.dynamic""; ""round.tonearest""; ""round.downward""; ""round.upward""; ""round.towardzero""; ""round.tonearestaway"". If this argument is ""round.dynamic"" optimization passes must assume that the; rounding mode is unknown and may change at runtime. No transformations that; depend on rounding mode may be performed in this case. The other possible values for the rounding mode argument correspond to the; similarly named IEEE rounding modes. If the argument is any of these values; optimization passes may perform transformations as long as they are consistent; with the specified rounding mode. For example, 'x-0'->'x' is not a valid transformation if the rounding mode is; ""round.downward"" or ""round.dynamic"" because if the value of 'x' is +0 then; 'x-0' should evaluate to '-0' when rounding downward. However, this; transformation is legal for all other rounding modes. For values other than ""round.dynamic"" optimization passes may assume that the; actual runtime rounding mode (as defined in a target-specific manner) matches; the specified rounding mode, but this is not guaranteed. Using a specific; non-dynamic rounding mode which does not match the actual rounding mode at; runtime results in undefined behavior. The exception behavior argument is a metadata string describing th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:913476,Integrability,depend,depending,913476," metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.trunc``' intrinsic returns the first; operand rounded to the nearest integer not larger in magnitude than the; operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``trunc`` functions; would and handles error conditions in the same way. .. _int_experimental_noalias_scope_decl:. '``llvm.experimental.noalias.scope.decl``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.experimental.noalias.scope.decl(metadata !id.scope.list). Overview:; """""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. Arguments:; """""""""""""""""""". The ``!id.scope.list`` argument is metadata that is a list of ``noalias``; metadata references. The format is identical to that required for ``noalias``; metadata. This list must have exactly one element. Semantics:; """""""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. For example, when the intrinsic is used inside a loop body, and that loop is; unrolled, the associated noalias scope must also be duplicated. Otherwise, the; noalias property it signifies would spill across loop iterations, whereas it; was only valid within a single iteration. .. code-block:: llvm. ; This examples shows two possible positions for noalias.decl and how they impact the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:914004,Integrability,depend,depending,914004,"the same way. .. _int_experimental_noalias_scope_decl:. '``llvm.experimental.noalias.scope.decl``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.experimental.noalias.scope.decl(metadata !id.scope.list). Overview:; """""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. Arguments:; """""""""""""""""""". The ``!id.scope.list`` argument is metadata that is a list of ``noalias``; metadata references. The format is identical to that required for ``noalias``; metadata. This list must have exactly one element. Semantics:; """""""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. For example, when the intrinsic is used inside a loop body, and that loop is; unrolled, the associated noalias scope must also be duplicated. Otherwise, the; noalias property it signifies would spill across loop iterations, whereas it; was only valid within a single iteration. .. code-block:: llvm. ; This examples shows two possible positions for noalias.decl and how they impact the semantics:; ; If it is outside the loop (Version 1), then %a and %b are noalias across *all* iterations.; ; If it is inside the loop (Version 2), then %a and %b are noalias only within *one* iteration.; declare void @decl_in_loop(ptr %a.base, ptr %b.base) {; entry:; ; call void @llvm.experimental.noalias.scope.decl(metadata !2) ; Version 1: noalias decl outside loop; br label %loop. loop:; %a = phi ptr [ %a.base, %entry ], [ %a.inc, %loop ]; %b = phi ptr [ %b.base, %entry ], [ %b.inc, %loop ]; ; call void @llvm.experiment",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:918398,Integrability,depend,dependent,918398,"^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <integer_type> @llvm.get.fpenv(). Overview:; """""""""""""""""". The '``llvm.get.fpenv``' intrinsic returns bits of the current floating-point; environment. The return value type is platform-specific. Semantics:; """""""""""""""""""". The '``llvm.get.fpenv``' intrinsic reads the current floating-point environment; and returns it as an integer value. '``llvm.set.fpenv``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.set.fpenv(<integer_type> <val>). Overview:; """""""""""""""""". The '``llvm.set.fpenv``' intrinsic sets the current floating-point environment. Arguments:; """""""""""""""""""". The argument is an integer representing the new floating-point environment. The; integer type is platform-specific. Semantics:; """""""""""""""""""". The '``llvm.set.fpenv``' intrinsic sets the current floating-point environment; to the state specified by the argument. The state may be previously obtained by a; call to '``llvm.get.fpenv``' or synthesised in a platform-dependent way. '``llvm.reset.fpenv``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.reset.fpenv(). Overview:; """""""""""""""""". The '``llvm.reset.fpenv``' intrinsic sets the default floating-point environment. Semantics:; """""""""""""""""""". The '``llvm.reset.fpenv``' intrinsic sets the current floating-point environment; to default state. It is similar to the call 'fesetenv(FE_DFL_ENV)', except it; does not return any value. .. _int_get_fpmode:. '``llvm.get.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". The '``llvm.get.fpmode``' intrinsic returns bits of the current floating-point; control modes. The return value type is platform-specific. ::. declare <integer_type> @llvm.get.fpmode(). Overview:; """""""""""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes and returns it as an integer value. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.get.fpmode``' intrinsic re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:919731,Integrability,depend,dependent,919731," current floating-point environment; to default state. It is similar to the call 'fesetenv(FE_DFL_ENV)', except it; does not return any value. .. _int_get_fpmode:. '``llvm.get.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". The '``llvm.get.fpmode``' intrinsic returns bits of the current floating-point; control modes. The return value type is platform-specific. ::. declare <integer_type> @llvm.get.fpmode(). Overview:; """""""""""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes and returns it as an integer value. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes, such as rounding direction, precision, treatment of denormals and; so on. It is similar to the C library function 'fegetmode', however this; function does not store the set of control modes into memory but returns it as; an integer value. Interpretation of the bits in this value is target-dependent. '``llvm.set.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current floating-point control modes. ::. declare void @llvm.set.fpmode(<integer_type> <val>). Overview:; """""""""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point; control modes. Arguments:; """""""""""""""""""". The argument is a set of floating-point control modes, represented as an integer; value in a target-dependent way. Semantics:; """""""""""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point; control modes to the state specified by the argument, which must be obtained by; a call to '``llvm.get.fpmode``' or constructed in a target-specific way. It is; similar to the C library function 'fesetmode', however this function does not; read the set of control modes from memory but gets it as integer value. '``llvm.reset.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:920204,Integrability,depend,dependent,920204,""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes and returns it as an integer value. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes, such as rounding direction, precision, treatment of denormals and; so on. It is similar to the C library function 'fegetmode', however this; function does not store the set of control modes into memory but returns it as; an integer value. Interpretation of the bits in this value is target-dependent. '``llvm.set.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current floating-point control modes. ::. declare void @llvm.set.fpmode(<integer_type> <val>). Overview:; """""""""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point; control modes. Arguments:; """""""""""""""""""". The argument is a set of floating-point control modes, represented as an integer; value in a target-dependent way. Semantics:; """""""""""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point; control modes to the state specified by the argument, which must be obtained by; a call to '``llvm.get.fpmode``' or constructed in a target-specific way. It is; similar to the C library function 'fesetmode', however this function does not; read the set of control modes from memory but gets it as integer value. '``llvm.reset.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.reset.fpmode(). Overview:; """""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the default dynamic floating-point; control modes. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the current dynamic floating-point; environment to default state. It is similar to the C library function call; 'fesetmode(FE_DFL_MODE)', however this function does not return any value. Fl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:921626,Integrability,depend,depending,921626,"llvm.reset.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.reset.fpmode(). Overview:; """""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the default dynamic floating-point; control modes. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the current dynamic floating-point; environment to default state. It is similar to the C library function call; 'fesetmode(FE_DFL_MODE)', however this function does not return any value. Floating-Point Test Intrinsics; ------------------------------. These functions get properties of floating-point values. .. _llvm.is.fpclass:. '``llvm.is.fpclass``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i1 @llvm.is.fpclass(<fptype> <op>, i32 <test>); declare <N x i1> @llvm.is.fpclass(<vector-fptype> <op>, i32 <test>). Overview:; """""""""""""""""". The '``llvm.is.fpclass``' intrinsic returns a boolean value or vector of boolean; values depending on whether the first argument satisfies the test specified by; the second argument. If the first argument is a floating-point scalar, then the result type is a; boolean (:ref:`i1 <t_integer>`). If the first argument is a floating-point vector, then the result type is a; vector of boolean with the same number of elements as the first argument. Arguments:; """""""""""""""""""". The first argument to the '``llvm.is.fpclass``' intrinsic must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>`; of floating-point values. The second argument specifies, which tests to perform. It must be a compile-time; integer constant, each bit in which specifies floating-point class:. +-------+----------------------+; | Bit # | floating-point class |; +=======+======================+; | 0 | Signaling NaN |; +-------+----------------------+; | 1 | Quiet NaN |; +-------+----------------------+; | 2 | Negative infinity |; +-------+----------------------+; | 3 | Negative normal |; +-------+----------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:923713,Integrability,depend,depend,923713,"---+; | 5 | Negative zero |; +-------+----------------------+; | 6 | Positive zero |; +-------+----------------------+; | 7 | Positive subnormal |; +-------+----------------------+; | 8 | Positive normal |; +-------+----------------------+; | 9 | Positive infinity |; +-------+----------------------+. Semantics:; """""""""""""""""""". The function checks if ``op`` belongs to any of the floating-point classes; specified by ``test``. If ``op`` is a vector, then the check is made element by; element. Each check yields an :ref:`i1 <t_integer>` result, which is ``true``,; if the element value satisfies the specified test. The argument ``test`` is a; bit mask where each bit specifies floating-point class to test. For example, the; value 0x108 makes test for normal value, - bits 3 and 8 in it are set, which; means that the function returns ``true`` if ``op`` is a positive or negative; normal value. The function never raises floating-point exceptions. The; function does not canonicalize its input value and does not depend; on the floating-point environment. If the floating-point environment; has a zeroing treatment of subnormal input values (such as indicated; by the ``""denormal-fp-math""`` attribute), a subnormal value will be; observed (will not be implicitly treated as zero). General Intrinsics; ------------------. This class of intrinsics is designed to be generic and has no specific; purpose. '``llvm.var.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.var.annotation(ptr <val>, ptr <str>, ptr <str>, i32 <int>). Overview:; """""""""""""""""". The '``llvm.var.annotation``' intrinsic. Arguments:; """""""""""""""""""". The first argument is a pointer to a value, the second is a pointer to a; global string, the third is a pointer to a global string which is the; source file name, and the last argument is the line number. Semantics:; """""""""""""""""""". This intrinsic allows annotation of local variables with arbitrary; strings. This can be useful for special ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:928470,Integrability,depend,dependent,928470,"asis but are allowed to; replace the intrinsic with its first argument without breaking semantics and the; intrinsic is completely dropped during instruction selection. '``llvm.codeview.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This annotation emits a label at its program point and an associated; ``S_ANNOTATION`` codeview record with some additional string metadata. This is; used to implement MSVC's ``__annotation`` intrinsic. It is marked; ``noduplicate``, so calls to this intrinsic prevent inlining and should be; considered expensive. ::. declare void @llvm.codeview.annotation(metadata). Arguments:; """""""""""""""""""". The argument should be an MDTuple containing any number of MDStrings. '``llvm.trap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.trap() cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.trap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to the target dependent trap instruction. If; the target does not have a trap instruction, this intrinsic will be; lowered to a call of the ``abort()`` function. '``llvm.debugtrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.debugtrap() nounwind. Overview:; """""""""""""""""". The '``llvm.debugtrap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:933250,Integrability,depend,depending,933250,""""""""""""". The ``llvm.objectsize`` intrinsic takes four arguments. The first argument is a; pointer to or into the ``object``. The second argument determines whether; ``llvm.objectsize`` returns 0 (if true) or -1 (if false) when the object size is; unknown. The third argument controls how ``llvm.objectsize`` acts when ``null``; in address space 0 is used as its pointer argument. If it's ``false``,; ``llvm.objectsize`` reports 0 bytes available when given ``null``. Otherwise, if; the ``null`` is in a non-zero address space or if ``true`` is given for the; third argument of ``llvm.objectsize``, we assume its size is unknown. The fourth; argument to ``llvm.objectsize`` determines if the value should be evaluated at; runtime. The second, third, and fourth arguments only accept constants. Semantics:; """""""""""""""""""". The ``llvm.objectsize`` intrinsic is lowered to a value representing the size of; the object concerned. If the size cannot be determined, ``llvm.objectsize``; returns ``i32/i64 -1 or 0`` (depending on the ``min`` argument). '``llvm.expect``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.expect`` on any; integer bit width. ::. declare i1 @llvm.expect.i1(i1 <val>, i1 <expected_val>); declare i32 @llvm.expect.i32(i32 <val>, i32 <expected_val>); declare i64 @llvm.expect.i64(i64 <val>, i64 <expected_val>). Overview:; """""""""""""""""". The ``llvm.expect`` intrinsic provides information about expected (the; most probable) value of ``val``, which can be used by optimizers. Arguments:; """""""""""""""""""". The ``llvm.expect`` intrinsic takes two arguments. The first argument is; a value. The second argument is an expected value. Semantics:; """""""""""""""""""". This intrinsic is lowered to the ``val``. '``llvm.expect.with.probability``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This intrinsic is similar to ``llvm.expect``. This is an overloaded intrinsic.; You can use ``llvm.expect.with.probability`` on ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:942525,Integrability,integrat,integrated,942525,"none). Overview:; """""""""""""""""". The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of only; three intrinsics (besides ``llvm.experimental.patchpoint`` and; ``llvm.experimental.gc.statepoint``) that can be called with an invoke; instruction. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic does nothing, and it's removed by optimizers and ignored; by codegen. '``llvm.experimental.deoptimize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare type @llvm.experimental.deoptimize(...) [ ""deopt""(...) ]. Overview:; """""""""""""""""". This intrinsic, together with :ref:`deoptimization operand bundles; <deopt_opbundles>`, allow frontends to express transfer of control and; frame-local state from the currently executing (typically more specialized,; hence faster) version of a function into another (typically more generic, hence; slower) version. In languages with a fully integrated managed runtime like Java and JavaScript; this intrinsic can be used to implement ""uncommon trap"" or ""side exit"" like; functionality. In unmanaged languages like C and C++, this intrinsic can be; used to represent the slow paths of specialized functions. Arguments:; """""""""""""""""""". The intrinsic takes an arbitrary number of arguments, whose meaning is; decided by the :ref:`lowering strategy<deoptimize_lowering>`. Semantics:; """""""""""""""""""". The ``@llvm.experimental.deoptimize`` intrinsic executes an attached; deoptimization continuation (denoted using a :ref:`deoptimization; operand bundle <deopt_opbundles>`) and returns the value returned by; the deoptimization continuation. Defining the semantic properties of; the continuation itself is out of scope of the language reference --; as far as LLVM is concerned, the deoptimization continuation can; invoke arbitrary side effects, including reading from and writing to; the entire heap. Deoptimization continuations expressed using ``""deopt""`` operand bundles always; continue execution to the end ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:953481,Integrability,depend,depends,953481," can use llvm.is.constant with any argument type. ::. declare i1 @llvm.is.constant.i32(i32 %operand) nounwind memory(none); declare i1 @llvm.is.constant.f32(float %operand) nounwind memory(none); declare i1 @llvm.is.constant.TYPENAME(TYPE %operand) nounwind memory(none). Overview:; """""""""""""""""". The '``llvm.is.constant``' intrinsic will return true if the argument; is known to be a manifest compile-time constant. It is guaranteed to; fold to either true or false before generating machine code. Semantics:; """""""""""""""""""". This intrinsic generates no code. If its argument is known to be a; manifest compile-time constant value, then the intrinsic will be; converted to a constant true value. Otherwise, it will be converted to; a constant false value. In particular, note that if the argument is a constant expression; which refers to a global (the address of which _is_ a constant, but; not manifest during the compile), then the intrinsic evaluates to; false. The result also intentionally depends on the result of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more informat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:953558,Integrability,depend,depending,953558,"t.i32(i32 %operand) nounwind memory(none); declare i1 @llvm.is.constant.f32(float %operand) nounwind memory(none); declare i1 @llvm.is.constant.TYPENAME(TYPE %operand) nounwind memory(none). Overview:; """""""""""""""""". The '``llvm.is.constant``' intrinsic will return true if the argument; is known to be a manifest compile-time constant. It is guaranteed to; fold to either true or false before generating machine code. Semantics:; """""""""""""""""""". This intrinsic generates no code. If its argument is known to be a; manifest compile-time constant value, then the intrinsic will be; converted to a constant true value. Otherwise, it will be converted to; a constant false value. In particular, note that if the argument is a constant expression; which refers to a global (the address of which _is_ a constant, but; not manifest during the compile), then the intrinsic evaluates to; false. The result also intentionally depends on the result of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """"""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:955852,Integrability,depend,depends,955852,"PtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local global is not a constant, since it depends on; the calling thread. The `llvm.threadlocal.address` intrinsic returns the; address of the given thread local global in the calling thread. .. _int_vscale:. '``llvm.vscale``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 llvm.vscale.i32(); declare i64 llvm.vscale.i64(). Overview:; """""""""""""""""". The ``llvm.vscale`` intrinsic returns the value for ``vscale`` in scalable; vectors such as ``<vscale x 16 x i8>``. Semantics:; """""""""""""""""""". ``vscale`` is a positive value that is constant throughout program; execution, but is unknown at compile time.; If the result value does not fit in the result type, then the result is; a :ref:`poison value <poisonvalues>`. Stack Map Intrinsics; --------------------. LLVM provides experimental intrinsics to support runtime patching; mechanisms commonly desired in dynamic language JITs. These intrinsics; are described in :doc:`StackMaps`. Element Wise Atomic Memory Intrinsics; --------------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:1651,Modifiability,variab,variable,1651,"mpiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:2720,Modifiability,variab,variables,2720,"t to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come in two basic types: global and local. Global; identifiers (functions, global variables) begin with the ``'@'``; character. Local identifiers (register names, types) begin with the; ``'%'`` character. Additionally, there are three different formats for; identifiers, for different purposes:. #. Named values are represented as a string of characters with their; prefix. For example, ``%foo``, ``@DivisionByZero``,; ``%a.really.long.identifier``. The actual regular expression used is; '``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*``'. Identifiers that require other; characters in their names can be surrounded with quotes. Special; characters may be escaped using ``""\xx""`` where ``xx`` is the ASCII; code for the character in hexadecimal. In this way, any character can; be used in a name value, even quotes themselves. The ``""\01""`` prefix; can be used on global values to suppress mangling.; #. Unnamed values are represented as an unsigned numeric value with; their prefix. For example, ``%12``, ``@2``, ``%44``.; #. Constants, which are described in the section Constants_ below. LLVM ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:4019,Modifiability,variab,variable,4019,"; prefix. For example, ``%foo``, ``@DivisionByZero``,; ``%a.really.long.identifier``. The actual regular expression used is; '``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*``'. Identifiers that require other; characters in their names can be surrounded with quotes. Special; characters may be escaped using ``""\xx""`` where ``xx`` is the ASCII; code for the character in hexadecimal. In this way, any character can; be used in a name value, even quotes themselves. The ``""\01""`` prefix; can be used on global values to suppress mangling.; #. Unnamed values are represented as an unsigned numeric value with; their prefix. For example, ``%12``, ``@2``, ``%44``.; #. Constants, which are described in the section Constants_ below. LLVM requires that values start with a prefix for two reasons: Compilers; don't need to worry about name clashes with reserved words, and the set; of reserved words may be expanded in the future without penalty.; Additionally, unnamed identifiers allow a compiler to quickly come up; with a temporary variable without having to avoid symbol table; conflicts. Reserved words in LLVM are very similar to reserved words in other; languages. There are keywords for different opcodes ('``add``',; '``bitcast``', '``ret``', etc...), for primitive type names ('``void``',; '``i32``', etc...), and others. These reserved words cannot conflict; with variable names, because none of them start with a prefix character; (``'%'`` or ``'@'``). Here is an example of LLVM code to multiply the integer variable; '``%X``' by 8:. The easy way:. .. code-block:: llvm. %result = mul i32 %X, 8. After strength reduction:. .. code-block:: llvm. %result = shl i32 %X, 3. And the hard way:. .. code-block:: llvm. %0 = add i32 %X, %X ; yields i32:%0; %1 = add i32 %0, %0 ; yields i32:%1; %result = add i32 %1, %1. This last way of multiplying ``%X`` by 8 illustrates several important; lexical features of LLVM:. #. Comments are delimited with a '``;``' and go until the end of line.; #. Unnamed temporaries a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:4359,Modifiability,variab,variable,4359,"way, any character can; be used in a name value, even quotes themselves. The ``""\01""`` prefix; can be used on global values to suppress mangling.; #. Unnamed values are represented as an unsigned numeric value with; their prefix. For example, ``%12``, ``@2``, ``%44``.; #. Constants, which are described in the section Constants_ below. LLVM requires that values start with a prefix for two reasons: Compilers; don't need to worry about name clashes with reserved words, and the set; of reserved words may be expanded in the future without penalty.; Additionally, unnamed identifiers allow a compiler to quickly come up; with a temporary variable without having to avoid symbol table; conflicts. Reserved words in LLVM are very similar to reserved words in other; languages. There are keywords for different opcodes ('``add``',; '``bitcast``', '``ret``', etc...), for primitive type names ('``void``',; '``i32``', etc...), and others. These reserved words cannot conflict; with variable names, because none of them start with a prefix character; (``'%'`` or ``'@'``). Here is an example of LLVM code to multiply the integer variable; '``%X``' by 8:. The easy way:. .. code-block:: llvm. %result = mul i32 %X, 8. After strength reduction:. .. code-block:: llvm. %result = shl i32 %X, 3. And the hard way:. .. code-block:: llvm. %0 = add i32 %X, %X ; yields i32:%0; %1 = add i32 %0, %0 ; yields i32:%1; %result = add i32 %1, %1. This last way of multiplying ``%X`` by 8 illustrates several important; lexical features of LLVM:. #. Comments are delimited with a '``;``' and go until the end of line.; #. Unnamed temporaries are created when the result of a computation is; not assigned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; number",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:4505,Modifiability,variab,variable,4505,"n global values to suppress mangling.; #. Unnamed values are represented as an unsigned numeric value with; their prefix. For example, ``%12``, ``@2``, ``%44``.; #. Constants, which are described in the section Constants_ below. LLVM requires that values start with a prefix for two reasons: Compilers; don't need to worry about name clashes with reserved words, and the set; of reserved words may be expanded in the future without penalty.; Additionally, unnamed identifiers allow a compiler to quickly come up; with a temporary variable without having to avoid symbol table; conflicts. Reserved words in LLVM are very similar to reserved words in other; languages. There are keywords for different opcodes ('``add``',; '``bitcast``', '``ret``', etc...), for primitive type names ('``void``',; '``i32``', etc...), and others. These reserved words cannot conflict; with variable names, because none of them start with a prefix character; (``'%'`` or ``'@'``). Here is an example of LLVM code to multiply the integer variable; '``%X``' by 8:. The easy way:. .. code-block:: llvm. %result = mul i32 %X, 8. After strength reduction:. .. code-block:: llvm. %result = shl i32 %X, 3. And the hard way:. .. code-block:: llvm. %0 = add i32 %X, %X ; yields i32:%0; %1 = add i32 %0, %0 ; yields i32:%1; %result = add i32 %1, %1. This last way of multiplying ``%X`` by 8 illustrates several important; lexical features of LLVM:. #. Comments are delimited with a '``;``' and go until the end of line.; #. Unnamed temporaries are created when the result of a computation is; not assigned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; numbering. For example, if the entry basic block is not given a label name; and all function parameters are named",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:5935,Modifiability,variab,variables,5935,"d with a '``;``' and go until the end of line.; #. Unnamed temporaries are created when the result of a computation is; not assigned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; numbering. For example, if the entry basic block is not given a label name; and all function parameters are named, then it will get number 0. It also shows a convention that we follow in this document. When; demonstrating instructions, we will follow an instruction with a comment; that defines the type and name of value produced. High Level Structure; ====================. Module Structure; ----------------. LLVM programs are composed of ``Module``'s, each of which is a; translation unit of the input programs. Each module consists of; functions, global variables, and symbol table entries. Modules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a modu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:6063,Modifiability,variab,variable,6063,"ned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; numbering. For example, if the entry basic block is not given a label name; and all function parameters are named, then it will get number 0. It also shows a convention that we follow in this document. When; demonstrating instructions, we will follow an instruction with a comment; that defines the type and name of value produced. High Level Structure; ====================. Module Structure; ----------------. LLVM programs are composed of ``Module``'s, each of which is a; translation unit of the input programs. Each module consists of; functions, global variables, and symbol table entries. Modules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; repres",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:6691,Modifiability,variab,variable,6691,"me of value produced. High Level Structure; ====================. Module Structure; ----------------. LLVM programs are composed of ``Module``'s, each of which is a; translation unit of the input programs. Each module consists of; functions, global variables, and symbol table entries. Modules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; represented by a pointer to a memory location (in this case, a pointer; to an array of char, and a pointer to a function), and have one of the; following :ref:`linkage types <linkage>`. .. _linkage:. Linkage Types; -------------. All Global Variables and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:7006,Modifiability,variab,variables,7006,"odules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; represented by a pointer to a memory location (in this case, a pointer; to an array of char, and a pointer to a function), and have one of the; following :ref:`linkage types <linkage>`. .. _linkage:. Linkage Types; -------------. All Global Variables and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references can be updated. This; doesn't show up in any symbol table in the object file.; ``internal``; Similar to private, but the value shows as a local symbol; (``STB_LOCAL`` in the case of ELF) in the object file. This; corresponds to the notion of the '``static``' keyword in C.; ``available_e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:10177,Modifiability,variab,variables,10177,"tion of the function is the definitive definition; within the program or whether it will be overridden by a stronger; definition. To enable inlining and other optimizations, use; ""``linkonce_odr``"" linkage.; ``weak``; ""``weak``"" linkage has the same merging semantics as ``linkonce``; linkage, except that unreferenced globals with ``weak`` linkage may; not be discarded. This is used for globals that are declared ""weak""; in C source code.; ``common``; ""``common``"" linkage is most similar to ""``weak``"" linkage, but they; are used for tentative definitions in C, such as ""``int X;``"" at; global scope. Symbols with ""``common``"" linkage are merged in the; same way as ``weak symbols``, and they may not be deleted if; unreferenced. ``common`` symbols may not have an explicit section,; must have a zero initializer, and may not be marked; ':ref:`constant <globalvars>`'. Functions and aliases may not have; common linkage. .. _linkage_appending:. ``appending``; ""``appending``"" linkage may only be applied to global variables of; pointer to array type. When two global variables with appending; linkage are linked together, the two global arrays are appended; together. This is the LLVM, typesafe, equivalent of having the; system linker append together ""sections"" with identical names when; .o files are linked. Unfortunately this doesn't correspond to any feature in .o files, so it; can only be used for variables like ``llvm.global_ctors`` which llvm; interprets specially. ``extern_weak``; The semantics of this linkage follow the ELF object file model: the; symbol is weak until linked, if not linked, the symbol becomes null; instead of being an undefined reference.; ``linkonce_odr``, ``weak_odr``; Some languages allow differing globals to be merged, such as two; functions with different semantics. Other languages, such as; ``C++``, ensure that only equivalent globals are ever merged (the; ""one definition rule"" --- ""ODR""). Such languages can use the; ``linkonce_odr`` and ``weak_odr`` l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:10230,Modifiability,variab,variables,10230,"onger; definition. To enable inlining and other optimizations, use; ""``linkonce_odr``"" linkage.; ``weak``; ""``weak``"" linkage has the same merging semantics as ``linkonce``; linkage, except that unreferenced globals with ``weak`` linkage may; not be discarded. This is used for globals that are declared ""weak""; in C source code.; ``common``; ""``common``"" linkage is most similar to ""``weak``"" linkage, but they; are used for tentative definitions in C, such as ""``int X;``"" at; global scope. Symbols with ""``common``"" linkage are merged in the; same way as ``weak symbols``, and they may not be deleted if; unreferenced. ``common`` symbols may not have an explicit section,; must have a zero initializer, and may not be marked; ':ref:`constant <globalvars>`'. Functions and aliases may not have; common linkage. .. _linkage_appending:. ``appending``; ""``appending``"" linkage may only be applied to global variables of; pointer to array type. When two global variables with appending; linkage are linked together, the two global arrays are appended; together. This is the LLVM, typesafe, equivalent of having the; system linker append together ""sections"" with identical names when; .o files are linked. Unfortunately this doesn't correspond to any feature in .o files, so it; can only be used for variables like ``llvm.global_ctors`` which llvm; interprets specially. ``extern_weak``; The semantics of this linkage follow the ELF object file model: the; symbol is weak until linked, if not linked, the symbol becomes null; instead of being an undefined reference.; ``linkonce_odr``, ``weak_odr``; Some languages allow differing globals to be merged, such as two; functions with different semantics. Other languages, such as; ``C++``, ensure that only equivalent globals are ever merged (the; ""one definition rule"" --- ""ODR""). Such languages can use the; ``linkonce_odr`` and ``weak_odr`` linkage types to indicate that the; global will only be merged with equivalent globals. These linkage; types are ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:10568,Modifiability,variab,variables,10568,"t are declared ""weak""; in C source code.; ``common``; ""``common``"" linkage is most similar to ""``weak``"" linkage, but they; are used for tentative definitions in C, such as ""``int X;``"" at; global scope. Symbols with ""``common``"" linkage are merged in the; same way as ``weak symbols``, and they may not be deleted if; unreferenced. ``common`` symbols may not have an explicit section,; must have a zero initializer, and may not be marked; ':ref:`constant <globalvars>`'. Functions and aliases may not have; common linkage. .. _linkage_appending:. ``appending``; ""``appending``"" linkage may only be applied to global variables of; pointer to array type. When two global variables with appending; linkage are linked together, the two global arrays are appended; together. This is the LLVM, typesafe, equivalent of having the; system linker append together ""sections"" with identical names when; .o files are linked. Unfortunately this doesn't correspond to any feature in .o files, so it; can only be used for variables like ``llvm.global_ctors`` which llvm; interprets specially. ``extern_weak``; The semantics of this linkage follow the ELF object file model: the; symbol is weak until linked, if not linked, the symbol becomes null; instead of being an undefined reference.; ``linkonce_odr``, ``weak_odr``; Some languages allow differing globals to be merged, such as two; functions with different semantics. Other languages, such as; ``C++``, ensure that only equivalent globals are ever merged (the; ""one definition rule"" --- ""ODR""). Such languages can use the; ``linkonce_odr`` and ``weak_odr`` linkage types to indicate that the; global will only be merged with equivalent globals. These linkage; types are otherwise the same as their non-``odr`` versions.; ``external``; If none of the above identifiers are used, the global is externally; visible, meaning that it participates in linkage and can be used to; resolve external symbol references. It is illegal for a global variable or function *d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:11538,Modifiability,variab,variable,11538,"s like ``llvm.global_ctors`` which llvm; interprets specially. ``extern_weak``; The semantics of this linkage follow the ELF object file model: the; symbol is weak until linked, if not linked, the symbol becomes null; instead of being an undefined reference.; ``linkonce_odr``, ``weak_odr``; Some languages allow differing globals to be merged, such as two; functions with different semantics. Other languages, such as; ``C++``, ensure that only equivalent globals are ever merged (the; ""one definition rule"" --- ""ODR""). Such languages can use the; ``linkonce_odr`` and ``weak_odr`` linkage types to indicate that the; global will only be merged with equivalent globals. These linkage; types are otherwise the same as their non-``odr`` versions.; ``external``; If none of the above identifiers are used, the global is externally; visible, meaning that it participates in linkage and can be used to; resolve external symbol references. It is illegal for a global variable or function *declaration* to have any; linkage type other than ``external`` or ``extern_weak``. .. _callingconv:. Calling Conventions; -------------------. LLVM :ref:`functions <functionstructure>`, :ref:`calls <i_call>` and; :ref:`invokes <i_invoke>` can all have an optional calling convention; specified for the call. The calling convention of any pair of dynamic; caller/callee must match, or the behavior of the program is undefined.; The following calling conventions are supported by LLVM, and more may be; added in the future:. ""``ccc``"" - The C calling convention; This calling convention (the default if no other calling convention; is specified) matches the target C calling conventions. This calling; convention supports varargs function calls and tolerates some; mismatch in the declared prototype and implemented declaration of; the function (as does normal C).; ""``fastcc``"" - The fast calling convention; This calling convention attempts to make calls as fast as possible; (e.g. by passing things in registers). T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:20198,Modifiability,variab,variables,20198," the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch register. Furthermore it also preserves; all floating-point registers (XMMs/YMMs). - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD -; floating point registers. The idea behind this convention is to support calls to runtime functions; that don't need to call out to any other functions. This calling convention, like the `PreserveMost` calling convention, will be; used by a future version of the ObjectiveC runtime and should be considered; experimental at this time.; ""``cxx_fast_tlscc``"" - The `CXX_FAST_TLS` calling convention for access functions; Clang generates an access function to access C++-style TLS. The access; function generally has an entry block, an exit block and an initialization; block that is run at the first time. The entry and exit blocks can access; a few TLS IR variables, each access will be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc,; except for an additional guarantee that tail calls will be produced; whenever possible. `Tail calls can only be optimized",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:24602,Modifiability,variab,variable,24602,"t visibility corresponds to ""external; linkage"" in the language.; ""``hidden``"" - Hidden style; Two declarations of an object with hidden visibility refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:24797,Modifiability,variab,variable,24797,"ity refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25082,Modifiability,variab,variable,25082,"ected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25625,Modifiability,variab,variable,25625,"crosoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without li",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25769,Modifiability,variab,variable,25769,"crosoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without li",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25817,Modifiability,variab,variables,25817,"le name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25894,Modifiability,variab,variables,25894," pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25980,Modifiability,variab,variables,25980,"` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifie",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:26058,Modifiability,variab,variables,26058,"n or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:26915,Modifiability,variab,variables,26915,"ary.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:27155,Modifiability,variab,variable,27155,"ic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:27293,Modifiability,variab,variable,27293,"er/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer types are a work in progress, and they should be; considered experimental at this time. LLVM IR optionally allows the frontend to denote poi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30394,Modifiability,variab,variables,30394,"zer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30488,Modifiability,variab,variable,30488,"s to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final de",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30537,Modifiability,variab,variables,30537,"neral, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly be",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30650,Modifiability,variab,variables,30650,"r would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; op",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30730,Modifiability,variab,variable,30730,"ce the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30954,Modifiability,variab,variable,30954,"ch as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always defin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31033,Modifiability,variab,variable,31033,"gnment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31125,Modifiability,variab,variable,31125,"gnment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31291,Modifiability,variab,variables,31291,"balvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31393,Modifiability,variab,variable,31393,"balvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31451,Modifiability,variab,variables,31451,"of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31814,Modifiability,variab,variables,31814,"optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31926,Modifiability,variab,variables,31926,"ing behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32098,Modifiability,variab,variables,32098,"modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; suppor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32593,Modifiability,variab,variable,32593,"uires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit g",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32820,Modifiability,variab,variable,32820,"nits that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values ar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:33812,Modifiability,extend,extended,33812,"s zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:33990,Modifiability,variab,variables,33990,"t, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break thi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34137,Modifiability,variab,variables,34137," an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34281,Modifiability,variab,variables,34281,"hat make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34342,Modifiability,variab,variable,34342,"on to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:35038,Modifiability,variab,variables,35038,"tart of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in struc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:35204,Modifiability,variab,variables,35204," outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalabl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:35265,Modifiability,variab,variable,35265,"lobal, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the sa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:37366,Modifiability,variab,variable,37366,"of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the same type while ``{<vscale x 2 x i32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an initializer, section, and alignment:. .. code-block:: llvm. @G = addrspace(5) constant float 1.0, section ""foo"", align 4. The following example just declares a global variable. .. code-block:: llvm. @G = external global i32. The following example defines a global variable with the; ``large`` code model:. .. code-block:: llvm. @G = internal global i32 0, code_model ""large"". The following example defines a thread-local global with the; ``initialexec`` TLS model:. .. code-block:: llvm. @G = thread_local(initialexec) global i32 0, align 4. .. _functionstructure:. Functions; ---------. LLVM function definitions consist of the ""``define``"" keyword, an; optional :ref:`linkage type <linkage>`, an optional :ref:`runtime preemption; specifier <runtime_preemption_model>`, an optional :ref:`visibility; style <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`calling convention <callingconv>`,; an optional ``unnamed_addr`` attribute, a return type, an optional; :ref:`parameter attribute <paramattrs>` for the return type, a function; name, a (possibly empty) argument list (each with optional :ref:`parameter",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:37463,Modifiability,variab,variable,37463,"32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an initializer, section, and alignment:. .. code-block:: llvm. @G = addrspace(5) constant float 1.0, section ""foo"", align 4. The following example just declares a global variable. .. code-block:: llvm. @G = external global i32. The following example defines a global variable with the; ``large`` code model:. .. code-block:: llvm. @G = internal global i32 0, code_model ""large"". The following example defines a thread-local global with the; ``initialexec`` TLS model:. .. code-block:: llvm. @G = thread_local(initialexec) global i32 0, align 4. .. _functionstructure:. Functions; ---------. LLVM function definitions consist of the ""``define``"" keyword, an; optional :ref:`linkage type <linkage>`, an optional :ref:`runtime preemption; specifier <runtime_preemption_model>`, an optional :ref:`visibility; style <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`calling convention <callingconv>`,; an optional ``unnamed_addr`` attribute, a return type, an optional; :ref:`parameter attribute <paramattrs>` for the return type, a function; name, a (possibly empty) argument list (each with optional :ref:`parameter; attributes <paramattrs>`), optional :ref:`function attributes <fnattrs>`,; an optional address space, an optional ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:42435,Modifiability,variab,variables,42435,"es <i_phi>`. LLVM allows an explicit section to be specified for functions. If the; target supports it, it will emit functions to the section specified.; Additionally, the function can be placed in a COMDAT. An explicit alignment may be specified for a function. If not present,; or if the alignment is set to zero, the alignment of the function is set; by the target to whatever it feels convenient. If an explicit alignment; is specified, the function is forced to have at least that much; alignment. All alignments must be a power of 2. If the ``unnamed_addr`` attribute is given, the address is known to not; be significant and two identical functions can be merged. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. If an explicit address space is not given, it will default to the program; address space from the :ref:`datalayout string<langref_datalayout>`. .. _langref_aliases:. Aliases; -------. Aliases, unlike function or variables, don't create any new data. They; are just a new symbol and metadata for an existing position. Aliases have a name and an aliasee that is either a global value or a; constant expression. Aliases may have an optional :ref:`linkage type <linkage>`, an optional; :ref:`runtime preemption specifier <runtime_preemption_model>`, an optional; :ref:`visibility style <visibility>`, an optional :ref:`DLL storage class; <dllstorageclass>` and an optional :ref:`tls model <tls_model>`. Syntax::. @<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* @<Aliasee>; [, partition ""name""]. The linkage must be one of ``private``, ``internal``, ``linkonce``, ``weak``,; ``linkonce_odr``, ``weak_odr``, ``external``, ``available_externally``. Note; that some system linkers might not correctly handle dropping a weak symbol that; is aliased. Aliases that are not ``unnamed_addr`` are guaranteed to have the sam",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:48657,Modifiability,variab,variables,48657,"s to it, must have the same name as the COMDAT group when; targeting COFF.; The contents and size of this object may be used during link-time to determine; which COMDAT groups get selected depending on the selection kind.; Because the name of the object must match the name of the COMDAT group, the; linkage of the global object must not be local; local symbols can get renamed; if a collision occurs in the symbol table. The combined use of COMDATS and section attributes may yield surprising results.; For example:. .. code-block:: llvm. $foo = comdat any; $bar = comdat any; @g1 = global i32 42, section ""sec"", comdat($foo); @g2 = global i32 42, section ""sec"", comdat($bar). From the object file perspective, this requires the creation of two sections; with the same name. This is necessary because both globals belong to different; COMDAT groups and COMDATs, at the object file level, are represented by; sections. Note that certain IR constructs like global variables and functions may; create COMDATs in the object file in addition to any which are specified using; COMDAT IR. This arises when the code generator is configured to emit globals; in individual sections (e.g. when `-data-sections` or `-function-sections`; is supplied to `llc`). .. _namedmetadatastructure:. Named Metadata; --------------. Named metadata is a collection of metadata. :ref:`Metadata; nodes <metadata>` (but not metadata strings) are the only valid; operands for a named metadata. #. Named metadata are represented as a string of characters with the; metadata prefix. The rules for metadata names are the same as for; identifiers, but quoted names are not allowed. ``""\xx""`` type escapes; are still valid, which allows any character to be part of a name. Syntax::. ; Some unnamed metadata nodes, which are referenced by the named metadata.; !0 = !{!""zero""}; !1 = !{!""one""}; !2 = !{!""two""}; ; A named metadata.; !name = !{!0, !1, !2}. .. _paramattrs:. Parameter Attributes; --------------------. The return type and ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:48816,Modifiability,config,configured,48816,"ng link-time to determine; which COMDAT groups get selected depending on the selection kind.; Because the name of the object must match the name of the COMDAT group, the; linkage of the global object must not be local; local symbols can get renamed; if a collision occurs in the symbol table. The combined use of COMDATS and section attributes may yield surprising results.; For example:. .. code-block:: llvm. $foo = comdat any; $bar = comdat any; @g1 = global i32 42, section ""sec"", comdat($foo); @g2 = global i32 42, section ""sec"", comdat($bar). From the object file perspective, this requires the creation of two sections; with the same name. This is necessary because both globals belong to different; COMDAT groups and COMDATs, at the object file level, are represented by; sections. Note that certain IR constructs like global variables and functions may; create COMDATs in the object file in addition to any which are specified using; COMDAT IR. This arises when the code generator is configured to emit globals; in individual sections (e.g. when `-data-sections` or `-function-sections`; is supplied to `llc`). .. _namedmetadatastructure:. Named Metadata; --------------. Named metadata is a collection of metadata. :ref:`Metadata; nodes <metadata>` (but not metadata strings) are the only valid; operands for a named metadata. #. Named metadata are represented as a string of characters with the; metadata prefix. The rules for metadata names are the same as for; identifiers, but quoted names are not allowed. ``""\xx""`` type escapes; are still valid, which allows any character to be part of a name. Syntax::. ; Some unnamed metadata nodes, which are referenced by the named metadata.; !0 = !{!""zero""}; !1 = !{!""one""}; !2 = !{!""two""}; ; A named metadata.; !name = !{!0, !1, !2}. .. _paramattrs:. Parameter Attributes; --------------------. The return type and each parameter of a function type may have a set of; *parameter attributes* associated with them. Parameter attributes are; used ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:50659,Modifiability,extend,extended,50659,"----. The return type and each parameter of a function type may have a set of; *parameter attributes* associated with them. Parameter attributes are; used to communicate additional information about the result or; parameters of a function. Parameter attributes are considered to be part; of the function, not of the function type, so functions with different; parameter attributes can have the same function type. Parameter attributes are simple keywords that follow the type specified.; If multiple parameter attributes are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a special target-dependent fashion while emitting code for; a function call or return (usually, by putting it in a register as; opposed to memory, though some targets use it to distinguish between; two different kinds of registers). Use of this attribute is; target-specific.; ``byval(<ty>)``; This indicates that the pointer parameter should really be passed by; value to the function. The attribute implies that a hidden copy of; the pointee is made between the caller and the callee, so the callee; is unable to modify the value in the caller. This ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:50882,Modifiability,extend,extended,50882,"on. Parameter attributes are considered to be part; of the function, not of the function type, so functions with different; parameter attributes can have the same function type. Parameter attributes are simple keywords that follow the type specified.; If multiple parameter attributes are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a special target-dependent fashion while emitting code for; a function call or return (usually, by putting it in a register as; opposed to memory, though some targets use it to distinguish between; two different kinds of registers). Use of this attribute is; target-specific.; ``byval(<ty>)``; This indicates that the pointer parameter should really be passed by; value to the function. The attribute implies that a hidden copy of; the pointee is made between the caller and the callee, so the callee; is unable to modify the value in the caller. This attribute is only; valid on LLVM pointer arguments. It is generally used to pass; structs and arrays by value, but is also valid on pointers to; scalars. The copy is considered to belong to the caller not the; callee (for example, ``read",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:63003,Modifiability,extend,extended,63003,"s ``dereferenceable(<n>)``; implies ``noundef``. ``dereferenceable_or_null(<n>)``; This indicates that the parameter or return value isn't both; non-null and non-dereferenceable (up to ``<n>`` bytes) at the same; time. All non-null pointers tagged with; ``dereferenceable_or_null(<n>)`` are ``dereferenceable(<n>)``.; For address space 0 ``dereferenceable_or_null(<n>)`` implies that; a pointer is exactly one of ``dereferenceable(<n>)`` or ``null``,; and in other address spaces ``dereferenceable_or_null(<n>)``; implies that a pointer is at least one of ``dereferenceable(<n>)``; or ``null`` (i.e. it may be both ``null`` and; ``dereferenceable(<n>)``). This attribute may only be applied to; pointer typed parameters. ``swiftself``; This indicates that the parameter is the self/context parameter. This is not; a valid attribute for return values and can only be applied to one; parameter. .. _swiftasync:. ``swiftasync``; This indicates that the parameter is the asynchronous context parameter and; triggers the creation of a target-specific extended frame record to store; this pointer. This is not a valid attribute for return values and can only; be applied to one parameter. ``swifterror``; This attribute is motivated to model and optimize Swift error handling. It; can be applied to a parameter with pointer to pointer type or a; pointer-sized alloca. At the call site, the actual argument that corresponds; to a ``swifterror`` parameter has to come from a ``swifterror`` alloca or; the ``swifterror`` parameter of the caller. A ``swifterror`` value (either; the parameter or the alloca) can only be loaded and stored from, or used as; a ``swifterror`` argument. This is not a valid attribute for return values; and can only be applied to one parameter. These constraints allow the calling convention to optimize access to; ``swifterror`` variables by associating them with a specific register at; call boundaries rather than placing them in memory. Since this does change; the calling conv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:63806,Modifiability,variab,variables,63806,"y be applied to one; parameter. .. _swiftasync:. ``swiftasync``; This indicates that the parameter is the asynchronous context parameter and; triggers the creation of a target-specific extended frame record to store; this pointer. This is not a valid attribute for return values and can only; be applied to one parameter. ``swifterror``; This attribute is motivated to model and optimize Swift error handling. It; can be applied to a parameter with pointer to pointer type or a; pointer-sized alloca. At the call site, the actual argument that corresponds; to a ``swifterror`` parameter has to come from a ``swifterror`` alloca or; the ``swifterror`` parameter of the caller. A ``swifterror`` value (either; the parameter or the alloca) can only be loaded and stored from, or used as; a ``swifterror`` argument. This is not a valid attribute for return values; and can only be applied to one parameter. These constraints allow the calling convention to optimize access to; ``swifterror`` variables by associating them with a specific register at; call boundaries rather than placing them in memory. Since this does change; the calling convention, a function which uses the ``swifterror`` attribute; on a parameter is not ABI-compatible with one which does not. These constraints also allow LLVM to assume that a ``swifterror`` argument; does not alias any other memory visible within a function and that a; ``swifterror`` alloca passed as an argument does not escape. ``immarg``; This indicates the parameter is required to be an immediate; value. This must be a trivial immediate integer or floating-point; constant. Undef or constant expressions are not valid. This is; only valid on intrinsic declarations and cannot be applied to a; call site or arbitrary function. ``noundef``; This attribute applies to parameters and return values. If the value; representation contains any undefined or poison bits, the behavior is; undefined. Note that this does not refer to padding introduced by the; type'",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:72078,Modifiability,plugin,plugins,72078,"in; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the pr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:73374,Modifiability,variab,variable,73374,"rate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the prefix data. For instance, take the example of a function annotated; with a single ``i32``,. .. code-block:: llvm. define void @f() prefix i32 123 { ... }. The prefix data can be referenced as,. .. code-block:: llvm. %a = getelementptr inbounds i32, ptr @f, i32 -1; %b = load i32, ptr %a. Prefix data is laid out as if it were an initializer for a global variable; of the prefix data's type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular format. Specifically, it must begin with a sequence of; bytes which decode to a sequence of m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95200,Modifiability,variab,variable,95200," function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the funct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:102831,Modifiability,variab,variables,102831,"will cause the caller to gain the attribute. This is intended; to provide a maximally conservative model where the code in a function; annotated with this attribute will always (even after inlining) end up; hardened.; ``speculatable``; This function attribute indicates that the function does not have any; effects besides calculating its result and does not have undefined behavior.; Note that ``speculatable`` is not enough to conclude that along any; particular execution path the number of calls to this function will not be; externally observable. This attribute is only valid on functions; and declarations, not on individual call sites. If a function is; incorrectly marked as speculatable and really does exhibit; undefined behavior, the undefined behavior may be observed even; if the call site is dead code. ``ssp``; This attribute indicates that the function should emit a stack; smashing protector. It is in the form of a ""canary"" --- a random value; placed on the stack before the local variables that's checked upon; return from the function to see if it has been overwritten. A; heuristic is used to determine if a function needs stack protectors; or not. The heuristic used will enable protectors for functions with:. - Character arrays larger than ``ssp-buffer-size`` (default 8).; - Aggregates containing character arrays larger than ``ssp-buffer-size``.; - Calls to alloca() with variable sizes or constant sizes greater than; ``ssp-buffer-size``. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard. If a function with an ``ssp`` attribute is inlined into a calling function,; the attribute is not carried over to the calling function. ``sspstrong``; This attribute indicates that the function should emit a stack smashing; protector. This attribute causes a strong heuristic to be used when; determining if a function needs stack protectors. The strong heuristic; will enable protectors f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:103230,Modifiability,variab,variable,103230,"enough to conclude that along any; particular execution path the number of calls to this function will not be; externally observable. This attribute is only valid on functions; and declarations, not on individual call sites. If a function is; incorrectly marked as speculatable and really does exhibit; undefined behavior, the undefined behavior may be observed even; if the call site is dead code. ``ssp``; This attribute indicates that the function should emit a stack; smashing protector. It is in the form of a ""canary"" --- a random value; placed on the stack before the local variables that's checked upon; return from the function to see if it has been overwritten. A; heuristic is used to determine if a function needs stack protectors; or not. The heuristic used will enable protectors for functions with:. - Character arrays larger than ``ssp-buffer-size`` (default 8).; - Aggregates containing character arrays larger than ``ssp-buffer-size``.; - Calls to alloca() with variable sizes or constant sizes greater than; ``ssp-buffer-size``. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard. If a function with an ``ssp`` attribute is inlined into a calling function,; the attribute is not carried over to the calling function. ``sspstrong``; This attribute indicates that the function should emit a stack smashing; protector. This attribute causes a strong heuristic to be used when; determining if a function needs stack protectors. The strong heuristic; will enable protectors for functions with:. - Arrays of any size and type; - Aggregates containing an array of any size and type.; - Calls to alloca().; - Local variables that have had their address taken. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:103968,Modifiability,variab,variables,103968,"tectors; or not. The heuristic used will enable protectors for functions with:. - Character arrays larger than ``ssp-buffer-size`` (default 8).; - Aggregates containing character arrays larger than ``ssp-buffer-size``.; - Calls to alloca() with variable sizes or constant sizes greater than; ``ssp-buffer-size``. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard. If a function with an ``ssp`` attribute is inlined into a calling function,; the attribute is not carried over to the calling function. ``sspstrong``; This attribute indicates that the function should emit a stack smashing; protector. This attribute causes a strong heuristic to be used when; determining if a function needs stack protectors. The strong heuristic; will enable protectors for functions with:. - Arrays of any size and type; - Aggregates containing an array of any size and type.; - Calls to alloca().; - Local variables that have had their address taken. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. This overrides the ``ssp`` function attribute. If a function with an ``sspstrong`` attribute is inlined into a calling; function which has an ``ssp`` attribute, the calling function's attribute; will be upgraded to ``sspstrong``. ``sspreq``; This attribute indicates that the function should *always* emit a stack; smashing protector. This overrides the ``ssp`` and ``sspstrong`` function; attributes. Variables that are identified as requiring a protector will be arranged; on th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108607,Modifiability,variab,variable,108607,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:114992,Modifiability,variab,variable,114992,", Arm and Internal LLVM),; the remaining tokens can have the following values:::. <mask>:= M | N -> mask | no mask. <vlen>:= number -> number of lanes; | x -> VLA (Vector Length Agnostic). <parameters>:= v -> vector; | l | l <number> -> linear; | R | R <number> -> linear with ref modifier; | L | L <number> -> linear with val modifier; | U | U <number> -> linear with uval modifier; | ls <pos> -> runtime linear; | Rs <pos> -> runtime linear with ref modifier; | Ls <pos> -> runtime linear with val modifier; | Us <pos> -> runtime linear with uval modifier; | u -> uniform. <scalar_name>:= name of the scalar function. <vector_redirection>:= optional, custom name of the vector function. ``preallocated(<ty>)``; This attribute is required on calls to ``llvm.call.preallocated.arg``; and cannot be used on any other call. See; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` for more; details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; supp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:115071,Modifiability,variab,variable,115071,"sk. <vlen>:= number -> number of lanes; | x -> VLA (Vector Length Agnostic). <parameters>:= v -> vector; | l | l <number> -> linear; | R | R <number> -> linear with ref modifier; | L | L <number> -> linear with val modifier; | U | U <number> -> linear with uval modifier; | ls <pos> -> runtime linear; | Rs <pos> -> runtime linear with ref modifier; | Ls <pos> -> runtime linear with val modifier; | Us <pos> -> runtime linear with uval modifier; | u -> uniform. <scalar_name>:= name of the scalar function. <vector_redirection>:= optional, custom name of the vector function. ``preallocated(<ty>)``; This attribute is required on calls to ``llvm.call.preallocated.arg``; and cannot be used on any other call. See; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` for more; details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the ass",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:115207,Modifiability,variab,variable,115207,"| U <number> -> linear with uval modifier; | ls <pos> -> runtime linear; | Rs <pos> -> runtime linear with ref modifier; | Ls <pos> -> runtime linear with val modifier; | Us <pos> -> runtime linear with uval modifier; | u -> uniform. <scalar_name>:= name of the scalar function. <vector_redirection>:= optional, custom name of the vector function. ``preallocated(<ty>)``; This attribute is required on calls to ``llvm.call.preallocated.arg``; and cannot be used on any other call. See; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` for more; details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the glob",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:115529,Modifiability,variab,variable,115529," of the vector function. ``preallocated(<ty>)``; This attribute is required on calls to ``llvm.call.preallocated.arg``; and cannot be used on any other call. See; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` for more; details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dy",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:115849,Modifiability,variab,variable,115849,"details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:116589,Modifiability,variab,variable,116589,"on applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; C++ rules. .. _opbundles:. Operand Bundles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are concep",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:116672,Modifiability,variab,variable,116672,"; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; C++ rules. .. _opbundles:. Operand Bundles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are conceptually a part of the ``call`` (or ``invoke``), not the; callee being dispatched to. Operand ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:116799,Modifiability,variab,variables,116799,"attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; C++ rules. .. _opbundles:. Operand Bundles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are conceptually a part of the ``call`` (or ``invoke``), not the; callee being dispatched to. Operand bundles are a generic mechanism intended to support; runtime-introspection-like functionality for managed languages. While; the exact ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:131857,Modifiability,variab,variables,131857,"`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:132579,Modifiability,variab,variables,132579,"he bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (e.g. in; LLVM passes). .. _alloca_addrspace:. ``A<address space>``; Specifies the address space of objects created by '``alloca``'.; Defaults to the default address space of 0.; ``p[n]:<size>:<abi>[:<pref>][:<idx>]``; This specifies the *size* of a pointer and its ``<abi>`` and; ``<pref>``\erred alignments for address space ``n``. ``<pref>`` is optional; and defaults to ``<abi>``. The fourth parameter ``<idx>`` is the size of the; index that used for address calculation, which must be less than or equal; to the pointer size. If not; specified, the default index size is equal to the pointer size. All sizes; are in bits. The address space, ``n`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:132677,Modifiability,variab,variable,132677,"fies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (e.g. in; LLVM passes). .. _alloca_addrspace:. ``A<address space>``; Specifies the address space of objects created by '``alloca``'.; Defaults to the default address space of 0.; ``p[n]:<size>:<abi>[:<pref>][:<idx>]``; This specifies the *size* of a pointer and its ``<abi>`` and; ``<pref>``\erred alignments for address space ``n``. ``<pref>`` is optional; and defaults to ``<abi>``. The fourth parameter ``<idx>`` is the size of the; index that used for address calculation, which must be less than or equal; to the pointer size. If not; specified, the default index size is equal to the pointer size. All sizes; are in bits. The address space, ``n``, is optional, and if not specified,; denotes the default address space 0. The value of ``n`` must be; in the range [1,2^24).; ``i<size>:<abi>[:<pref>]``; This specifies the alignment for an integer type of a given bit; ``<size>``. The value ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140314,Modifiability,variab,variable,140314,"d to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifest",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:141740,Modifiability,variab,variable,141740,"nd; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:141794,Modifiability,variab,variable,141794,"nd; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:153247,Modifiability,variab,variables,153247,". Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition to the guarantees of ``unordered``, there is a single; total order for modifications by ``monotonic`` operations on each; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:166385,Modifiability,variab,variable,166385,"d on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arguments. Variable; argument functions can access their arguments with the :ref:`variable argument; handling intrinsic <int_varargs>` functions. '``<returntype>``' is any type; except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`. :Examples:. +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (i32)`` | function taking an ``i32``, returning an ``i32`` |; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (ptr, ...)`` | A vararg function that takes at least one :ref:`pointer <t_pointer>` argument and returns an integer. This is the signature for ``printf`` in LLVM. |; +---------------------------------+---------------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:166486,Modifiability,variab,variable,166486,"e; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arguments. Variable; argument functions can access their arguments with the :ref:`variable argument; handling intrinsic <int_varargs>` functions. '``<returntype>``' is any type; except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`. :Examples:. +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (i32)`` | function taking an ``i32``, returning an ``i32`` |; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (ptr, ...)`` | A vararg function that takes at least one :ref:`pointer <t_pointer>` argument and returns an integer. This is the signature for ``printf`` in LLVM. |; +---------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:173854,Modifiability,variab,variable,173854,"d by the target. The only constants that target extension types may have are ``zeroinitializer``,; ``undef``, and ``poison``. Other possible values for target extension types may; arise from target-specific intrinsics and functions. These types cannot be converted to other types. As such, it is not legal to use; them in :ref:`bitcast <i_bitcast>` instructions (as a source or target type),; nor is it legal to use them in :ref:`ptrtoint <i_ptrtoint>` or; :ref:`inttoptr <i_inttoptr>` instructions. Similarly, they are not legal to use; in an :ref:`icmp <i_icmp>` instruction. Target extension types have a name and optional type or integer parameters. The; meanings of name and parameters are defined by the target. When being defined in; LLVM IR, all of the type parameters must precede all of the integer parameters. Specific target extension types are registered with LLVM as having specific; properties. These properties can be used to restrict the type from appearing in; certain contexts, such as being the type of a global variable or having a; ``zeroinitializer`` constant be valid. A complete list of type properties may be; found in the documentation for ``llvm::TargetExtType::Property`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1TargetExtType.html>`_). :Syntax:. .. code-block:: llvm. target(""label""); target(""label"", void); target(""label"", void, i32); target(""label"", 0, 1, 2); target(""label"", void, i32, 0, 1, 2). .. _t_vector:. Vector Type; """""""""""""""""""""". :Overview:. A vector type is a simple derived type that represents a vector of; elements. Vector types are used when multiple primitive data are; operated in parallel using a single instruction (SIMD). A vector type; requires a size (number of elements), an underlying primitive data type,; and a scalable property to represent vectors where the exact hardware; vector length is unknown at compile time. Vector types are considered; :ref:`first class <t_firstclass>`. :Memory Layout:. In general vector elements are laid o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:180978,Modifiability,variab,variable,180978,"x i8]`` | Array of 4 8-bit integer values. |; +------------------+--------------------------------------+. Here are some examples of multidimensional arrays:. +-----------------------------+----------------------------------------------------------+; | ``[3 x [4 x i32]]`` | 3x4 array of 32-bit integer values. |; +-----------------------------+----------------------------------------------------------+; | ``[12 x [10 x float]]`` | 12x10 array of single precision floating-point values. |; +-----------------------------+----------------------------------------------------------+; | ``[2 x [3 x [4 x i16]]]`` | 2x3x4 array of 16-bit integer values. |; +-----------------------------+----------------------------------------------------------+. There is no restriction on indexing beyond the end of the array implied; by a static type (though there are restrictions on indexing beyond the; bounds of an allocated object in some cases). This means that; single-dimension 'variable sized array' addressing can be implemented in; LLVM with a zero length array type. An implementation of 'pascal style; arrays' in LLVM could use the type ""``{ i32, [0 x float]}``"", for; example. .. _t_struct:. Structure Type; """""""""""""""""""""""""""". :Overview:. The structure type is used to represent a collection of data members; together in memory. The elements of a structure may be any type that has; a size. Structures in memory are accessed using '``load``' and '``store``' by; getting a pointer to a field with the '``getelementptr``' instruction.; Structures in registers are accessed using the '``extractvalue``' and; '``insertvalue``' instructions. Structures may optionally be ""packed"" structures, which indicate that; the alignment of the struct is one byte, and that there is no padding; between the elements. In non-packed structs, padding between field types; is inserted as defined by the DataLayout string in the module, which is; required to match what the underlying code generator expects. Structures can e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:184916,Modifiability,extend,extended,184916," structure. They can be named (``%X``) or; unnamed (``%52``). :Syntax:. ::. %X = type opaque; %52 = type opaque. :Examples:. +--------------+-------------------+; | ``opaque`` | An opaque type. |; +--------------+-------------------+. .. _constants:. Constants; =========. LLVM has several different basic types of constants. This section; describes them all and their syntax. Simple Constants; ----------------. **Boolean constants**; The two strings '``true``' and '``false``' are both valid constants; of the ``i1`` type.; **Integer constants**; Standard integers (such as '4') are constants of the :ref:`integer; <t_integer>` type. They can be either decimal or; hexadecimal. Decimal integers can be prefixed with - to represent; negative integers, e.g. '``-1234``'. Hexadecimal integers must be; prefixed with either u or s to indicate whether they are unsigned; or signed respectively. e.g '``u0x8000``' gives 32768, whilst; '``s0x8000``' gives -32768. Note that hexadecimal integers are sign extended from the number; of active bits, i.e. the bit width minus the number of leading; zeros. So '``s0x0001``' of type '``i16``' will be -1, not 1.; **Floating-point constants**; Floating-point constants use standard decimal notation (e.g.; 123.421), exponential notation (e.g. 1.23421e+2), or a more precise; hexadecimal notation (see below). The assembler requires the exact; decimal value of a floating-point constant. For example, the; assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating; decimal in binary. Floating-point constants must have a; :ref:`floating-point <t_floating>` type.; **Null pointer constants**; The identifier '``null``' is recognized as a null pointer constant; and must be of :ref:`pointer type <t_pointer>`.; **Token constants**; The identifier '``none``' is recognized as an empty token constant; and must be of :ref:`token type <t_token>`. The one non-intuitive notation for constants is the hexadecimal form of; floating-point constants. For example, the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:190265,Modifiability,variab,variables,190265," must have ::ref:`vector type <t_vector>` with an; element type that matches the ``splat`` operand.; **Zero initialization**; The string '``zeroinitializer``' can be used to zero initialize a; value to zero of *any* type, including scalar and; :ref:`aggregate <t_aggregate>` types. This is often used to avoid; having to print large zero initializers (e.g. for large arrays) and; is always exactly equivalent to using explicit zero initializers.; **Metadata node**; A metadata node is a constant tuple without types. For example:; ""``!{!0, !{!2, !0}, !""test""}``"". Metadata can reference constant values,; for example: ""``!{!0, i32 0, ptr @global, ptr @function, !""str""}``"".; Unlike other typed constants that are meant to be interpreted as part of; the instruction stream, metadata is a place to attach additional; information such as debug info. Global Variable and Function Addresses; --------------------------------------. The addresses of :ref:`global variables <globalvars>` and; :ref:`functions <functionstructure>` are always implicitly valid; (link-time) constants. These constants are explicitly referenced when; the :ref:`identifier for the global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i32 17; @Y = global i32 42; @Z = global [2 x ptr] [ ptr @X, ptr @Y ]. .. _undefvalues:. Undefined Values; ----------------. The string '``undef``' can be used anywhere a constant is expected, and; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Und",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:194014,Modifiability,variab,variable,194014,"s can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live range*. Instead, the value is logically; read from arbitrary registers that happen to be around when needed, so; the value is not necessarily consistent over time. In fact, ``%A`` and; ``%C`` need to have the same semantics or the core LLVM ""replace all; uses with"" concept would not hold. To ensure all uses of a given register observe the same value (even if; '``undef``'), the :ref:`freeze instruction <i_freeze>` can be used. .. code-block:: llvm. %A = sdiv undef, %X; %B = sdiv %X, undef; Safe:; %A = 0; b: unreachable. These examples show the crucial difference between an *undefined value*; and *undefined behavior*. An undefined value (like '``undef``') is; allowed to have an arbitrary bit-pattern. This means that the ``%A``; operation can be constant folded to '``0``', because the '``undef``'; could be zero, and zero divided by any value is zer",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:194106,Modifiability,variab,variable,194106,"``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live range*. Instead, the value is logically; read from arbitrary registers that happen to be around when needed, so; the value is not necessarily consistent over time. In fact, ``%A`` and; ``%C`` need to have the same semantics or the core LLVM ""replace all; uses with"" concept would not hold. To ensure all uses of a given register observe the same value (even if; '``undef``'), the :ref:`freeze instruction <i_freeze>` can be used. .. code-block:: llvm. %A = sdiv undef, %X; %B = sdiv %X, undef; Safe:; %A = 0; b: unreachable. These examples show the crucial difference between an *undefined value*; and *undefined behavior*. An undefined value (like '``undef``') is; allowed to have an arbitrary bit-pattern. This means that the ``%A``; operation can be constant folded to '``0``', because the '``undef``'; could be zero, and zero divided by any value is zero.; However, in the second example, we can make a more aggressive; assumption: because the ``undef`` is allowed to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:204674,Modifiability,extend,extended,204674,"trtoint>` on constants.; ``inttoptr (CST to TYPE)``; Perform the :ref:`inttoptr operation <i_inttoptr>` on constants.; This one is *really* dangerous!; ``bitcast (CST to TYPE)``; Convert a constant, CST, to another TYPE.; The constraints of the operands are the same as those for the; :ref:`bitcast instruction <i_bitcast>`.; ``addrspacecast (CST to TYPE)``; Convert a constant pointer or constant vector of pointer, CST, to another; TYPE in a different address space. The constraints of the operands are the; same as those for the :ref:`addrspacecast instruction <i_addrspacecast>`.; ``getelementptr (TY, CSTPTR, IDX0, IDX1, ...)``, ``getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)``; Perform the :ref:`getelementptr operation <i_getelementptr>` on; constants. As with the :ref:`getelementptr <i_getelementptr>`; instruction, the index list may have one or more indexes, which are; required to make sense for the type of ""pointer to TY"". These indexes; may be implicitly sign-extended or truncated to match the index size; of CSTPTR's address space.; ``icmp COND (VAL1, VAL2)``; Perform the :ref:`icmp operation <i_icmp>` on constants.; ``fcmp COND (VAL1, VAL2)``; Perform the :ref:`fcmp operation <i_fcmp>` on constants.; ``extractelement (VAL, IDX)``; Perform the :ref:`extractelement operation <i_extractelement>` on; constants.; ``insertelement (VAL, ELT, IDX)``; Perform the :ref:`insertelement operation <i_insertelement>` on; constants.; ``shufflevector (VEC1, VEC2, IDXMASK)``; Perform the :ref:`shufflevector operation <i_shufflevector>` on; constants.; ``add (LHS, RHS)``; Perform an addition on constants.; ``sub (LHS, RHS)``; Perform a subtraction on constants.; ``mul (LHS, RHS)``; Perform a multiplication on constants.; ``shl (LHS, RHS)``; Perform a left shift on constants.; ``xor (LHS, RHS)``; Perform a bitwise xor on constants. Other Values; ============. .. _inlineasmexprs:. Inline Assembler Expressions; ----------------------------. LLVM supports inline assembler expres",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:216294,Modifiability,variab,variable,216294,"u're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). This is most typically used for memory constraint, e.g. ""``=*m``"", to pass the; address of a variable as a value. It is also possible to use an indirect *register* constraint, but only on output; (e.g. ""``=*r``""). This will cause LLVM to allocate a register for an output; value normally, and then, separately emit a store to the address provided as; input, after the provided inline asm. (It's not clear what value this; functionality provides, compared to writing the store explicitly after the asm; statement, and it can only produce worse code, since it bypasses many; optimization passes. I would recommend not using it.). Call arguments for indirect constraints must have pointer type and must specify; the :ref:`elementtype <attr_elementtype>` attribute to indicate the pointer; element type. Clobber constraints; """""""""""""""""""""""""""""""""""""". A clobber constraint is indicated by a ""``~``"" prefix. A clobber does not; consume an input operand, nor generate an output. Clobbers cannot use any of the; general constraint code letters -- they may use only explicit register; constraints, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:244697,Modifiability,variab,variable,244697,"`distinct`` keyword. For example:. .. code-block:: text. !0 = distinct !{!""test\00"", i32 10}. ``distinct`` nodes are useful when nodes shouldn't be merged based on their; content. They can also occur when transformations cause uniquing collisions; when metadata operands change. A :ref:`named metadata <namedmetadatastructure>` is a collection of; metadata nodes, which can be looked up in the module symbol table. For; example:. .. code-block:: llvm. !foo = !{!4, !3}. Metadata can be used as function arguments. Here the ``llvm.dbg.value``; intrinsic is using three metadata arguments:. .. code-block:: llvm. call void @llvm.dbg.value(metadata !24, metadata !25, metadata !26). Metadata can be attached to an instruction. Here metadata ``!21`` is attached; to the ``add`` instruction using the ``!dbg`` identifier:. .. code-block:: llvm. %indvar.next = add i64 %indvar, 1, !dbg !21. Instructions may not have multiple metadata attachments with the same; identifier. Metadata can also be attached to a function or a global variable. Here metadata; ``!22`` is attached to the ``f1`` and ``f2`` functions, and the globals ``g1``; and ``g2`` using the ``!dbg`` identifier:. .. code-block:: llvm. declare !dbg !22 void @f1(); define void @f2() !dbg !22 {; ret void; }. @g1 = global i32 0, !dbg !22; @g2 = external global i32, !dbg !22. Unlike instructions, global objects (functions and global variables) may have; multiple metadata attachments with the same identifier. A transformation is required to drop any metadata attachment that it; does not know or know it can't preserve. Currently there is an; exception for metadata attachment to globals for ``!func_sanitize``,; ``!type``, ``!absolute_symbol`` and ``!associated`` which can't be; unconditionally dropped unless the global is itself deleted. Metadata attached to a module using named metadata may not be dropped, with; the exception of debug metadata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata n",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:245064,Modifiability,variab,variables,245064,"e symbol table. For; example:. .. code-block:: llvm. !foo = !{!4, !3}. Metadata can be used as function arguments. Here the ``llvm.dbg.value``; intrinsic is using three metadata arguments:. .. code-block:: llvm. call void @llvm.dbg.value(metadata !24, metadata !25, metadata !26). Metadata can be attached to an instruction. Here metadata ``!21`` is attached; to the ``add`` instruction using the ``!dbg`` identifier:. .. code-block:: llvm. %indvar.next = add i64 %indvar, 1, !dbg !21. Instructions may not have multiple metadata attachments with the same; identifier. Metadata can also be attached to a function or a global variable. Here metadata; ``!22`` is attached to the ``f1`` and ``f2`` functions, and the globals ``g1``; and ``g2`` using the ``!dbg`` identifier:. .. code-block:: llvm. declare !dbg !22 void @f1(); define void @f2() !dbg !22 {; ret void; }. @g1 = global i32 0, !dbg !22; @g2 = external global i32, !dbg !22. Unlike instructions, global objects (functions and global variables) may have; multiple metadata attachments with the same identifier. A transformation is required to drop any metadata attachment that it; does not know or know it can't preserve. Currently there is an; exception for metadata attachment to globals for ``!func_sanitize``,; ``!type``, ``!absolute_symbol`` and ``!associated`` which can't be; unconditionally dropped unless the global is itself deleted. Metadata attached to a module using named metadata may not be dropped, with; the exception of debug metadata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata nodes recognized by the; optimizers and code generator is found below. .. _specialized-metadata:. Specialized Metadata Nodes; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Specialized metadata nodes are custom data structures in metadata (as opposed; to generic tuples). Their fields are labelled, and can be specified in any; order. These aren't inherently debug info centric, but currently all the specialized; metada",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:247213,Modifiability,variab,variables,247213,"s:``, ``globals:``, ``imports:`` and ``macros:`` fields are tuples; containing the debug info to be emitted along with the compile unit, regardless; of code optimizations (some nodes are only emitted if there are references to; them from instructions). The ``debugInfoForProfiling:`` field is a boolean; indicating whether or not line-table discriminators are updated to provide; more-accurate debug info for profiling results. .. code-block:: text. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang"",; isOptimized: true, flags: ""-O2"", runtimeVersion: 2,; splitDebugFilename: ""abc.debug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes used in ``scope:`` fields, and are the only valid target; for ``file:`` fields. The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these; fields is present, then the other is required to be present as well. Valid; values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}. .. _DIBasicType:. DIBasicType; """""""""""""""""""""". ``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and; ``float``. ``tag:`` defaults to ``DW_TAG_base_type``. .. code-block:: text. !0 = !DIBasicType(name: ""unsigned char"", size: 8, align: 8,; encoding: DW_ATE_unsigned_char); !1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: ""declty",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:254592,Modifiability,variab,variable,254592,"mber``, ``tag: DW_TAG_inheritance``, or; ``tag: DW_TAG_friend``; or :ref:`subprograms <DISubprogram>` with; ``isDefinition: false``. .. _DISubrange:. DISubrange; """""""""""""""""""". ``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of; :ref:`DICompositeType`. - ``count: -1`` indicates an empty array.; - ``count: !10`` describes the count with a :ref:`DILocalVariable`.; - ``count: !12`` describes the count with a :ref:`DIGlobalVariable`. .. code-block:: text. !0 = !DISubrange(count: 5, lowerBound: 0) ; array counting from 0; !1 = !DISubrange(count: 5, lowerBound: 1) ; array counting from 1; !2 = !DISubrange(count: -1) ; empty array. ; Scopes used in rest of example; !6 = !DIFile(filename: ""vla.c"", directory: ""/path/to/file""); !7 = distinct !DICompileUnit(language: DW_LANG_C99, file: !6); !8 = distinct !DISubprogram(name: ""foo"", scope: !7, file: !6, line: 5). ; Use of local variable as count value; !9 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !10 = !DILocalVariable(name: ""count"", scope: !8, file: !6, line: 42, type: !9); !11 = !DISubrange(count: !10, lowerBound: 0). ; Use of global variable as count value; !12 = !DIGlobalVariable(name: ""count"", scope: !8, file: !6, line: 22, type: !9); !13 = !DISubrange(count: !12, lowerBound: 0). .. _DIEnumerator:. DIEnumerator; """""""""""""""""""""""". ``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type``; variants of :ref:`DICompositeType`. .. code-block:: text. !0 = !DIEnumerator(name: ""SixKind"", value: 7); !1 = !DIEnumerator(name: ""SevenKind"", value: 7); !2 = !DIEnumerator(name: ""NegEightKind"", value: -8). DITemplateTypeParameter; """""""""""""""""""""""""""""""""""""""""""""". ``DITemplateTypeParameter`` nodes represent type parameters to generic source; language constructs. They are used (optionally) in :ref:`DICompositeType` and; :ref:`DISubprogram` ``templateParams:`` fields. .. code-block:: text. !0 = !DITemplateTypeParameter(name: ""Ty"", type: !1). DITemplateValueParameter; """""""""""""""""""""""""""""""""""""""""""""""". ``DIT",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:254826,Modifiability,variab,variable,254826,"e elements for ``DW_TAG_array_type`` variants of; :ref:`DICompositeType`. - ``count: -1`` indicates an empty array.; - ``count: !10`` describes the count with a :ref:`DILocalVariable`.; - ``count: !12`` describes the count with a :ref:`DIGlobalVariable`. .. code-block:: text. !0 = !DISubrange(count: 5, lowerBound: 0) ; array counting from 0; !1 = !DISubrange(count: 5, lowerBound: 1) ; array counting from 1; !2 = !DISubrange(count: -1) ; empty array. ; Scopes used in rest of example; !6 = !DIFile(filename: ""vla.c"", directory: ""/path/to/file""); !7 = distinct !DICompileUnit(language: DW_LANG_C99, file: !6); !8 = distinct !DISubprogram(name: ""foo"", scope: !7, file: !6, line: 5). ; Use of local variable as count value; !9 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !10 = !DILocalVariable(name: ""count"", scope: !8, file: !6, line: 42, type: !9); !11 = !DISubrange(count: !10, lowerBound: 0). ; Use of global variable as count value; !12 = !DIGlobalVariable(name: ""count"", scope: !8, file: !6, line: 22, type: !9); !13 = !DISubrange(count: !12, lowerBound: 0). .. _DIEnumerator:. DIEnumerator; """""""""""""""""""""""". ``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type``; variants of :ref:`DICompositeType`. .. code-block:: text. !0 = !DIEnumerator(name: ""SixKind"", value: 7); !1 = !DIEnumerator(name: ""SevenKind"", value: 7); !2 = !DIEnumerator(name: ""NegEightKind"", value: -8). DITemplateTypeParameter; """""""""""""""""""""""""""""""""""""""""""""". ``DITemplateTypeParameter`` nodes represent type parameters to generic source; language constructs. They are used (optionally) in :ref:`DICompositeType` and; :ref:`DISubprogram` ``templateParams:`` fields. .. code-block:: text. !0 = !DITemplateTypeParameter(name: ""Ty"", type: !1). DITemplateValueParameter; """""""""""""""""""""""""""""""""""""""""""""""". ``DITemplateValueParameter`` nodes represent value parameters to generic source; language constructs. ``tag:`` defaults to ``DW_TAG_template_value_parameter``,; but if specified can also be set to ``DW_TAG",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:256453,Modifiability,variab,variables,256453,"tructs. They are used (optionally) in :ref:`DICompositeType` and; :ref:`DISubprogram` ``templateParams:`` fields. .. code-block:: text. !0 = !DITemplateTypeParameter(name: ""Ty"", type: !1). DITemplateValueParameter; """""""""""""""""""""""""""""""""""""""""""""""". ``DITemplateValueParameter`` nodes represent value parameters to generic source; language constructs. ``tag:`` defaults to ``DW_TAG_template_value_parameter``,; but if specified can also be set to ``DW_TAG_GNU_template_template_param`` or; ``DW_TAG_GNU_template_param_pack``. They are used (optionally) in; :ref:`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields. .. code-block:: text. !0 = !DITemplateValueParameter(name: ""Ty"", type: !1, value: i32 7). DINamespace; """""""""""""""""""""". ``DINamespace`` nodes represent namespaces in the source language. .. code-block:: text. !0 = !DINamespace(name: ""myawesomeproject"", scope: !1, file: !2, line: 7). .. _DIGlobalVariable:. DIGlobalVariable; """""""""""""""""""""""""""""""". ``DIGlobalVariable`` nodes represent global variables in the source language. .. code-block:: text. @foo = global i32, !dbg !0; !0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression()); !1 = !DIGlobalVariable(name: ""foo"", linkageName: ""foo"", scope: !2,; file: !3, line: 7, type: !4, isLocal: true,; isDefinition: false, declaration: !5). DIGlobalVariableExpression; """""""""""""""""""""""""""""""""""""""""""""""""""". ``DIGlobalVariableExpression`` nodes tie a :ref:`DIGlobalVariable` together; with a :ref:`DIExpression`. .. code-block:: text. @lower = global i32, !dbg !0; @upper = global i32, !dbg !1; !0 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32); ); !1 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32); ); !2 = !DIGlobalVariable(name: ""split64"", linkageName: ""split64"", scope: !3,; file: !4, line: 8, type: !5, declaration: !6). All global variable expressions should be referenced by the `globals:` field of; a :ref:`compile unit <DICompileUnit>`. .. _DISubpr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:257327,Modifiability,variab,variable,257327,"GlobalVariable; """""""""""""""""""""""""""""""". ``DIGlobalVariable`` nodes represent global variables in the source language. .. code-block:: text. @foo = global i32, !dbg !0; !0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression()); !1 = !DIGlobalVariable(name: ""foo"", linkageName: ""foo"", scope: !2,; file: !3, line: 7, type: !4, isLocal: true,; isDefinition: false, declaration: !5). DIGlobalVariableExpression; """""""""""""""""""""""""""""""""""""""""""""""""""". ``DIGlobalVariableExpression`` nodes tie a :ref:`DIGlobalVariable` together; with a :ref:`DIExpression`. .. code-block:: text. @lower = global i32, !dbg !0; @upper = global i32, !dbg !1; !0 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32); ); !1 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32); ); !2 = !DIGlobalVariable(name: ""split64"", linkageName: ""split64"", scope: !3,; file: !4, line: 8, type: !5, declaration: !6). All global variable expressions should be referenced by the `globals:` field of; a :ref:`compile unit <DICompileUnit>`. .. _DISubprogram:. DISubprogram; """""""""""""""""""""""". ``DISubprogram`` nodes represent functions from the source language. A distinct; ``DISubprogram`` may be attached to a function definition using ``!dbg``; metadata. A unique ``DISubprogram`` may be attached to a function declaration; used for call site debug info. The ``retainedNodes:`` field is a list of; :ref:`variables <DILocalVariable>` and :ref:`labels <DILabel>` that must be; retained, even if their IR counterparts are optimized out of the IR. The; ``type:`` field must point at an :ref:`DISubroutineType`. .. _DISubprogramDeclaration:. When ``spFlags: DISPFlagDefinition`` is not present, subprograms describe a; declaration in the type tree as opposed to a definition of a function. In this; case, the ``declaration`` field must be empty. If the scope is a composite type; with an ODR ``identifier:`` and that does not set ``flags: DIFwdDecl``, then; the subprogram declaration is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:257797,Modifiability,variab,variables,257797," nodes tie a :ref:`DIGlobalVariable` together; with a :ref:`DIExpression`. .. code-block:: text. @lower = global i32, !dbg !0; @upper = global i32, !dbg !1; !0 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32); ); !1 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32); ); !2 = !DIGlobalVariable(name: ""split64"", linkageName: ""split64"", scope: !3,; file: !4, line: 8, type: !5, declaration: !6). All global variable expressions should be referenced by the `globals:` field of; a :ref:`compile unit <DICompileUnit>`. .. _DISubprogram:. DISubprogram; """""""""""""""""""""""". ``DISubprogram`` nodes represent functions from the source language. A distinct; ``DISubprogram`` may be attached to a function definition using ``!dbg``; metadata. A unique ``DISubprogram`` may be attached to a function declaration; used for call site debug info. The ``retainedNodes:`` field is a list of; :ref:`variables <DILocalVariable>` and :ref:`labels <DILabel>` that must be; retained, even if their IR counterparts are optimized out of the IR. The; ``type:`` field must point at an :ref:`DISubroutineType`. .. _DISubprogramDeclaration:. When ``spFlags: DISPFlagDefinition`` is not present, subprograms describe a; declaration in the type tree as opposed to a definition of a function. In this; case, the ``declaration`` field must be empty. If the scope is a composite type; with an ODR ``identifier:`` and that does not set ``flags: DIFwdDecl``, then; the subprogram declaration is uniqued based only on its ``linkageName:`` and; ``scope:``. .. code-block:: text. define void @_Z3foov() !dbg !0 {; ...; }. !0 = distinct !DISubprogram(name: ""foo"", linkageName: ""_Zfoov"", scope: !1,; file: !2, line: 7, type: !3,; spFlags: DISPFlagDefinition | DISPFlagLocalToUnit,; scopeLine: 8, containingType: !4,; virtuality: DW_VIRTUALITY_pure_virtual,; virtualIndex: 10, flags: DIFlagPrototyped,; isOptimized: true, unit: !5, templateParams: !6,; declaration: !",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:260358,Modifiability,variab,variables,260358,"ILexicalBlockFile:. DILexicalBlockFile; """""""""""""""""""""""""""""""""""". ``DILexicalBlockFile`` nodes are used to discriminate between sections of a; :ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be changed to; indicate textual inclusion, or the ``discriminator:`` field can be used to; discriminate between control flow within a single block in the source language. .. code-block:: text. !0 = !DILexicalBlock(scope: !3, file: !4, line: 7, column: 35); !1 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 0); !2 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 1). .. _DILocation:. DILocation; """""""""""""""""""". ``DILocation`` nodes represent source debug locations. The ``scope:`` field is; mandatory, and points at an :ref:`DILexicalBlockFile`, an; :ref:`DILexicalBlock`, or an :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and eva",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:260445,Modifiability,variab,variable,260445,"tions of a; :ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be changed to; indicate textual inclusion, or the ``discriminator:`` field can be used to; discriminate between control flow within a single block in the source language. .. code-block:: text. !0 = !DILexicalBlock(scope: !3, file: !4, line: 7, column: 35); !1 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 0); !2 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 1). .. _DILocation:. DILocation; """""""""""""""""""". ``DILocation`` nodes represent source debug locations. The ``scope:`` field is; mandatory, and points at an :ref:`DILexicalBlockFile`, an; :ref:`DILexicalBlock`, or an :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:261151,Modifiability,variab,variable,261151,"f:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is desc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:261191,Modifiability,variab,variable,261191,"f:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is desc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:261406,Modifiability,variab,variable,261406,"ILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:262048,Modifiability,variab,variable,262048," in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`` here, respectively) to which the top of the; expression stack is to be converted. Maps into a ``DW_OP_convert`` operation; that references a base type constructed from the supplied values.; - ``DW_OP_LLVM_tag_offset, tag_offset`` specifies that a memory tag should be; optionally applied to the pointer. The memory tag is derived from the; given tag offset in an implementation-defined manner.; - ``DW_OP_swap`` swaps top two stack entries.; - ``DW_OP_xderef`` provides extended dereference mechanism. The entry at the top; of the stack is treated as an address. The second stack entry is treated as an; address space identifier.; - ``DW_OP_stack_value`` marks a constant value.; - ``DW_OP_LLVM",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:262202,Modifiability,variab,variable,262202,"ariable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`` here, respectively) to which the top of the; expression stack is to be converted. Maps into a ``DW_OP_convert`` operation; that references a base type constructed from the supplied values.; - ``DW_OP_LLVM_tag_offset, tag_offset`` specifies that a memory tag should be; optionally applied to the pointer. The memory tag is derived from the; given tag offset in an implementation-defined manner.; - ``DW_OP_swap`` swaps top two stack entries.; - ``DW_OP_xderef`` provides extended dereference mechanism. The entry at the top; of the stack is treated as an address. The second stack entry is treated as an; address space identifier.; - ``DW_OP_stack_value`` marks a constant value.; - ``DW_OP_LLVM_entry_value, N`` refers to the value a register had upon; function entry. When targeting DWARF, a ``DBG_VALUE(reg, ...,; DIExpression(DW",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:262792,Modifiability,extend,extended,262792,"y from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`` here, respectively) to which the top of the; expression stack is to be converted. Maps into a ``DW_OP_convert`` operation; that references a base type constructed from the supplied values.; - ``DW_OP_LLVM_tag_offset, tag_offset`` specifies that a memory tag should be; optionally applied to the pointer. The memory tag is derived from the; given tag offset in an implementation-defined manner.; - ``DW_OP_swap`` swaps top two stack entries.; - ``DW_OP_xderef`` provides extended dereference mechanism. The entry at the top; of the stack is treated as an address. The second stack entry is treated as an; address space identifier.; - ``DW_OP_stack_value`` marks a constant value.; - ``DW_OP_LLVM_entry_value, N`` refers to the value a register had upon; function entry. When targeting DWARF, a ``DBG_VALUE(reg, ...,; DIExpression(DW_OP_LLVM_entry_value, 1, ...)`` is lowered to; ``DW_OP_entry_value [reg], ...``, which pushes the value ``reg`` had upon; function entry onto the DWARF expression stack. The next ``(N - 1)`` operations will be part of the ``DW_OP_entry_value``; block argument. For example, ``!DIExpression(DW_OP_LLVM_entry_value, 1,; DW_OP_plus_uconst, 123, DW_OP_stack_value)`` specifies an expression where; the entry value of ``reg`` is pushed onto the stack, and is added with 123.; Due to framework limitations ``N`` must be 1, in other words,; ``DW_OP_entry_value`` always refers to the value/address operand of the; instruction. Because ``DW_OP_LLVM",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:264482,Modifiability,variab,variables,264482,"st, 123, DW_OP_stack_value)`` specifies an expression where; the entry value of ``reg`` is pushed onto the stack, and is added with 123.; Due to framework limitations ``N`` must be 1, in other words,; ``DW_OP_entry_value`` always refers to the value/address operand of the; instruction. Because ``DW_OP_LLVM_entry_value`` is defined in terms of registers, it is; usually used in MIR, but it is also allowed in LLVM IR when targeting a; :ref:`swiftasync <swiftasync>` argument. The operation is introduced by:. - ``LiveDebugValues`` pass, which applies it to function parameters that; are unmodified throughout the function. Support is limited to simple; register location descriptions, or as indirect locations (e.g.,; parameters passed-by-value to a callee via a pointer to a temporary copy; made in the caller).; - ``AsmPrinter`` pass when a call site parameter value; (``DW_AT_call_site_parameter_value``) is represented as entry value of; the parameter.; - ``CoroSplit`` pass, which may move variables from allocas into a; coroutine frame. If the coroutine frame is a; :ref:`swiftasync <swiftasync>` argument, the variable is described with; an ``DW_OP_LLVM_entry_value`` operation. - ``DW_OP_LLVM_arg, N`` is used in debug intrinsics that refer to more than one; value, such as one that calculates the sum of two registers. This is always; used in combination with an ordered list of values, such that; ``DW_OP_LLVM_arg, N`` refers to the ``N``\ :sup:`th` element in that list. For; example, ``!DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus,; DW_OP_stack_value)`` used with the list ``(%reg1, %reg2)`` would evaluate to; ``%reg1 - reg2``. This list of values should be provided by the containing; intrinsic/instruction.; - ``DW_OP_breg`` (or ``DW_OP_bregx``) represents a content on the provided; signed offset of the specified register. The opcode is only generated by the; ``AsmPrinter`` pass to describe call site parameter value which requires an; expression over two regist",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:264604,Modifiability,variab,variable,264604,"and is added with 123.; Due to framework limitations ``N`` must be 1, in other words,; ``DW_OP_entry_value`` always refers to the value/address operand of the; instruction. Because ``DW_OP_LLVM_entry_value`` is defined in terms of registers, it is; usually used in MIR, but it is also allowed in LLVM IR when targeting a; :ref:`swiftasync <swiftasync>` argument. The operation is introduced by:. - ``LiveDebugValues`` pass, which applies it to function parameters that; are unmodified throughout the function. Support is limited to simple; register location descriptions, or as indirect locations (e.g.,; parameters passed-by-value to a callee via a pointer to a temporary copy; made in the caller).; - ``AsmPrinter`` pass when a call site parameter value; (``DW_AT_call_site_parameter_value``) is represented as entry value of; the parameter.; - ``CoroSplit`` pass, which may move variables from allocas into a; coroutine frame. If the coroutine frame is a; :ref:`swiftasync <swiftasync>` argument, the variable is described with; an ``DW_OP_LLVM_entry_value`` operation. - ``DW_OP_LLVM_arg, N`` is used in debug intrinsics that refer to more than one; value, such as one that calculates the sum of two registers. This is always; used in combination with an ordered list of values, such that; ``DW_OP_LLVM_arg, N`` refers to the ``N``\ :sup:`th` element in that list. For; example, ``!DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus,; DW_OP_stack_value)`` used with the list ``(%reg1, %reg2)`` would evaluate to; ``%reg1 - reg2``. This list of values should be provided by the containing; intrinsic/instruction.; - ``DW_OP_breg`` (or ``DW_OP_bregx``) represents a content on the provided; signed offset of the specified register. The opcode is only generated by the; ``AsmPrinter`` pass to describe call site parameter value which requires an; expression over two registers.; - ``DW_OP_push_object_address`` pushes the address of the object which can then; serve as a descriptor in sub",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:266109,Modifiability,variab,variables,266109,"to; ``%reg1 - reg2``. This list of values should be provided by the containing; intrinsic/instruction.; - ``DW_OP_breg`` (or ``DW_OP_bregx``) represents a content on the provided; signed offset of the specified register. The opcode is only generated by the; ``AsmPrinter`` pass to describe call site parameter value which requires an; expression over two registers.; - ``DW_OP_push_object_address`` pushes the address of the object which can then; serve as a descriptor in subsequent calculation. This opcode can be used to; calculate bounds of fortran allocatable array which has array descriptors.; - ``DW_OP_over`` duplicates the entry currently second in the stack at the top; of the stack. This opcode can be used to calculate bounds of fortran assumed; rank array which has rank known at run time and current dimension number is; implicitly first element of the stack.; - ``DW_OP_LLVM_implicit_pointer`` It specifies the dereferenced value. It can; be used to represent pointer variables which are optimized out but the value; it points to is known. This operator is required as it is different than DWARF; operator DW_OP_implicit_pointer in representation and specification (number; and types of operands) and later can not be used as multiple level. .. code-block:: text. IR for ""*ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !20); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267486,Modifiability,variab,variable,267486,"ata !20); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the D",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267627,Modifiability,variab,variable,267627,", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267769,Modifiability,variab,variable,267769,", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267944,Modifiability,variab,variable,267944,"able(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: text. !0 = !DIExpression(DW_OP_deref); !1 = !DIExpression(DW_OP_plus_uconst, 3); !1 = !DIExpression(DW_OP_constu, 3, DW_OP_plus); !2 = !DIExpression(DW_OP_bit_piece, 3, 7); !3 = !DIExpression(DW_OP_deref, DW_OP_cons",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:268132,Modifiability,variab,variable,268132,"ointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: text. !0 = !DIExpression(DW_OP_deref); !1 = !DIExpression(DW_OP_plus_uconst, 3); !1 = !DIExpression(DW_OP_constu, 3, DW_OP_plus); !2 = !DIExpression(DW_OP_bit_piece, 3, 7); !3 = !DIExpression(DW_OP_deref, DW_OP_constu, 3, DW_OP_plus, DW_OP_LLVM_fragment, 3, 7); !4 = !DIExpression(DW_OP_constu, 2, DW_OP_swap, DW_OP_xderef); !5 = !DIExpression(DW_OP_constu, 42, DW_OP_stack_value). DIAs",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:268212,Modifiability,variab,variable,268212,"!21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: text. !0 = !DIExpression(DW_OP_deref); !1 = !DIExpression(DW_OP_plus_uconst, 3); !1 = !DIExpression(DW_OP_constu, 3, DW_OP_plus); !2 = !DIExpression(DW_OP_bit_piece, 3, 7); !3 = !DIExpression(DW_OP_deref, DW_OP_constu, 3, DW_OP_plus, DW_OP_LLVM_fragment, 3, 7); !4 = !DIExpression(DW_OP_constu, 2, DW_OP_swap, DW_OP_xderef); !5 = !DIExpression(DW_OP_constu, 42, DW_OP_stack_value). DIAssignID; """""""""""""""""""""""". ``DIAssignID`` nodes have no operands and are always distinct. They are used to; lin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:270979,Modifiability,variab,variables,270979,"s a function argument, must always be; inlined, and cannot appear in named metadata. .. code-block:: text. llvm.dbg.value(metadata !DIArgList(i32 %a, i32 %b),; metadata !16,; metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus)). DIFlags; """""""""""""""""""""""""""""". These flags encode various properties of DINodes. The `ExportSymbols` flag marks a class, struct or union whose members; may be referenced as if they were defined in the containing class or; union. This flag is used to decide whether the DW_AT_export_symbols can; be used for the structure type. DIObjCProperty; """""""""""""""""""""""""""". ``DIObjCProperty`` nodes represent Objective-C property nodes. .. code-block:: text. !3 = !DIObjCProperty(name: ""foo"", file: !1, line: 7, setter: ""setFoo"",; getter: ""getFoo"", attributes: 7, type: !2). DIImportedEntity; """""""""""""""""""""""""""""""". ``DIImportedEntity`` nodes represent entities (such as modules) imported into a; compile unit. The ``elements`` field is a list of renamed entities (such as; variables and subprograms) in the imported entity (such as module). .. code-block:: text. !2 = !DIImportedEntity(tag: DW_TAG_imported_module, name: ""foo"", scope: !0,; entity: !1, line: 7, elements: !3); !3 = !{!4}; !4 = !DIImportedEntity(tag: DW_TAG_imported_declaration, name: ""bar"", scope: !0,; entity: !5, line: 7). DIMacro; """""""""""""". ``DIMacro`` nodes represent definition or undefinition of a macro identifiers.; The ``name:`` field is the macro identifier, followed by macro parameters when; defining a function-like macro, and the ``value`` field is the token-string; used to expand the macro identifier. .. code-block:: text. !2 = !DIMacro(macinfo: DW_MACINFO_define, line: 7, name: ""foo(x)"",; value: ""((x) + 1)""); !3 = !DIMacro(macinfo: DW_MACINFO_undef, line: 30, name: ""foo""). DIMacroFile; """""""""""""""""""""". ``DIMacroFile`` nodes represent inclusion of source files.; The ``nodes:`` field is a list of ``DIMacro`` and ``DIMacroFile`` nodes that; appear in the included source file. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:286404,Modifiability,variab,variable,286404,"ruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = external global i8, !absolute_symbol !1 ; Absolute symbol in range [0,2^64). ...; !0 = !{ i64 0, i64 256 }; !1 = !{ i64 -1, i64 -1 }. '``callees``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``callees`` metadata may be attached to indirect call sites. If ``callees``; metadata is attached to a call site, and any callee is not among the set of; functions provided by the metadata, the behavior is undefined. The intent of;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:286646,Modifiability,variab,variable,286646," in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = external global i8, !absolute_symbol !1 ; Absolute symbol in range [0,2^64). ...; !0 = !{ i64 0, i64 256 }; !1 = !{ i64 -1, i64 -1 }. '``callees``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``callees`` metadata may be attached to indirect call sites. If ``callees``; metadata is attached to a call site, and any callee is not among the set of; functions provided by the metadata, the behavior is undefined. The intent of; this metadata is to facilitate optimizations such as indirect-call promotion.; For example, in the code below, the call instruction may only target the; ``add`` or ``sub`` functions:. .. code-block:: llvm. %result = call i64 %binop(i64 %x, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:291430,Modifiability,variab,variable,291430,"w is set to highlight as 'llvm', despite that we; have misc.highlighting_failure set?. .. code-block:: text. declare !callback !1 dso_local i32 @pthread_create(ptr, ptr, ptr, ptr). ...; !2 = !{i64 2, i64 3, i1 false}; !1 = !{!2}. Another example is shown below. The callback callee is the second argument of; the ``__kmpc_fork_call`` function (``i64 2``). The callee is given two unknown; values (each identified by a ``i64 -1``) and afterwards all; variadic arguments that are passed to the ``__kmpc_fork_call`` call (due to the; final ``i1 true``). .. FIXME why does the llvm-sphinx-docs builder give a highlighting; error if the below is set to highlight as 'llvm', despite that we; have misc.highlighting_failure set?. .. code-block:: text. declare !callback !0 dso_local void @__kmpc_fork_call(ptr, i32, ptr, ...). ...; !1 = !{i64 2, i64 -1, i64 -1, i1 true}; !0 = !{!1}. '``exclude``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``exclude`` metadata may be attached to a global variable to signify that its; section should not be included in the final executable or shared library. This; option is only valid for global variables with an explicit section targeting ELF; or COFF. This is done using the ``SHF_EXCLUDE`` flag on ELF targets and the; ``IMAGE_SCN_LNK_REMOVE`` and ``IMAGE_SCN_MEM_DISCARDABLE`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:291572,Modifiability,variab,variables,291572,"k !1 dso_local i32 @pthread_create(ptr, ptr, ptr, ptr). ...; !2 = !{i64 2, i64 3, i1 false}; !1 = !{!2}. Another example is shown below. The callback callee is the second argument of; the ``__kmpc_fork_call`` function (``i64 2``). The callee is given two unknown; values (each identified by a ``i64 -1``) and afterwards all; variadic arguments that are passed to the ``__kmpc_fork_call`` call (due to the; final ``i1 true``). .. FIXME why does the llvm-sphinx-docs builder give a highlighting; error if the below is set to highlight as 'llvm', despite that we; have misc.highlighting_failure set?. .. code-block:: text. declare !callback !0 dso_local void @__kmpc_fork_call(ptr, i32, ptr, ...). ...; !1 = !{i64 2, i64 -1, i64 -1, i1 true}; !0 = !{!1}. '``exclude``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``exclude`` metadata may be attached to a global variable to signify that its; section should not be included in the final executable or shared library. This; option is only valid for global variables with an explicit section targeting ELF; or COFF. This is done using the ``SHF_EXCLUDE`` flag on ELF targets and the; ``IMAGE_SCN_LNK_REMOVE`` and ``IMAGE_SCN_MEM_DISCARDABLE`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:317998,Modifiability,variab,variable,317998,"knownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a di",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318210,Modifiability,variab,variable,318210,"hrough launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-de",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318454,Modifiability,variab,variable,318454,"ing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-defined encapsulation symbols ``__start_<section_name>`` and; ``__stop_<section_name>``. It does not have any effect on non-ELF targets. Example:. .. code-block:: text. $a = comdat any; @a = global i32 1, comdat $a; @b = internal global i32 2, comdat $a, section ""abc"", !as",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318569,Modifiability,variab,variable,318569,"en we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-defined encapsulation symbols ``__start_<section_name>`` and; ``__stop_<section_name>``. It does not have any effect on non-ELF targets. Example:. .. code-block:: text. $a = comdat any; @a = global i32 1, comdat $a; @b = internal global i32 2, comdat $a, section ""abc"", !associated !0; !0 = !{ptr @a}. '``prof``' Metadata; ^^^^^^^^^^^^^^^^^^^. The ``prof`` metadata is used to record profile data in the IR.; The first operand of the metadata node indicates th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:322939,Modifiability,variab,variable,322939,"nds give the execution count that each of the respective prior target; functions was called. .. _md_annotation:. '``annotation``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``annotation`` metadata can be used to attach a tuple of annotation strings; or a tuple of a tuple of annotation strings to any instruction. This metadata does; not impact the semantics of the program and may only be used to provide additional; insight about the program and transformations to users. Example:. .. code-block:: text. %a.addr = alloca ptr, align 8, !annotation !0; !0 = !{!""auto-init""}. Embedding tuple of strings example:. .. code-block:: text. %a.ptr = getelementptr ptr, ptr %base, i64 0. !annotation !0; !0 = !{!1}; !1 = !{!""gep offset"", !""0""}. '``func_sanitize``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``func_sanitize`` metadata is used to attach two values for the function; sanitizer instrumentation. The first value is the ubsan function signature.; The second value is the address of the proxy variable which stores the address; of the RTTI descriptor. If :ref:`prologue <prologuedata>` and '``func_sanitize``'; are used at the same time, :ref:`prologue <prologuedata>` is emitted before; '``func_sanitize``' in the output. Example:. .. code-block:: text. @__llvm_rtti_proxy = private unnamed_addr constant ptr @_ZTIFvvE; define void @_Z3funv() !func_sanitize !0 {; return void; }; !0 = !{i32 846595819, ptr @__llvm_rtti_proxy}. .. _md_kcfi_type:. '``kcfi_type``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``kcfi_type`` metadata can be used to attach a type identifier to; functions that can be called indirectly. The type data is emitted before the; function entry in the assembly. Indirect calls with the :ref:`kcfi operand; bundle<ob_kcfi>` will emit a check that compares the type identifier to the; metadata. Example:. .. code-block:: text. define dso_local i32 @f() !kcfi_type !0 {; ret i32 0; }; !0 = !{i32 12345678}. Clang emits ``kcfi_type`` metadata nodes for address-taken functions with; ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:341254,Modifiability,variab,variable,341254," path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:342393,Modifiability,variab,variable,342393,"tion, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summary>`,; :ref:`Params<params_summary>`, :ref:`Refs<refs_summary>`. .. _variable_summary:. Global Variable Summary; ^^^^^^^^^^^^^^^^^^^^^^^. If the global value is a variable, the ``Summary`` entry will look like:. .. code-block:: text. variable: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0)[, Refs]?. The variable entry contains a subset of the fields in a; :ref:`function summary <function_summary>`, see the descriptions there. .. _alias_summary:. Alias Summary; ^^^^^^^^^^^^^. If the global value is an alias, the ``Summary`` entry will look like:. .. code-block:: text. alias: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), aliasee: ^2). The ``module`` and ``flags`` fields are as described for a; :ref:`function summary <function_summary>`. The ``aliasee`` field; contains a reference to the global value summary entry of the aliasee. .. _funcflags_summary:. Function Flags; ^^^^^^^^^^^^^^. The optional ``FuncFlags`` field looks like:. .. code-block:: text. funcFlags: (readNone: 0, readOnly: 0, noRecurse: 0, returnDoesNotAlias: 0, noInline: 0, alwaysInline: 0, noUnwind: 1, mayThrow: 0, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:342464,Modifiability,variab,variable,342464,"nal, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summary>`,; :ref:`Params<params_summary>`, :ref:`Refs<refs_summary>`. .. _variable_summary:. Global Variable Summary; ^^^^^^^^^^^^^^^^^^^^^^^. If the global value is a variable, the ``Summary`` entry will look like:. .. code-block:: text. variable: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0)[, Refs]?. The variable entry contains a subset of the fields in a; :ref:`function summary <function_summary>`, see the descriptions there. .. _alias_summary:. Alias Summary; ^^^^^^^^^^^^^. If the global value is an alias, the ``Summary`` entry will look like:. .. code-block:: text. alias: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), aliasee: ^2). The ``module`` and ``flags`` fields are as described for a; :ref:`function summary <function_summary>`. The ``aliasee`` field; contains a reference to the global value summary entry of the aliasee. .. _funcflags_summary:. Function Flags; ^^^^^^^^^^^^^^. The optional ``FuncFlags`` field looks like:. .. code-block:: text. funcFlags: (readNone: 0, readOnly: 0, noRecurse: 0, returnDoesNotAlias: 0, noInline: 0, alwaysInline: 0, noUnwind: 1, mayThrow: 0, hasUnknownCall: 0). If unspecified, flags are assumed to hold the conservative ``false`` value of; ``0``. .. _ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:342574,Modifiability,variab,variable,342574,"]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summary>`,; :ref:`Params<params_summary>`, :ref:`Refs<refs_summary>`. .. _variable_summary:. Global Variable Summary; ^^^^^^^^^^^^^^^^^^^^^^^. If the global value is a variable, the ``Summary`` entry will look like:. .. code-block:: text. variable: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0)[, Refs]?. The variable entry contains a subset of the fields in a; :ref:`function summary <function_summary>`, see the descriptions there. .. _alias_summary:. Alias Summary; ^^^^^^^^^^^^^. If the global value is an alias, the ``Summary`` entry will look like:. .. code-block:: text. alias: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), aliasee: ^2). The ``module`` and ``flags`` fields are as described for a; :ref:`function summary <function_summary>`. The ``aliasee`` field; contains a reference to the global value summary entry of the aliasee. .. _funcflags_summary:. Function Flags; ^^^^^^^^^^^^^^. The optional ``FuncFlags`` field looks like:. .. code-block:: text. funcFlags: (readNone: 0, readOnly: 0, noRecurse: 0, returnDoesNotAlias: 0, noInline: 0, alwaysInline: 0, noUnwind: 1, mayThrow: 0, hasUnknownCall: 0). If unspecified, flags are assumed to hold the conservative ``false`` value of; ``0``. .. _calls_summary:. Calls; ^^^^^. The optional ``Calls`` field looks like:. .. code-block:: text. calls: ((Callee)[, (Callee",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:350492,Modifiability,variab,variables,350492," wpdRes: (kind: branchFunnel); wpdRes: (kind: singleImpl, singleImplName: ""_ZN1A1nEi""); wpdRes: (kind: indir). Additionally, each wpdRes has an optional ``resByArg`` field, which; describes the resolutions for calls with all constant integer arguments:. .. code-block:: text. resByArg: (ResByArg[, ResByArg]*). where ResByArg is:. .. code-block:: text. args: (Arg[, Arg]*), byArg: (kind: UniformRetVal[, info: 0][, byte: 0][, bit: 0]). Where the ``kind`` can be ``Indir``, ``UniformRetVal``, ``UniqueRetVal``; or ``VirtualConstProp``. The ``info`` field is only used if the kind; is ``UniformRetVal`` (indicates the uniform return value), or; ``UniqueRetVal`` (holds the return value associated with the unique vtable; (0 or 1)). The ``byte`` and ``bit`` fields are only used if the target does; not support the use of absolute symbols to store constants. .. _intrinsicglobalvariables:. Intrinsic Global Variables; ==========================. LLVM has a number of ""magic"" global variables that contain data that; affect code generation or other IR semantics. These are documented here.; All globals of this sort should have a section specified as; ""``llvm.metadata``"". This section and all globals that start with; ""``llvm.``"" are reserved for use by LLVM. .. _gv_llvmused:. The '``llvm.used``' Global Variable; -----------------------------------. The ``@llvm.used`` global is an array which has; :ref:`appending linkage <linkage_appending>`. This array contains a list of; pointers to named global variables, functions and aliases which may optionally; have a pointer cast formed of bitcast or getelementptr. For example, a legal; use of it is:. .. code-block:: llvm. @X = global i8 4; @Y = global i32 123. @llvm.used = appending global [2 x ptr] [; ptr @X,; ptr @Y; ], section ""llvm.metadata"". If a symbol appears in the ``@llvm.used`` list, then the compiler, assembler,; and linker are required to treat the symbol as if there is a reference to the; symbol that it cannot see (which is why they ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:351013,Modifiability,variab,variables,351013,"tProp``. The ``info`` field is only used if the kind; is ``UniformRetVal`` (indicates the uniform return value), or; ``UniqueRetVal`` (holds the return value associated with the unique vtable; (0 or 1)). The ``byte`` and ``bit`` fields are only used if the target does; not support the use of absolute symbols to store constants. .. _intrinsicglobalvariables:. Intrinsic Global Variables; ==========================. LLVM has a number of ""magic"" global variables that contain data that; affect code generation or other IR semantics. These are documented here.; All globals of this sort should have a section specified as; ""``llvm.metadata``"". This section and all globals that start with; ""``llvm.``"" are reserved for use by LLVM. .. _gv_llvmused:. The '``llvm.used``' Global Variable; -----------------------------------. The ``@llvm.used`` global is an array which has; :ref:`appending linkage <linkage_appending>`. This array contains a list of; pointers to named global variables, functions and aliases which may optionally; have a pointer cast formed of bitcast or getelementptr. For example, a legal; use of it is:. .. code-block:: llvm. @X = global i8 4; @Y = global i32 123. @llvm.used = appending global [2 x ptr] [; ptr @X,; ptr @Y; ], section ""llvm.metadata"". If a symbol appears in the ``@llvm.used`` list, then the compiler, assembler,; and linker are required to treat the symbol as if there is a reference to the; symbol that it cannot see (which is why they have to be named). For example, if; a variable has internal linkage and no references other than that from the; ``@llvm.used`` list, it cannot be deleted. This is commonly used to represent; references from inline asms and other things the compiler cannot ""see"", and; corresponds to ""``attribute((used))``"" in GNU C. On some targets, the code generator must emit a directive to the; assembler or object file to prevent the assembler and linker from; removing the symbol. .. _gv_llvmcompilerused:. The '``llvm.compiler.used``' G",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:351551,Modifiability,variab,variable,351551,"documented here.; All globals of this sort should have a section specified as; ""``llvm.metadata``"". This section and all globals that start with; ""``llvm.``"" are reserved for use by LLVM. .. _gv_llvmused:. The '``llvm.used``' Global Variable; -----------------------------------. The ``@llvm.used`` global is an array which has; :ref:`appending linkage <linkage_appending>`. This array contains a list of; pointers to named global variables, functions and aliases which may optionally; have a pointer cast formed of bitcast or getelementptr. For example, a legal; use of it is:. .. code-block:: llvm. @X = global i8 4; @Y = global i32 123. @llvm.used = appending global [2 x ptr] [; ptr @X,; ptr @Y; ], section ""llvm.metadata"". If a symbol appears in the ``@llvm.used`` list, then the compiler, assembler,; and linker are required to treat the symbol as if there is a reference to the; symbol that it cannot see (which is why they have to be named). For example, if; a variable has internal linkage and no references other than that from the; ``@llvm.used`` list, it cannot be deleted. This is commonly used to represent; references from inline asms and other things the compiler cannot ""see"", and; corresponds to ""``attribute((used))``"" in GNU C. On some targets, the code generator must emit a directive to the; assembler or object file to prevent the assembler and linker from; removing the symbol. .. _gv_llvmcompilerused:. The '``llvm.compiler.used``' Global Variable; --------------------------------------------. The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used``; directive, except that it only prevents the compiler from touching the; symbol. On targets that support it, this allows an intelligent linker to; optimize references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:353166,Modifiability,variab,variable,353166,"only prevents the compiler from touching the; symbol. On targets that support it, this allows an intelligent linker to; optimize references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, ptr @ctor, ptr @data }]. The ``@llvm.global_ctors`` array contains a list of constructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in ascending order; of priority (i.e. lowest first) when the module is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Inst",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:353324,Modifiability,variab,variable,353324," references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, ptr @ctor, ptr @data }]. The ``@llvm.global_ctors`` array contains a list of constructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in ascending order; of priority (i.e. lowest first) when the module is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:353999,Modifiability,variab,variable,353999,"le is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary; instructions <binaryops>`, :ref:`bitwise binary; instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and; :ref:`other instructions <otherops>`. .. _terminators:. Terminator Instructions; -----------------------. As mentioned :ref:`previously <functionstructure>`, every basic block in a; program ends with a ""Terminator"" instruction, which indicates which; block should be executed after the current block is finished. These; terminator instructions typically yield a '``void``' value: they produce; control flow, not values (the one exception being the; ':ref:`invoke <i_invoke>`' instruction). The terminator instructions a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:354156,Modifiability,variab,variable,354156,"obal variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary; instructions <binaryops>`, :ref:`bitwise binary; instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and; :ref:`other instructions <otherops>`. .. _terminators:. Terminator Instructions; -----------------------. As mentioned :ref:`previously <functionstructure>`, every basic block in a; program ends with a ""Terminator"" instruction, which indicates which; block should be executed after the current block is finished. These; terminator instructions typically yield a '``void``' value: they produce; control flow, not values (the one exception being the; ':ref:`invoke <i_invoke>`' instruction). The terminator instructions are: ':ref:`ret <i_ret>`',; ':ref:`br <i_br>`', ':ref:`switch <i_switch>`',; ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke <",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:364263,Modifiability,variab,variable,364263,"te the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the call instruction itself which is also the; type of the return value. Functions that return no value are marked; ``void``.; #. '``fnty``': shall be the signature of the function being invoked. The; argument types must match the types implied by this signature. This; type can be omitted if the function is not varargs.; #. '``fnptrval``': An LLVM value containing a pointer to a function to; be invoked. In most cases, this is a direct function invocation, but; indirect ``invoke``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. '``normal label``': the label reached when the called function; executes a '``ret``' instruction.; #. '``exception label``': the label reached when a callee returns via; the :ref:`resume <i_resume>` instruction or other exception handling; mechanism.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with a label, which is used by the runtime; library to unwind the stack. This instruction is used in languages with destructors to ensure that; proper cleanup is performed in the case of either a ``longjmp`` or a; thrown exception. Additionally, this is important for implementation of; '``catch``' clauses in high-level languages that support them. For the purposes of the SSA for",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:368361,Modifiability,variab,variable,368361,"d to indicate the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the call instruction itself which is also the; type of the return value. Functions that return no value are marked; ``void``.; #. '``fnty``': shall be the signature of the function being called. The; argument types must match the types implied by this signature. This; type can be omitted if the function is not varargs.; #. '``fnptrval``': An LLVM value containing a pointer to a function to; be called. In most cases, this is a direct function call, but; other ``callbr``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. '``fallthrough label``': the label reached when the inline assembly's; execution exits the bottom.; #. '``indirect labels``': the labels reached when a callee transfers control; to a location other than the '``fallthrough label``'. Label constraints; refer to these destinations.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations fo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:383041,Modifiability,extend,extended,383041,"mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, the result; returned is the mathematical result modulo 2\ :sup:`n`\ , where n is the; bit width of the result. Because LLVM integers use a two's complement representation, and the; result is the same width as the operands, this instruction returns the; correct result for both signed and unsigned integers. If a full product; (e.g. ``i32`` * ``i32`` -> ``i64``) is needed, the operands should be; sign-extended or zero-extended as appropriate to the width of the full; product. ``nuw`` and ``nsw`` stand for ""No Unsigned Wrap"" and ""No Signed Wrap"",; respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:383058,Modifiability,extend,extended,383058,"mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, the result; returned is the mathematical result modulo 2\ :sup:`n`\ , where n is the; bit width of the result. Because LLVM integers use a two's complement representation, and the; result is the same width as the operands, this instruction returns the; correct result for both signed and unsigned integers. If a full product; (e.g. ``i32`` * ``i32`` -> ``i64``) is needed, the operands should be; sign-extended or zero-extended as appropriate to the width of the full; product. ``nuw`` and ``nsw`` stand for ""No Unsigned Wrap"" and ""No Signed Wrap"",; respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:401493,Modifiability,variab,variable,401493,"tor operations in a; target-independent manner. These instructions cover the element-access; and vector-specific operations needed to process vectors effectively.; While LLVM does directly support these vector operations, many; sophisticated algorithms will want to use target-specific intrinsics to; take full advantage of a specific target. .. _i_extractelement:. '``extractelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = extractelement <n x <ty>> <val>, <ty2> <idx> ; yields <ty>; <result> = extractelement <vscale x n x <ty>> <val>, <ty2> <idx> ; yields <ty>. Overview:; """""""""""""""""". The '``extractelement``' instruction extracts a single scalar element; from a vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``extractelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is an index indicating; the position from which to extract the element. The index may be a; variable of any integer type, and will be treated as an unsigned integer. Semantics:; """""""""""""""""""". The result is a scalar of the same type as the element type of ``val``.; Its value is the value at position ``idx`` of ``val``. If ``idx``; exceeds the length of ``val`` for a fixed-length vector, the result is a; :ref:`poison value <poisonvalues>`. For a scalable vector, if the value; of ``idx`` exceeds the runtime length of the vector, the result is a; :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = extractelement <4 x i32> %vec, i32 0 ; yields i32. .. _i_insertelement:. '``insertelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <n x <ty>>; <result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>. Overview:; """""""""""""""""". The '``insertelement``' instruction inserts a scalar element into a; vector at a specified index. Argumen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:402842,Modifiability,variab,variable,402842,"he value; of ``idx`` exceeds the runtime length of the vector, the result is a; :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = extractelement <4 x i32> %vec, i32 0 ; yields i32. .. _i_insertelement:. '``insertelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <n x <ty>>; <result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>. Overview:; """""""""""""""""". The '``insertelement``' instruction inserts a scalar element into a; vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``insertelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is a scalar value whose; type must equal the element type of the first operand. The third operand; is an index indicating the position at which to insert the value. The; index may be a variable of any integer type, and will be treated as an; unsigned integer. Semantics:; """""""""""""""""""". The result is a vector of the same type as ``val``. Its element values; are those of ``val`` except at position ``idx``, where it gets the value; ``elt``. If ``idx`` exceeds the length of ``val`` for a fixed-length vector,; the result is a :ref:`poison value <poisonvalues>`. For a scalable vector,; if the value of ``idx`` exceeds the runtime length of the vector, the result; is a :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = insertelement <4 x i32> %vec, i32 1, i32 0 ; yields <4 x i32>. .. _i_shufflevector:. '``shufflevector``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask> ; yields <m x <ty>>; <result> = shufflevector <vscale x n x <ty>> <v1>, <vscale x n x <ty>> v2, <vscale x m x i32> <mask> ; yields <vscale x m x <ty>>. Overview:; """""""""""""""""". The '``shufflevector``' instructi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410828,Modifiability,variab,variables,410828,"anteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436251,Modifiability,extend,extended,436251,"0 x [20 x i32]], i8 }``' type, another; structure. The third index indexes into the second element of the; structure, yielding a '``[10 x [20 x i32]]``' type, an array. The two; dimensions of the array are subscripted into, yielding an '``i32``'; type. The '``getelementptr``' instruction returns a pointer to this; element. Note that it is perfectly legal to index partially through a structure,; returning a pointer to an inner element. Because of this, the LLVM code; for the given testcase is equivalent to:. .. code-block:: llvm. define ptr @foo(ptr %s) {; %t1 = getelementptr %struct.ST, ptr %s, i32 1; %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2; %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436337,Modifiability,extend,extended,436337," two; dimensions of the array are subscripted into, yielding an '``i32``'; type. The '``getelementptr``' instruction returns a pointer to this; element. Note that it is perfectly legal to index partially through a structure,; returning a pointer to an inner element. Because of this, the LLVM code; for the given testcase is equivalent to:. .. code-block:: llvm. define ptr @foo(ptr %s) {; %t1 = getelementptr %struct.ST, ptr %s, i32 1; %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2; %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:443343,Modifiability,extend,extends,443343,"takes a value to trunc, and a type to trunc; it to. Both types must be of :ref:`integer <t_integer>` types, or vectors; of the same number of integers. The bit size of the ``value`` must be; larger than the bit size of the destination type, ``ty2``. Equal sized; types are not allowed. Semantics:; """""""""""""""""""". The '``trunc``' instruction truncates the high order bits in ``value``; and converts the remaining bits to ``ty2``. Since the source size must; be larger than the destination size, ``trunc`` cannot be a *no-op cast*.; It will always truncate bits. Example:; """""""""""""""". .. code-block:: llvm. %X = trunc i32 257 to i8 ; yields i8:1; %Y = trunc i32 123 to i1 ; yields i1:true; %Z = trunc i32 122 to i1 ; yields i1:false; %W = trunc <2 x i16> <i16 8, i16 7> to <2 x i8> ; yields <i8 8, i8 7>. .. _i_zext:. '``zext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = zext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``zext``' instruction zero extends its operand to type ``ty2``. The ``nneg`` (non-negative) flag, if present, specifies that the operand is; non-negative. This property may be used by optimization passes to later; convert the ``zext`` into a ``sext``. Arguments:; """""""""""""""""""". The '``zext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The ``zext`` fills the high order bits of the ``value`` with zero bits; until it reaches the size of the destination type, ``ty2``. When zero extending from i1, the result will always be either 0 or 1. If the ``nneg`` flag is set, and the ``zext`` argument is negative, the result; is a poison value. Example:; """""""""""""""". .. code-block:: llvm. %X = zext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:444034,Modifiability,extend,extending,444034,"ds i1:false; %W = trunc <2 x i16> <i16 8, i16 7> to <2 x i8> ; yields <i8 8, i8 7>. .. _i_zext:. '``zext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = zext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``zext``' instruction zero extends its operand to type ``ty2``. The ``nneg`` (non-negative) flag, if present, specifies that the operand is; non-negative. This property may be used by optimization passes to later; convert the ``zext`` into a ``sext``. Arguments:; """""""""""""""""""". The '``zext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The ``zext`` fills the high order bits of the ``value`` with zero bits; until it reaches the size of the destination type, ``ty2``. When zero extending from i1, the result will always be either 0 or 1. If the ``nneg`` flag is set, and the ``zext`` argument is negative, the result; is a poison value. Example:; """""""""""""""". .. code-block:: llvm. %X = zext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' ins",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:444677,Modifiability,extend,extends,444677,"be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The ``zext`` fills the high order bits of the ``value`` with zero bits; until it reaches the size of the destination type, ``ty2``. When zero extending from i1, the result will always be either 0 or 1. If the ``nneg`` flag is set, and the ``zext`` argument is negative, the result; is a poison value. Example:; """""""""""""""". .. code-block:: llvm. %X = zext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' instruction performs a sign extension by copying the sign; bit (highest order bit) of the ``value`` until it reaches the bit size; of the type ``ty2``. When sign extending from i1, the extension always results in -1 or 0. Example:; """""""""""""""". .. code-block:: llvm. %X = sext i8 -1 to i16 ; yields i16 :65535; %Y = sext i1 true to i32 ; yields i32:-1; %Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. '``fptrunc .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptrunc <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptrunc``' instruction truncates ``v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:445217,Modifiability,extend,extending,445217,"ext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' instruction performs a sign extension by copying the sign; bit (highest order bit) of the ``value`` until it reaches the bit size; of the type ``ty2``. When sign extending from i1, the extension always results in -1 or 0. Example:; """""""""""""""". .. code-block:: llvm. %X = sext i8 -1 to i16 ; yields i16 :65535; %Y = sext i1 true to i32 ; yields i32:-1; %Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. '``fptrunc .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptrunc <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptrunc``' instruction truncates ``value`` to type ``ty2``. Arguments:; """""""""""""""""""". The '``fptrunc``' instruction takes a :ref:`floating-point <t_floating>`; value to cast and a :ref:`floating-point <t_floating>` type to cast it to.; The size of ``value`` must be larger than the size of ``ty2``. This; implies that ``fptrunc`` cannot be used to make a *no-op cast*. Semantics:; """""""""""""""""""". The '``fptrunc``' instruction casts a ``value`` from a larger; :ref:`floating-point <t_floating>` type to a smaller :ref:`floating-point; <t_floating>` type.; This instruction is assumed to execute in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:447157,Modifiability,extend,extends,447157,"loating>` type.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`. NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that _if_ a; NaN payload is propagated from the input (""Quieting NaN propagation"" or; ""Unchanged NaN propagation"" cases), then the low order bits of the NaN payload; which cannot fit in the resulting type are discarded. Note that if discarding; the low order bits leads to an all-0 payload, this cannot be represented as a; signaling NaN (it would represent an infinity instead), so in that case; ""Unchanged NaN propagation"" is not possible. Example:; """""""""""""""". .. code-block:: llvm. %X = fptrunc double 16777217.0 to float ; yields float:16777216.0; %Y = fptrunc double 1.0E+300 to half ; yields half:+infinity. '``fpext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fpext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fpext``' extends a floating-point ``value`` to a larger floating-point; value. Arguments:; """""""""""""""""""". The '``fpext``' instruction takes a :ref:`floating-point <t_floating>`; ``value`` to cast, and a :ref:`floating-point <t_floating>` type to cast it; to. The source type must be smaller than the destination type. Semantics:; """""""""""""""""""". The '``fpext``' instruction extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The ``fpext`` cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op cast* for a floating-point cast. NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that _if_ a; NaN payload is propagated from the input (""Quieting NaN propagation"" or; ""Unchanged NaN propagation"" cases), then it is copied to the high order bits of; the resulting payload, and the remaining low order bits are zero. Example:; """""""""""""""". .. code-block:: llvm. %X = fpext float 3.125 to double ; yields",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:447515,Modifiability,extend,extends,447515,"ng type are discarded. Note that if discarding; the low order bits leads to an all-0 payload, this cannot be represented as a; signaling NaN (it would represent an infinity instead), so in that case; ""Unchanged NaN propagation"" is not possible. Example:; """""""""""""""". .. code-block:: llvm. %X = fptrunc double 16777217.0 to float ; yields float:16777216.0; %Y = fptrunc double 1.0E+300 to half ; yields half:+infinity. '``fpext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fpext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fpext``' extends a floating-point ``value`` to a larger floating-point; value. Arguments:; """""""""""""""""""". The '``fpext``' instruction takes a :ref:`floating-point <t_floating>`; ``value`` to cast, and a :ref:`floating-point <t_floating>` type to cast it; to. The source type must be smaller than the destination type. Semantics:; """""""""""""""""""". The '``fpext``' instruction extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The ``fpext`` cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op cast* for a floating-point cast. NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that _if_ a; NaN payload is propagated from the input (""Quieting NaN propagation"" or; ""Unchanged NaN propagation"" cases), then it is copied to the high order bits of; the resulting payload, and the remaining low order bits are zero. Example:; """""""""""""""". .. code-block:: llvm. %X = fpext float 3.125 to double ; yields double:3.125000e+00; %Y = fpext double %X to fp128 ; yields fp128:0xL00000000000000004000900000000000. '``fptoui .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptoui <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptoui``' converts a floating-point ``value`` to its unsigned; integer equivalent of type ``ty2``. Arguments:;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:453345,Modifiability,extend,extending,453345," corresponding floating-point value. If the; value cannot be exactly represented, it is rounded using the default rounding; mode. Example:; """""""""""""""". .. code-block:: llvm. %X = sitofp i32 257 to float ; yields float:257.0; %Y = sitofp i8 -1 to double ; yields double:-1.0. .. _i_ptrtoint:. '``ptrtoint .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = ptrtoint <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``ptrtoint``' instruction converts the pointer or a vector of; pointers ``value`` to the integer (or vector of integers) type ``ty2``. Arguments:; """""""""""""""""""". The '``ptrtoint``' instruction takes a ``value`` to cast, which must be; a value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a; type to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` or; a vector of integers type. Semantics:; """""""""""""""""""". The '``ptrtoint``' instruction converts ``value`` to integer type; ``ty2`` by interpreting the pointer value as an integer and either; truncating or zero extending that value to the size of the integer type.; If ``value`` is smaller than ``ty2`` then a zero extension is done. If; ``value`` is larger than ``ty2`` then a truncation is done. If they are; the same size, then nothing is done (*no-op cast*) other than a type; change. Example:; """""""""""""""". .. code-block:: llvm. %X = ptrtoint ptr %P to i8 ; yields truncation on 32-bit architecture; %Y = ptrtoint ptr %P to i64 ; yields zero extension on 32-bit architecture; %Z = ptrtoint <4 x ptr> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture. .. _i_inttoptr:. '``inttoptr .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = inttoptr <ty> <value> to <ty2>[, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>] ; yields ty2. Overview:; """""""""""""""""". The '``inttoptr``' instruction converts an integer ``value`` to a; pointer type, ``ty2``.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:477533,Modifiability,variab,variable,477533," to indicate the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the call instruction itself which is also the; type of the return value. Functions that return no value are marked; ``void``.; #. '``fnty``': shall be the signature of the function being called. The; argument types must match the types implied by this signature. This; type can be omitted if the function is not varargs.; #. '``fnptrval``': An LLVM value containing a pointer to a function to; be called. In most cases, this is a direct function call, but; indirect ``call``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". The '``call``' instruction is used to cause control flow to transfer to; a specified function, with its incoming arguments bound to the specified; values. Upon a '``ret``' instruction in the called function, control; flow continues with the instruction after the function call, and the; return value of the function is bound to the result argument. Example:; """""""""""""""". .. code-block:: llvm. %retval = call i32 @test(i32 %argc); call i32 (ptr, ...) @printf(ptr %msg, i32 12, i8 42) ; yields i32; %X = tail call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:478665,Modifiability,extend,extended,478665,"ecified.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". The '``call``' instruction is used to cause control flow to transfer to; a specified function, with its incoming arguments bound to the specified; values. Upon a '``ret``' instruction in the called function, control; flow continues with the instruction after the function call, and the; return value of the function is bound to the result argument. Example:; """""""""""""""". .. code-block:: llvm. %retval = call i32 @test(i32 %argc); call i32 (ptr, ...) @printf(ptr %msg, i32 12, i8 42) ; yields i32; %X = tail call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z = call void @foo() noreturn ; indicates that %foo never returns normally; %ZZ = call zeroext i32 @bar() ; Return value is %zero extended. llvm treats calls to some functions with names and arguments that match; the standard C99 library as being the C99 library functions, and may; perform optimizations or generate code for them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:479267,Modifiability,variab,variable,479267,"call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z = call void @foo() noreturn ; indicates that %foo never returns normally; %ZZ = call zeroext i32 @bar() ; Return value is %zero extended. llvm treats calls to some functions with names and arguments that match; the standard C99 library as being the C99 library functions, and may; perform optimizations or generate code for them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument proc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:479841,Modifiability,variab,variable,479841," them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument processing <int_varargs>` section. Note that the code generator does not yet fully support va\_arg on many; targets. Also, it does not currently support va\_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.h",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:479994,Modifiability,variab,variable,479994,"nvironments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument processing <int_varargs>` section. Note that the code generator does not yet fully support va\_arg on many; targets. Also, it does not currently support va\_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a landing pad --- one where the exception lands, and corresponds to the; code",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:480227,Modifiability,variab,variable,480227," passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument processing <int_varargs>` section. Note that the code generator does not yet fully support va\_arg on many; targets. Also, it does not currently support va\_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a landing pad --- one where the exception lands, and corresponds to the; code found in the ``catch`` portion of a ``try``/``catch`` sequence. It; defines values supplied by the :ref:`personality function <personalityfn>` upon; re-entry to the function. The ``resultval`` has the type ``resultty``. Arguments:; """""""""""""""""""". The optional; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:481412,Modifiability,variab,variable,481412,"_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a landing pad --- one where the exception lands, and corresponds to the; code found in the ``catch`` portion of a ``try``/``catch`` sequence. It; defines values supplied by the :ref:`personality function <personalityfn>` upon; re-entry to the function. The ``resultval`` has the type ``resultty``. Arguments:; """""""""""""""""""". The optional; ``cleanup`` flag indicates that the landing pad block is a cleanup. A ``clause`` begins with the clause type --- ``catch`` or ``filter`` --- and; contains the global variable representing the ""type"" that may be caught; or filtered respectively. Unlike the ``catch`` clause, the ``filter``; clause takes an array constant as its argument. Use; ""``[0 x ptr] undef``"" for a filter which cannot throw. The; '``landingpad``' instruction must contain *at least* one ``clause`` or; the ``cleanup`` flag. Semantics:; """""""""""""""""""". The '``landingpad``' instruction defines the values which are set by the; :ref:`personality function <personalityfn>` upon re-entry to the function, and; therefore the ""result type"" of the ``landingpad`` instruction. As with; calling conventions, how the personality function results are; represented in LLVM IR is target specific. The clauses are applied in order from top to bottom. If two; ``landingpad`` instructions are merged together through inlining, the; clauses from the calling function are appended to the list of clauses.; When the call stack is being unwound due to an exception being thrown,; the exception is compared a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:492220,Modifiability,variab,variable,492220,"and; FP intrinsics rather than rely on overloading. For example, if different; codegen is required for ``llvm.target.foo(<4 x i32>)`` and; ``llvm.target.foo(<4 x float>)`` then these should be split into; different intrinsics. To learn how to add an intrinsic function, please see the `Extending; LLVM Guide <ExtendingLLVM.html>`_. .. _int_varargs:. Variable Argument Handling Intrinsics; -------------------------------------. Variable argument support is defined in LLVM with the; :ref:`va_arg <i_va_arg>` instruction and these three intrinsic; functions. These functions are related to the similarly named macros; defined in the ``<stdarg.h>`` header file. All of these functions operate on arguments that use a target-specific; value type ""``va_list``"". The LLVM assembly language reference manual; does not define what this type is, so all transformations should be; prepared to handle these functions regardless of the type used. This example shows how the :ref:`va_arg <i_va_arg>` instruction and the; variable argument handling intrinsic functions are used. .. code-block:: llvm. ; This struct is different for every platform. For most platforms,; ; it is merely a ptr.; %struct.va_list = type { ptr }. ; For Unix x86_64 platforms, va_list is the following struct:; ; %struct.va_list = type { i32, i32, ptr, ptr }. define i32 @test(i32 %X, ...) {; ; Initialize variable argument processing; %ap = alloca %struct.va_list; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <argl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:492580,Modifiability,variab,variable,492580,"cs; -------------------------------------. Variable argument support is defined in LLVM with the; :ref:`va_arg <i_va_arg>` instruction and these three intrinsic; functions. These functions are related to the similarly named macros; defined in the ``<stdarg.h>`` header file. All of these functions operate on arguments that use a target-specific; value type ""``va_list``"". The LLVM assembly language reference manual; does not define what this type is, so all transformations should be; prepared to handle these functions regardless of the type used. This example shows how the :ref:`va_arg <i_va_arg>` instruction and the; variable argument handling intrinsic functions are used. .. code-block:: llvm. ; This struct is different for every platform. For most platforms,; ; it is merely a ptr.; %struct.va_list = type { ptr }. ; For Unix x86_64 platforms, va_list is the following struct:; ; %struct.va_list = type { i32, i32, ptr, ptr }. define i32 @test(i32 %X, ...) {; ; Initialize variable argument processing; %ap = alloca %struct.va_list; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for; subsequent use by ``va_arg``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:493696,Modifiability,variab,variable,493696,"; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for; subsequent use by ``va_arg``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list`` element to which the argument points, so that the next call; to ``va_arg`` will produce the first variable argument passed to the; function. Unlike the C ``va_start`` macro, this intrinsic does not need; to know the last argument of the function as the compiler can figure; that out. '``llvm.va_end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_end(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been; initialized previously with ``llvm.va_start`` or ``llvm.va_copy``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` to destroy. Semantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:501822,Modifiability,variab,variable,501822,"' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specifie",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:512921,Modifiability,extend,extended,512921,"trinsic indicates which function to return the; frame pointer for. Zero indicates the calling function, one indicates; its caller, etc. The argument is **required** to be a constant integer; value. Semantics:; """""""""""""""""""". The '``llvm.frameaddress``' intrinsic either returns a pointer; indicating the frame address of the specified call frame, or zero if it; cannot be identified. The value returned by this intrinsic is likely to; be incorrect or 0 for arguments other than zero, so it should only be; used for debugging purposes. Note that calling this intrinsic does not prevent function inlining or; other aggressive transformations, so the value returned may not be that; of the obvious source-language caller. '``llvm.swift.async.context.addr``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.swift.async.context.addr(). Overview:; """""""""""""""""". The '``llvm.swift.async.context.addr``' intrinsic returns a pointer to; the part of the extended frame record containing the asynchronous; context of a Swift execution. Semantics:; """""""""""""""""""". If the caller has a ``swiftasync`` parameter, that argument will initially; be stored at the returned address. If not, it will be initialized to null. '``llvm.localescape``' and '``llvm.localrecover``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.localescape(...); declare ptr @llvm.localrecover(ptr %func, ptr %fp, i32 %idx). Overview:; """""""""""""""""". The '``llvm.localescape``' intrinsic escapes offsets of a collection of static; allocas, and the '``llvm.localrecover``' intrinsic applies those offsets to a; live frame pointer to recover the address of the allocation. The offset is; computed during frame layout of the caller of ``llvm.localescape``. Arguments:; """""""""""""""""""". All arguments to '``llvm.localescape``' must be pointers to static allocas or; casts of static allocas. Each function can only call '``llvm.local",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:518904,Modifiability,variab,variables,518904,"a); declare i64 @llvm.read_volatile_register.i64(metadata); declare void @llvm.write_register.i32(metadata, i32 @value); declare void @llvm.write_register.i64(metadata, i64 @value); !0 = !{!""sp\00""}. Overview:; """""""""""""""""". The '``llvm.read_register``', '``llvm.read_volatile_register``', and; '``llvm.write_register``' intrinsics provide access to the named register.; The register must be valid on the architecture being compiled to. The type; needs to be compatible with the register being read. Semantics:; """""""""""""""""""". The '``llvm.read_register``' and '``llvm.read_volatile_register``' intrinsics; return the current value of the register, where possible. The; '``llvm.write_register``' intrinsic sets the current value of the register,; where possible. A call to '``llvm.read_volatile_register``' is assumed to have side-effects; and possibly return a different value each time (e.g. for a timer register). This is useful to implement named register global variables that need; to always be mapped to a specific register, as is common practice on; bare-metal programs including OS kernels. The compiler doesn't check for register availability or use of the used; register in surrounding code, including inline assembly. Because of that,; allocatable registers are not supported. Warning: So far it only works with the stack pointer on selected; architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of; work is needed to support other registers and even more so, allocatable; registers. .. _int_stacksave:. '``llvm.stacksave``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stacksave.p0(); declare ptr addrspace(5) @llvm.stacksave.p5(). Overview:; """""""""""""""""". The '``llvm.stacksave``' intrinsic is used to remember the current state; of the function stack, for use with; :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for; implementing language features like scoped automatic variable sized; arrays in C99. Semantics:; """""""""""""""""""". Thi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:519887,Modifiability,variab,variable,519887,"ful to implement named register global variables that need; to always be mapped to a specific register, as is common practice on; bare-metal programs including OS kernels. The compiler doesn't check for register availability or use of the used; register in surrounding code, including inline assembly. Because of that,; allocatable registers are not supported. Warning: So far it only works with the stack pointer on selected; architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of; work is needed to support other registers and even more so, allocatable; registers. .. _int_stacksave:. '``llvm.stacksave``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stacksave.p0(); declare ptr addrspace(5) @llvm.stacksave.p5(). Overview:; """""""""""""""""". The '``llvm.stacksave``' intrinsic is used to remember the current state; of the function stack, for use with; :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for; implementing language features like scoped automatic variable sized; arrays in C99. Semantics:; """""""""""""""""""". This intrinsic returns an opaque pointer value that can be passed to; :ref:`llvm.stackrestore <int_stackrestore>`. When an; ``llvm.stackrestore`` intrinsic is executed with a value saved from; ``llvm.stacksave``, it effectively restores the state of the stack to; the state it was in when the ``llvm.stacksave`` intrinsic executed. In; practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack; that were allocated after the ``llvm.stacksave`` was executed. The; address space should typically be the; :ref:`alloca address space <alloca_addrspace>`. .. _int_stackrestore:. '``llvm.stackrestore``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackrestore.p0(ptr %ptr); declare void @llvm.stackrestore.p5(ptr addrspace(5) %ptr). Overview:; """""""""""""""""". The '``llvm.stackrestore``' intrinsic is used to restore the state of; the function stack to the state it was in when ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:521016,Modifiability,variab,variable,521016," can be passed to; :ref:`llvm.stackrestore <int_stackrestore>`. When an; ``llvm.stackrestore`` intrinsic is executed with a value saved from; ``llvm.stacksave``, it effectively restores the state of the stack to; the state it was in when the ``llvm.stacksave`` intrinsic executed. In; practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack; that were allocated after the ``llvm.stacksave`` was executed. The; address space should typically be the; :ref:`alloca address space <alloca_addrspace>`. .. _int_stackrestore:. '``llvm.stackrestore``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackrestore.p0(ptr %ptr); declare void @llvm.stackrestore.p5(ptr addrspace(5) %ptr). Overview:; """""""""""""""""". The '``llvm.stackrestore``' intrinsic is used to restore the state of; the function stack to the state it was in when the corresponding; :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is; useful for implementing language features like scoped automatic; variable sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.get.dynamic.area.offset.i32(); declare i64 @llvm.get.dynamic.area.offset.i64(). Overview:; """""""""""""""""". The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to; get the offset from native stack pointer to the address of the most; recent dynamic alloca on the caller's stack. These intrinsics are; intended for use in combination with; :ref:`llvm.stacksave <int_stacksave>` to get a; pointer to the most recent dynamic alloca. This is useful, for example,; for AddressSanitizer's stack unpoisoning routines. Semantics:; """""""""""""""""""". These intrinsics return a non-negative integer value that can",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:527306,Modifiability,variab,variable,527306,"hes (e.g. x86), this; intrinsic is a nop. On platforms with non-coherent instruction and data; cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate; instructions or a system call, if cache flushing requires special; privileges. The default behavior is to emit a call to ``__clear_cache`` from the run; time library. This intrinsic does *not* empty the instruction pipeline. Modifications; of the current function are outside the scope of the intrinsic. '``llvm.instrprof.increment``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. These will be; lowered by the ``-instrprof`` pass to generate execution counts of a; program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source, and; the third is the number of counters associated with ``name``. It is an; error if ``hash`` or ``num-counters`` differ between two instances of; ``instrprof.increment`` that refer to the same name. The last argument refers to which of the counters for ``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:528869,Modifiability,variab,variable,528869,"``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment.step(ptr <name>, i64 <hash>,; i32 <num-counters>,; i32 <index>, i64 <step>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment.step``' intrinsic is an extension to; the '``llvm.instrprof.increment``' intrinsic with an additional fifth; argument to specify the step of the increment. Arguments:; """"""""""""""""""""; The first four arguments are the same as '``llvm.instrprof.increment``'; intrinsic. The last argument specifies the value of the increment of the counter variable. Semantics:; """"""""""""""""""""; See description of '``llvm.instrprof.increment``' intrinsic. '``llvm.instrprof.timestamp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.timestamp(i8* <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a; timestamp representing when this function was executed for the first time. '``llvm.instrprof.cover``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.cover(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.cover`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:530132,Modifiability,variab,variable,530132," <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a; timestamp representing when this function was executed for the first time. '``llvm.instrprof.cover``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.cover(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.cover``' intrinsic is used to implement coverage; instrumentation. Arguments:; """"""""""""""""""""; The arguments are the same as the first four arguments of; '``llvm.instrprof.increment``'. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an erro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:530834,Modifiability,variab,variable,530834,"trinsic is used to implement coverage; instrumentation. Arguments:; """"""""""""""""""""; The arguments are the same as the first four arguments of; '``llvm.instrprof.increment``'. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:532500,Modifiability,variab,variable,532500,"d through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <has",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:533813,Modifiability,variab,variable,533813,"tes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:535584,Modifiability,variab,variable,535584," in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is the address of the condition bitmap, which contains a; value representing an executed MC/DC test vector. It is loaded and used as the; bit index of the test vector bitmap. Semantics:; """""""""""""""""""". This intrinsic represents the final operation of an MC/DC instrumentation; sequence and will cause the ``-instrprof`` pass to generate the code to; instrument an update of a function's global test vector bitmap to indicate that; a test vector has been execute",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:592227,Modifiability,extend,extend,592227,"^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic function. You can use bswap on any; integer type that is an even number of bytes (i.e. BitWidth % 16 == 0). ::. declare i16 @llvm.bswap.i16(i16 <id>); declare i32 @llvm.bswap.i32(i32 <id>); declare i64 @llvm.bswap.i64(i64 <id>); declare <4 x i32> @llvm.bswap.v4i32(<4 x i32> <id>). Overview:; """""""""""""""""". The '``llvm.bswap``' family of intrinsics is used to byte swap an integer; value or vector of integer values with an even number of bytes (positive; multiple of 16 bits). Semantics:; """""""""""""""""""". The ``llvm.bswap.i16`` intrinsic returns an i16 value that has the high; and low byte of the input i16 swapped. Similarly, the ``llvm.bswap.i32``; intrinsic returns an i32 value that has the four bytes of the input i32; swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the; returned i32 will have its bytes in 3, 2, 1, 0 order. The; ``llvm.bswap.i48``, ``llvm.bswap.i64`` and other intrinsics extend this; concept to additional even-byte lengths (6 bytes, 8 bytes and more,; respectively). The vector intrinsics, such as ``llvm.bswap.v4i32``,; operate on a per-element basis and the element order is not affected. .. _int_ctpop:. '``llvm.ctpop.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.ctpop on any integer; bit width, or on any vector with integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.ctpop.i8(i8 <src>); declare i16 @llvm.ctpop.i16(i16 <src>); declare i32 @llvm.ctpop.i32(i32 <src>); declare i64 @llvm.ctpop.i64(i64 <src>); declare i256 @llvm.ctpop.i256(i256 <src>); declare <2 x i32> @llvm.ctpop.v2i32(<2 x i32> <src>). Overview:; """""""""""""""""". The '``llvm.ctpop``' family of intrinsics counts the number of bits set; in a value. Arguments:; """""""""""""""""""". The only argument is the value to be counted. The argument may be of any; integer type, or a vector with integer elements. The return type mus",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:593365,Modifiability,variab,variable,593365,"v4i32``,; operate on a per-element basis and the element order is not affected. .. _int_ctpop:. '``llvm.ctpop.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.ctpop on any integer; bit width, or on any vector with integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.ctpop.i8(i8 <src>); declare i16 @llvm.ctpop.i16(i16 <src>); declare i32 @llvm.ctpop.i32(i32 <src>); declare i64 @llvm.ctpop.i64(i64 <src>); declare i256 @llvm.ctpop.i256(i256 <src>); declare <2 x i32> @llvm.ctpop.v2i32(<2 x i32> <src>). Overview:; """""""""""""""""". The '``llvm.ctpop``' family of intrinsics counts the number of bits set; in a value. Arguments:; """""""""""""""""""". The only argument is the value to be counted. The argument may be of any; integer type, or a vector with integer elements. The return type must; match the argument type. Semantics:; """""""""""""""""""". The '``llvm.ctpop``' intrinsic counts the 1's in a variable, or within; each element of a vector. .. _int_ctlz:. '``llvm.ctlz.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any; integer bit width, or any vector whose elements are integers. Not all; targets support all bit widths or vector types, however. ::. declare i8 @llvm.ctlz.i8 (i8 <src>, i1 <is_zero_poison>); declare <2 x i37> @llvm.ctlz.v2i37(<2 x i37> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.ctlz``' family of intrinsic functions counts the number of; leading zeros in a variable. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:593947,Modifiability,variab,variable,593947,"tpop.i256(i256 <src>); declare <2 x i32> @llvm.ctpop.v2i32(<2 x i32> <src>). Overview:; """""""""""""""""". The '``llvm.ctpop``' family of intrinsics counts the number of bits set; in a value. Arguments:; """""""""""""""""""". The only argument is the value to be counted. The argument may be of any; integer type, or a vector with integer elements. The return type must; match the argument type. Semantics:; """""""""""""""""""". The '``llvm.ctpop``' intrinsic counts the 1's in a variable, or within; each element of a vector. .. _int_ctlz:. '``llvm.ctlz.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any; integer bit width, or any vector whose elements are integers. Not all; targets support all bit widths or vector types, however. ::. declare i8 @llvm.ctlz.i8 (i8 <src>, i1 <is_zero_poison>); declare <2 x i37> @llvm.ctlz.v2i37(<2 x i37> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.ctlz``' family of intrinsic functions counts the number of; leading zeros in a variable. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.ctlz``' intrinsic counts the leading (most significant); zeros in a variable, or within each element of the vector. If; ``src == 0`` then the result is the size in bits of the type of ``src``; if ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.ctlz(i32 2) = 30``. .. _int_cttz:. '``llvm.cttz.*``' Intrin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:594654,Modifiability,variab,variable,594654,"rgets support all bit widths or vector types, however. ::. declare i8 @llvm.ctlz.i8 (i8 <src>, i1 <is_zero_poison>); declare <2 x i37> @llvm.ctlz.v2i37(<2 x i37> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.ctlz``' family of intrinsic functions counts the number of; leading zeros in a variable. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.ctlz``' intrinsic counts the leading (most significant); zeros in a variable, or within each element of the vector. If; ``src == 0`` then the result is the size in bits of the type of ``src``; if ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.ctlz(i32 2) = 30``. .. _int_cttz:. '``llvm.cttz.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.cttz`` on any; integer bit width, or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:596099,Modifiability,variab,variable,596099,"ot all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.cttz``' intrinsic counts the trailing (least significant); zeros in a variable, or within each element of a vector. If ``src == 0``; then the result is the size in bits of the type of ``src`` if; ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.cttz(2) = 1``. .. _int_overflow:. .. _int_fshl:. '``llvm.fshl.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.fshl`` on any; integer bit width or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.fshl.i8 (i8 %a, i8 %b, i8 %c); declare i64 @llvm.fshl.i64(i64 %a, i64 %b, i64 %c); declare <2 x i32> @llvm.fshl.v2i32(<2 x i32> %a, <2 x i32> %b, <2 x i32> %c). Overview:; """""""""""""""""". The '``llvm.fshl``' family of intrinsic functions performs a funnel shift left:; the first two values are concatenated as { %a : %b } (%a is the most significant; bits of the wide value), the combined value is shifted left, and the most; significant bits are extracted to prod",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:602062,Modifiability,variab,variables,602062,"nsic. You can use ``llvm.sadd.with.overflow``; on any integer bit width or vectors of integers. ::. declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b); declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b); declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b); declare {<4 x i32>, <4 x i1>} @llvm.sadd.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b). Overview:; """""""""""""""""". The '``llvm.sadd.with.overflow``' family of intrinsic functions perform; a signed addition of the two arguments, and indicate whether an overflow; occurred during the signed summation. Arguments:; """""""""""""""""""". The arguments (%a and %b) and the first element of the result structure; may be of integer types of any bit width, but they must have the same; bit width. The second element of the result structure must be of type; ``i1``. ``%a`` and ``%b`` are the two values that will undergo signed; addition. Semantics:; """""""""""""""""""". The '``llvm.sadd.with.overflow``' family of intrinsic functions perform; a signed addition of the two variables. They return a structure --- the; first element of which is the signed summation, and the second element; of which is a bit specifying if the signed summation resulted in an; overflow. Examples:; """""""""""""""""". .. code-block:: llvm. %res = call {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b); %sum = extractvalue {i32, i1} %res, 0; %obit = extractvalue {i32, i1} %res, 1; br i1 %obit, label %overflow, label %normal. '``llvm.uadd.with.overflow.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.uadd.with.overflow``; on any integer bit width or vectors of integers. ::. declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b); declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b); declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b); declare {<4 x i32>, <4 x i1>} @llvm.uadd.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b). Overview:; """"""""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:644698,Modifiability,variab,variable,644698," the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.set.loop.iterations.*``' intrinsics do not perform any arithmetic; on their operand. It's a hint to the backend that can use this to set up the; hardware-loop count with a target specific instruction, usually a move of this; value to a special register or a hardware-loop instruction. '``llvm.start.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i32 @llvm.start.loop.iterations.i32(i32); declare i64 @llvm.start.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.start.loop.iterations.*``' intrinsics are similar to the; '``llvm.set.loop.iterations.*``' intrinsics, used to specify the; hardware-loop trip count but also produce a value identical to the input; that can be used as the input to the loop. They are placed in the loop; preheader basic block and the output is expected to be the input to the; phi for the induction variable of the loop, decremented by the; '``llvm.loop.decrement.reg.*``'. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.start.loop.iterations.*``' intrinsics do not perform any arithmetic; on their operand. It's a hint to the backend that can use this to set up the; hardware-loop count with a target specific instruction, usually a move of this; value to a special register or a hardware-loop instruction. '``llvm.test.set.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.test.set.loop.iterations.i32(i32); declare i1 @llvm.test.set.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.test.set.loop.iterations.*``' intrinsics are used to specify the; the loop trip count, and also test that the given count is not zero,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:681234,Modifiability,extend,extending,681234," a positive, constant integer with; ``%Stride >= <Rows>``. ``%Stride`` is used to compute the column memory; addresses. I.e., for a column ``C``, its start memory addresses is calculated; with ``%Ptr + C * %Stride``. The fourth argument ``<IsVolatile>`` is a boolean; value. The arguments ``<Rows>`` and ``<Cols>`` correspond to the number of rows; and columns, respectively, and must be positive, constant integers. The :ref:`align <attr_align>` parameter attribute can be provided; for the ``%Ptr`` arguments. Half Precision Floating-Point Intrinsics; ----------------------------------------. For most target platforms, half precision floating-point is a; storage-only format. This means that it is a dense encoding (in memory); but does not support computation in the format. This means that code must first load the half-precision floating-point; value as an i16, then convert it to float with; :ref:`llvm.convert.from.fp16 <int_convert_from_fp16>`. Computation can; then be performed on the float value (including extending to double; etc). To store the value back to memory, it is first converted to float; if needed, then converted to i16 with; :ref:`llvm.convert.to.fp16 <int_convert_to_fp16>`, then storing as an; i16 value. .. _int_convert_to_fp16:. '``llvm.convert.to.fp16``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i16 @llvm.convert.to.fp16.f32(float %a); declare i16 @llvm.convert.to.fp16.f64(double %a). Overview:; """""""""""""""""". The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from a; conventional floating-point type to half precision floating-point format. Arguments:; """""""""""""""""""". The intrinsic function contains single argument - the value to be; converted. Semantics:; """""""""""""""""""". The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from a; conventional floating-point format to half precision floating-point format. The; return value is an ``i16`` which contains the converted number. Examples:; """"""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:689743,Modifiability,portab,portable,689743,"s:. .. code-block:: llvm. %tramp = alloca [10 x i8], align 4 ; size and alignment only correct for X86; call ptr @llvm.init.trampoline(ptr %tramp, ptr @f, ptr %nval); %fp = call ptr @llvm.adjust.trampoline(ptr %tramp). The call ``%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to; ``%val = call i32 %f(ptr %nval, i32 %x, i32 %y)``. .. _int_it:. '``llvm.init.trampoline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.init.trampoline(ptr <tramp>, ptr <func>, ptr <nval>). Overview:; """""""""""""""""". This fills the memory pointed to by ``tramp`` with executable code,; turning it into a trampoline. Arguments:; """""""""""""""""""". The ``llvm.init.trampoline`` intrinsic takes three arguments, all; pointers. The ``tramp`` argument must point to a sufficiently large and; sufficiently aligned block of memory; this memory is written to by the; intrinsic. Note that the size and the alignment are target-specific -; LLVM currently provides no portable way of determining them, so a; front-end that generates this intrinsic needs to have some; target-specific knowledge. The ``func`` argument must hold a function. Semantics:; """""""""""""""""""". The block of memory pointed to by ``tramp`` is filled with target; dependent code, turning it into a function. Then ``tramp`` needs to be; passed to :ref:`llvm.adjust.trampoline <int_at>` to get a pointer which can; be :ref:`bitcast (to a new function) and called <int_trampoline>`. The new; function's signature is the same as that of ``func`` with any arguments; marked with the ``nest`` attribute removed. At most one such ``nest``; argument is allowed, and it must be of pointer type. Calling the new; function is equivalent to calling ``func`` with the same argument list,; but with ``nval`` used for the missing ``nest`` argument. If, after; calling ``llvm.init.trampoline``, the memory pointed to by ``tramp`` is; modified, then the effect of any later call to the returned function; pointer is undefined. .. _int_at:",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:778234,Modifiability,variab,variable,778234,"4(i64 %base, i64 %n). Overview:; """""""""""""""""". Create a mask representing active and inactive vector lanes. Arguments:; """""""""""""""""""". Both operands have the same scalar integer type. The result is a vector with; the i1 element type. Semantics:; """""""""""""""""""". The '``llvm.get.active.lane.mask.*``' intrinsics are semantically equivalent; to:. ::. %m[i] = icmp ult (%base + i), %n. where ``%m`` is a vector (mask) of active/inactive lanes with its elements; indexed by ``i``, and ``%base``, ``%n`` are the two arguments to; ``llvm.get.active.lane.mask.*``, ``%icmp`` is an integer compare and ``ult``; the unsigned less-than comparison operator. Overflow cannot occur in; ``(%base + i)`` and its comparison against ``%n`` as it is performed in integer; numbers and not in machine numbers. If ``%n`` is ``0``, then the result is a; poison value. The above is equivalent to:. ::. %m = @llvm.get.active.lane.mask(%base, %n). This can, for example, be emitted by the loop vectorizer in which case; ``%base`` is the first element of the vector induction variable (VIV) and; ``%n`` is the loop tripcount. Thus, these intrinsics perform an element-wise; less than comparison of VIV with the loop tripcount, producing a mask of; true/false values representing active/inactive vector lanes, except if the VIV; overflows in which case they return false in the lanes where the VIV overflows.; The arguments are scalar types to accommodate scalable vector types, for which; it is unknown what the type of the step vector needs to be that enumerate its; lanes without overflow. This mask ``%m`` can e.g. be used in masked load/store instructions. These; intrinsics provide a hint to the backend. I.e., for a vector loop, the; back-edge taken count of the original scalar loop is explicit as the second; argument. Examples:; """""""""""""""""". .. code-block:: llvm. %active.lane.mask = call <4 x i1> @llvm.get.active.lane.mask.v4i1.i64(i64 %elem0, i64 429); %wide.masked.load = call <4 x i32> @llvm.masked.load.v4i32.p0v4i32(<4 x i3",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:797990,Modifiability,extend,extends,797990,"he destination size, '``llvm.vp.trunc``' cannot be a *no-op cast*. It will; always truncate bits. The conversion is performed on lane positions below the; explicit vector length and where the vector mask is true. Masked-off lanes are; ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i16> @llvm.vp.trunc.v4i16.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = trunc <4 x i32> %a to <4 x i16>; %also.r = select <4 x i1> %mask, <4 x i16> %t, <4 x i16> poison. .. _int_vp_zext:. '``llvm.vp.zext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.zext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.zext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.zext``' intrinsic zero extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic fill the high order bits of the value with zero; bits until it reaches the size of the return type. When zero extending from i1,; the result will always be either 0 or 1. The conversion is performed on lane; positions below the explicit vector length and where the vector mask is true.; Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. cod",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:798764,Modifiability,extend,extending,798764,"_length>); declare <vscale x 4 x i32> @llvm.vp.zext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.zext``' intrinsic zero extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic fill the high order bits of the value with zero; bits until it reaches the size of the return type. When zero extending from i1,; the result will always be either 0 or 1. The conversion is performed on lane; positions below the explicit vector length and where the vector mask is true.; Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.zext.v4i32.v4i16(<4 x i16> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = zext <4 x i16> %a to <4 x i32>; %also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> poison. .. _int_vp_sext:. '``llvm.vp.sext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.sext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.sext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.sext``' intrinsic sign extends its first operand to the return; type. The operation has a mask and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:799714,Modifiability,extend,extends,799714,"the size of the return type. When zero extending from i1,; the result will always be either 0 or 1. The conversion is performed on lane; positions below the explicit vector length and where the vector mask is true.; Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.zext.v4i32.v4i16(<4 x i16> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = zext <4 x i16> %a to <4 x i32>; %also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> poison. .. _int_vp_sext:. '``llvm.vp.sext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.sext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.sext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.sext``' intrinsic sign extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.sext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.sext``' intrinsic performs a sign extension by copying the sign; bit (highest order bit) of the value until it reaches the size of the return; type. When sign extending from i1, the result will always be either -1 or 0.; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:800519,Modifiability,extend,extending,800519,"x i32> @llvm.vp.sext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.sext``' intrinsic sign extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.sext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.sext``' intrinsic performs a sign extension by copying the sign; bit (highest order bit) of the value until it reaches the size of the return; type. When sign extending from i1, the result will always be either -1 or 0.; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.sext.v4i32.v4i16(<4 x i16> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = sext <4 x i16> %a to <4 x i32>; %also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> poison. .. _int_vp_fptrunc:. '``llvm.vp.fptrunc.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x float> @llvm.vp.fptrunc.v16f32.v16f64 (<16 x double> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x float> @llvm.vp.trunc.nxv4f32.nxv4f64 (<vscale x 4 x double> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.fptrunc``' intrinsic truncates its first operand to the return; type. The oper",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:803395,Modifiability,extend,extends,803395,"ecute in the default :ref:`floating-point; environment <floatenv>`. The conversion is performed on lane positions below the; explicit vector length and where the vector mask is true. Masked-off lanes are; ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x float> @llvm.vp.fptrunc.v4f32.v4f64(<4 x double> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = fptrunc <4 x double> %a to <4 x float>; %also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> poison. .. _int_vp_fpext:. '``llvm.vp.fpext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x double> @llvm.vp.fpext.v16f64.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vector of; :ref:`floating-point <t_floating>` type. The bit size of the value must be; smaller than the bit size of the return type. This implies that; '``llvm.vp.fpext``' cannot be used to make a *no-op cast*. The second operand; is the vector mask. The return type, the value to cast, and the vector mask have; the same number of elements. The third operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The '``llvm.vp.fpext``' cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:804147,Modifiability,extend,extends,804147,"eclare <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vector of; :ref:`floating-point <t_floating>` type. The bit size of the value must be; smaller than the bit size of the return type. This implies that; '``llvm.vp.fpext``' cannot be used to make a *no-op cast*. The second operand; is the vector mask. The return type, the value to cast, and the vector mask have; the same number of elements. The third operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The '``llvm.vp.fpext``' cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op cast* for a floating-point cast.; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x double> @llvm.vp.fpext.v4f64.v4f32(<4 x float> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = fpext <4 x float> %a to <4 x double>; %also.r = select <4 x i1> %mask, <4 x double> %t, <4 x double> poison. .. _int_vp_fptoui:. '``llvm.vp.fptoui.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.fptoui.v16i32.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.fp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:814090,Modifiability,extend,extending,814090,"tor_length>); declare <vscale x 4 x i8> @llvm.vp.ptrtoint.nxv4i8.nxv4p0(<vscale x 4 x ptr> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>); declare <256 x i64> @llvm.vp.ptrtoint.v16i64.v16p0(<256 x ptr> <op>, <256 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.ptrtoint``' intrinsic converts its pointer to the integer return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.ptrtoint``' intrinsic takes a value to cast as its first operand; , which must be a vector of pointers, and a type to cast it to return type,; which must be a vector of :ref:`integer <t_integer>` type.; The second operand is the vector mask. The return type, the value to cast, and; the vector mask have the same number of elements.; The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.ptrtoint``' intrinsic converts value to return type by; interpreting the pointer value as an integer and either truncating or zero; extending that value to the size of the integer type.; If ``value`` is smaller than return type, then a zero extension is done. If; ``value`` is larger than return type, then a truncation is done. If they are; the same size, then nothing is done (*no-op cast*) other than a type; change.; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i8> @llvm.vp.ptrtoint.v4i8.v4p0i32(<4 x ptr> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = ptrtoint <4 x ptr> %a to <4 x i8>; %also.r = select <4 x i1> %mask, <4 x i8> %t, <4 x i8> poison. .. _int_vp_inttoptr:. '``llvm.vp.inttoptr.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x ptr> @llvm.vp.inttoptr.v16p0.v16i32 (<16 x i32> <op>,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:860981,Modifiability,variab,variables,860981,": c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as aliv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:861423,Modifiability,variab,variable,861423,"tr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:862954,Modifiability,variab,variable,862954,"s marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic spe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:864094,Modifiability,variab,variable,864094,"is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare void @llvm.invariant.end.p0(ptr <start>, i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.end``' intrinsic specifies that the contents of a; memory object are mutable. Arguments:; """""""""""""""""""". The first argument is the matching ``llvm.invariant.start`` intrinsic.; The second argument is a constant integer representing the size of the; object, or -1 if it is variable sized and the third argument is a; pointer to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that the memory is mutable aga",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:864908,Modifiability,variab,variable,864908,"start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare void @llvm.invariant.end.p0(ptr <start>, i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.end``' intrinsic specifies that the contents of a; memory object are mutable. Arguments:; """""""""""""""""""". The first argument is the matching ``llvm.invariant.start`` intrinsic.; The second argument is a constant integer representing the size of the; object, or -1 if it is variable sized and the third argument is a; pointer to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that the memory is mutable again. '``llvm.launder.invariant.group``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address; space. The returned pointer must belong to the same address space as the; argument. ::. declare ptr @llvm.launder.invariant.group.p0(ptr <ptr>). Overview:; """""""""""""""""". The '``llvm.launder.invariant.group``' intrinsic can be used when an invariant; established by ``invariant.group`` metadata no longer holds, to obtain a new; pointer value that carries fresh invariant group information. It is an; experimental intrinsic, which means that its semantics might change in the; future. Arguments:; """""""""""""""""""". The ``llvm.launder.invariant.group`` takes only one argument, which is a pointer; to the memory. Semantics:; """""""""""""""""""". Returns another point",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:882356,Modifiability,extend,extends,882356," <value>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fptrunc``' intrinsic truncates ``value``; to type ``ty2``. Arguments:; """""""""""""""""""". The first argument to the '``llvm.experimental.constrained.fptrunc``'; intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector; <t_vector>` of floating point values. This argument must be larger in size; than the result. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value truncated to be smaller in size; than the operand. '``llvm.experimental.constrained.fpext``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fpext(<type> <value>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fpext``' intrinsic extends a; floating-point ``value`` to a larger floating-point value. Arguments:; """""""""""""""""""". The first argument to the '``llvm.experimental.constrained.fpext``'; intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector; <t_vector>` of floating point values. This argument must be smaller in size; than the result. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value extended to be larger in size; than the operand. All restrictions that apply to the fpext instruction also; apply to this intrinsic. '``llvm.experimental.constrained.fcmp``' and '``llvm.experimental.constrained.fcmps``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fcmp(<type> <op1>, <type> <op2>,; metadata <condition code>,; metadata <exception behavior>); declare <ty2>; @llvm.experimental.constrained.fcmps(<type> <op",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:882826,Modifiability,extend,extended,882826," The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value truncated to be smaller in size; than the operand. '``llvm.experimental.constrained.fpext``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fpext(<type> <value>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fpext``' intrinsic extends a; floating-point ``value`` to a larger floating-point value. Arguments:; """""""""""""""""""". The first argument to the '``llvm.experimental.constrained.fpext``'; intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector; <t_vector>` of floating point values. This argument must be smaller in size; than the result. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value extended to be larger in size; than the operand. All restrictions that apply to the fpext instruction also; apply to this intrinsic. '``llvm.experimental.constrained.fcmp``' and '``llvm.experimental.constrained.fcmps``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fcmp(<type> <op1>, <type> <op2>,; metadata <condition code>,; metadata <exception behavior>); declare <ty2>; @llvm.experimental.constrained.fcmps(<type> <op1>, <type> <op2>,; metadata <condition code>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fcmp``' and; '``llvm.experimental.constrained.fcmps``' intrinsics return a boolean; value or vector of boolean values based on comparison of its operands. If the operands are floating-point scalars, then the result type is a; boolean (:ref:`i1 <t_integer>`). If the operands are floating-point vectors, then ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:924635,Modifiability,variab,variables,924635,"point exceptions. The; function does not canonicalize its input value and does not depend; on the floating-point environment. If the floating-point environment; has a zeroing treatment of subnormal input values (such as indicated; by the ``""denormal-fp-math""`` attribute), a subnormal value will be; observed (will not be implicitly treated as zero). General Intrinsics; ------------------. This class of intrinsics is designed to be generic and has no specific; purpose. '``llvm.var.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.var.annotation(ptr <val>, ptr <str>, ptr <str>, i32 <int>). Overview:; """""""""""""""""". The '``llvm.var.annotation``' intrinsic. Arguments:; """""""""""""""""""". The first argument is a pointer to a value, the second is a pointer to a; global string, the third is a pointer to a global string which is the; source file name, and the last argument is the line number. Semantics:; """""""""""""""""""". This intrinsic allows annotation of local variables with arbitrary; strings. This can be useful for special purpose optimizations that want; to look for these annotations. These have no other defined use; they are; ignored by code generation and optimization. '``llvm.ptr.annotation.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use '``llvm.ptr.annotation``' on a; pointer to an integer of any width. *NOTE* you must specify an address space for; the pointer. The identifier for the default address space is the integer; '``0``'. ::. declare ptr @llvm.ptr.annotation.p0(ptr <val>, ptr <str>, ptr <str>, i32 <int>); declare ptr @llvm.ptr.annotation.p1(ptr addrspace(1) <val>, ptr <str>, ptr <str>, i32 <int>). Overview:; """""""""""""""""". The '``llvm.ptr.annotation``' intrinsic. Arguments:; """""""""""""""""""". The first argument is a pointer to an integer value of arbitrary bitwidth; (result of some expression), the second is a pointer to a global string, the; third is a pointer to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:929923,Modifiability,variab,variables,929923,"code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930125,Modifiability,variab,variable,930125,"; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Argument",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930358,Modifiability,variab,variables,930358,""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930417,Modifiability,variab,variable,930417," somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same thread. On other platforms, it returns the same; global variable value, if any, e.g. ``@__stack_chk_guard``. Currently some platform",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:931362,Modifiability,variab,variable,931362,"e local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same thread. On other platforms, it returns the same; global variable value, if any, e.g. ``@__stack_chk_guard``. Currently some platforms have IR-level customized stack guard loading (e.g.; X86 Linux) that is not handled by ``llvm.stackguard()``, while they should be; in the future. '``llvm.objectsize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.objectsize.i32(ptr <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>); declare i64 @llvm.objectsize.i64(ptr <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>). Overview:; """""""""""""""""". The ``llvm.objectsize`` intrinsic is designed to provide information to the; optimizer to determine whether a) an operation (like memcpy) will overflow a; buffer that corresponds to an object, or b) that a runtime check for overflow; isn't necessary. An object in this context means an allocation of a specific; class, structure, array, or other object. Arguments:; """""""""""""""""""". The ``llvm.objectsize`` intrinsic takes four arguments. The first argument is a; pointer to or in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:955127,Modifiability,extend,extended,955127,"s; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local global is not a constant, since it depends on; the calling thread. The `llvm.threadlocal.address` intrinsic returns the; address of the given thread local global in the calling thread. .. _int_vscale:. '``llvm.vscale``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 llvm.vscale.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:710,Performance,load,loading,710,"==============================; LLVM Language Reference Manual; ==============================. .. contents::; :local:; :depth: 3. Abstract; ========. This document is a reference manual for the LLVM assembly language. LLVM; is a Static Single Assignment (SSA) based representation that provides; type safety, low-level operations, flexibility, and the capability of; representing 'all' high-level languages cleanly. It is the common code; representation used throughout all phases of the LLVM compilation; strategy. Introduction; ============. The LLVM code representation is designed to be used in three different; forms: as an in-memory compiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:1560,Performance,optimiz,optimizations,1560,"mpiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:2427,Performance,optimiz,optimizer,2427,"icroprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come in two basic types: global and local. Global; identifiers (functions, global variables) begin with the ``'@'``; character. Local identifiers (register names, types) begin with the; ``'%'`` character. Additionally, there are three different formats for; identifiers, for different purposes:. #. Named values are represented as a string of characters with their; prefix. For example, ``%foo``, ``@DivisionByZero``,; ``%a.really.long.identifier``. The actual regular expression used is; '``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*``'. Identifiers that require other; characters in their names can be surrounded with quotes. Special; characters may be escaped using ``""\xx""`` where ``xx`` is the ASCII; code for the character in hexadecimal. In this way, any character ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:8259,Performance,optimiz,optimizations,8259,"les and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references can be updated. This; doesn't show up in any symbol table in the object file.; ``internal``; Similar to private, but the value shows as a local symbol; (``STB_LOCAL`` in the case of ELF) in the object file. This; corresponds to the notion of the '``static``' keyword in C.; ``available_externally``; Globals with ""``available_externally``"" linkage are never emitted into; the object file corresponding to the LLVM module. From the linker's; perspective, an ``available_externally`` global is equivalent to; an external declaration. They exist to allow inlining and other; optimizations to take place given knowledge of the definition of the; global, which is known to be somewhere outside the module. Globals; with ``available_externally`` linkage are allowed to be discarded at; will, and allow inlining and other optimizations. This linkage type is; only allowed on definitions, not declarations.; ``linkonce``; Globals with ""``linkonce``"" linkage are merged with other globals of; the same name when linkage occurs. This can be used to implement; some forms of inline functions, templates, or other code which must; be generated in each translation unit that uses it, but where the; body may be overridden with a more definitive definition later.; Unreferenced ``linkonce`` globals are allowed to be discarded. Note; that ``linkonce`` linkage does not actually allow the optimizer to; inline the body of this function into callers because it doesn't; know if this definition of the function is the definitive definition; within the program or whether it will be overridden by a stronger; definition. To enable inl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:8502,Performance,optimiz,optimizations,8502,"y objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references can be updated. This; doesn't show up in any symbol table in the object file.; ``internal``; Similar to private, but the value shows as a local symbol; (``STB_LOCAL`` in the case of ELF) in the object file. This; corresponds to the notion of the '``static``' keyword in C.; ``available_externally``; Globals with ""``available_externally``"" linkage are never emitted into; the object file corresponding to the LLVM module. From the linker's; perspective, an ``available_externally`` global is equivalent to; an external declaration. They exist to allow inlining and other; optimizations to take place given knowledge of the definition of the; global, which is known to be somewhere outside the module. Globals; with ``available_externally`` linkage are allowed to be discarded at; will, and allow inlining and other optimizations. This linkage type is; only allowed on definitions, not declarations.; ``linkonce``; Globals with ""``linkonce``"" linkage are merged with other globals of; the same name when linkage occurs. This can be used to implement; some forms of inline functions, templates, or other code which must; be generated in each translation unit that uses it, but where the; body may be overridden with a more definitive definition later.; Unreferenced ``linkonce`` globals are allowed to be discarded. Note; that ``linkonce`` linkage does not actually allow the optimizer to; inline the body of this function into callers because it doesn't; know if this definition of the function is the definitive definition; within the program or whether it will be overridden by a stronger; definition. To enable inlining and other optimizations, use; ""``linkonce_odr``"" linkage.; ``weak``; ""``weak``"" linkage has the same merging semantics as ``linkonce``; linkage",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:9061,Performance,optimiz,optimizer,9061,"``available_externally`` global is equivalent to; an external declaration. They exist to allow inlining and other; optimizations to take place given knowledge of the definition of the; global, which is known to be somewhere outside the module. Globals; with ``available_externally`` linkage are allowed to be discarded at; will, and allow inlining and other optimizations. This linkage type is; only allowed on definitions, not declarations.; ``linkonce``; Globals with ""``linkonce``"" linkage are merged with other globals of; the same name when linkage occurs. This can be used to implement; some forms of inline functions, templates, or other code which must; be generated in each translation unit that uses it, but where the; body may be overridden with a more definitive definition later.; Unreferenced ``linkonce`` globals are allowed to be discarded. Note; that ``linkonce`` linkage does not actually allow the optimizer to; inline the body of this function into callers because it doesn't; know if this definition of the function is the definitive definition; within the program or whether it will be overridden by a stronger; definition. To enable inlining and other optimizations, use; ""``linkonce_odr``"" linkage.; ``weak``; ""``weak``"" linkage has the same merging semantics as ``linkonce``; linkage, except that unreferenced globals with ``weak`` linkage may; not be discarded. This is used for globals that are declared ""weak""; in C source code.; ``common``; ""``common``"" linkage is most similar to ""``weak``"" linkage, but they; are used for tentative definitions in C, such as ""``int X;``"" at; global scope. Symbols with ""``common``"" linkage are merged in the; same way as ``weak symbols``, and they may not be deleted if; unreferenced. ``common`` symbols may not have an explicit section,; must have a zero initializer, and may not be marked; ':ref:`constant <globalvars>`'. Functions and aliases may not have; common linkage. .. _linkage_appending:. ``appending``; ""``appending``"" linkag",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:9319,Performance,optimiz,optimizations,9319,"; global, which is known to be somewhere outside the module. Globals; with ``available_externally`` linkage are allowed to be discarded at; will, and allow inlining and other optimizations. This linkage type is; only allowed on definitions, not declarations.; ``linkonce``; Globals with ""``linkonce``"" linkage are merged with other globals of; the same name when linkage occurs. This can be used to implement; some forms of inline functions, templates, or other code which must; be generated in each translation unit that uses it, but where the; body may be overridden with a more definitive definition later.; Unreferenced ``linkonce`` globals are allowed to be discarded. Note; that ``linkonce`` linkage does not actually allow the optimizer to; inline the body of this function into callers because it doesn't; know if this definition of the function is the definitive definition; within the program or whether it will be overridden by a stronger; definition. To enable inlining and other optimizations, use; ""``linkonce_odr``"" linkage.; ``weak``; ""``weak``"" linkage has the same merging semantics as ``linkonce``; linkage, except that unreferenced globals with ``weak`` linkage may; not be discarded. This is used for globals that are declared ""weak""; in C source code.; ``common``; ""``common``"" linkage is most similar to ""``weak``"" linkage, but they; are used for tentative definitions in C, such as ""``int X;``"" at; global scope. Symbols with ""``common``"" linkage are merged in the; same way as ``weak symbols``, and they may not be deleted if; unreferenced. ``common`` symbols may not have an explicit section,; must have a zero initializer, and may not be marked; ':ref:`constant <globalvars>`'. Functions and aliases may not have; common linkage. .. _linkage_appending:. ``appending``; ""``appending``"" linkage may only be applied to global variables of; pointer to array type. When two global variables with appending; linkage are linked together, the two global arrays are appended; togethe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:12803,Performance,optimiz,optimized,12803,"lling convention; specified for the call. The calling convention of any pair of dynamic; caller/callee must match, or the behavior of the program is undefined.; The following calling conventions are supported by LLVM, and more may be; added in the future:. ""``ccc``"" - The C calling convention; This calling convention (the default if no other calling convention; is specified) matches the target C calling conventions. This calling; convention supports varargs function calls and tolerates some; mismatch in the declared prototype and implemented declaration of; the function (as does normal C).; ""``fastcc``"" - The fast calling convention; This calling convention attempts to make calls as fast as possible; (e.g. by passing things in registers). This calling convention; allows the target to use whatever tricks it wants to produce fast; code for the target, without having to conform to an externally; specified ABI (Application Binary Interface). `Tail calls can only; be optimized when this, the tailcc, the GHC or the HiPE convention is; used. <CodeGenerator.html#tail-call-optimization>`_ This calling; convention does not support varargs and requires the prototype of all; callees to exactly match the prototype of the function definition.; ""``coldcc``"" - The cold calling convention; This calling convention attempts to make code in the caller as; efficient as possible under the assumption that the call is not; commonly executed. As such, these calls often preserve all registers; so that the call does not break any live ranges in the caller side.; This calling convention does not support varargs and requires the; prototype of all callees to exactly match the prototype of the; function definition. Furthermore the inliner doesn't consider such function; calls for inlining.; ""``ghccc``"" - GHC convention; This calling convention has been implemented specifically for use by; the `Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_.; It passes everything in registers, going ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:12907,Performance,optimiz,optimization,12907,"d.; The following calling conventions are supported by LLVM, and more may be; added in the future:. ""``ccc``"" - The C calling convention; This calling convention (the default if no other calling convention; is specified) matches the target C calling conventions. This calling; convention supports varargs function calls and tolerates some; mismatch in the declared prototype and implemented declaration of; the function (as does normal C).; ""``fastcc``"" - The fast calling convention; This calling convention attempts to make calls as fast as possible; (e.g. by passing things in registers). This calling convention; allows the target to use whatever tricks it wants to produce fast; code for the target, without having to conform to an externally; specified ABI (Application Binary Interface). `Tail calls can only; be optimized when this, the tailcc, the GHC or the HiPE convention is; used. <CodeGenerator.html#tail-call-optimization>`_ This calling; convention does not support varargs and requires the prototype of all; callees to exactly match the prototype of the function definition.; ""``coldcc``"" - The cold calling convention; This calling convention attempts to make code in the caller as; efficient as possible under the assumption that the call is not; commonly executed. As such, these calls often preserve all registers; so that the call does not break any live ranges in the caller side.; This calling convention does not support varargs and requires the; prototype of all callees to exactly match the prototype of the; function definition. Furthermore the inliner doesn't consider such function; calls for inlining.; ""``ghccc``"" - GHC convention; This calling convention has been implemented specifically for use by; the `Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_.; It passes everything in registers, going to extremes to achieve this; by disabling callee save registers. This calling convention should; not be used lightly but only for specific situations such a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:14027,Performance,perform,performance,14027,"f all; callees to exactly match the prototype of the function definition.; ""``coldcc``"" - The cold calling convention; This calling convention attempts to make code in the caller as; efficient as possible under the assumption that the call is not; commonly executed. As such, these calls often preserve all registers; so that the call does not break any live ranges in the caller side.; This calling convention does not support varargs and requires the; prototype of all callees to exactly match the prototype of the; function definition. Furthermore the inliner doesn't consider such function; calls for inlining.; ""``ghccc``"" - GHC convention; This calling convention has been implemented specifically for use by; the `Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_.; It passes everything in registers, going to extremes to achieve this; by disabling callee save registers. This calling convention should; not be used lightly but only for specific situations such as an; alternative to the *register pinning* performance technique often; used when implementing functional programming languages. At the; moment only X86, AArch64, and RISCV support this convention. The ; following limitations exist:. - On *X86-32* only up to 4 bit type parameters are supported. No; floating-point types are supported.; - On *X86-64* only up to 10 bit type parameters and 6; floating-point parameters are supported.; - On *AArch64* only up to 4 32-bit floating-point parameters,; 4 64-bit floating-point parameters, and 10 bit type parameters; are supported.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiP",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:14740,Performance,optimiz,optimization,14740,"askell Compiler (GHC) <http://www.haskell.org/ghc>`_.; It passes everything in registers, going to extremes to achieve this; by disabling callee save registers. This calling convention should; not be used lightly but only for specific situations such as an; alternative to the *register pinning* performance technique often; used when implementing functional programming languages. At the; moment only X86, AArch64, and RISCV support this convention. The ; following limitations exist:. - On *X86-32* only up to 4 bit type parameters are supported. No; floating-point types are supported.; - On *X86-64* only up to 10 bit type parameters and 6; floating-point parameters are supported.; - On *AArch64* only up to 4 32-bit floating-point parameters,; 4 64-bit floating-point parameters, and 10 bit type parameters; are supported.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynam",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:14783,Performance,optimiz,optimization,14783,"registers, going to extremes to achieve this; by disabling callee save registers. This calling convention should; not be used lightly but only for specific situations such as an; alternative to the *register pinning* performance technique often; used when implementing functional programming languages. At the; moment only X86, AArch64, and RISCV support this convention. The ; following limitations exist:. - On *X86-32* only up to 4 bit type parameters are supported. No; floating-point types are supported.; - On *X86-64* only up to 10 bit type parameters and 6; floating-point parameters are supported.; - On *AArch64* only up to 4 32-bit floating-point parameters,; 4 64-bit floating-point parameters, and 10 bit type parameters; are supported.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that suppo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15358,Performance,optimiz,optimization,15358,"o 10 bit type parameters and 6; floating-point parameters are supported.; - On *AArch64* only up to 4 32-bit floating-point parameters,; 4 64-bit floating-point parameters, and 10 bit type parameters; are supported.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15401,Performance,optimiz,optimization,15401,"4* only up to 4 32-bit floating-point parameters,; 4 64-bit floating-point parameters, and 10 bit type parameters; are supported.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are pass",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:18256,Performance,optimiz,optimize,18256,"time functions; that have a hot path and a cold path. The hot path is usually a small piece; of code that doesn't use many registers. The cold path might need to call out to; another function and therefore only needs to preserve the caller-saved; registers, which haven't already been saved by the caller. The; `PreserveMost` calling convention is very similar to the `cold` calling; convention in terms of caller/callee-saved registers, but they are used for; different types of function calls. `coldcc` is for function calls that are; rarely executed, whereas `preserve_mostcc` function calls are intended to be; on the hot path and definitely executed a lot. Furthermore `preserve_mostcc`; doesn't prevent the inliner from inlining the function call. This calling convention will be used by a future version of the ObjectiveC; runtime and should therefore still be considered experimental at this time.; Although this convention was created to optimize certain runtime calls to; the ObjectiveC runtime, it is not limited to this runtime and might be used; by other runtimes in the future too. The current implementation only; supports X86-64, but the intention is to support more architectures in the; future.; ""``preserve_allcc``"" - The `PreserveAll` calling convention; This calling convention attempts to make the code in the caller even less; intrusive than the `PreserveMost` calling convention. This calling; convention also behaves identical to the `C` calling convention on how; arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. This removes the burden of saving and; recovering a large register set before and after the call in the caller. If; the arguments are passed in callee-saved registers, then they will be; preserved by the callee across the call. This doesn't apply for values; returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:21026,Performance,optimiz,optimized,21026,"Clang generates an access function to access C++-style TLS. The access; function generally has an entry block, an exit block and an initialization; block that is run at the first time. The entry and exit blocks can access; a few TLS IR variables, each access will be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc,; except for an additional guarantee that tail calls will be produced; whenever possible. `Tail calls can only be optimized when this, the fastcc,; the GHC or the HiPE convention is used. <CodeGenerator.html#tail-call-optimization>`_; This calling convention does not support varargs and requires the prototype of; all callees to exactly match the prototype of the function definition.; ""``swiftcc``"" - This calling convention is used for Swift language.; - On X86-64 RCX and R8 are available for additional integer returns, and; XMM2 and XMM3 are available for additional FP/vector returns.; - On iOS platforms, we use AAPCS-VFP calling convention.; ""``swifttailcc``""; This calling convention is like ``swiftcc`` in most respects, but also the; callee pops the argument area of the stack so that mandatory tail calls are; possible as in ``tailcc``.; ""``cfguard_checkcc``"" - Win",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:21199,Performance,optimiz,optimized,21199,"ll be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc,; except for an additional guarantee that tail calls will be produced; whenever possible. `Tail calls can only be optimized when this, the fastcc,; the GHC or the HiPE convention is used. <CodeGenerator.html#tail-call-optimization>`_; This calling convention does not support varargs and requires the prototype of; all callees to exactly match the prototype of the function definition.; ""``swiftcc``"" - This calling convention is used for Swift language.; - On X86-64 RCX and R8 are available for additional integer returns, and; XMM2 and XMM3 are available for additional FP/vector returns.; - On iOS platforms, we use AAPCS-VFP calling convention.; ""``swifttailcc``""; This calling convention is like ``swiftcc`` in most respects, but also the; callee pops the argument area of the stack so that mandatory tail calls are; possible as in ``tailcc``.; ""``cfguard_checkcc``"" - Windows Control Flow Guard (Check mechanism); This calling convention is used for the Control Flow Guard check function,; calls to which can be inserted before indirect calls to check that the call; target is a valid function address. The check function has no re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:21303,Performance,optimiz,optimization,21303," (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc,; except for an additional guarantee that tail calls will be produced; whenever possible. `Tail calls can only be optimized when this, the fastcc,; the GHC or the HiPE convention is used. <CodeGenerator.html#tail-call-optimization>`_; This calling convention does not support varargs and requires the prototype of; all callees to exactly match the prototype of the function definition.; ""``swiftcc``"" - This calling convention is used for Swift language.; - On X86-64 RCX and R8 are available for additional integer returns, and; XMM2 and XMM3 are available for additional FP/vector returns.; - On iOS platforms, we use AAPCS-VFP calling convention.; ""``swifttailcc``""; This calling convention is like ``swiftcc`` in most respects, but also the; callee pops the argument area of the stack so that mandatory tail calls are; possible as in ``tailcc``.; ""``cfguard_checkcc``"" - Windows Control Flow Guard (Check mechanism); This calling convention is used for the Control Flow Guard check function,; calls to which can be inserted before indirect calls to check that the call; target is a valid function address. The check function has no return value,; but it will trigger an OS-level error if the address is not a valid target.; The set of registers preserved by the check function, and the regi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25260,Performance,load,loader,25260," bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:26018,Performance,load,loaded,26018,"` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifie",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29427,Performance,optimiz,optimizer,29427,"s, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29561,Performance,optimiz,optimizer,29561,"s, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29670,Performance,optimiz,optimizer,29670,"mal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29850,Performance,optimiz,optimizer,29850,"ns to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31179,Performance,optimiz,optimization,31179,"gnment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31591,Performance,optimiz,optimization,31591," optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered addr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31677,Performance,optimiz,optimizations,31677," optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered addr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32736,Performance,optimiz,optimizations,32736,"nits that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values ar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32754,Performance,perform,performed,32754,"nits that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values ar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:33955,Performance,optimiz,optimized,33955,"t, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break thi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34707,Performance,optimiz,optimizers,34707,"es are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:36168,Performance,scalab,scalable,36168,"e variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the same type while ``{<vscale x 2 x i32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an init",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:36235,Performance,load,loads,36235,"e variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the same type while ``{<vscale x 2 x i32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an init",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:36329,Performance,scalab,scalable,36329,"ay be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the same type while ``{<vscale x 2 x i32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an initializer, section, and alignment:. .. code-block:: llvm. @G = addrspace(5) constant float 1.0, section ""foo"", align ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:36554,Performance,scalab,scalable,36554,"se the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the same type while ``{<vscale x 2 x i32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an initializer, section, and alignment:. .. code-block:: llvm. @G = addrspace(5) constant float 1.0, section ""foo"", align 4. The following example just declares a global variable. .. code-block:: llvm. @G = external global i32. The following example defines a global variable with the; ``large`` code model:. .. code-block:: llvm. @G = internal global i32 0, code_model ""large"". The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:36620,Performance,load,loads,36620,"se the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the same type while ``{<vscale x 2 x i32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an initializer, section, and alignment:. .. code-block:: llvm. @G = addrspace(5) constant float 1.0, section ""foo"", align 4. The following example just declares a global variable. .. code-block:: llvm. @G = external global i32. The following example defines a global variable with the; ``large`` code model:. .. code-block:: llvm. @G = internal global i32 0, code_model ""large"". The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:44469,Performance,optimiz,optimization,44469,"liasee expression. ``unnamed_addr`` ones are only guaranteed to point; to the same content. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. Since aliases are only a second name, some restrictions apply, of which; some can only be checked when producing an object file:. * The expression defining the aliasee must be computable at assembly; time. Since it is just a name, no relocations can be used. * No alias in the expression can be weak as the possibility of the; intermediate alias being overridden cannot be represented in an; object file. * If the alias has the ``available_externally`` linkage, the aliasee must be an; ``available_externally`` global value; otherwise the aliasee can be an; expression but no global value in the expression can be a declaration, since; that would require a relocation, which is not possible. * If either the alias or the aliasee may be replaced by a symbol outside the; module at link time or runtime, any optimization cannot replace the alias with; the aliasee, since the behavior may be different. The alias may be used as a; name guaranteed to point to the content in the current module. .. _langref_ifunc:. IFuncs; -------. IFuncs, like as aliases, don't create any new data or func. They are just a new; symbol that is resolved at runtime by calling a resolver function. On ELF platforms, IFuncs are resolved by the dynamic linker at load time. On; Mach-O platforms, they are lowered in terms of ``.symbol_resolver`` functions,; which lazily resolve the callee the first time they are called. IFunc may have an optional :ref:`linkage type <linkage>` and an optional; :ref:`visibility style <visibility>`. Syntax::. @<Name> = [Linkage] [PreemptionSpecifier] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>; [, partition ""name""]. .. _langref_comdats:. Comdats; -------. Comdat IR provides access to object file COMDAT/section group functionality; which represents interrelated section",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:44902,Performance,load,load,44902,"it is just a name, no relocations can be used. * No alias in the expression can be weak as the possibility of the; intermediate alias being overridden cannot be represented in an; object file. * If the alias has the ``available_externally`` linkage, the aliasee must be an; ``available_externally`` global value; otherwise the aliasee can be an; expression but no global value in the expression can be a declaration, since; that would require a relocation, which is not possible. * If either the alias or the aliasee may be replaced by a symbol outside the; module at link time or runtime, any optimization cannot replace the alias with; the aliasee, since the behavior may be different. The alias may be used as a; name guaranteed to point to the content in the current module. .. _langref_ifunc:. IFuncs; -------. IFuncs, like as aliases, don't create any new data or func. They are just a new; symbol that is resolved at runtime by calling a resolver function. On ELF platforms, IFuncs are resolved by the dynamic linker at load time. On; Mach-O platforms, they are lowered in terms of ``.symbol_resolver`` functions,; which lazily resolve the callee the first time they are called. IFunc may have an optional :ref:`linkage type <linkage>` and an optional; :ref:`visibility style <visibility>`. Syntax::. @<Name> = [Linkage] [PreemptionSpecifier] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>; [, partition ""name""]. .. _langref_comdats:. Comdats; -------. Comdat IR provides access to object file COMDAT/section group functionality; which represents interrelated sections. Comdats have a name which represents the COMDAT key and a selection kind to; provide input on how the linker deduplicates comdats with the same key in two; different object files. A comdat must be included or omitted as a unit.; Discarding the whole comdat is allowed but discarding a subset is not. A global object may be a member of at most one comdat. Aliases are placed in the; same COMDAT that their aliasee c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:46455,Performance,perform,performed,46455,"nterrelated sections. Comdats have a name which represents the COMDAT key and a selection kind to; provide input on how the linker deduplicates comdats with the same key in two; different object files. A comdat must be included or omitted as a unit.; Discarding the whole comdat is allowed but discarding a subset is not. A global object may be a member of at most one comdat. Aliases are placed in the; same COMDAT that their aliasee computes to, if any. Syntax::. $<Name> = comdat SelectionKind. For selection kinds other than ``nodeduplicate``, only one of the duplicate; comdats may be retained by the linker and the members of the remaining comdats; must be discarded. The following selection kinds are supported:. ``any``; The linker may choose any COMDAT key, the choice is arbitrary.; ``exactmatch``; The linker may choose any COMDAT key but the sections must contain the; same data.; ``largest``; The linker will choose the section containing the largest COMDAT key.; ``nodeduplicate``; No deduplication is performed.; ``samesize``; The linker may choose any COMDAT key but the sections must contain the; same amount of data. - XCOFF and Mach-O don't support COMDATs.; - COFF supports all selection kinds. Non-``nodeduplicate`` selection kinds need; a non-local linkage COMDAT symbol.; - ELF supports ``any`` and ``nodeduplicate``.; - WebAssembly only supports ``any``. Here is an example of a COFF COMDAT where a function will only be selected if; the COMDAT key's section is the largest:. .. code-block:: text. $foo = comdat largest; @foo = global i32 2, comdat($foo). define void @bar() comdat($foo) {; ret void; }. In a COFF object file, this will create a COMDAT section with selection kind; ``IMAGE_COMDAT_SELECT_LARGEST`` containing the contents of the ``@foo`` symbol; and another COMDAT section with selection kind; ``IMAGE_COMDAT_SELECT_ASSOCIATIVE`` which is associated with the first COMDAT; section and contains the contents of the ``@bar`` symbol. As a syntactic sugar the ``$na",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:53282,Performance,optimiz,optimization,53282,"nt of the stack slot to; form and the known alignment of the pointer specified to the call; site. If the alignment is not specified, then the code generator; makes a target-specific assumption. .. _attr_byref:. ``byref(<ty>)``. The ``byref`` argument attribute allows specifying the pointee; memory type of an argument. This is similar to ``byval``, but does; not imply a copy is made anywhere, or that the argument is passed; on the stack. This implies the pointer is dereferenceable up to; the storage size of the type. It is not generally permissible to introduce a write to an; ``byref`` pointer. The pointer may have any address space and may; be read only. This is not a valid attribute for return values. The alignment for an ``byref`` parameter can be explicitly; specified by combining it with the ``align`` attribute, similar to; ``byval``. If the alignment is not specified, then the code generator; makes a target-specific assumption. This is intended for representing ABI constraints, and is not; intended to be inferred for optimization use. .. _attr_preallocated:. ``preallocated(<ty>)``; This indicates that the pointer parameter should really be passed by; value to the function, and that the pointer parameter's pointee has; already been initialized before the call instruction. This attribute; is only valid on LLVM pointer arguments. The argument must be the value; returned by the appropriate; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` on non; ``musttail`` calls, or the corresponding caller parameter in ``musttail``; calls, although it is ignored during codegen. A non ``musttail`` function call with a ``preallocated`` attribute in; any parameter must have a ``""preallocated""`` operand bundle. A ``musttail``; function call cannot have a ``""preallocated""`` operand bundle. The preallocated attribute requires a type argument, which must be; the same as the pointee type of the argument. The preallocated attribute also supports specifying an alignment with t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:56105,Performance,load,loads,56105,"storage, like ``inreg``, ``nest``, ``sret``, or ``byval``. The; ``inalloca`` attribute also disables LLVM's implicit lowering of; large aggregate return values, which means that frontend authors; must lower them with ``sret`` pointers. When the call site is reached, the argument allocation must have; been the most recent stack allocation that is still live, or the; behavior is undefined. It is possible to allocate additional stack; space after an argument allocation and before its call site, but it; must be cleared off with :ref:`llvm.stackrestore; <int_stackrestore>`. The inalloca attribute requires a type argument, which must be the; same as the pointee type of the argument. See :doc:`InAlloca` for more information on how to use this; attribute. ``sret(<ty>)``; This indicates that the pointer parameter specifies the address of a; structure that is the return value of the function in the source; program. This pointer must be guaranteed by the caller to be valid:; loads and stores to the structure may be assumed by the callee not; to trap and to be properly aligned. This is not a valid attribute; for return values. The sret type argument specifies the in memory type, which must be; the same as the pointee type of the argument. .. _attr_elementtype:. ``elementtype(<ty>)``. The ``elementtype`` argument attribute can be used to specify a pointer; element type in a way that is compatible with `opaque pointers; <OpaquePointers.html>`__. The ``elementtype`` attribute by itself does not carry any specific; semantics. However, certain intrinsics may require this attribute to be; present and assign it particular semantics. This will be documented on; individual intrinsics. The attribute may only be applied to pointer typed arguments of intrinsic; calls. It cannot be applied to non-intrinsic calls, and cannot be applied; to parameters on function declarations. For non-opaque pointers, the type; passed to ``elementtype`` must match the pointer element type. .. _attr_align:. ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:60216,Performance,optimiz,optimizer,60216," return values.; This attribute applies only to the particular copy of the pointer passed in; this argument. A caller could pass two copies of the same pointer with one; being annotated nocapture and the other not, and the callee could validly; capture through the non annotated parameter. .. code-block:: llvm. define void @f(ptr nocapture %a, ptr %b) {; ; (capture %b); }. call void @f(ptr @glb, ptr @glb) ; well-defined. ``nofree``; This indicates that callee does not free the pointer argument. This is not; a valid attribute for return values. .. _nest:. ``nest``; This indicates that the pointer parameter can be excised using the; :ref:`trampoline intrinsics <int_trampoline>`. This is not a valid; attribute for return values and can only be applied to one parameter. ``returned``; This indicates that the function always returns the argument as its return; value. This is a hint to the optimizer and code generator used when; generating the caller, allowing value propagation, tail call optimization,; and omission of register saves and restores in some cases; it is not; checked or enforced when generating the callee. The parameter and the; function return type must be valid operands for the; :ref:`bitcast instruction <i_bitcast>`. This is not a valid attribute for; return values and can only be applied to one parameter. ``nonnull``; This indicates that the parameter or return pointer is not null. This; attribute may only be applied to pointer typed parameters. This is not; checked or enforced by LLVM; if the parameter or return pointer is null,; :ref:`poison value <poisonvalues>` is returned or passed instead.; The ``nonnull`` attribute should be combined with the ``noundef`` attribute; to ensure a pointer is not null or otherwise the behavior is undefined. ``dereferenceable(<n>)``; This indicates that the parameter or return pointer is dereferenceable. This; attribute may only be applied to pointer typed parameters. A pointer that; is dereferenceable can be loaded from s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:60317,Performance,optimiz,optimization,60317," return values.; This attribute applies only to the particular copy of the pointer passed in; this argument. A caller could pass two copies of the same pointer with one; being annotated nocapture and the other not, and the callee could validly; capture through the non annotated parameter. .. code-block:: llvm. define void @f(ptr nocapture %a, ptr %b) {; ; (capture %b); }. call void @f(ptr @glb, ptr @glb) ; well-defined. ``nofree``; This indicates that callee does not free the pointer argument. This is not; a valid attribute for return values. .. _nest:. ``nest``; This indicates that the pointer parameter can be excised using the; :ref:`trampoline intrinsics <int_trampoline>`. This is not a valid; attribute for return values and can only be applied to one parameter. ``returned``; This indicates that the function always returns the argument as its return; value. This is a hint to the optimizer and code generator used when; generating the caller, allowing value propagation, tail call optimization,; and omission of register saves and restores in some cases; it is not; checked or enforced when generating the callee. The parameter and the; function return type must be valid operands for the; :ref:`bitcast instruction <i_bitcast>`. This is not a valid attribute for; return values and can only be applied to one parameter. ``nonnull``; This indicates that the parameter or return pointer is not null. This; attribute may only be applied to pointer typed parameters. This is not; checked or enforced by LLVM; if the parameter or return pointer is null,; :ref:`poison value <poisonvalues>` is returned or passed instead.; The ``nonnull`` attribute should be combined with the ``noundef`` attribute; to ensure a pointer is not null or otherwise the behavior is undefined. ``dereferenceable(<n>)``; This indicates that the parameter or return pointer is dereferenceable. This; attribute may only be applied to pointer typed parameters. A pointer that; is dereferenceable can be loaded from s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:61308,Performance,load,loaded,61308,"all optimization,; and omission of register saves and restores in some cases; it is not; checked or enforced when generating the callee. The parameter and the; function return type must be valid operands for the; :ref:`bitcast instruction <i_bitcast>`. This is not a valid attribute for; return values and can only be applied to one parameter. ``nonnull``; This indicates that the parameter or return pointer is not null. This; attribute may only be applied to pointer typed parameters. This is not; checked or enforced by LLVM; if the parameter or return pointer is null,; :ref:`poison value <poisonvalues>` is returned or passed instead.; The ``nonnull`` attribute should be combined with the ``noundef`` attribute; to ensure a pointer is not null or otherwise the behavior is undefined. ``dereferenceable(<n>)``; This indicates that the parameter or return pointer is dereferenceable. This; attribute may only be applied to pointer typed parameters. A pointer that; is dereferenceable can be loaded from speculatively without a risk of; trapping. The number of bytes known to be dereferenceable must be provided; in parentheses. It is legal for the number of bytes to be less than the; size of the pointee type. The ``nonnull`` attribute does not imply; dereferenceability (consider a pointer to one element past the end of an; array), however ``dereferenceable(<n>)`` does imply ``nonnull`` in; ``addrspace(0)`` (which is the default address space), except if the; ``null_pointer_is_valid`` function attribute is present.; ``n`` should be a positive number. The pointer should be well defined,; otherwise it is undefined behavior. This means ``dereferenceable(<n>)``; implies ``noundef``. ``dereferenceable_or_null(<n>)``; This indicates that the parameter or return value isn't both; non-null and non-dereferenceable (up to ``<n>`` bytes) at the same; time. All non-null pointers tagged with; ``dereferenceable_or_null(<n>)`` are ``dereferenceable(<n>)``.; For address space 0 ``dereferenceable_o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:63197,Performance,optimiz,optimize,63197,"-null pointers tagged with; ``dereferenceable_or_null(<n>)`` are ``dereferenceable(<n>)``.; For address space 0 ``dereferenceable_or_null(<n>)`` implies that; a pointer is exactly one of ``dereferenceable(<n>)`` or ``null``,; and in other address spaces ``dereferenceable_or_null(<n>)``; implies that a pointer is at least one of ``dereferenceable(<n>)``; or ``null`` (i.e. it may be both ``null`` and; ``dereferenceable(<n>)``). This attribute may only be applied to; pointer typed parameters. ``swiftself``; This indicates that the parameter is the self/context parameter. This is not; a valid attribute for return values and can only be applied to one; parameter. .. _swiftasync:. ``swiftasync``; This indicates that the parameter is the asynchronous context parameter and; triggers the creation of a target-specific extended frame record to store; this pointer. This is not a valid attribute for return values and can only; be applied to one parameter. ``swifterror``; This attribute is motivated to model and optimize Swift error handling. It; can be applied to a parameter with pointer to pointer type or a; pointer-sized alloca. At the call site, the actual argument that corresponds; to a ``swifterror`` parameter has to come from a ``swifterror`` alloca or; the ``swifterror`` parameter of the caller. A ``swifterror`` value (either; the parameter or the alloca) can only be loaded and stored from, or used as; a ``swifterror`` argument. This is not a valid attribute for return values; and can only be applied to one parameter. These constraints allow the calling convention to optimize access to; ``swifterror`` variables by associating them with a specific register at; call boundaries rather than placing them in memory. Since this does change; the calling convention, a function which uses the ``swifterror`` attribute; on a parameter is not ABI-compatible with one which does not. These constraints also allow LLVM to assume that a ``swifterror`` argument; does not alias any other mem",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:63567,Performance,load,loaded,63567,"ay be both ``null`` and; ``dereferenceable(<n>)``). This attribute may only be applied to; pointer typed parameters. ``swiftself``; This indicates that the parameter is the self/context parameter. This is not; a valid attribute for return values and can only be applied to one; parameter. .. _swiftasync:. ``swiftasync``; This indicates that the parameter is the asynchronous context parameter and; triggers the creation of a target-specific extended frame record to store; this pointer. This is not a valid attribute for return values and can only; be applied to one parameter. ``swifterror``; This attribute is motivated to model and optimize Swift error handling. It; can be applied to a parameter with pointer to pointer type or a; pointer-sized alloca. At the call site, the actual argument that corresponds; to a ``swifterror`` parameter has to come from a ``swifterror`` alloca or; the ``swifterror`` parameter of the caller. A ``swifterror`` value (either; the parameter or the alloca) can only be loaded and stored from, or used as; a ``swifterror`` argument. This is not a valid attribute for return values; and can only be applied to one parameter. These constraints allow the calling convention to optimize access to; ``swifterror`` variables by associating them with a specific register at; call boundaries rather than placing them in memory. Since this does change; the calling convention, a function which uses the ``swifterror`` attribute; on a parameter is not ABI-compatible with one which does not. These constraints also allow LLVM to assume that a ``swifterror`` argument; does not alias any other memory visible within a function and that a; ``swifterror`` alloca passed as an argument does not escape. ``immarg``; This indicates the parameter is required to be an immediate; value. This must be a trivial immediate integer or floating-point; constant. Undef or constant expressions are not valid. This is; only valid on intrinsic declarations and cannot be applied to a; call s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:63771,Performance,optimiz,optimize,63771,"y be applied to one; parameter. .. _swiftasync:. ``swiftasync``; This indicates that the parameter is the asynchronous context parameter and; triggers the creation of a target-specific extended frame record to store; this pointer. This is not a valid attribute for return values and can only; be applied to one parameter. ``swifterror``; This attribute is motivated to model and optimize Swift error handling. It; can be applied to a parameter with pointer to pointer type or a; pointer-sized alloca. At the call site, the actual argument that corresponds; to a ``swifterror`` parameter has to come from a ``swifterror`` alloca or; the ``swifterror`` parameter of the caller. A ``swifterror`` value (either; the parameter or the alloca) can only be loaded and stored from, or used as; a ``swifterror`` argument. This is not a valid attribute for return values; and can only be applied to one parameter. These constraints allow the calling convention to optimize access to; ``swifterror`` variables by associating them with a specific register at; call boundaries rather than placing them in memory. Since this does change; the calling convention, a function which uses the ``swifterror`` attribute; on a parameter is not ABI-compatible with one which does not. These constraints also allow LLVM to assume that a ``swifterror`` argument; does not alias any other memory visible within a function and that a; ``swifterror`` alloca passed as an argument does not escape. ``immarg``; This indicates the parameter is required to be an immediate; value. This must be a trivial immediate integer or floating-point; constant. Undef or constant expressions are not valid. This is; only valid on intrinsic declarations and cannot be applied to a; call site or arbitrary function. ``noundef``; This attribute applies to parameters and return values. If the value; representation contains any undefined or poison bits, the behavior is; undefined. Note that this does not refer to padding introduced by the; type'",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:70149,Performance,load,loaded,70149,"ment, even though it may read or write the memory that the; pointer points to if accessed through other pointers. If a function reads from or writes to a readnone pointer argument, the; behavior is undefined. ``readonly``; This attribute indicates that the function does not write through this; pointer argument, even though it may write to the memory that the pointer; points to. If a function writes to a readonly pointer argument, the behavior is; undefined. ``writeonly``; This attribute indicates that the function may write to, but does not read; through this pointer argument (even though it may read from the memory that; the pointer points to). If a function reads from a writeonly pointer argument, the behavior is; undefined. ``writable``; This attribute is only meaningful in conjunction with ``dereferenceable(N)``; or another attribute that implies the first ``N`` bytes of the pointer; argument are dereferenceable. In that case, the attribute indicates that the first ``N`` bytes will be; (non-atomically) loaded and stored back on entry to the function. This implies that it's possible to introduce spurious stores on entry to; the function without introducing traps or data races. This does not; necessarily hold throughout the whole function, as the pointer may escape; to a different thread during the execution of the function. See also the; :ref:`atomic optimization guide <Optimization outside atomic>`. The ""other attributes"" that imply dereferenceability are; ``dereferenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argum",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:70503,Performance,optimiz,optimization,70503,"unction writes to a readonly pointer argument, the behavior is; undefined. ``writeonly``; This attribute indicates that the function may write to, but does not read; through this pointer argument (even though it may read from the memory that; the pointer points to). If a function reads from a writeonly pointer argument, the behavior is; undefined. ``writable``; This attribute is only meaningful in conjunction with ``dereferenceable(N)``; or another attribute that implies the first ``N`` bytes of the pointer; argument are dereferenceable. In that case, the attribute indicates that the first ``N`` bytes will be; (non-atomically) loaded and stored back on entry to the function. This implies that it's possible to introduce spurious stores on entry to; the function without introducing traps or data races. This does not; necessarily hold throughout the whole function, as the pointer may escape; to a different thread during the execution of the function. See also the; :ref:`atomic optimization guide <Optimization outside atomic>`. The ""other attributes"" that imply dereferenceability are; ``dereferenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:71622,Performance,load,loads,71622,"erenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow fronte",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:72071,Performance,load,loaded,72071,"in; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the pr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:73290,Performance,load,load,73290,"lector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the prefix data. For instance, take the example of a function annotated; with a single ``i32``,. .. code-block:: llvm. define void @f() prefix i32 123 { ... }. The prefix data can be referenced as,. .. code-block:: llvm. %a = getelementptr inbounds i32, ptr @f, i32 -1; %b = load i32, ptr %a. Prefix data is laid out as if it were an initializer for a global variable; of the prefix data's type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular forma",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:73880,Performance,optimiz,optimizers,73880,"am may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the prefix data. For instance, take the example of a function annotated; with a single ``i32``,. .. code-block:: llvm. define void @f() prefix i32 123 { ... }. The prefix data can be referenced as,. .. code-block:: llvm. %a = getelementptr inbounds i32, ptr @f, i32 -1; %b = load i32, ptr %a. Prefix data is laid out as if it were an initializer for a global variable; of the prefix data's type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular format. Specifically, it must begin with a sequence of; bytes which decode to a sequence of machine instructions, valid for the; module's target, which transfer control to the point immediately succeeding; the prologue data, without performing any other visible action. This allows; the inliner and other passes to reason about the semantics of the function; definition without needing to reason about the prologue data. Obviously this; makes the format of the prologue data highly target dependent. A trivial example of valid prologue data for the x86 architecture is ``i8 144``,; which ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:74499,Performance,perform,performing,74499," type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular format. Specifically, it must begin with a sequence of; bytes which decode to a sequence of machine instructions, valid for the; module's target, which transfer control to the point immediately succeeding; the prologue data, without performing any other visible action. This allows; the inliner and other passes to reason about the semantics of the function; definition without needing to reason about the prologue data. Obviously this; makes the format of the prologue data highly target dependent. A trivial example of valid prologue data for the x86 architecture is ``i8 144``,; which encodes the ``nop`` instruction:. .. code-block:: text. define void @f() prologue i8 144 { ... }. Generally prologue data can be formed by encoding a relative branch instruction; which skips the metadata, as in this example of valid prologue data for the; x86_64 architecture, where the first two bytes encode ``jmp .+10``:. .. code-block:: text. %0 = type <{ i8, i8, ptr }>. define void @f() prologue %0 <{ i8 235, i8 8, ptr @md}> { ... }. A function may have prologue data but no body. This has similar semantics; to the ``available_externally`` li",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:75447,Performance,optimiz,optimizers,75447,"nsfer control to the point immediately succeeding; the prologue data, without performing any other visible action. This allows; the inliner and other passes to reason about the semantics of the function; definition without needing to reason about the prologue data. Obviously this; makes the format of the prologue data highly target dependent. A trivial example of valid prologue data for the x86 architecture is ``i8 144``,; which encodes the ``nop`` instruction:. .. code-block:: text. define void @f() prologue i8 144 { ... }. Generally prologue data can be formed by encoding a relative branch instruction; which skips the metadata, as in this example of valid prologue data for the; x86_64 architecture, where the first two bytes encode ``jmp .+10``:. .. code-block:: text. %0 = type <{ i8, i8, ptr }>. define void @f() prologue %0 <{ i8 235, i8 8, ptr @md}> { ... }. A function may have prologue data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _personalityfn:. Personality Function; --------------------. The ``personality`` attribute permits functions to specify what function; to use for exception handling. .. _attrgrp:. Attribute Groups; ----------------. Attribute groups are groups of attributes that are referenced by objects within; the IR. They are important for keeping ``.ll`` files readable, because a lot of; functions will use the same set of attributes. In the degenerative case of a; ``.ll`` file that corresponds to a single ``.c`` file, the single attribute; group will capture the important command line flags used to build that file. An attribute group is a module-level object. To use an attribute group, an; object references the attribute group's ID (e.g. ``#37``). An object may refer; to more than one attribute group. In that situation, the attributes from the; different groups are merged. Here is an example of attribute groups for ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:78126,Performance,optimiz,optimized,78126,"ction attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses.; ``""alloc-family""=""FAMILY""``; This indicates which ""family"" an allocator function is part of. To avoid; collisions, the family name should match the mangled name of the primary; allocator function, that is ""malloc"" for malloc/calloc/realloc/free,; ""_Znwm"" for ``::operator::new`` and ``::operator::delete``, and; ""_ZnwmSt11align_val_t"" for aligned ``::operator::new`` and; ``::operator::delete``. Matching malloc/realloc/free calls within a family; can be optimized, but mismatched ones will be left alone.; ``allockind(""KIND"")``; Describes the behavior of an allocation function. The KIND string contains comma; separated entries from the following options:. * ""alloc"": the function returns a new block of memory or null.; * ""realloc"": the function returns a new block of memory or null. If the; result is non-null the memory contents from the start of the block up to; the smaller of the original allocation size and the new allocation size; will match that of the ``allocptr`` argument and the ``allocptr``; argument is invalidated, even if the function returns the same address.; * ""free"": the function frees the block of memory specified by ``allocptr``.; Functions marked as ""free"" ``allockind`` must return void.; * ""uninitialized"": Any newly-allocated memory (either a new block from; a ""alloc"" function or the enlarged capacity from a ""realloc"" function); will be uninitialized.; * ""zeroed"": Any newly-allocated memory (either a new block fro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:82148,Performance,optimiz,optimization,82148," This is particularly useful on indirect; calls; without this we may treat such calls as though the target; is non-convergent. See :doc:`ConvergentOperations` for further details. It is an error to call :ref:`llvm.experimental.convergence.entry; <llvm.experimental.convergence.entry>` from a function that; does not have this attribute.; ``disable_sanitizer_instrumentation``; When instrumenting code with sanitizers, it can be important to skip certain; functions to ensure no instrumentation is applied to them. This attribute is not always similar to absent ``sanitize_<name>``; attributes: depending on the specific sanitizer, code can be inserted into; functions regardless of the ``sanitize_<name>`` attribute to prevent false; positive reports. ``disable_sanitizer_instrumentation`` disables all kinds of instrumentation,; taking precedence over the ``sanitize_<name>`` attributes and other compiler; flags.; ``""dontcall-error""``; This attribute denotes that an error diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``""dontcall-warn""``; This attribute denotes that a warning diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``fn_ret_thunk_extern``; This attribute tells the code generator that returns from functions should; be replaced with jumps to externally-defined architecture-specific symbols.; For X86, this symbol's identifier is ``__x86_return_thunk``.; ``""frame-pointer""``; This attribute tells the code generator whether the f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:82533,Performance,optimiz,optimization,82533,"trumenting code with sanitizers, it can be important to skip certain; functions to ensure no instrumentation is applied to them. This attribute is not always similar to absent ``sanitize_<name>``; attributes: depending on the specific sanitizer, code can be inserted into; functions regardless of the ``sanitize_<name>`` attribute to prevent false; positive reports. ``disable_sanitizer_instrumentation`` disables all kinds of instrumentation,; taking precedence over the ``sanitize_<name>`` attributes and other compiler; flags.; ``""dontcall-error""``; This attribute denotes that an error diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``""dontcall-warn""``; This attribute denotes that a warning diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``fn_ret_thunk_extern``; This attribute tells the code generator that returns from functions should; be replaced with jumps to externally-defined architecture-specific symbols.; For X86, this symbol's identifier is ``__x86_return_thunk``.; ``""frame-pointer""``; This attribute tells the code generator whether the function; should keep the frame pointer. The code generator may emit the frame pointer; even if this attribute says the frame pointer can be eliminated.; The allowed string values are:. * ``""none""`` (default) - the frame pointer can be eliminated.; * ``""non-leaf""`` - the frame pointer should be kept if the function calls; other functions.; * ``""all""`` - the frame pointer should be ke",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:83580,Performance,optimiz,optimized,83580,"ch callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``fn_ret_thunk_extern``; This attribute tells the code generator that returns from functions should; be replaced with jumps to externally-defined architecture-specific symbols.; For X86, this symbol's identifier is ``__x86_return_thunk``.; ``""frame-pointer""``; This attribute tells the code generator whether the function; should keep the frame pointer. The code generator may emit the frame pointer; even if this attribute says the frame pointer can be eliminated.; The allowed string values are:. * ``""none""`` (default) - the frame pointer can be eliminated.; * ``""non-leaf""`` - the frame pointer should be kept if the function calls; other functions.; * ``""all""`` - the frame pointer should be kept.; ``hot``; This attribute indicates that this function is a hot spot of the program; execution. The function will be optimized more aggressively and will be; placed into special subsection of the text section to improving locality. When profile feedback is enabled, this attribute has the precedence over; the profile information. By marking a function ``hot``, users can work; around the cases where the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jum",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86742,Performance,optimiz,optimization,86742,"odule (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``naked``; This attribute disables prologue / epilogue emission for the; function. This can have very system-specific consequences.; ``""no-inline-line-tables""``; When this attribute is set to true, the inliner discards source locations; when inlining code and instead uses the source location of the call site.; Breakpoints set on code that was inlined into the current function will; not fire during the execution of the inlined call sites. If the debugger; stops inside an inlined call site, it will appear to be stopped at the; outermost inlined call site.; ``no-jump-tables``; When this attribute is set to true, the jump tables and lookup tables that; can be generated from a switch case lowering are disabled.; ``nobuiltin``; This indicates that the callee function a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86869,Performance,perform,perform,86869,"odule (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``naked``; This attribute disables prologue / epilogue emission for the; function. This can have very system-specific consequences.; ``""no-inline-line-tables""``; When this attribute is set to true, the inliner discards source locations; when inlining code and instead uses the source location of the call site.; Breakpoints set on code that was inlined into the current function will; not fire during the execution of the inlined call sites. If the debugger; stops inside an inlined call site, it will appear to be stopped at the; outermost inlined call site.; ``no-jump-tables``; When this attribute is set to true, the jump tables and lookup tables that; can be generated from a switch case lowering are disabled.; ``nobuiltin``; This indicates that the callee function a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86877,Performance,optimiz,optimizations,86877,"odule (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``naked``; This attribute disables prologue / epilogue emission for the; function. This can have very system-specific consequences.; ``""no-inline-line-tables""``; When this attribute is set to true, the inliner discards source locations; when inlining code and instead uses the source location of the call site.; Breakpoints set on code that was inlined into the current function will; not fire during the execution of the inlined call sites. If the debugger; stops inside an inlined call site, it will appear to be stopped at the; outermost inlined call site.; ``no-jump-tables``; When this attribute is set to true, the jump tables and lookup tables that; can be generated from a switch case lowering are disabled.; ``nobuiltin``; This indicates that the callee function a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86919,Performance,perform,performance,86919,"odule (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``naked``; This attribute disables prologue / epilogue emission for the; function. This can have very system-specific consequences.; ``""no-inline-line-tables""``; When this attribute is set to true, the inliner discards source locations; when inlining code and instead uses the source location of the call site.; Breakpoints set on code that was inlined into the current function will; not fire during the execution of the inlined call sites. If the debugger; stops inside an inlined call site, it will appear to be stopped at the; outermost inlined call site.; ``no-jump-tables``; When this attribute is set to true, the jump tables and lookup tables that; can be generated from a switch case lowering are disabled.; ``nobuiltin``; This indicates that the callee function a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:90163,Performance,optimiz,optimizations,90163,"memory-deallocation function (``free``, for example); on a memory allocation which existed before the call. As a result, uncaptured pointers that are known to be dereferenceable; prior to a call to a function with the ``nofree`` attribute are still; known to be dereferenceable after the call. The capturing condition is; necessary in environments where the function might communicate the; pointer to another thread which then deallocates the memory. Alternatively,; ``nosync`` would ensure such communication cannot happen and even captured; pointers cannot be freed by the function. A ``nofree`` function is explicitly allowed to free memory which it; allocated or (if not ``nosync``) arrange for another thread to free; memory on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making sta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:90314,Performance,perform,perform,90314,"known to be dereferenceable; prior to a call to a function with the ``nofree`` attribute are still; known to be dereferenceable after the call. The capturing condition is; necessary in environments where the function might communicate the; pointer to another thread which then deallocates the memory. Alternatively,; ``nosync`` would ensure such communication cannot happen and even captured; pointers cannot be freed by the function. A ``nofree`` function is explicitly allowed to free memory which it; allocated or (if not ``nosync``) arrange for another thread to free; memory on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``n",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:90463,Performance,optimiz,optimizations,90463,"pturing condition is; necessary in environments where the function might communicate the; pointer to another thread which then deallocates the memory. Alternatively,; ``nosync`` would ensure such communication cannot happen and even captured; pointers cannot be freed by the function. A ``nofree`` function is explicitly allowed to free memory which it; allocated or (if not ``nosync``) arrange for another thread to free; memory on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``nonlazybind``; This attribute suppresses lazy symbol binding for the function. This; may make calls to the function faster, at the cost of extra progra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:90577,Performance,optimiz,optimization,90577,"pturing condition is; necessary in environments where the function might communicate the; pointer to another thread which then deallocates the memory. Alternatively,; ``nosync`` would ensure such communication cannot happen and even captured; pointers cannot be freed by the function. A ``nofree`` function is explicitly allowed to free memory which it; allocated or (if not ``nosync``) arrange for another thread to free; memory on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``nonlazybind``; This attribute suppresses lazy symbol binding for the function. This; may make calls to the function faster, at the cost of extra progra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:90989,Performance,optimiz,optimization,90989,"ry on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``nonlazybind``; This attribute suppresses lazy symbol binding for the function. This; may make calls to the function faster, at the cost of extra program; startup time if the function is not called during program startup.; ``noprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. It; also blocks inlining if the caller and callee have different values of this; attribute.; ``skipprofile``; This function attribute prevents instrumentation based profiling, used for; coverag",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:91707,Performance,optimiz,optimization,91707,"se; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``nonlazybind``; This attribute suppresses lazy symbol binding for the function. This; may make calls to the function faster, at the cost of extra program; startup time if the function is not called during program startup.; ``noprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. It; also blocks inlining if the caller and callee have different values of this; attribute.; ``skipprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. This; attribute does not restrict inlining, so instrumented instruction could end; up in this function.; ``noredzone``; This attribute indicates that the code generator should not use a; red zone, even if the target-specific ABI normally permits it.; ``indirect-tls-seg-refs``; This attribute indicates that the code generator should not use; direct TLS access through segment registers, even if the; target-specific ABI normally permits it.; ``noreturn``; This function attribute indicates that the function never returns; normally, hence through a return instruction. This produces undefined; behavior at runtime if the function ever does dynamically return",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:91965,Performance,optimiz,optimization,91965,"es that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``nonlazybind``; This attribute suppresses lazy symbol binding for the function. This; may make calls to the function faster, at the cost of extra program; startup time if the function is not called during program startup.; ``noprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. It; also blocks inlining if the caller and callee have different values of this; attribute.; ``skipprofile``; This function attribute prevents instrumentation based profiling, used for; coverage or profile based optimization, from being added to a function. This; attribute does not restrict inlining, so instrumented instruction could end; up in this function.; ``noredzone``; This attribute indicates that the code generator should not use a; red zone, even if the target-specific ABI normally permits it.; ``indirect-tls-seg-refs``; This attribute indicates that the code generator should not use; direct TLS access through segment registers, even if the; target-specific ABI normally permits it.; ``noreturn``; This function attribute indicates that the function never returns; normally, hence through a return instruction. This produces undefined; behavior at runtime if the function ever does dynamically return. Annotated; functions may still raise an exception, i.a., ``nounwind`` is not implied.; ``norecurse``; This function attribute indicates that the function does not call itself; either directly or indirectly down any possible call path. This produces; undef",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95021,Performance,load,loads,95021,"ssarily imply an; ordering between threads for the purposes of the memory model. Therefore,; an operation can be both `convergent` and `nosync`. If a `nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95056,Performance,optimiz,optimization,95056,"`nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95375,Performance,optimiz,optimization,95375,"chronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95515,Performance,perform,performance,95515,"chronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95698,Performance,optimiz,optimized,95698,"ing sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performanc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95795,Performance,optimiz,optimization,95795,"strumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95879,Performance,optimiz,optimization,95879,"strumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:96446,Performance,optimiz,optimization,96446,"e is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requir",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:96570,Performance,optimiz,optimizations,96570,"e is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requir",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:96670,Performance,perform,performance,96670,"e is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requir",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97906,Performance,optimiz,optimizations,97906," needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further apart than the size of the guard region to a previous; access of the stack. It takes one required string value, the name of; the stack probing function that will be called. If a function that has a ``""probe-stack""`` attribute is inlined into; a function with another ``""probe-stack""`` attribute, the resulting; function has the ``""probe-stack""`` attribute of the caller. If a; function that has a ``""probe-stack""`` attribute is inlined into a; function that has no ``""probe-stack""`` attribute at all, the resulting; function has the ``""probe-stack""`` attribute of the callee.; ``""stack-probe-size""``; This attribute controls the behavior of stack probes: either; the ``""probe-stack",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:99870,Performance,optimiz,optimizations,99870,"e, or ABI-required stack probes, if any.; It defines the size of the guard region. It ensures that if the function; may use more stack space than the size of the guard region, stack probing; sequence will be emitted. It takes one required integer value, which; is 4096 by default. If a function that has a ``""stack-probe-size""`` attribute is inlined into; a function with another ``""stack-probe-size""`` attribute, the resulting; function has the ``""stack-probe-size""`` attribute that has the lower; numeric value. If a function that has a ``""stack-probe-size""`` attribute is; inlined into a function that has no ``""stack-probe-size""`` attribute; at all, the resulting function has the ``""stack-probe-size""`` attribute; of the callee.; ``""no-stack-arg-probe""``; This attribute disables ABI-required stack probes, if any.; ``returns_twice``; This attribute indicates that this function can return twice. The C; ``setjmp`` is an example of such a function. The compiler disables; some optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:105749,Performance,optimiz,optimizations,105749,"r. This overrides the ``ssp`` and ``sspstrong`` function; attributes. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. If a function with an ``sspreq`` attribute is inlined into a calling; function which has an ``ssp`` or ``sspstrong`` attribute, the calling; function's attribute will be upgraded to ``sspreq``. ``strictfp``; This attribute indicates that the function was called from a scope that; requires strict floating-point semantics. LLVM will not attempt any; optimizations that require assumptions about the floating-point rounding; mode or that might alter the state of floating-point status flags that; might otherwise be set or cleared by calling this function. LLVM will; not introduce any new floating-point instructions that may trap. .. _denormal_fp_math:. ``""denormal-fp-math""``; This indicates the denormal (subnormal) handling that may be; assumed for the default floating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instructions. For compatibility with older; bitcode, if the second value is omitted, both input and output; modes will assume the same mode. If this is attribute is not specified, the default is ``""ieee,ieee""``. If the output mode is ``""preserve-sign""``, or ``""positive-zero""``,; denormal outputs may be flushed to zero by standard floating-point; op",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:107203,Performance,perform,performed,107203,"ating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instructions. For compatibility with older; bitcode, if the second value is omitted, both input and output; modes will assume the same mode. If this is attribute is not specified, the default is ``""ieee,ieee""``. If the output mode is ``""preserve-sign""``, or ``""positive-zero""``,; denormal outputs may be flushed to zero by standard floating-point; operations. It is not mandated that flushing to zero occurs, but if; a denormal output is flushed to zero, it must respect the sign; mode. Not all targets support all modes. If the mode is ``""dynamic""``, the behavior is derived from the; dynamic state of the floating-point environment. Transformations; which depend on the behavior of denormal values should not be; performed. While this indicates the expected floating point mode the function; will be executed with, this does not make any attempt to ensure; the mode is consistent. User or platform code is expected to set; the floating point mode appropriately before function entry. If the input mode is ``""preserve-sign""``, or ``""positive-zero""``,; a floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108360,Performance,optimiz,optimization,108360," the mode is consistent. User or platform code is expected to set; the floating point mode appropriately before function entry. If the input mode is ``""preserve-sign""``, or ``""positive-zero""``,; a floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; ent",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108479,Performance,load,load-hoist,108479,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:109259,Performance,perform,performed,109259,"hat the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicates that the ShadowCallStack checks are enabled for; the function. The instrumentation checks that the return address for the; function has not changed between the function prolog and epilog. It is; currently x86_64-specific. .. _langref_mustprogress:. ``mustprogress``; This attribute indicates that the function is required to return, unwind,; or interact with the environment in an observable way e.g. via a volatile; memory access, I/O, or other synchronization. The ``mustprogress``; attribute is intended to model the requirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to term",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:112472,Performance,perform,perform,112472,"te make no assumptions about the value of `vscale`.; ``""nooutline""``; This attribute indicates that outlining passes should not modify the; function. Call Site Attributes; ----------------------. In addition to function attributes the following call site only; attributes are supported:. ``vector-function-abi-variant``; This attribute can be attached to a :ref:`call <i_call>` to list; the vector functions associated to the function. Notice that the; attribute cannot be attached to a :ref:`invoke <i_invoke>` or a; :ref:`callbr <i_callbr>` instruction. The attribute consists of a; comma separated list of mangled names. The order of the list does; not imply preference (it is logically a set). The compiler is free; to pick any listed vector function of its choosing. The syntax for the mangled names is as follows:::. _ZGV<isa><mask><vlen><parameters>_<scalar_name>[(<vector_redirection>)]. When present, the attribute informs the compiler that the function; ``<scalar_name>`` has a corresponding vector variant that can be; used to perform the concurrent invocation of ``<scalar_name>`` on; vectors. The shape of the vector function is described by the; tokens between the prefix ``_ZGV`` and the ``<scalar_name>``; token. The standard name of the vector function is; ``_ZGV<isa><mask><vlen><parameters>_<scalar_name>``. When present,; the optional token ``(<vector_redirection>)`` informs the compiler; that a custom name is provided in addition to the standard one; (custom names can be provided for example via the use of ``declare; variant`` in OpenMP 5.0). The declaration of the variant must be; present in the IR Module. The signature of the vector variant is; determined by the rules of the Vector Function ABI (VFABI); specifications of the target. For Arm and X86, the VFABI can be; found at https://github.com/ARM-software/abi-aa and; https://software.intel.com/content/www/us/en/develop/download/vector-simd-function-abi.html,; respectively. For X86 and Arm targets, the values of t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:112484,Performance,concurren,concurrent,112484,"te make no assumptions about the value of `vscale`.; ``""nooutline""``; This attribute indicates that outlining passes should not modify the; function. Call Site Attributes; ----------------------. In addition to function attributes the following call site only; attributes are supported:. ``vector-function-abi-variant``; This attribute can be attached to a :ref:`call <i_call>` to list; the vector functions associated to the function. Notice that the; attribute cannot be attached to a :ref:`invoke <i_invoke>` or a; :ref:`callbr <i_callbr>` instruction. The attribute consists of a; comma separated list of mangled names. The order of the list does; not imply preference (it is logically a set). The compiler is free; to pick any listed vector function of its choosing. The syntax for the mangled names is as follows:::. _ZGV<isa><mask><vlen><parameters>_<scalar_name>[(<vector_redirection>)]. When present, the attribute informs the compiler that the function; ``<scalar_name>`` has a corresponding vector variant that can be; used to perform the concurrent invocation of ``<scalar_name>`` on; vectors. The shape of the vector function is described by the; tokens between the prefix ``_ZGV`` and the ``<scalar_name>``; token. The standard name of the vector function is; ``_ZGV<isa><mask><vlen><parameters>_<scalar_name>``. When present,; the optional token ``(<vector_redirection>)`` informs the compiler; that a custom name is provided in addition to the standard one; (custom names can be provided for example via the use of ``declare; variant`` in OpenMP 5.0). The declaration of the variant must be; present in the IR Module. The signature of the vector variant is; determined by the rules of the Vector Function ABI (VFABI); specifications of the target. For Arm and X86, the VFABI can be; found at https://github.com/ARM-software/abi-aa and; https://software.intel.com/content/www/us/en/develop/download/vector-simd-function-abi.html,; respectively. For X86 and Arm targets, the values of t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:118745,Performance,optimiz,optimizations,118745,"naged languages. While; the exact semantics of an operand bundle depend on the bundle tag,; there are certain limitations to how much the presence of an operand; bundle can influence the semantics of a program. These restrictions; are described as the semantics of an ""unknown"" operand bundle. As; long as the behavior of an operand bundle is describable within these; restrictions, LLVM does not need to have special knowledge of the; operand bundle to not miscompile programs containing it. - The bundle operands for an unknown operand bundle escape in unknown; ways before control is transferred to the callee or invokee.; - Calls and invokes with operand bundles have unknown read / write; effect on the heap on entry and exit (even if the call target specifies; a ``memory`` attribute), unless they're overridden with; callsite specific attributes.; - An operand bundle at a call site cannot change the implementation; of the called function. Inter-procedural optimizations work as; usual as long as they take into account the first two properties. More specific types of operand bundles are described below. .. _deopt_opbundles:. Deoptimization Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Deoptimization operand bundles are characterized by the ``""deopt""``; operand bundle tag. These operand bundles represent an alternate; ""safe"" continuation for the call site they're attached to, and can be; used by a suitable runtime to deoptimize the compiled frame at the; specified call site. There can be at most one ``""deopt""`` operand; bundle attached to a call site. Exact details of deoptimization is; out of scope for the language reference, but it usually involves; rewriting a compiled frame into a set of interpreted frames. From the compiler's perspective, deoptimization operand bundles make; the call sites they're attached to at least ``readonly``. They read; through all of their pointer typed operands (even if they're not; otherwise escaped) and the entire visible heap. Deoptimizat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:124256,Performance,optimiz,optimizer,124256," or a; :ref:`function attribute <fnattrs>` holds for a certain value at a certain; location. Operand bundles enable assumptions that are either hard or impossible; to represent as a boolean argument of an :ref:`llvm.assume <int_assume>`. An assume operand bundle has the form:. ::. ""<tag>""([ <arguments>] ]). In the case of function or parameter attributes, the operand bundle has the; restricted form:. ::. ""<tag>""([ <holds for value> [, <attribute argument>] ]). * The tag of the operand bundle is usually the name of attribute that can be; assumed to hold. It can also be `ignore`, this tag doesn't contain any; information and should be ignored.; * The first argument if present is the value for which the attribute hold.; * The second argument if present is an argument of the attribute. If there are no arguments the attribute is a property of the call location. For example:. .. code-block:: llvm. call void @llvm.assume(i1 true) [""align""(ptr %val, i32 8)]. allows the optimizer to assume that at location of call to; :ref:`llvm.assume <int_assume>` ``%val`` has an alignment of at least 8. .. code-block:: llvm. call void @llvm.assume(i1 %cond) [""cold""(), ""nonnull""(ptr %val)]. allows the optimizer to assume that the :ref:`llvm.assume <int_assume>`; call location is cold and that ``%val`` may not be null. Just like for the argument of :ref:`llvm.assume <int_assume>`, if any of the; provided guarantees are violated at runtime the behavior is undefined. While attributes expect constant arguments, assume operand bundles may be; provided a dynamic value, for example:. .. code-block:: llvm. call void @llvm.assume(i1 true) [""align""(ptr %val, i32 %align)]. If the operand bundle value violates any requirements on the attribute value,; the behavior is undefined, unless one of the following exceptions applies:. * ``""align""`` operand bundles may specify a non-power-of-two alignment; (including a zero alignment). If this is the case, then the pointer value; must be a null pointer, otherwi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:124477,Performance,optimiz,optimizer,124477,"llvm.assume <int_assume>`. An assume operand bundle has the form:. ::. ""<tag>""([ <arguments>] ]). In the case of function or parameter attributes, the operand bundle has the; restricted form:. ::. ""<tag>""([ <holds for value> [, <attribute argument>] ]). * The tag of the operand bundle is usually the name of attribute that can be; assumed to hold. It can also be `ignore`, this tag doesn't contain any; information and should be ignored.; * The first argument if present is the value for which the attribute hold.; * The second argument if present is an argument of the attribute. If there are no arguments the attribute is a property of the call location. For example:. .. code-block:: llvm. call void @llvm.assume(i1 true) [""align""(ptr %val, i32 8)]. allows the optimizer to assume that at location of call to; :ref:`llvm.assume <int_assume>` ``%val`` has an alignment of at least 8. .. code-block:: llvm. call void @llvm.assume(i1 %cond) [""cold""(), ""nonnull""(ptr %val)]. allows the optimizer to assume that the :ref:`llvm.assume <int_assume>`; call location is cold and that ``%val`` may not be null. Just like for the argument of :ref:`llvm.assume <int_assume>`, if any of the; provided guarantees are violated at runtime the behavior is undefined. While attributes expect constant arguments, assume operand bundles may be; provided a dynamic value, for example:. .. code-block:: llvm. call void @llvm.assume(i1 true) [""align""(ptr %val, i32 %align)]. If the operand bundle value violates any requirements on the attribute value,; the behavior is undefined, unless one of the following exceptions applies:. * ``""align""`` operand bundles may specify a non-power-of-two alignment; (including a zero alignment). If this is the case, then the pointer value; must be a null pointer, otherwise the behavior is undefined. In addition to allowing operand bundles encoding function and parameter; attributes, an assume operand bundle my also encode a ``separate_storage``; operand bundle. This has the for",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:125929,Performance,optimiz,optimizer,125929,"assume(i1 true) [""align""(ptr %val, i32 %align)]. If the operand bundle value violates any requirements on the attribute value,; the behavior is undefined, unless one of the following exceptions applies:. * ``""align""`` operand bundles may specify a non-power-of-two alignment; (including a zero alignment). If this is the case, then the pointer value; must be a null pointer, otherwise the behavior is undefined. In addition to allowing operand bundles encoding function and parameter; attributes, an assume operand bundle my also encode a ``separate_storage``; operand bundle. This has the form:. .. code-block:: llvm. separate_storage(<val1>, <val2>)``. This indicates that no pointer :ref:`based <pointeraliasing>` on one of its; arguments can alias any pointer based on the other. Even if the assumed property can be encoded as a boolean value, like; ``nonnull``, using operand bundles to express the property can still have; benefits:. * Attributes that can be expressed via operand bundles are directly the; property that the optimizer uses and cares about. Encoding attributes as; operand bundles removes the need for an instruction sequence that represents; the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the; optimizer to deduce the property from that instruction sequence.; * Expressing the property using operand bundles makes it easy to identify the; use of the value as a use in an :ref:`llvm.assume <int_assume>`. This then; simplifies and improves heuristics, e.g., for use ""use-sensitive""; optimizations. .. _ob_preallocated:. Preallocated Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Preallocated operand bundles are characterized by the ``""preallocated""``; operand bundle tag. These operand bundles allow separation of the allocation; of the call argument memory from the call site. This is necessary to pass; non-trivially copyable objects by value in a way that is compatible with MSVC; on some targets. There can be at most one ``""preallocated""`` operand bundl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:126134,Performance,optimiz,optimizer,126134,"cify a non-power-of-two alignment; (including a zero alignment). If this is the case, then the pointer value; must be a null pointer, otherwise the behavior is undefined. In addition to allowing operand bundles encoding function and parameter; attributes, an assume operand bundle my also encode a ``separate_storage``; operand bundle. This has the form:. .. code-block:: llvm. separate_storage(<val1>, <val2>)``. This indicates that no pointer :ref:`based <pointeraliasing>` on one of its; arguments can alias any pointer based on the other. Even if the assumed property can be encoded as a boolean value, like; ``nonnull``, using operand bundles to express the property can still have; benefits:. * Attributes that can be expressed via operand bundles are directly the; property that the optimizer uses and cares about. Encoding attributes as; operand bundles removes the need for an instruction sequence that represents; the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the; optimizer to deduce the property from that instruction sequence.; * Expressing the property using operand bundles makes it easy to identify the; use of the value as a use in an :ref:`llvm.assume <int_assume>`. This then; simplifies and improves heuristics, e.g., for use ""use-sensitive""; optimizations. .. _ob_preallocated:. Preallocated Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Preallocated operand bundles are characterized by the ``""preallocated""``; operand bundle tag. These operand bundles allow separation of the allocation; of the call argument memory from the call site. This is necessary to pass; non-trivially copyable objects by value in a way that is compatible with MSVC; on some targets. There can be at most one ``""preallocated""`` operand bundle; attached to a call site and it must have exactly one bundle operand, which is; a token generated by ``@llvm.call.preallocated.setup``. A call with this; operand bundle should not adjust the stack before entering the function, as; that wil",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:126422,Performance,optimiz,optimizations,126422,"ndle my also encode a ``separate_storage``; operand bundle. This has the form:. .. code-block:: llvm. separate_storage(<val1>, <val2>)``. This indicates that no pointer :ref:`based <pointeraliasing>` on one of its; arguments can alias any pointer based on the other. Even if the assumed property can be encoded as a boolean value, like; ``nonnull``, using operand bundles to express the property can still have; benefits:. * Attributes that can be expressed via operand bundles are directly the; property that the optimizer uses and cares about. Encoding attributes as; operand bundles removes the need for an instruction sequence that represents; the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the; optimizer to deduce the property from that instruction sequence.; * Expressing the property using operand bundles makes it easy to identify the; use of the value as a use in an :ref:`llvm.assume <int_assume>`. This then; simplifies and improves heuristics, e.g., for use ""use-sensitive""; optimizations. .. _ob_preallocated:. Preallocated Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Preallocated operand bundles are characterized by the ``""preallocated""``; operand bundle tag. These operand bundles allow separation of the allocation; of the call argument memory from the call site. This is necessary to pass; non-trivially copyable objects by value in a way that is compatible with MSVC; on some targets. There can be at most one ``""preallocated""`` operand bundle; attached to a call site and it must have exactly one bundle operand, which is; a token generated by ``@llvm.call.preallocated.setup``. A call with this; operand bundle should not adjust the stack before entering the function, as; that will have been done by one of the ``@llvm.call.preallocated.*`` intrinsics. .. code-block:: llvm. %foo = type { i64, i32 }. ... %t = call token @llvm.call.preallocated.setup(i32 1); %a = call ptr @llvm.call.preallocated.arg(token %t, i32 0) preallocated(%foo); ; initialize %b; c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:138969,Performance,optimiz,optimizers,138969,"it aligned. When LLVM is determining the alignment for a given type, it uses the; following rules:. #. If the type sought is an exact match for one of the specifications,; that specification is used.; #. If no match is found, and the type sought is an integer type, then; the smallest integer type that is larger than the bitwidth of the; sought type is used. If none of the specifications are larger than; the bitwidth then the largest integer type is used. For example,; given the default specifications above, the i7 type will use the; alignment of i8 (next largest) while both i65 and i256 will use the; alignment of i64 (largest specified). The function of the data layout string may not be what you expect.; Notably, this is not a specification from the frontend of what alignment; the code generator should use. Instead, if specified, the target data layout is required to match what; the ultimate *code generator* expects. This string is used by the; mid-level optimizers to improve code, and this only works if it matches; what the ultimate code generator uses. There is no way to generate IR; that does not embed this target-specific detail into the IR. If you; don't specify the string, the default specifications will be used to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:139273,Performance,optimiz,optimization,139273,"nteger type that is larger than the bitwidth of the; sought type is used. If none of the specifications are larger than; the bitwidth then the largest integer type is used. For example,; given the default specifications above, the i7 type will use the; alignment of i8 (next largest) while both i65 and i256 will use the; alignment of i64 (largest specified). The function of the data layout string may not be what you expect.; Notably, this is not a specification from the frontend of what alignment; the code generator should use. Instead, if specified, the target data layout is required to match what; the ultimate *code generator* expects. This string is used by the; mid-level optimizers to improve code, and this only works if it matches; what the ultimate code generator uses. There is no way to generate IR; that does not embed this target-specific detail into the IR. If you; don't specify the string, the default specifications will be used to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; al",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:143323,Performance,load,load,143323,"llocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the vector-of-pointers-typed operand; of the ``getelementptr``.; - The result value of a ``bitcast`` is *based* on the operand of the; ``bitcast``.; - A pointer value formed by an ``inttoptr`` is *based* on all pointer; values that contribute (directly or indirectly) to the computation of; the pointer's value.; - The ""*based* on"" relationship is transitive. Note that this definition of *""based""* is intentionally similar to the; definition of *""based""* in C99, though it is slightly weaker. LLVM IR does not associate types with memory. The result type of a; ``load`` merely indicates the size and alignment of the memory from; which to load, as well as the interpretation of the value. The first; operand type of a ``store`` similarly only indicates the size and; alignment of the store. Consequently, type-based alias analysis, aka TBAA, aka; ``-fstrict-aliasing``, is not applicable to general unadorned LLVM IR.; :ref:`Metadata <metadata>` may be used to encode additional information; which specialized optimization passes may use to implement type-based; alias analysis. .. _pointercapture:. Pointer Capture; ---------------. Given a function call and a pointer that is passed as an argument or stored in; the memory before the call, a pointer is *captured* by the call if it makes a; copy of any part of the pointer that outlives the call.; To be precise, a pointer is captured if one or more of the following conditions; hold:. 1. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be read from the place by the caller after this call; exits. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:143399,Performance,load,load,143399,"llocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the vector-of-pointers-typed operand; of the ``getelementptr``.; - The result value of a ``bitcast`` is *based* on the operand of the; ``bitcast``.; - A pointer value formed by an ``inttoptr`` is *based* on all pointer; values that contribute (directly or indirectly) to the computation of; the pointer's value.; - The ""*based* on"" relationship is transitive. Note that this definition of *""based""* is intentionally similar to the; definition of *""based""* in C99, though it is slightly weaker. LLVM IR does not associate types with memory. The result type of a; ``load`` merely indicates the size and alignment of the memory from; which to load, as well as the interpretation of the value. The first; operand type of a ``store`` similarly only indicates the size and; alignment of the store. Consequently, type-based alias analysis, aka TBAA, aka; ``-fstrict-aliasing``, is not applicable to general unadorned LLVM IR.; :ref:`Metadata <metadata>` may be used to encode additional information; which specialized optimization passes may use to implement type-based; alias analysis. .. _pointercapture:. Pointer Capture; ---------------. Given a function call and a pointer that is passed as an argument or stored in; the memory before the call, a pointer is *captured* by the call if it makes a; copy of any part of the pointer that outlives the call.; To be precise, a pointer is captured if one or more of the following conditions; hold:. 1. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be read from the place by the caller after this call; exits. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:143770,Performance,optimiz,optimization,143770,"f the vector-of-pointers-typed operand; of the ``getelementptr``.; - The result value of a ``bitcast`` is *based* on the operand of the; ``bitcast``.; - A pointer value formed by an ``inttoptr`` is *based* on all pointer; values that contribute (directly or indirectly) to the computation of; the pointer's value.; - The ""*based* on"" relationship is transitive. Note that this definition of *""based""* is intentionally similar to the; definition of *""based""* in C99, though it is slightly weaker. LLVM IR does not associate types with memory. The result type of a; ``load`` merely indicates the size and alignment of the memory from; which to load, as well as the interpretation of the value. The first; operand type of a ``store`` similarly only indicates the size and; alignment of the store. Consequently, type-based alias analysis, aka TBAA, aka; ``-fstrict-aliasing``, is not applicable to general unadorned LLVM IR.; :ref:`Metadata <metadata>` may be used to encode additional information; which specialized optimization passes may use to implement type-based; alias analysis. .. _pointercapture:. Pointer Capture; ---------------. Given a function call and a pointer that is passed as an argument or stored in; the memory before the call, a pointer is *captured* by the call if it makes a; copy of any part of the pointer that outlives the call.; To be precise, a pointer is captured if one or more of the following conditions; hold:. 1. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be read from the place by the caller after this call; exits. .. code-block:: llvm. @glb = global ptr null; @glb2 = global ptr null; @glb3 = global ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145869,Performance,load,load,145869,"%d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145985,Performance,optimiz,optimizers,145985,"on into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:146126,Performance,optimiz,optimizers,146126,"block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address spac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:146313,Performance,load,load,146313,"ad can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:146516,Performance,load,load,146516,"arrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:147876,Performance,load,loads,147876,"ile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:147910,Performance,optimiz,optimized,147910,"ile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:148088,Performance,load,load,148088,"n may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ mem",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:148142,Performance,load,loads,148142,"s space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:148278,Performance,load,loads,148278,"alid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens-before* partial order as the least partial order; that. - Is a superset of single-thread program order, and; - When ``a`` *synchronizes-wit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:149742,Performance,load,load,149742,"ns; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens-before* partial order as the least partial order; that. - Is a superset of single-thread program order, and; - When ``a`` *synchronizes-with* ``b``, includes an edge from ``a`` to; ``b``. *Synchronizes-with* pairs are introduced by platform-specific; techniques, like pthread locks, thread creation, thread joining,; etc., and by atomic instructions. (See also :ref:`Atomic Memory Ordering; Constraints <ordering>`). Note that program order does not introduce *happens-before* edges; between a thread and signals executing inside that thread. Every (defined) read operation (load instructions, memcpy, atomic; loads/read-modify-writes, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like nor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:149777,Performance,load,loads,149777,"ns; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens-before* partial order as the least partial order; that. - Is a superset of single-thread program order, and; - When ``a`` *synchronizes-with* ``b``, includes an edge from ``a`` to; ``b``. *Synchronizes-with* pairs are introduced by platform-specific; techniques, like pthread locks, thread creation, thread joining,; etc., and by atomic instructions. (See also :ref:`Atomic Memory Ordering; Constraints <ordering>`). Note that program order does not introduce *happens-before* edges; between a thread and signals executing inside that thread. Every (defined) read operation (load instructions, memcpy, atomic; loads/read-modify-writes, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like nor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152112,Performance,load,load,152112,"Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; part",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152156,Performance,load,load,152156,"Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; part",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152400,Performance,load,load,152400,"f bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:158218,Performance,perform,performed,158218,"ormals are assumed to be preserved. Running LLVM code in an environment where these assumptions are not met can lead; to undefined behavior. The ``strictfp`` and ``denormal-fp-math`` attributes as; well as :ref:`Constrained Floating-Point Intrinsics <constrainedfp>` can be used; to weaken LLVM's assumptions and ensure defined behavior in non-default; floating-point environments; see their respective documentation for details. .. _floatnan:. Behavior of Floating-Point NaN values; -------------------------------------. A floating-point NaN value consists of a sign bit, a quiet/signaling bit, and a; payload (which makes up the rest of the mantissa except for the quiet/signaling; bit). LLVM assumes that the quiet/signaling bit being set to ``1`` indicates a; quiet NaN (QNaN), and a value of ``0`` indicates a signaling NaN (SNaN). In the; following we will hence just call it the ""quiet bit"". The representation bits of a floating-point value do not mutate arbitrarily; in; particular, if there is no floating-point operation being performed, NaN signs,; quiet bits, and payloads are preserved. For the purpose of this section, ``bitcast`` as well as the following operations; are not ""floating-point math operations"": ``fneg``, ``llvm.fabs``, and; ``llvm.copysign``. These operations act directly on the underlying bit; representation and never change anything except possibly for the sign bit. For floating-point math operations, unless specified otherwise, the following; rules apply when a NaN value is returned: the result has a non-deterministic; sign; the quiet bit and payload are non-deterministically chosen from the; following set of options:. - The quiet bit is set and the payload is all-zero. (""Preferred NaN"" case); - The quiet bit is set and the payload is copied from any input operand that is; a NaN. (""Quieting NaN propagation"" case); - The quiet bit and payload are copied from any input operand that is a NaN.; (""Unchanged NaN propagation"" case); - The quiet bit is set an",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:160695,Performance,perform,performing,160695," the output NaN is definitely quiet. Signaling NaN outputs can only occur if they; are provided as an input value. For example, ""fmul SNaN, 1.0"" may be simplified; to SNaN rather than QNaN. Similarly, if all input NaNs are preferred (or if; there are no input NaNs) and the target does not have any ""extra"" NaN payloads,; then the output NaN is guaranteed to be preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this should use the; :ref:`Constrained Floating-Point Intrinsics <constrainedfp>`.; In particular, constrained intrinsics rule out the ""Unchanged NaN propagation""; case; they are guaranteed to return a QNaN. Unfortunately, due to hard-or-impossible-to-fix issues, LLVM violates its own; specification on some architectures:. - x86-32 without SSE2 enabled may convert floating-point values to x86_fp80 and; back when performing floating-point math operations; this can lead to results; with different precision than expected and it can alter NaN values. Since; optimizations can make contradicting assumptions, this can lead to arbitrary; miscompilations. See `issue #44218; <https://github.com/llvm/llvm-project/issues/44218>`_.; - x86-32 (even with SSE2 enabled) may implicitly perform such a conversion on; values returned from a function for some calling conventions. See `issue; #66803 <https://github.com/llvm/llvm-project/issues/66803>`_.; - Older MIPS versions use the opposite polarity for the quiet/signaling bit, and; LLVM does not correctly represent this. See `issue #60796; <https://github.com/llvm/llvm-project/issues/60796>`_. .. _fastmath:. Fast-Math Flags; ---------------. LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:160839,Performance,optimiz,optimizations,160839,"o SNaN rather than QNaN. Similarly, if all input NaNs are preferred (or if; there are no input NaNs) and the target does not have any ""extra"" NaN payloads,; then the output NaN is guaranteed to be preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this should use the; :ref:`Constrained Floating-Point Intrinsics <constrainedfp>`.; In particular, constrained intrinsics rule out the ""Unchanged NaN propagation""; case; they are guaranteed to return a QNaN. Unfortunately, due to hard-or-impossible-to-fix issues, LLVM violates its own; specification on some architectures:. - x86-32 without SSE2 enabled may convert floating-point values to x86_fp80 and; back when performing floating-point math operations; this can lead to results; with different precision than expected and it can alter NaN values. Since; optimizations can make contradicting assumptions, this can lead to arbitrary; miscompilations. See `issue #44218; <https://github.com/llvm/llvm-project/issues/44218>`_.; - x86-32 (even with SSE2 enabled) may implicitly perform such a conversion on; values returned from a function for some calling conventions. See `issue; #66803 <https://github.com/llvm/llvm-project/issues/66803>`_.; - Older MIPS versions use the opposite polarity for the quiet/signaling bit, and; LLVM does not correctly represent this. See `issue #60796; <https://github.com/llvm/llvm-project/issues/60796>`_. .. _fastmath:. Fast-Math Flags; ---------------. LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the argume",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:161058,Performance,perform,perform,161058," preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this should use the; :ref:`Constrained Floating-Point Intrinsics <constrainedfp>`.; In particular, constrained intrinsics rule out the ""Unchanged NaN propagation""; case; they are guaranteed to return a QNaN. Unfortunately, due to hard-or-impossible-to-fix issues, LLVM violates its own; specification on some architectures:. - x86-32 without SSE2 enabled may convert floating-point values to x86_fp80 and; back when performing floating-point math operations; this can lead to results; with different precision than expected and it can alter NaN values. Since; optimizations can make contradicting assumptions, this can lead to arbitrary; miscompilations. See `issue #44218; <https://github.com/llvm/llvm-project/issues/44218>`_.; - x86-32 (even with SSE2 enabled) may implicitly perform such a conversion on; values returned from a function for some calling conventions. See `issue; #66803 <https://github.com/llvm/llvm-project/issues/66803>`_.; - Older MIPS versions use the opposite polarity for the quiet/signaling bit, and; LLVM does not correctly represent this. See `issue #60796; <https://github.com/llvm/llvm-project/issues/60796>`_. .. _fastmath:. Fast-Math Flags; ---------------. LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:161848,Performance,optimiz,optimizations,161848,"tradicting assumptions, this can lead to arbitrary; miscompilations. See `issue #44218; <https://github.com/llvm/llvm-project/issues/44218>`_.; - x86-32 (even with SSE2 enabled) may implicitly perform such a conversion on; values returned from a function for some calling conventions. See `issue; #66803 <https://github.com/llvm/llvm-project/issues/66803>`_.; - Older MIPS versions use the opposite polarity for the quiet/signaling bit, and; LLVM does not correctly represent this. See `issue #60796; <https://github.com/llvm/llvm-project/issues/60796>`_. .. _fastmath:. Fast-Math Flags; ---------------. LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162051,Performance,optimiz,optimizations,162051," a conversion on; values returned from a function for some calling conventions. See `issue; #66803 <https://github.com/llvm/llvm-project/issues/66803>`_.; - Older MIPS versions use the opposite polarity for the quiet/signaling bit, and; LLVM does not correctly represent this. See `issue #60796; <https://github.com/llvm/llvm-project/issues/60796>`_. .. _fastmath:. Fast-Math Flags; ---------------. LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162266,Performance,optimiz,optimizations,162266,"aling bit, and; LLVM does not correctly represent this. See `issue #60796; <https://github.com/llvm/llvm-project/issues/60796>`_. .. _fastmath:. Fast-Math Flags; ---------------. LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162476,Performance,optimiz,optimizations,162476,"tions (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162540,Performance,perform,perform,162540,"tions (:ref:`fneg <i_fneg>`, :ref:`fadd <i_fadd>`,; :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`,; :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`), :ref:`phi <i_phi>`,; :ref:`select <i_select>` and :ref:`call <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:165348,Performance,optimiz,optimizations,165348," At global scope.; uselistorder ptr @global, { 1, 2, 0 }; uselistorder i32 7, { 1, 0 }; uselistorder i32 (i32) @bar, { 1, 0 }; uselistorder_bb @foo, %bb, { 5, 1, 3, 2, 0, 4 }. .. _source_filename:. Source Filename; ---------------. The *source filename* string is set to the original module identifier,; which will be the name of the compiled source file when compiling from; source through the clang front end, for example. It is then preserved through; the IR and bitcode. This is currently necessary to generate a consistent unique global; identifier for local functions used in profile data, which prepends the; source file name to the local function name. The syntax for the source file name is simply:. .. code-block:: text. source_filename = ""/path/to/source.c"". .. _typesystem:. Type System; ===========. The LLVM type system is one of the most important features of the; intermediate representation. Being typed enables a number of; optimizations to be performed on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arg",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:165368,Performance,perform,performed,165368," At global scope.; uselistorder ptr @global, { 1, 2, 0 }; uselistorder i32 7, { 1, 0 }; uselistorder i32 (i32) @bar, { 1, 0 }; uselistorder_bb @foo, %bb, { 5, 1, 3, 2, 0, 4 }. .. _source_filename:. Source Filename; ---------------. The *source filename* string is set to the original module identifier,; which will be the name of the compiled source file when compiling from; source through the clang front end, for example. It is then preserved through; the IR and bitcode. This is currently necessary to generate a consistent unique global; identifier for local functions used in profile data, which prepends the; source file name to the local function name. The syntax for the source file name is simply:. .. code-block:: text. source_filename = ""/path/to/source.c"". .. _typesystem:. Type System; ===========. The LLVM type system is one of the most important features of the; intermediate representation. Being typed enables a number of; optimizations to be performed on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arg",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:165638,Performance,perform,perform,165638,"lename:. Source Filename; ---------------. The *source filename* string is set to the original module identifier,; which will be the name of the compiled source file when compiling from; source through the clang front end, for example. It is then preserved through; the IR and bitcode. This is currently necessary to generate a consistent unique global; identifier for local functions used in profile data, which prepends the; source file name to the local function name. The syntax for the source file name is simply:. .. code-block:: text. source_filename = ""/path/to/source.c"". .. _typesystem:. Type System; ===========. The LLVM type system is one of the most important features of the; intermediate representation. Being typed enables a number of; optimizations to be performed on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arguments. Variable; argument functions can access their arguments with the :ref:`variable argument; handling intrinsic <int_varargs>` functions. '``<returntype>``' is any type; except :ref:`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:170088,Performance,load,load,170088,"ion. * - ``half``; - 16-bit floating-point value. * - ``bfloat``; - 16-bit ""brain"" floating-point value (7-bit significand). Provides the; same number of exponent bits as ``float``, so that it matches its dynamic; range, but with greatly reduced precision. Used in Intel's AVX-512 BF16; extensions and Arm's ARMv8.6-A extensions, among others. * - ``float``; - 32-bit floating-point value. * - ``double``; - 64-bit floating-point value. * - ``fp128``; - 128-bit floating-point value (113-bit significand). * - ``x86_fp80``; - 80-bit floating-point value (X87). * - ``ppc_fp128``; - 128-bit floating-point value (two 64-bits). The binary format of half, float, double, and fp128 correspond to the; IEEE-754-2008 specifications for binary16, binary32, binary64, and binary128; respectively. X86_amx Type; """""""""""""""""""""""". :Overview:. The x86_amx type represents a value held in an AMX tile register on an x86; machine. The operations allowed on it are quite limited. Only few intrinsics; are allowed: stride load and store, zero and dot product. No instruction is; allowed for this type. There are no arguments, arrays, pointers, vectors; or constants of this type. :Syntax:. ::. x86_amx. X86_mmx Type; """""""""""""""""""""""". :Overview:. The x86_mmx type represents a value held in an MMX register on an x86; machine. The operations allowed on it are quite limited: parameters and; return values, load and store, and bitcast. User-specified MMX; instructions are represented as intrinsic or asm calls with arguments; and/or results of this type. There are no arrays, vectors or constants; of this type. :Syntax:. ::. x86_mmx. .. _t_pointer:. Pointer Type; """""""""""""""""""""""". :Overview:. The pointer type ``ptr`` is used to specify memory locations. Pointers are; commonly used to reference objects in memory. Pointer types may have an optional address space attribute defining; the numbered address space where the pointed-to object resides. For; example, ``ptr addrspace(5)`` is a pointer to address space 5.; In additi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:170468,Performance,load,load,170468,"; - 32-bit floating-point value. * - ``double``; - 64-bit floating-point value. * - ``fp128``; - 128-bit floating-point value (113-bit significand). * - ``x86_fp80``; - 80-bit floating-point value (X87). * - ``ppc_fp128``; - 128-bit floating-point value (two 64-bits). The binary format of half, float, double, and fp128 correspond to the; IEEE-754-2008 specifications for binary16, binary32, binary64, and binary128; respectively. X86_amx Type; """""""""""""""""""""""". :Overview:. The x86_amx type represents a value held in an AMX tile register on an x86; machine. The operations allowed on it are quite limited. Only few intrinsics; are allowed: stride load and store, zero and dot product. No instruction is; allowed for this type. There are no arguments, arrays, pointers, vectors; or constants of this type. :Syntax:. ::. x86_amx. X86_mmx Type; """""""""""""""""""""""". :Overview:. The x86_mmx type represents a value held in an MMX register on an x86; machine. The operations allowed on it are quite limited: parameters and; return values, load and store, and bitcast. User-specified MMX; instructions are represented as intrinsic or asm calls with arguments; and/or results of this type. There are no arrays, vectors or constants; of this type. :Syntax:. ::. x86_mmx. .. _t_pointer:. Pointer Type; """""""""""""""""""""""". :Overview:. The pointer type ``ptr`` is used to specify memory locations. Pointers are; commonly used to reference objects in memory. Pointer types may have an optional address space attribute defining; the numbered address space where the pointed-to object resides. For; example, ``ptr addrspace(5)`` is a pointer to address space 5.; In addition to integer constants, ``addrspace`` can also reference one of the; address spaces defined in the :ref:`datalayout string<langref_datalayout>`.; ``addrspace(""A"")`` will use the alloca address space, ``addrspace(""G"")``; the default globals address space and ``addrspace(""P"")`` the program address; space. The default address space is number zero. The sema",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:172389,Performance,optimiz,optimization,172389,"space. The default address space is number zero. The semantics of non-zero address spaces are target-specific. Memory; access through a non-dereferenceable pointer is undefined behavior in; any address space. Pointers with the bit-value 0 are only assumed to; be non-dereferenceable in address space 0, unless the function is; marked with the ``null_pointer_is_valid`` attribute. If an object can be proven accessible through a pointer with a; different address space, the access may be modified to use that; address space. Exceptions apply if the operation is ``volatile``. Prior to LLVM 15, pointer types also specified a pointee type, such as; ``i8*``, ``[4 x i32]*`` or ``i32 (i32*)*``. In LLVM 15, such ""typed; pointers"" are still supported under non-default options. See the; `opaque pointers document <OpaquePointers.html>`__ for more information. .. _t_target_type:. Target Extension Type; """""""""""""""""""""""""""""""""""""""""". :Overview:. Target extension types represent types that must be preserved through; optimization, but are otherwise generally opaque to the compiler. They may be; used as function parameters or arguments, and in :ref:`phi <i_phi>` or; :ref:`select <i_select>` instructions. Some types may be also used in; :ref:`alloca <i_alloca>` instructions or as global values, and correspondingly; it is legal to use :ref:`load <i_load>` and :ref:`store <i_store>` instructions; on them. Full semantics for these types are defined by the target. The only constants that target extension types may have are ``zeroinitializer``,; ``undef``, and ``poison``. Other possible values for target extension types may; arise from target-specific intrinsics and functions. These types cannot be converted to other types. As such, it is not legal to use; them in :ref:`bitcast <i_bitcast>` instructions (as a source or target type),; nor is it legal to use them in :ref:`ptrtoint <i_ptrtoint>` or; :ref:`inttoptr <i_inttoptr>` instructions. Similarly, they are not legal to use; in an :ref:`icmp <i_icmp>`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:172716,Performance,load,load,172716,"space 0, unless the function is; marked with the ``null_pointer_is_valid`` attribute. If an object can be proven accessible through a pointer with a; different address space, the access may be modified to use that; address space. Exceptions apply if the operation is ``volatile``. Prior to LLVM 15, pointer types also specified a pointee type, such as; ``i8*``, ``[4 x i32]*`` or ``i32 (i32*)*``. In LLVM 15, such ""typed; pointers"" are still supported under non-default options. See the; `opaque pointers document <OpaquePointers.html>`__ for more information. .. _t_target_type:. Target Extension Type; """""""""""""""""""""""""""""""""""""""""". :Overview:. Target extension types represent types that must be preserved through; optimization, but are otherwise generally opaque to the compiler. They may be; used as function parameters or arguments, and in :ref:`phi <i_phi>` or; :ref:`select <i_select>` instructions. Some types may be also used in; :ref:`alloca <i_alloca>` instructions or as global values, and correspondingly; it is legal to use :ref:`load <i_load>` and :ref:`store <i_store>` instructions; on them. Full semantics for these types are defined by the target. The only constants that target extension types may have are ``zeroinitializer``,; ``undef``, and ``poison``. Other possible values for target extension types may; arise from target-specific intrinsics and functions. These types cannot be converted to other types. As such, it is not legal to use; them in :ref:`bitcast <i_bitcast>` instructions (as a source or target type),; nor is it legal to use them in :ref:`ptrtoint <i_ptrtoint>` or; :ref:`inttoptr <i_inttoptr>` instructions. Similarly, they are not legal to use; in an :ref:`icmp <i_icmp>` instruction. Target extension types have a name and optional type or integer parameters. The; meanings of name and parameters are defined by the target. When being defined in; LLVM IR, all of the type parameters must precede all of the integer parameters. Specific target extension types are ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:174598,Performance,scalab,scalable,174598," precede all of the integer parameters. Specific target extension types are registered with LLVM as having specific; properties. These properties can be used to restrict the type from appearing in; certain contexts, such as being the type of a global variable or having a; ``zeroinitializer`` constant be valid. A complete list of type properties may be; found in the documentation for ``llvm::TargetExtType::Property`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1TargetExtType.html>`_). :Syntax:. .. code-block:: llvm. target(""label""); target(""label"", void); target(""label"", void, i32); target(""label"", 0, 1, 2); target(""label"", void, i32, 0, 1, 2). .. _t_vector:. Vector Type; """""""""""""""""""""". :Overview:. A vector type is a simple derived type that represents a vector of; elements. Vector types are used when multiple primitive data are; operated in parallel using a single instruction (SIMD). A vector type; requires a size (number of elements), an underlying primitive data type,; and a scalable property to represent vectors where the exact hardware; vector length is unknown at compile time. Vector types are considered; :ref:`first class <t_firstclass>`. :Memory Layout:. In general vector elements are laid out in memory in the same way as; :ref:`array types <t_array>`. Such an analogy works fine as long as the vector; elements are byte sized. However, when the elements of the vector aren't byte; sized it gets a bit more complicated. One way to describe the layout is by; describing what happens when a vector such as <N x iM> is bitcasted to an; integer type with N*M bits, and then following the rules for storing such an; integer to memory. A bitcast from a vector type to a scalar integer type will see the elements; being packed together (without padding). The order in which elements are; inserted in the integer depends on endianness. For little endian element zero; is put in the least significant bits of the integer, and for big endian; element zero is put in the most signi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:177171,Performance,scalab,scalable,177171,"sting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal value 0x5321. store i16 %val, ptr %ptr. ; In memory the content will be (8-bit addressing):; ;; ; [%ptr + 0]: 00100001 (0x21); ; [%ptr + 1]: 01010011 (0x53). When ``<N*M>`` isn't evenly divisible by the byte size the exact memory layout; is unspecified (just like it is for an integral type of the same size). This; is because different targets could put the padding at different positions when; the type size is smaller than the type's store size. :Syntax:. ::. < <# elements> x <elementtype> > ; Fixed-length vector; < vscale x <# elements> x <elementtype> > ; Scalable vector. The number of elements is a constant integer value larger than 0;; elementtype may be any integer, floating-point or pointer type. Vectors; of size zero are not allowed. For scalable vectors, the total number of; elements is a constant multiple (called vscale) of the specified number; of elements; vscale is a positive integer that is unknown at compile time; and the same hardware-dependent constant for all scalable vectors at run; time. The size of a specific scalable vector type is thus constant within; IR, even if the exact size in bytes cannot be determined until run time. :Examples:. +------------------------+----------------------------------------------------+; | ``<4 x i32>`` | Vector of 4 32-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<8 x float>`` | Vector of 8 32-bit floating-point values. |; +------------------------+----------------------------------------------------+; | ``<2 x i64>`` | Vector of 2 64-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<4 x ptr>`` | Vector of 4 pointers |; +------------------------+----------------------------------------------------+; | ``<vscale x 4 x i32>`` | Vector with a multiple of 4 32-bit integer values. |; +----",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:177407,Performance,scalab,scalable,177407,"sting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal value 0x5321. store i16 %val, ptr %ptr. ; In memory the content will be (8-bit addressing):; ;; ; [%ptr + 0]: 00100001 (0x21); ; [%ptr + 1]: 01010011 (0x53). When ``<N*M>`` isn't evenly divisible by the byte size the exact memory layout; is unspecified (just like it is for an integral type of the same size). This; is because different targets could put the padding at different positions when; the type size is smaller than the type's store size. :Syntax:. ::. < <# elements> x <elementtype> > ; Fixed-length vector; < vscale x <# elements> x <elementtype> > ; Scalable vector. The number of elements is a constant integer value larger than 0;; elementtype may be any integer, floating-point or pointer type. Vectors; of size zero are not allowed. For scalable vectors, the total number of; elements is a constant multiple (called vscale) of the specified number; of elements; vscale is a positive integer that is unknown at compile time; and the same hardware-dependent constant for all scalable vectors at run; time. The size of a specific scalable vector type is thus constant within; IR, even if the exact size in bytes cannot be determined until run time. :Examples:. +------------------------+----------------------------------------------------+; | ``<4 x i32>`` | Vector of 4 32-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<8 x float>`` | Vector of 8 32-bit floating-point values. |; +------------------------+----------------------------------------------------+; | ``<2 x i64>`` | Vector of 2 64-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<4 x ptr>`` | Vector of 4 pointers |; +------------------------+----------------------------------------------------+; | ``<vscale x 4 x i32>`` | Vector with a multiple of 4 32-bit integer values. |; +----",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:177461,Performance,scalab,scalable,177461,"; ;; ; [%ptr + 0]: 00100001 (0x21); ; [%ptr + 1]: 01010011 (0x53). When ``<N*M>`` isn't evenly divisible by the byte size the exact memory layout; is unspecified (just like it is for an integral type of the same size). This; is because different targets could put the padding at different positions when; the type size is smaller than the type's store size. :Syntax:. ::. < <# elements> x <elementtype> > ; Fixed-length vector; < vscale x <# elements> x <elementtype> > ; Scalable vector. The number of elements is a constant integer value larger than 0;; elementtype may be any integer, floating-point or pointer type. Vectors; of size zero are not allowed. For scalable vectors, the total number of; elements is a constant multiple (called vscale) of the specified number; of elements; vscale is a positive integer that is unknown at compile time; and the same hardware-dependent constant for all scalable vectors at run; time. The size of a specific scalable vector type is thus constant within; IR, even if the exact size in bytes cannot be determined until run time. :Examples:. +------------------------+----------------------------------------------------+; | ``<4 x i32>`` | Vector of 4 32-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<8 x float>`` | Vector of 8 32-bit floating-point values. |; +------------------------+----------------------------------------------------+; | ``<2 x i64>`` | Vector of 2 64-bit integer values. |; +------------------------+----------------------------------------------------+; | ``<4 x ptr>`` | Vector of 4 pointers |; +------------------------+----------------------------------------------------+; | ``<vscale x 4 x i32>`` | Vector with a multiple of 4 32-bit integer values. |; +------------------------+----------------------------------------------------+. .. _t_label:. Label Type; ^^^^^^^^^^. :Overview:. The label type represents code labels. :Syntax:. ::. label. .. _t_token:. Token ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:181436,Performance,load,load,181436,"ecision floating-point values. |; +-----------------------------+----------------------------------------------------------+; | ``[2 x [3 x [4 x i16]]]`` | 2x3x4 array of 16-bit integer values. |; +-----------------------------+----------------------------------------------------------+. There is no restriction on indexing beyond the end of the array implied; by a static type (though there are restrictions on indexing beyond the; bounds of an allocated object in some cases). This means that; single-dimension 'variable sized array' addressing can be implemented in; LLVM with a zero length array type. An implementation of 'pascal style; arrays' in LLVM could use the type ""``{ i32, [0 x float]}``"", for; example. .. _t_struct:. Structure Type; """""""""""""""""""""""""""". :Overview:. The structure type is used to represent a collection of data members; together in memory. The elements of a structure may be any type that has; a size. Structures in memory are accessed using '``load``' and '``store``' by; getting a pointer to a field with the '``getelementptr``' instruction.; Structures in registers are accessed using the '``extractvalue``' and; '``insertvalue``' instructions. Structures may optionally be ""packed"" structures, which indicate that; the alignment of the struct is one byte, and that there is no padding; between the elements. In non-packed structs, padding between field types; is inserted as defined by the DataLayout string in the module, which is; required to match what the underlying code generator expects. Structures can either be ""literal"" or ""identified"". A literal structure; is defined inline with other types (e.g. ``[2 x {i32, i32}]``) whereas; identified types are always defined at the top level with a name.; Literal types are uniqued by their contents and can never be recursive; or opaque since there is no way to write one. Identified types can be; recursive, can be opaqued, and are never uniqued. :Syntax:. ::. %T1 = type { <type list> } ; Identified normal struct ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:191200,Performance,optimiz,optimizations,191200,"ction Addresses; --------------------------------------. The addresses of :ref:`global variables <globalvars>` and; :ref:`functions <functionstructure>` are always implicitly valid; (link-time) constants. These constants are explicitly referenced when; the :ref:`identifier for the global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i32 17; @Y = global i32 42; @Z = global [2 x ptr] [ ptr @X, ptr @Y ]. .. _undefvalues:. Undefined Values; ----------------. The string '``undef``' can be used anywhere a constant is expected, and; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Undefined values are useful because they indicate to the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:191265,Performance,optimiz,optimizations,191265,"lobal variables <globalvars>` and; :ref:`functions <functionstructure>` are always implicitly valid; (link-time) constants. These constants are explicitly referenced when; the :ref:`identifier for the global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i32 17; @Y = global i32 42; @Z = global [2 x ptr] [ ptr @X, ptr @Y ]. .. _undefvalues:. Undefined Values; ----------------. The string '``undef``' can be used anywhere a constant is expected, and; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Undefined values are useful because they indicate to the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:191476,Performance,optimiz,optimize,191476," global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i32 17; @Y = global i32 42; @Z = global [2 x ptr] [ ptr @X, ptr @Y ]. .. _undefvalues:. Undefined Values; ----------------. The string '``undef``' can be used anywhere a constant is expected, and; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Undefined values are useful because they indicate to the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192338,Performance,optimiz,optimize,192338,"the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is pro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192487,Performance,optimiz,optimize,192487,"more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:193252,Performance,optimiz,optimizer,193252," is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live range*. Instead, the value is logically; read from arbitrary registers that happen to be around when needed, so; the value is not necessarily consistent over time. In fact, ``%A`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:195423,Performance,optimiz,optimizer,195423,"would not hold. To ensure all uses of a given register observe the same value (even if; '``undef``'), the :ref:`freeze instruction <i_freeze>` can be used. .. code-block:: llvm. %A = sdiv undef, %X; %B = sdiv %X, undef; Safe:; %A = 0; b: unreachable. These examples show the crucial difference between an *undefined value*; and *undefined behavior*. An undefined value (like '``undef``') is; allowed to have an arbitrary bit-pattern. This means that the ``%A``; operation can be constant folded to '``0``', because the '``undef``'; could be zero, and zero divided by any value is zero.; However, in the second example, we can make a more aggressive; assumption: because the ``undef`` is allowed to be an arbitrary value,; we are allowed to assume that it could be zero. Since a divide by zero; has *undefined behavior*, we are allowed to assume that the operation; does not execute at all. This allows us to delete the divide and all; code after it. Because the undefined operation ""can't happen"", the; optimizer can assume that it occurs in dead code. .. code-block:: text. a: store undef -> %X; b: store %X -> undef; Safe:; a: <deleted> (if the stored value in %X is provably not poison); b: unreachable. A store *of* an undefined value can be assumed to not have any effect;; we can assume that the value is overwritten with bits that happen to; match what was already there. This argument is only valid if the stored value; is provably not ``poison``. However, a store *to* an undefined; location could clobber arbitrary memory, therefore, it has undefined; behavior. Branching on an undefined value is undefined behavior.; This explains optimizations that depend on branch conditions to construct; predicates, such as Correlated Value Propagation and Global Value Numbering.; In case of switch instruction, the branch condition should be frozen, otherwise; it is undefined behavior. .. code-block:: llvm. Unsafe:; br undef, BB1, BB2 ; UB. %X = and i32 undef, 255; switch %X, label %ret [ .. ] ; U",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:196062,Performance,optimiz,optimizations,196062,"n arbitrary value,; we are allowed to assume that it could be zero. Since a divide by zero; has *undefined behavior*, we are allowed to assume that the operation; does not execute at all. This allows us to delete the divide and all; code after it. Because the undefined operation ""can't happen"", the; optimizer can assume that it occurs in dead code. .. code-block:: text. a: store undef -> %X; b: store %X -> undef; Safe:; a: <deleted> (if the stored value in %X is provably not poison); b: unreachable. A store *of* an undefined value can be assumed to not have any effect;; we can assume that the value is overwritten with bits that happen to; match what was already there. This argument is only valid if the stored value; is provably not ``poison``. However, a store *to* an undefined; location could clobber arbitrary memory, therefore, it has undefined; behavior. Branching on an undefined value is undefined behavior.; This explains optimizations that depend on branch conditions to construct; predicates, such as Correlated Value Propagation and Global Value Numbering.; In case of switch instruction, the branch condition should be frozen, otherwise; it is undefined behavior. .. code-block:: llvm. Unsafe:; br undef, BB1, BB2 ; UB. %X = and i32 undef, 255; switch %X, label %ret [ .. ] ; UB. store undef, ptr %ptr; %X = load ptr %ptr ; %X is undef; switch i8 %X, label %ret [ .. ] ; UB. Safe:; %X = or i8 undef, 255 ; always 255; switch i8 %X, label %ret [ .. ] ; Well-defined. %X = freeze i1 undef; br %X, BB1, BB2 ; Well-defined (non-deterministic jump). .. _poisonvalues:. Poison Values; -------------. A poison value is a result of an erroneous operation.; In order to facilitate speculative execution, many instructions do not; invoke immediate undefined behavior when provided with illegal operands,; and return a poison value instead.; The string '``poison``' can be used anywhere a constant is expected, and; operations such as :ref:`add <i_add>` with the ``nsw`` flag can produce; a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:196452,Performance,load,load,196452," code. .. code-block:: text. a: store undef -> %X; b: store %X -> undef; Safe:; a: <deleted> (if the stored value in %X is provably not poison); b: unreachable. A store *of* an undefined value can be assumed to not have any effect;; we can assume that the value is overwritten with bits that happen to; match what was already there. This argument is only valid if the stored value; is provably not ``poison``. However, a store *to* an undefined; location could clobber arbitrary memory, therefore, it has undefined; behavior. Branching on an undefined value is undefined behavior.; This explains optimizations that depend on branch conditions to construct; predicates, such as Correlated Value Propagation and Global Value Numbering.; In case of switch instruction, the branch condition should be frozen, otherwise; it is undefined behavior. .. code-block:: llvm. Unsafe:; br undef, BB1, BB2 ; UB. %X = and i32 undef, 255; switch %X, label %ret [ .. ] ; UB. store undef, ptr %ptr; %X = load ptr %ptr ; %X is undef; switch i8 %X, label %ret [ .. ] ; UB. Safe:; %X = or i8 undef, 255 ; always 255; switch i8 %X, label %ret [ .. ] ; Well-defined. %X = freeze i1 undef; br %X, BB1, BB2 ; Well-defined (non-deterministic jump). .. _poisonvalues:. Poison Values; -------------. A poison value is a result of an erroneous operation.; In order to facilitate speculative execution, many instructions do not; invoke immediate undefined behavior when provided with illegal operands,; and return a poison value instead.; The string '``poison``' can be used anywhere a constant is expected, and; operations such as :ref:`add <i_add>` with the ``nsw`` flag can produce; a poison value. Most instructions return '``poison``' when one of their arguments is; '``poison``'. A notable exception is the :ref:`select instruction <i_select>`.; Propagation of poison can be stopped with the; :ref:`freeze instruction <i_freeze>`. It is correct to replace a poison value with an; :ref:`undef value <undefvalues>` or any valu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:197721,Performance,load,load,197721,"t of an erroneous operation.; In order to facilitate speculative execution, many instructions do not; invoke immediate undefined behavior when provided with illegal operands,; and return a poison value instead.; The string '``poison``' can be used anywhere a constant is expected, and; operations such as :ref:`add <i_add>` with the ``nsw`` flag can produce; a poison value. Most instructions return '``poison``' when one of their arguments is; '``poison``'. A notable exception is the :ref:`select instruction <i_select>`.; Propagation of poison can be stopped with the; :ref:`freeze instruction <i_freeze>`. It is correct to replace a poison value with an; :ref:`undef value <undefvalues>` or any value of the type. This means that immediate undefined behavior occurs if a poison value is; used as an instruction operand that has any values that trigger undefined; behavior. Notably this includes (but is not limited to):. - The pointer operand of a :ref:`load <i_load>`, :ref:`store <i_store>` or; any other pointer dereferencing instruction (independent of address; space).; - The divisor operand of a ``udiv``, ``sdiv``, ``urem`` or ``srem``; instruction.; - The condition operand of a :ref:`br <i_br>` instruction.; - The callee operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction.; - The parameter operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction, when the function or invoking call site has a ``noundef``; attribute in the corresponding position.; - The operand of a :ref:`ret <i_ret>` instruction if the function or invoking; call site has a `noundef` attribute in the return value position. Here are some examples:. .. code-block:: llvm. entry:; %poison = sub nuw i32 0, 1 ; Results in a poison value.; %poison2 = sub i32 poison, 1 ; Also results in a poison value.; %still_poison = and i32 %poison, 0 ; 0, but also poison.; %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison; store i32 0, ptr %poison_yet_again ; Undefined beha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:198867,Performance,load,load,198867," ``urem`` or ``srem``; instruction.; - The condition operand of a :ref:`br <i_br>` instruction.; - The callee operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction.; - The parameter operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction, when the function or invoking call site has a ``noundef``; attribute in the corresponding position.; - The operand of a :ref:`ret <i_ret>` instruction if the function or invoking; call site has a `noundef` attribute in the return value position. Here are some examples:. .. code-block:: llvm. entry:; %poison = sub nuw i32 0, 1 ; Results in a poison value.; %poison2 = sub i32 poison, 1 ; Also results in a poison value.; %still_poison = and i32 %poison, 0 ; 0, but also poison.; %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison; store i32 0, ptr %poison_yet_again ; Undefined behavior due to; ; store to poison. store i32 %poison, ptr @g ; Poison value stored to memory.; %poison3 = load i32, ptr @g ; Poison value loaded back from memory. %poison4 = load i16, ptr @g ; Returns a poison value.; %poison5 = load i64, ptr @g ; Returns a poison value. %cmp = icmp slt i32 %poison, 0 ; Returns a poison value.; br i1 %cmp, label %end, label %end ; undefined behavior. end:. .. _welldefinedvalues:. Well-Defined Values; -------------------. Given a program execution, a value is *well defined* if the value does not; have an undef bit and is not poison in the execution.; An aggregate value or vector is well defined if its elements are well defined.; The padding of an aggregate isn't considered, since it isn't visible; without storing it into memory and loading it with a different type. A constant of a :ref:`single value <t_single_value>`, non-vector type is well; defined if it is neither '``undef``' constant nor '``poison``' constant.; The result of :ref:`freeze instruction <i_freeze>` is well defined regardless; of its operand. .. _blockaddress:. Addresses of Basic Blocks; -------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:198899,Performance,load,loaded,198899," ``urem`` or ``srem``; instruction.; - The condition operand of a :ref:`br <i_br>` instruction.; - The callee operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction.; - The parameter operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction, when the function or invoking call site has a ``noundef``; attribute in the corresponding position.; - The operand of a :ref:`ret <i_ret>` instruction if the function or invoking; call site has a `noundef` attribute in the return value position. Here are some examples:. .. code-block:: llvm. entry:; %poison = sub nuw i32 0, 1 ; Results in a poison value.; %poison2 = sub i32 poison, 1 ; Also results in a poison value.; %still_poison = and i32 %poison, 0 ; 0, but also poison.; %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison; store i32 0, ptr %poison_yet_again ; Undefined behavior due to; ; store to poison. store i32 %poison, ptr @g ; Poison value stored to memory.; %poison3 = load i32, ptr @g ; Poison value loaded back from memory. %poison4 = load i16, ptr @g ; Returns a poison value.; %poison5 = load i64, ptr @g ; Returns a poison value. %cmp = icmp slt i32 %poison, 0 ; Returns a poison value.; br i1 %cmp, label %end, label %end ; undefined behavior. end:. .. _welldefinedvalues:. Well-Defined Values; -------------------. Given a program execution, a value is *well defined* if the value does not; have an undef bit and is not poison in the execution.; An aggregate value or vector is well defined if its elements are well defined.; The padding of an aggregate isn't considered, since it isn't visible; without storing it into memory and loading it with a different type. A constant of a :ref:`single value <t_single_value>`, non-vector type is well; defined if it is neither '``undef``' constant nor '``poison``' constant.; The result of :ref:`freeze instruction <i_freeze>` is well defined regardless; of its operand. .. _blockaddress:. Addresses of Basic Blocks; -------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:198935,Performance,load,load,198935,"f a :ref:`br <i_br>` instruction.; - The callee operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction.; - The parameter operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction, when the function or invoking call site has a ``noundef``; attribute in the corresponding position.; - The operand of a :ref:`ret <i_ret>` instruction if the function or invoking; call site has a `noundef` attribute in the return value position. Here are some examples:. .. code-block:: llvm. entry:; %poison = sub nuw i32 0, 1 ; Results in a poison value.; %poison2 = sub i32 poison, 1 ; Also results in a poison value.; %still_poison = and i32 %poison, 0 ; 0, but also poison.; %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison; store i32 0, ptr %poison_yet_again ; Undefined behavior due to; ; store to poison. store i32 %poison, ptr @g ; Poison value stored to memory.; %poison3 = load i32, ptr @g ; Poison value loaded back from memory. %poison4 = load i16, ptr @g ; Returns a poison value.; %poison5 = load i64, ptr @g ; Returns a poison value. %cmp = icmp slt i32 %poison, 0 ; Returns a poison value.; br i1 %cmp, label %end, label %end ; undefined behavior. end:. .. _welldefinedvalues:. Well-Defined Values; -------------------. Given a program execution, a value is *well defined* if the value does not; have an undef bit and is not poison in the execution.; An aggregate value or vector is well defined if its elements are well defined.; The padding of an aggregate isn't considered, since it isn't visible; without storing it into memory and loading it with a different type. A constant of a :ref:`single value <t_single_value>`, non-vector type is well; defined if it is neither '``undef``' constant nor '``poison``' constant.; The result of :ref:`freeze instruction <i_freeze>` is well defined regardless; of its operand. .. _blockaddress:. Addresses of Basic Blocks; -------------------------. ``blockaddress(@function, %block)``. The '``blockaddress``'",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:198990,Performance,load,load,198990,"d of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction.; - The parameter operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; instruction, when the function or invoking call site has a ``noundef``; attribute in the corresponding position.; - The operand of a :ref:`ret <i_ret>` instruction if the function or invoking; call site has a `noundef` attribute in the return value position. Here are some examples:. .. code-block:: llvm. entry:; %poison = sub nuw i32 0, 1 ; Results in a poison value.; %poison2 = sub i32 poison, 1 ; Also results in a poison value.; %still_poison = and i32 %poison, 0 ; 0, but also poison.; %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison; store i32 0, ptr %poison_yet_again ; Undefined behavior due to; ; store to poison. store i32 %poison, ptr @g ; Poison value stored to memory.; %poison3 = load i32, ptr @g ; Poison value loaded back from memory. %poison4 = load i16, ptr @g ; Returns a poison value.; %poison5 = load i64, ptr @g ; Returns a poison value. %cmp = icmp slt i32 %poison, 0 ; Returns a poison value.; br i1 %cmp, label %end, label %end ; undefined behavior. end:. .. _welldefinedvalues:. Well-Defined Values; -------------------. Given a program execution, a value is *well defined* if the value does not; have an undef bit and is not poison in the execution.; An aggregate value or vector is well defined if its elements are well defined.; The padding of an aggregate isn't considered, since it isn't visible; without storing it into memory and loading it with a different type. A constant of a :ref:`single value <t_single_value>`, non-vector type is well; defined if it is neither '``undef``' constant nor '``poison``' constant.; The result of :ref:`freeze instruction <i_freeze>` is well defined regardless; of its operand. .. _blockaddress:. Addresses of Basic Blocks; -------------------------. ``blockaddress(@function, %block)``. The '``blockaddress``' constant computes the address of the specified; basic ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:199536,Performance,load,loading,199536,"sults in a poison value.; %poison2 = sub i32 poison, 1 ; Also results in a poison value.; %still_poison = and i32 %poison, 0 ; 0, but also poison.; %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison; store i32 0, ptr %poison_yet_again ; Undefined behavior due to; ; store to poison. store i32 %poison, ptr @g ; Poison value stored to memory.; %poison3 = load i32, ptr @g ; Poison value loaded back from memory. %poison4 = load i16, ptr @g ; Returns a poison value.; %poison5 = load i64, ptr @g ; Returns a poison value. %cmp = icmp slt i32 %poison, 0 ; Returns a poison value.; br i1 %cmp, label %end, label %end ; undefined behavior. end:. .. _welldefinedvalues:. Well-Defined Values; -------------------. Given a program execution, a value is *well defined* if the value does not; have an undef bit and is not poison in the execution.; An aggregate value or vector is well defined if its elements are well defined.; The padding of an aggregate isn't considered, since it isn't visible; without storing it into memory and loading it with a different type. A constant of a :ref:`single value <t_single_value>`, non-vector type is well; defined if it is neither '``undef``' constant nor '``poison``' constant.; The result of :ref:`freeze instruction <i_freeze>` is well defined regardless; of its operand. .. _blockaddress:. Addresses of Basic Blocks; -------------------------. ``blockaddress(@function, %block)``. The '``blockaddress``' constant computes the address of the specified; basic block in the specified function. It always has an ``ptr addrspace(P)`` type, where ``P`` is the address space; of the function containing ``%block`` (usually ``addrspace(0)``). Taking the address of the entry block is illegal. This value only has defined behavior when used as an operand to the; ':ref:`indirectbr <i_indirectbr>`' or for comparisons against null. Pointer; equality tests between labels addresses results in undefined behavior ---; though, again, comparison against null is ok, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:200689,Performance,perform,performed,200689,"; The result of :ref:`freeze instruction <i_freeze>` is well defined regardless; of its operand. .. _blockaddress:. Addresses of Basic Blocks; -------------------------. ``blockaddress(@function, %block)``. The '``blockaddress``' constant computes the address of the specified; basic block in the specified function. It always has an ``ptr addrspace(P)`` type, where ``P`` is the address space; of the function containing ``%block`` (usually ``addrspace(0)``). Taking the address of the entry block is illegal. This value only has defined behavior when used as an operand to the; ':ref:`indirectbr <i_indirectbr>`' or for comparisons against null. Pointer; equality tests between labels addresses results in undefined behavior ---; though, again, comparison against null is ok, and no label is equal to the null; pointer. This may be passed around as an opaque pointer sized value as long as; the bits are not inspected. This allows ``ptrtoint`` and arithmetic to be; performed on these values so long as the original value is reconstituted before; the ``indirectbr`` instruction. Finally, some targets may provide defined semantics when using the value; as the operand to an inline assembly, but that is target specific. .. _dso_local_equivalent:. DSO Local Equivalent; --------------------. ``dso_local_equivalent @func``. A '``dso_local_equivalent``' constant represents a function which is; functionally equivalent to a given function, but is always defined in the; current linkage unit. The resulting pointer has the same type as the underlying; function. The resulting pointer is permitted, but not required, to be different; from a pointer to the function, and it may have different values in different; translation units. The target function may not have ``extern_weak`` linkage. ``dso_local_equivalent`` can be implemented as such:. - If the function has local linkage, hidden visibility, or is; ``dso_local``, ``dso_local_equivalent`` can be implemented as simply a pointer; to the function",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:203447,Performance,load,load,203447,"ic relocations for function pointers in VTables can be replaced with; static relocations for offsets between the VTable and virtual functions which; may not be ``dso_local``. This is currently only supported for ELF binary formats. .. _no_cfi:. No CFI; ------. ``no_cfi @func``. With `Control-Flow Integrity (CFI); <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_, a '``no_cfi``'; constant represents a function reference that does not get replaced with a; reference to the CFI jump table in the ``LowerTypeTests`` pass. These constants; may be useful in low-level programs, such as operating system kernels, which; need to refer to the actual function body. .. _constantexprs:. Constant Expressions; --------------------. Constant expressions are used to allow expressions involving other; constants to be used as constants. Constant expressions may be of any; :ref:`first class <t_firstclass>` type and may involve any LLVM operation; that does not have side effects (e.g. load and call are not supported).; The following is the syntax for constant expressions:. ``trunc (CST to TYPE)``; Perform the :ref:`trunc operation <i_trunc>` on constants.; ``ptrtoint (CST to TYPE)``; Perform the :ref:`ptrtoint operation <i_ptrtoint>` on constants.; ``inttoptr (CST to TYPE)``; Perform the :ref:`inttoptr operation <i_inttoptr>` on constants.; This one is *really* dangerous!; ``bitcast (CST to TYPE)``; Convert a constant, CST, to another TYPE.; The constraints of the operands are the same as those for the; :ref:`bitcast instruction <i_bitcast>`.; ``addrspacecast (CST to TYPE)``; Convert a constant pointer or constant vector of pointer, CST, to another; TYPE in a different address space. The constraints of the operands are the; same as those for the :ref:`addrspacecast instruction <i_addrspacecast>`.; ``getelementptr (TY, CSTPTR, IDX0, IDX1, ...)``, ``getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)``; Perform the :ref:`getelementptr operation <i_getelementptr>` on; constants. As w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:207170,Performance,optimiz,optimizations,207170,"on of the operands using ""``$``""; followed by a number, to indicate substitution of the given register/memory; location, as specified by the constraint string. ""``${NUM:MODIFIER}``"" may also; be used, where ``MODIFIER`` is a target-specific annotation for how to print the; operand (See :ref:`inline-asm-modifiers`). A literal ""``$``"" may be included by using ""``$$``"" in the template. To include; other special characters into the output, the usual ""``\XX``"" escapes may be; used, just as in other strings. Note that after template substitution, the; resulting assembly string is parsed by LLVM's integrated assembler unless it is; disabled -- even when emitting a ``.s`` file -- and thus must contain assembly; syntax known to LLVM. LLVM also supports a few more substitutions useful for writing inline assembly:. - ``${:uid}``: Expands to a decimal integer unique to this inline assembly blob.; This substitution is useful when declaring a local label. Many standard; compiler optimizations, such as inlining, may duplicate an inline asm blob.; Adding a blob-unique identifier ensures that the two labels will not conflict; during assembly. This is used to implement `GCC's %= special format; string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_.; - ``${:comment}``: Expands to the comment character of the current target's; assembly dialect. This is usually ``#``, but many targets use other strings,; such as ``;``, ``//``, or ``!``.; - ``${:private}``: Expands to the assembler private label prefix. Labels with; this prefix will not appear in the symbol table of the assembled object.; Typically the prefix is ``L``, but targets may use other strings. ``.L`` is; relatively popular. LLVM's support for inline asm is modeled closely on the requirements of Clang's; GCC-compatible inline-asm support. Thus, the feature-set and the constraint and; modifier codes listed here are similar or identical to those in GCC's inline asm; support. However, to be clear, the syntax of the templat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:214775,Performance,load,load,214775," the 0'th; constraint). It is permitted to tie an input to an ""early-clobber"" output. In that case, no; *other* input may share the same register as the input tied to the early-clobber; (even when the other input has the same value). You may only tie an input to an output which has a register constraint, not a; memory constraint. Only a single input may be tied to an output. There is also an ""interesting"" feature which deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:214850,Performance,load,loads,214850,". In that case, no; *other* input may share the same register as the input tied to the early-clobber; (even when the other input has the same value). You may only tie an input to an output which has a register constraint, not a; memory constraint. Only a single input may be tied to an output. There is also an ""interesting"" feature which deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:216774,Performance,optimiz,optimization,216774," the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). This is most typically used for memory constraint, e.g. ""``=*m``"", to pass the; address of a variable as a value. It is also possible to use an indirect *register* constraint, but only on output; (e.g. ""``=*r``""). This will cause LLVM to allocate a register for an output; value normally, and then, separately emit a store to the address provided as; input, after the provided inline asm. (It's not clear what value this; functionality provides, compared to writing the store explicitly after the asm; statement, and it can only produce worse code, since it bypasses many; optimization passes. I would recommend not using it.). Call arguments for indirect constraints must have pointer type and must specify; the :ref:`elementtype <attr_elementtype>` attribute to indicate the pointer; element type. Clobber constraints; """""""""""""""""""""""""""""""""""""". A clobber constraint is indicated by a ""``~``"" prefix. A clobber does not; consume an input operand, nor generate an output. Clobbers cannot use any of the; general constraint code letters -- they may use only explicit register; constraints, e.g. ""``~{eax}``"". The one exception is that a clobber string of; ""``~{memory}``"" indicates that the assembly writes to arbitrary undeclared; memory locations -- not only the memory pointed to by a declared indirect; output. Note that clobbering named registers that are also present in output; constraints is not legal. Label constraints; """""""""""""""""""""""""""""""""". A label constraint is indicated by a ""``!``"" pre",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:219934,Performance,perform,performance,219934,"s in the set"". The; choice of constraint is made independently for each constraint in the; constraint list. 2) Use ""``|``"" between constraint code sets, creating alternatives. Every; constraint in the constraint list must have the same number of alternative; sets. With this syntax, the same alternative in *all* of the items in the; constraint list will be chosen together. Putting those together, you might have a two operand constraint string like; ``""rm|r,ri|rm""``. This indicates that if operand 0 is ``r`` or ``m``, then; operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand 1; may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type m. However, the use of either of the alternatives features is *NOT* recommended, as; LLVM is not able to make an intelligent choice about which one to use. (At the; point it currently needs to choose, not enough information is available to do so; in a smart way.) Thus, it simply tries to make a choice that's most likely to; compile, not one that will be optimal performance. (e.g., given ""``rm``"", it'll; always choose to use memory, not registers). And, if given multiple registers,; or multiple register classes, it will simply choose the first one. (In fact, it; doesn't currently even ensure explicitly specified physical registers are; unique, so specifying multiple physical registers as alternatives, like; ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address oper",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:221141,Performance,load,load,221141,"ly even ensure explicitly specified physical registers are; unique, so specifying multiple physical registers as alternatives, like; ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address operand. It is target-specific what addressing modes; are supported, typical examples are register, or register + register offset,; or register + immediate offset (of some target-specific size).; - ``p``: An address operand. Similar to ``m``, but used by ""load address""; type instructions without touching memory.; - ``i``: An integer constant (of target-specific width). Allows either a simple; immediate, or a relocatable value.; - ``n``: An integer constant -- *not* including relocatable values.; - ``s``: An integer constant, but allowing *only* relocatable values.; - ``X``: Allows an operand of any kind, no constraint whatsoever. Typically; useful to pass a label for an asm branch or call. .. FIXME: but that surely isn't actually okay to jump out of an asm; block without telling llvm about the control transfer???). - ``{register-name}``: Requires exactly the named physical register. Other constraints are target-specific:. AArch64:. - ``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate.; - ``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction,; i.e. 0 to 4095 with optional shift by 12.; - ``J``: An immediate integer that, when negated, is valid for an ``ADD`` or; ``SUB`` instruction, i.e. -1 to -4095 with optio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:222702,Performance,load,loaded,222702,"g llvm about the control transfer???). - ``{register-name}``: Requires exactly the named physical register. Other constraints are target-specific:. AArch64:. - ``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate.; - ``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction,; i.e. 0 to 4095 with optional shift by 12.; - ``J``: An immediate integer that, when negated, is valid for an ``ADD`` or; ``SUB`` instruction, i.e. -1 to -4095 with optional left shift by 12.; - ``K``: An immediate integer that is valid for the 'bitmask immediate 32' of a; logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 32-bit register.; - ``L``: An immediate integer that is valid for the 'bitmask immediate 64' of a; logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 64-bit register.; - ``M``: An immediate integer for use with the ``MOV`` assembly alias on a; 32-bit register. This is a superset of ``K``: in addition to the bitmask; immediate, also allows immediate integers which can be loaded with a single; ``MOVZ`` or ``MOVL`` instruction.; - ``N``: An immediate integer for use with the ``MOV`` assembly alias on a; 64-bit register. This is a superset of ``L``.; - ``Q``: Memory address operand must be in a single register (no; offsets). (However, LLVM currently does this for the ``m`` constraint as; well.); - ``r``: A 32 or 64-bit integer register (W* or X*).; - ``Uci``: Like r, but restricted to registers 8 to 11 inclusive.; - ``Ucj``: Like r, but restricted to registers 12 to 15 inclusive.; - ``w``: A 32, 64, or 128-bit floating-point, SIMD or SVE vector register.; - ``x``: Like w, but restricted to registers 0 to 15 inclusive.; - ``y``: Like w, but restricted to SVE vector registers Z0 to Z7 inclusive.; - ``Uph``: One of the upper eight SVE predicate registers (P8 to P15); - ``Upl``: One of the lower eight SVE predicate registers (P0 to P7); - ``Upa``: Any of the SVE predicate registers (P0 to P15). AMDGPU:. - ``r``: A 32 or 64-bit int",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:242671,Performance,optimiz,optimizers,242671,"ugh it's PC-relative.). XCore:. No additional modifiers. Inline Asm Metadata; ^^^^^^^^^^^^^^^^^^^. The call instructions that wrap inline asm nodes may have a; ""``!srcloc``"" MDNode attached to it that contains a list of constant; integers. If present, the code generator will use the integer as the; location cookie value when report errors through the ``LLVMContext``; error reporting mechanisms. This allows a front-end to correlate backend; errors that occur with inline asm back to the source code that produced; it. For example:. .. code-block:: llvm. call void asm sideeffect ""something bad"", """"(), !srcloc !42; ...; !42 = !{ i32 1234567 }. It is up to the front-end to make sense of the magic numbers it places; in the IR. If the MDNode contains multiple constants, the code generator; will use the one that corresponds to the line of the asm that the error; occurs on. .. _metadata:. Metadata; ========. LLVM IR allows metadata to be attached to instructions and global objects in the; program that can convey extra information about the code to the optimizers and; code generator. One example application of metadata is source-level; debug information. There are two metadata primitives: strings and nodes. Metadata does not have a type, and is not a value. If referenced from a; ``call`` instruction, it uses the ``metadata`` type. All metadata are identified in syntax by an exclamation point ('``!``'). .. _metadata-string:. Metadata Nodes and Metadata Strings; -----------------------------------. A metadata string is a string surrounded by double quotes. It can; contain any character by escaping non-printable characters with; ""``\xx``"" where ""``xx``"" is the two digit hex code. For example:; ""``!""test\00""``"". Metadata nodes are represented with notation similar to structure; constants (a comma separated list of elements, surrounded by braces and; preceded by an exclamation point). Metadata nodes can have any values as; their operand. For example:. .. code-block:: llvm. !{ !""tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:245697,Performance,optimiz,optimizers,245697,"r a global variable. Here metadata; ``!22`` is attached to the ``f1`` and ``f2`` functions, and the globals ``g1``; and ``g2`` using the ``!dbg`` identifier:. .. code-block:: llvm. declare !dbg !22 void @f1(); define void @f2() !dbg !22 {; ret void; }. @g1 = global i32 0, !dbg !22; @g2 = external global i32, !dbg !22. Unlike instructions, global objects (functions and global variables) may have; multiple metadata attachments with the same identifier. A transformation is required to drop any metadata attachment that it; does not know or know it can't preserve. Currently there is an; exception for metadata attachment to globals for ``!func_sanitize``,; ``!type``, ``!absolute_symbol`` and ``!associated`` which can't be; unconditionally dropped unless the global is itself deleted. Metadata attached to a module using named metadata may not be dropped, with; the exception of debug metadata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata nodes recognized by the; optimizers and code generator is found below. .. _specialized-metadata:. Specialized Metadata Nodes; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Specialized metadata nodes are custom data structures in metadata (as opposed; to generic tuples). Their fields are labelled, and can be specified in any; order. These aren't inherently debug info centric, but currently all the specialized; metadata nodes are related to debug info. .. _DICompileUnit:. DICompileUnit; """""""""""""""""""""""""". ``DICompileUnit`` nodes represent a compile unit. The ``enums:``,; ``retainedTypes:``, ``globals:``, ``imports:`` and ``macros:`` fields are tuples; containing the debug info to be emitted along with the compile unit, regardless; of code optimizations (some nodes are only emitted if there are references to; them from instructions). The ``debugInfoForProfiling:`` field is a boolean; indicating whether or not line-table discriminators are updated to provide; more-accurate debug info for profiling results. .. code-block:: te",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:246397,Performance,optimiz,optimizations,246397,"pe``, ``!absolute_symbol`` and ``!associated`` which can't be; unconditionally dropped unless the global is itself deleted. Metadata attached to a module using named metadata may not be dropped, with; the exception of debug metadata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata nodes recognized by the; optimizers and code generator is found below. .. _specialized-metadata:. Specialized Metadata Nodes; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Specialized metadata nodes are custom data structures in metadata (as opposed; to generic tuples). Their fields are labelled, and can be specified in any; order. These aren't inherently debug info centric, but currently all the specialized; metadata nodes are related to debug info. .. _DICompileUnit:. DICompileUnit; """""""""""""""""""""""""". ``DICompileUnit`` nodes represent a compile unit. The ``enums:``,; ``retainedTypes:``, ``globals:``, ``imports:`` and ``macros:`` fields are tuples; containing the debug info to be emitted along with the compile unit, regardless; of code optimizations (some nodes are only emitted if there are references to; them from instructions). The ``debugInfoForProfiling:`` field is a boolean; indicating whether or not line-table discriminators are updated to provide; more-accurate debug info for profiling results. .. code-block:: text. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang"",; isOptimized: true, flags: ""-O2"", runtimeVersion: 2,; splitDebugFilename: ""abc.debug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:257912,Performance,optimiz,optimized,257912," nodes tie a :ref:`DIGlobalVariable` together; with a :ref:`DIExpression`. .. code-block:: text. @lower = global i32, !dbg !0; @upper = global i32, !dbg !1; !0 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32); ); !1 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32); ); !2 = !DIGlobalVariable(name: ""split64"", linkageName: ""split64"", scope: !3,; file: !4, line: 8, type: !5, declaration: !6). All global variable expressions should be referenced by the `globals:` field of; a :ref:`compile unit <DICompileUnit>`. .. _DISubprogram:. DISubprogram; """""""""""""""""""""""". ``DISubprogram`` nodes represent functions from the source language. A distinct; ``DISubprogram`` may be attached to a function definition using ``!dbg``; metadata. A unique ``DISubprogram`` may be attached to a function declaration; used for call site debug info. The ``retainedNodes:`` field is a list of; :ref:`variables <DILocalVariable>` and :ref:`labels <DILabel>` that must be; retained, even if their IR counterparts are optimized out of the IR. The; ``type:`` field must point at an :ref:`DISubroutineType`. .. _DISubprogramDeclaration:. When ``spFlags: DISPFlagDefinition`` is not present, subprograms describe a; declaration in the type tree as opposed to a definition of a function. In this; case, the ``declaration`` field must be empty. If the scope is a composite type; with an ODR ``identifier:`` and that does not set ``flags: DIFwdDecl``, then; the subprogram declaration is uniqued based only on its ``linkageName:`` and; ``scope:``. .. code-block:: text. define void @_Z3foov() !dbg !0 {; ...; }. !0 = distinct !DISubprogram(name: ""foo"", linkageName: ""_Zfoov"", scope: !1,; file: !2, line: 7, type: !3,; spFlags: DISPFlagDefinition | DISPFlagLocalToUnit,; scopeLine: 8, containingType: !4,; virtuality: DW_VIRTUALITY_pure_virtual,; virtualIndex: 10, flags: DIFlagPrototyped,; isOptimized: true, unit: !5, templateParams: !6,; declaration: !",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:266129,Performance,optimiz,optimized,266129,"to; ``%reg1 - reg2``. This list of values should be provided by the containing; intrinsic/instruction.; - ``DW_OP_breg`` (or ``DW_OP_bregx``) represents a content on the provided; signed offset of the specified register. The opcode is only generated by the; ``AsmPrinter`` pass to describe call site parameter value which requires an; expression over two registers.; - ``DW_OP_push_object_address`` pushes the address of the object which can then; serve as a descriptor in subsequent calculation. This opcode can be used to; calculate bounds of fortran allocatable array which has array descriptors.; - ``DW_OP_over`` duplicates the entry currently second in the stack at the top; of the stack. This opcode can be used to calculate bounds of fortran assumed; rank array which has rank known at run time and current dimension number is; implicitly first element of the stack.; - ``DW_OP_LLVM_implicit_pointer`` It specifies the dereferenced value. It can; be used to represent pointer variables which are optimized out but the value; it points to is known. This operator is required as it is different than DWARF; operator DW_OP_implicit_pointer in representation and specification (number; and types of operands) and later can not be used as multiple level. .. code-block:: text. IR for ""*ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !20); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:274554,Performance,load,load,274554,". The rules mentioned in; this section only pertain to TBAA nodes living under the same root. .. _tbaa_node_semantics:. Semantics; """""""""""""""""". The TBAA metadata system, referred to as ""struct path TBAA"" (not to be; confused with ``tbaa.struct``), consists of the following high level; concepts: *Type Descriptors*, further subdivided into scalar type; descriptors and struct type descriptors; and *Access Tags*. **Type descriptors** describe the type system of the higher level language; being compiled. **Scalar type descriptors** describe types that do not; contain other types. Each scalar type has a parent type, which must also; be a scalar type or the TBAA root. Via this parent relation, scalar types; within a TBAA root form a tree. **Struct type descriptors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:275104,Performance,load,load,275104,"Each scalar type has a parent type, which must also; be a scalar type or the TBAA root. Via this parent relation, scalar types; within a TBAA root form a tree. **Struct type descriptors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in; ``BaseTy`` at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted; to be relative within that inner type. A memory access with an access tag ``(BaseTy1, AccessTy1, Offset1)``; aliases a memory access with an access tag ``(BaseTy2",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:281161,Performance,load,loads,281161,"adata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the byte offset of a; field in bytes, the second gives its size in bytes, and the third gives; its tbaa tag. e.g.:. .. code-block:: llvm. !4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }. This describes a struct with two fields. The first is at offset 0 bytes; with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes; and has size 4 bytes and has tbaa tag !2. Note that the fields need not be contiguous. In this example, there is a; 4 byte gap between the two fields. This gap represents padding which; does not carry useful data and need not be preserved. '``noalias``' and '``alias.scope``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``noalias`` and ``alias.scope`` metadata provide the ability to specify generic; noalias memory-access sets. This means that some collection of memory access; instructions (loads, stores, memory-accessing calls, etc.) that carry; ``noalias`` metadata can specifically be specified not to alias with some other; collection of memory access instructions that carry ``alias.scope`` metadata.; Each type of metadata specifies a list of scopes where each scope has an id and; a domain. When evaluating an aliasing query, if for some domain, the set; of scopes with that domain in one instruction's ``alias.scope`` list is a; subset of (or equal to) the set of scopes for that domain in another; instruction's ``noalias`` list, then the two memory accesses are assumed not to; alias. Because scopes in one domain don't affect scopes in other domains, separate; domains can be used to compose multiple independent noalias sets. This is; used for example during inlining. As the noalias function parameters are; turned into noalias scope metadata, a new domain is used every time the; function is inlined. The metadata identifying each domain is itself a list containing",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:283202,Performance,load,load,283202,"me of the domain. Note that if the name is a; string then it can be combined across functions and translation units. A; self-reference can be used to create globally unique domain names. A; descriptive string may optionally be provided as a second list entry. The metadata identifying each scope is also itself a list containing two or; three entries. The first entry is the name of the scope. Note that if the name; is a string then it can be combined across functions and translation units. A; self-reference can be used to create globally unique scope names. A metadata; reference to the scope's domain is the second entry. A descriptive string may; optionally be provided as a third list entry. For example,. .. code-block:: llvm. ; Two scope domains:; !0 = !{!0}; !1 = !{!1}. ; Some scopes in these domains:; !2 = !{!2, !0}; !3 = !{!3, !0}; !4 = !{!4, !1}. ; Some scope lists:; !5 = !{!4} ; A list containing only scope !4; !6 = !{!4, !3, !2}; !7 = !{!3}. ; These two instructions don't alias:; %0 = load float, ptr %c, align 4, !alias.scope !5; store float %0, ptr %arrayidx.i, align 4, !noalias !5. ; These two instructions also don't alias (for domain !1, the set of scopes; ; in the !alias.scope equals that in the !noalias list):; %2 = load float, ptr %c, align 4, !alias.scope !5; store float %2, ptr %arrayidx.i2, align 4, !noalias !6. ; These two instructions may alias (for domain !0, the set of scopes in; ; the !noalias list is not a superset of, or equal to, the scopes in the; ; !alias.scope list):; %2 = load float, ptr %c, align 4, !alias.scope !6; store float %0, ptr %arrayidx.i, align 4, !noalias !7. '``fpmath``' Metadata; ^^^^^^^^^^^^^^^^^^^^^. ``fpmath`` metadata may be attached to any instruction of floating-point; type. It can be used to express the maximum acceptable error in the; result of that instruction, in ULPs, thus potentially allowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:283443,Performance,load,load,283443," second list entry. The metadata identifying each scope is also itself a list containing two or; three entries. The first entry is the name of the scope. Note that if the name; is a string then it can be combined across functions and translation units. A; self-reference can be used to create globally unique scope names. A metadata; reference to the scope's domain is the second entry. A descriptive string may; optionally be provided as a third list entry. For example,. .. code-block:: llvm. ; Two scope domains:; !0 = !{!0}; !1 = !{!1}. ; Some scopes in these domains:; !2 = !{!2, !0}; !3 = !{!3, !0}; !4 = !{!4, !1}. ; Some scope lists:; !5 = !{!4} ; A list containing only scope !4; !6 = !{!4, !3, !2}; !7 = !{!3}. ; These two instructions don't alias:; %0 = load float, ptr %c, align 4, !alias.scope !5; store float %0, ptr %arrayidx.i, align 4, !noalias !5. ; These two instructions also don't alias (for domain !1, the set of scopes; ; in the !alias.scope equals that in the !noalias list):; %2 = load float, ptr %c, align 4, !alias.scope !5; store float %2, ptr %arrayidx.i2, align 4, !noalias !6. ; These two instructions may alias (for domain !0, the set of scopes in; ; the !noalias list is not a superset of, or equal to, the scopes in the; ; !alias.scope list):; %2 = load float, ptr %c, align 4, !alias.scope !6; store float %0, ptr %arrayidx.i, align 4, !noalias !7. '``fpmath``' Metadata; ^^^^^^^^^^^^^^^^^^^^^. ``fpmath`` metadata may be attached to any instruction of floating-point; type. It can be used to express the maximum acceptable error in the; result of that instruction, in ULPs, thus potentially allowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a real number that lies between two finite consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-poin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:283720,Performance,load,load,283720,"e globally unique scope names. A metadata; reference to the scope's domain is the second entry. A descriptive string may; optionally be provided as a third list entry. For example,. .. code-block:: llvm. ; Two scope domains:; !0 = !{!0}; !1 = !{!1}. ; Some scopes in these domains:; !2 = !{!2, !0}; !3 = !{!3, !0}; !4 = !{!4, !1}. ; Some scope lists:; !5 = !{!4} ; A list containing only scope !4; !6 = !{!4, !3, !2}; !7 = !{!3}. ; These two instructions don't alias:; %0 = load float, ptr %c, align 4, !alias.scope !5; store float %0, ptr %arrayidx.i, align 4, !noalias !5. ; These two instructions also don't alias (for domain !1, the set of scopes; ; in the !alias.scope equals that in the !noalias list):; %2 = load float, ptr %c, align 4, !alias.scope !5; store float %2, ptr %arrayidx.i2, align 4, !noalias !6. ; These two instructions may alias (for domain !0, the set of scopes in; ; the !noalias list is not a superset of, or equal to, the scopes in the; ; !alias.scope list):; %2 = load float, ptr %c, align 4, !alias.scope !6; store float %0, ptr %arrayidx.i, align 4, !noalias !7. '``fpmath``' Metadata; ^^^^^^^^^^^^^^^^^^^^^. ``fpmath`` metadata may be attached to any instruction of floating-point; type. It can be used to express the maximum acceptable error in the; result of that instruction, in ULPs, thus potentially allowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a real number that lies between two finite consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-point numbers; nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``. The metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metada",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:284823,Performance,load,load,284823,"etadata; ^^^^^^^^^^^^^^^^^^^^^. ``fpmath`` metadata may be attached to any instruction of floating-point; type. It can be used to express the maximum acceptable error in the; result of that instruction, in ULPs, thus potentially allowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a real number that lies between two finite consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-point numbers; nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``. The metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:284932,Performance,load,loaded,284932,"be used to express the maximum acceptable error in the; result of that instruction, in ULPs, thus potentially allowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a real number that lies between two finite consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-point numbers; nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``. The metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !ra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:285024,Performance,load,loaded,285024,"llowing the; compiler to use a more efficient but less accurate method of computing; it. ULP is defined as follows:. If ``x`` is a real number that lies between two finite consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-point numbers; nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``. The metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:285184,Performance,load,loaded,285184," consecutive; floating-point numbers ``a`` and ``b``, without being equal to one; of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the; distance between the two non-equal finite floating-point numbers; nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``. The metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:285800,Performance,load,load,285800,"ed function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = extern",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:285863,Performance,load,load,285863,"ed function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = extern",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:286099,Performance,load,load,286099,"ed function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = extern",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:287418,Performance,optimiz,optimizations,287418,"laration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = external global i8, !absolute_symbol !1 ; Absolute symbol in range [0,2^64). ...; !0 = !{ i64 0, i64 256 }; !1 = !{ i64 -1, i64 -1 }. '``callees``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``callees`` metadata may be attached to indirect call sites. If ``callees``; metadata is attached to a call site, and any callee is not among the set of; functions provided by the metadata, the behavior is undefined. The intent of; this metadata is to facilitate optimizations such as indirect-call promotion.; For example, in the code below, the call instruction may only target the; ``add`` or ``sub`` functions:. .. code-block:: llvm. %result = call i64 %binop(i64 %x, i64 %y), !callees !0. ...; !0 = !{ptr @add, ptr @sub}. '``callback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^. ``callback`` metadata may be attached to a function declaration, or definition.; (Call sites are excluded only due to the lack of a use case.) For ease of; exposition, we'll refer to the function annotated w/ metadata as a broker; function. The metadata describes how the arguments of a call to the broker are; in turn passed to the callback function specified by the metadata. Thus, the; ``callback`` metadata provides a partial description of a call site inside the; broker function with regards to the arguments of a call to the broker. The only; semantic restriction on the broker function itself is that it is not allowed to; inspect or modify arguments referenced in the ``callbac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:292369,Performance,optimiz,optimizations,292369,"^^^. ``exclude`` metadata may be attached to a global variable to signify that its; section should not be included in the final executable or shared library. This; option is only valid for global variables with an explicit section targeting ELF; or COFF. This is done using the ``SHF_EXCLUDE`` flag on ELF targets and the; ``IMAGE_SCN_LNK_REMOVE`` and ``IMAGE_SCN_MEM_DISCARDABLE`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md_dereferenceable:. '``dereferenceable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable`` metadata on the instruction; tells the optimizer that the value loaded is known to be dereferenceable,; otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable''; attribute on parameters and return values. .. _md_dereferenceable_or_null:. '``dereferenceable_or_null``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable_or_null`` metadata on the; instruction tells the optimizer that the value loaded is known to be either; dereferenceable or null, otherwise the behavior is undefined.; The number of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:292746,Performance,optimiz,optimizer,292746,"`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md_dereferenceable:. '``dereferenceable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable`` metadata on the instruction; tells the optimizer that the value loaded is known to be dereferenceable,; otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable''; attribute on parameters and return values. .. _md_dereferenceable_or_null:. '``dereferenceable_or_null``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable_or_null`` metadata on the; instruction tells the optimizer that the value loaded is known to be either; dereferenceable or null, otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable_or_null''; attribute on parameters and return values. .. _llvm.loop:. '``llvm.loop``'; ^^^^^^^^^^^^^^^. It is sometimes useful to attach information to loop constructs. Currently,; loop metadata is implemented as metadata attached to the branch ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:292771,Performance,load,loaded,292771,"`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md_dereferenceable:. '``dereferenceable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable`` metadata on the instruction; tells the optimizer that the value loaded is known to be dereferenceable,; otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable''; attribute on parameters and return values. .. _md_dereferenceable_or_null:. '``dereferenceable_or_null``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable_or_null`` metadata on the; instruction tells the optimizer that the value loaded is known to be either; dereferenceable or null, otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable_or_null''; attribute on parameters and return values. .. _llvm.loop:. '``llvm.loop``'; ^^^^^^^^^^^^^^^. It is sometimes useful to attach information to loop constructs. Currently,; loop metadata is implemented as metadata attached to the branch ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:293245,Performance,optimiz,optimizer,293245," express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md_dereferenceable:. '``dereferenceable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable`` metadata on the instruction; tells the optimizer that the value loaded is known to be dereferenceable,; otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable''; attribute on parameters and return values. .. _md_dereferenceable_or_null:. '``dereferenceable_or_null``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable_or_null`` metadata on the; instruction tells the optimizer that the value loaded is known to be either; dereferenceable or null, otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable_or_null''; attribute on parameters and return values. .. _llvm.loop:. '``llvm.loop``'; ^^^^^^^^^^^^^^^. It is sometimes useful to attach information to loop constructs. Currently,; loop metadata is implemented as metadata attached to the branch instruction; in the loop latch block. The loop metadata node is a list of; other metadata nodes, each representing a property of the loop. Usually,; the first item of the property node is a string. For example, the; ``llvm.loop.unroll.count`` suggests an unroll factor to the loop; unroller:. .. code-block:: llvm. br i1 %exitcond, label %._crit_edge, label %.lr.ph, !llvm.loop !0; ...; !0 = !{!0, !1, !2}; !1 = !{!""llvm.loop.unroll.enable""}; !2 = !{!""llvm.loop.unroll.count"", i32 4}. For legacy reason",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:293270,Performance,load,loaded,293270," express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md_dereferenceable:. '``dereferenceable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable`` metadata on the instruction; tells the optimizer that the value loaded is known to be dereferenceable,; otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable''; attribute on parameters and return values. .. _md_dereferenceable_or_null:. '``dereferenceable_or_null``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The existence of the ``!dereferenceable_or_null`` metadata on the; instruction tells the optimizer that the value loaded is known to be either; dereferenceable or null, otherwise the behavior is undefined.; The number of bytes known to be dereferenceable is specified by the integer; value in the metadata node. This is analogous to the ''dereferenceable_or_null''; attribute on parameters and return values. .. _llvm.loop:. '``llvm.loop``'; ^^^^^^^^^^^^^^^. It is sometimes useful to attach information to loop constructs. Currently,; loop metadata is implemented as metadata attached to the branch instruction; in the loop latch block. The loop metadata node is a list of; other metadata nodes, each representing a property of the loop. Usually,; the first item of the property node is a string. For example, the; ``llvm.loop.unroll.count`` suggests an unroll factor to the loop; unroller:. .. code-block:: llvm. br i1 %exitcond, label %._crit_edge, label %.lr.ph, !llvm.loop !0; ...; !0 = !{!0, !1, !2}; !1 = !{!""llvm.loop.unroll.enable""}; !2 = !{!""llvm.loop.unroll.count"", i32 4}. For legacy reason",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:296486,Performance,optimiz,optimization,296486,"e. Mandatory loop canonicalizations such; as loop rotation are still applied. It is recommended to use this metadata in addition to any llvm.loop.*; transformation directive. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an interleave count to the loop interleaver.; The first operand is the string ``llvm.loop.interleave.count`` and the; second operand is an integer specifying the interleave count. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.interleave.count"", i32 4}. Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving; multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0; then the interleave count will be determined automatically. '``llvm.loop.vectorize.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables vectorization for the loo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:296513,Performance,optimiz,optimizer,296513,"e. Mandatory loop canonicalizations such; as loop rotation are still applied. It is recommended to use this metadata in addition to any llvm.loop.*; transformation directive. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an interleave count to the loop interleaver.; The first operand is the string ``llvm.loop.interleave.count`` and the; second operand is an integer specifying the interleave count. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.interleave.count"", i32 4}. Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving; multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0; then the interleave count will be determined automatically. '``llvm.loop.vectorize.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables vectorization for the loo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:298467,Performance,scalab,scalable,298467,"electively enables or disables vectorization for the loop. The; first operand is the string ``llvm.loop.vectorize.enable`` and the second operand; is a bit. If the bit operand value is 1 vectorization is enabled. A value of; 0 disables vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.enable"", i1 1}. '``llvm.loop.vectorize.predicate.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables creating predicated instructions; for the loop, which can enable folding of the scalar epilogue loop into the; main loop. The first operand is the string; ``llvm.loop.vectorize.predicate.enable`` and the second operand is a bit. If; the bit operand value is 1 vectorization is enabled. A value of 0 disables; vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.predicate.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.predicate.enable"", i1 1}. '``llvm.loop.vectorize.scalable.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables scalable vectorization for the; loop, and only has any effect if vectorization for the loop is already enabled.; The first operand is the string ``llvm.loop.vectorize.scalable.enable``; and the second operand is a bit. If the bit operand value is 1 scalable; vectorization is enabled, whereas a value of 0 reverts to the default fixed; width vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.scalable.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.scalable.enable"", i1 1}. '``llvm.loop.vectorize.width``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata sets the target width of the vectorizer. The first; operand is the string ``llvm.loop.vectorize.width`` and the second; operand is an integer specifying the width. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.width"", i32 4}. Note that setting ``llvm.loop.vectorize.width`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:298595,Performance,scalab,scalable,298595," If the bit operand value is 1 vectorization is enabled. A value of; 0 disables vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.enable"", i1 1}. '``llvm.loop.vectorize.predicate.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables creating predicated instructions; for the loop, which can enable folding of the scalar epilogue loop into the; main loop. The first operand is the string; ``llvm.loop.vectorize.predicate.enable`` and the second operand is a bit. If; the bit operand value is 1 vectorization is enabled. A value of 0 disables; vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.predicate.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.predicate.enable"", i1 1}. '``llvm.loop.vectorize.scalable.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables scalable vectorization for the; loop, and only has any effect if vectorization for the loop is already enabled.; The first operand is the string ``llvm.loop.vectorize.scalable.enable``; and the second operand is a bit. If the bit operand value is 1 scalable; vectorization is enabled, whereas a value of 0 reverts to the default fixed; width vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.scalable.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.scalable.enable"", i1 1}. '``llvm.loop.vectorize.width``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata sets the target width of the vectorizer. The first; operand is the string ``llvm.loop.vectorize.width`` and the second; operand is an integer specifying the width. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.width"", i32 4}. Note that setting ``llvm.loop.vectorize.width`` to 1 disables; vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to; 0 or if the loop does not have this metadata the width will be; det",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:298762,Performance,scalab,scalable,298762,"ctorize.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.enable"", i1 1}. '``llvm.loop.vectorize.predicate.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables creating predicated instructions; for the loop, which can enable folding of the scalar epilogue loop into the; main loop. The first operand is the string; ``llvm.loop.vectorize.predicate.enable`` and the second operand is a bit. If; the bit operand value is 1 vectorization is enabled. A value of 0 disables; vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.predicate.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.predicate.enable"", i1 1}. '``llvm.loop.vectorize.scalable.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables scalable vectorization for the; loop, and only has any effect if vectorization for the loop is already enabled.; The first operand is the string ``llvm.loop.vectorize.scalable.enable``; and the second operand is a bit. If the bit operand value is 1 scalable; vectorization is enabled, whereas a value of 0 reverts to the default fixed; width vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.scalable.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.scalable.enable"", i1 1}. '``llvm.loop.vectorize.width``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata sets the target width of the vectorizer. The first; operand is the string ``llvm.loop.vectorize.width`` and the second; operand is an integer specifying the width. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.width"", i32 4}. Note that setting ``llvm.loop.vectorize.width`` to 1 disables; vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to; 0 or if the loop does not have this metadata the width will be; determined automatically. '``llvm.loop.vectorize.followup_vectorized``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:298844,Performance,scalab,scalable,298844,"data; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables creating predicated instructions; for the loop, which can enable folding of the scalar epilogue loop into the; main loop. The first operand is the string; ``llvm.loop.vectorize.predicate.enable`` and the second operand is a bit. If; the bit operand value is 1 vectorization is enabled. A value of 0 disables; vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.predicate.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.predicate.enable"", i1 1}. '``llvm.loop.vectorize.scalable.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables scalable vectorization for the; loop, and only has any effect if vectorization for the loop is already enabled.; The first operand is the string ``llvm.loop.vectorize.scalable.enable``; and the second operand is a bit. If the bit operand value is 1 scalable; vectorization is enabled, whereas a value of 0 reverts to the default fixed; width vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.scalable.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.scalable.enable"", i1 1}. '``llvm.loop.vectorize.width``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata sets the target width of the vectorizer. The first; operand is the string ``llvm.loop.vectorize.width`` and the second; operand is an integer specifying the width. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.width"", i32 4}. Note that setting ``llvm.loop.vectorize.width`` to 1 disables; vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to; 0 or if the loop does not have this metadata the width will be; determined automatically. '``llvm.loop.vectorize.followup_vectorized``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the vectorized loop will; have. See :ref:`transformation-metadata` for detail",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:299004,Performance,scalab,scalable,299004,"nstructions; for the loop, which can enable folding of the scalar epilogue loop into the; main loop. The first operand is the string; ``llvm.loop.vectorize.predicate.enable`` and the second operand is a bit. If; the bit operand value is 1 vectorization is enabled. A value of 0 disables; vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.predicate.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.predicate.enable"", i1 1}. '``llvm.loop.vectorize.scalable.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables scalable vectorization for the; loop, and only has any effect if vectorization for the loop is already enabled.; The first operand is the string ``llvm.loop.vectorize.scalable.enable``; and the second operand is a bit. If the bit operand value is 1 scalable; vectorization is enabled, whereas a value of 0 reverts to the default fixed; width vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.scalable.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.scalable.enable"", i1 1}. '``llvm.loop.vectorize.width``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata sets the target width of the vectorizer. The first; operand is the string ``llvm.loop.vectorize.width`` and the second; operand is an integer specifying the width. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.width"", i32 4}. Note that setting ``llvm.loop.vectorize.width`` to 1 disables; vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to; 0 or if the loop does not have this metadata the width will be; determined automatically. '``llvm.loop.vectorize.followup_vectorized``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the vectorized loop will; have. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize.followup_epilogue``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:299058,Performance,scalab,scalable,299058," the scalar epilogue loop into the; main loop. The first operand is the string; ``llvm.loop.vectorize.predicate.enable`` and the second operand is a bit. If; the bit operand value is 1 vectorization is enabled. A value of 0 disables; vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.predicate.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.predicate.enable"", i1 1}. '``llvm.loop.vectorize.scalable.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables scalable vectorization for the; loop, and only has any effect if vectorization for the loop is already enabled.; The first operand is the string ``llvm.loop.vectorize.scalable.enable``; and the second operand is a bit. If the bit operand value is 1 scalable; vectorization is enabled, whereas a value of 0 reverts to the default fixed; width vectorization:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.scalable.enable"", i1 0}; !1 = !{!""llvm.loop.vectorize.scalable.enable"", i1 1}. '``llvm.loop.vectorize.width``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata sets the target width of the vectorizer. The first; operand is the string ``llvm.loop.vectorize.width`` and the second; operand is an integer specifying the width. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.vectorize.width"", i32 4}. Note that setting ``llvm.loop.vectorize.width`` to 1 disables; vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to; 0 or if the loop does not have this metadata the width will be; determined automatically. '``llvm.loop.vectorize.followup_vectorized``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the vectorized loop will; have. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize.followup_epilogue``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the epilogue will have. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:300784,Performance,optimiz,optimization,300784,"op attributes the vectorized loop will; have. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize.followup_epilogue``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the epilogue will have. The; epilogue is not vectorized and is executed when either the vectorized; loop is not known to preserve semantics (because e.g., it processes two; arrays that are found to alias by a runtime check) or for the last; iterations that do not fill a complete set of vector lanes. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.vectorize.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes in the metadata will be added to both the vectorized and; epilogue loop.; See :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll``'; ^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling; optimization hints such as the unroll factor. ``llvm.loop.unroll``; metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. The ``llvm.loop.unroll`` metadata are only; optimization hints and the unrolling will only be performed if the; optimizer believes it is safe to do so. '``llvm.loop.unroll.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll factor to the loop unroller. The; first operand is the string ``llvm.loop.unroll.count`` and the second; operand is a positive integer specifying the unroll factor. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unrolled. '``llvm.loop.unroll.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unrolling. The metadata has a single operand; which is the string ``llvm.loop.unroll.disable``. For example:. .. code-block:: llvm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:300985,Performance,optimiz,optimization,300985,"oop attributes the epilogue will have. The; epilogue is not vectorized and is executed when either the vectorized; loop is not known to preserve semantics (because e.g., it processes two; arrays that are found to alias by a runtime check) or for the last; iterations that do not fill a complete set of vector lanes. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.vectorize.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes in the metadata will be added to both the vectorized and; epilogue loop.; See :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll``'; ^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling; optimization hints such as the unroll factor. ``llvm.loop.unroll``; metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. The ``llvm.loop.unroll`` metadata are only; optimization hints and the unrolling will only be performed if the; optimizer believes it is safe to do so. '``llvm.loop.unroll.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll factor to the loop unroller. The; first operand is the string ``llvm.loop.unroll.count`` and the second; operand is a positive integer specifying the unroll factor. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unrolled. '``llvm.loop.unroll.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unrolling. The metadata has a single operand; which is the string ``llvm.loop.unroll.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.disable""}. '``llvm.loop.unroll.runtime.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables runtime loop unrolling. The metadata has a single; operand which is the s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:301035,Performance,perform,performed,301035,"oop attributes the epilogue will have. The; epilogue is not vectorized and is executed when either the vectorized; loop is not known to preserve semantics (because e.g., it processes two; arrays that are found to alias by a runtime check) or for the last; iterations that do not fill a complete set of vector lanes. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.vectorize.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes in the metadata will be added to both the vectorized and; epilogue loop.; See :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll``'; ^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling; optimization hints such as the unroll factor. ``llvm.loop.unroll``; metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. The ``llvm.loop.unroll`` metadata are only; optimization hints and the unrolling will only be performed if the; optimizer believes it is safe to do so. '``llvm.loop.unroll.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll factor to the loop unroller. The; first operand is the string ``llvm.loop.unroll.count`` and the second; operand is a positive integer specifying the unroll factor. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unrolled. '``llvm.loop.unroll.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unrolling. The metadata has a single operand; which is the string ``llvm.loop.unroll.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.disable""}. '``llvm.loop.unroll.runtime.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables runtime loop unrolling. The metadata has a single; operand which is the s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:301053,Performance,optimiz,optimizer,301053,"oop attributes the epilogue will have. The; epilogue is not vectorized and is executed when either the vectorized; loop is not known to preserve semantics (because e.g., it processes two; arrays that are found to alias by a runtime check) or for the last; iterations that do not fill a complete set of vector lanes. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.vectorize.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes in the metadata will be added to both the vectorized and; epilogue loop.; See :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll``'; ^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling; optimization hints such as the unroll factor. ``llvm.loop.unroll``; metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. The ``llvm.loop.unroll`` metadata are only; optimization hints and the unrolling will only be performed if the; optimizer believes it is safe to do so. '``llvm.loop.unroll.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll factor to the loop unroller. The; first operand is the string ``llvm.loop.unroll.count`` and the second; operand is a positive integer specifying the unroll factor. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unrolled. '``llvm.loop.unroll.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unrolling. The metadata has a single operand; which is the string ``llvm.loop.unroll.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.disable""}. '``llvm.loop.unroll.runtime.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables runtime loop unrolling. The metadata has a single; operand which is the s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:304181,Performance,perform,performed,304181,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the remainder loop after; partial/runtime unrolling will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata is treated very similarly to the ``llvm.loop.unroll`` metadata; above, but affect the unroll and jam pass. In addition any loop with; ``llvm.loop.unroll`` metadata but no ``llvm.loop.unroll_and_jam`` metadata will; disable unroll and jam (so ``llvm.loop.unroll`` metadata will be left to the; unroller, plus ``llvm.loop.unroll.disable`` metadata will disable unroll and jam; too.). The metadata for unroll and jam otherwise is the same as for ``unroll``.; ``llvm.loop.unroll_and_jam.enable``, ``llvm.loop.unroll_and_jam.disable`` and; ``llvm.loop.unroll_and_jam.count`` do the same as for unroll.; ``llvm.loop.unroll_and_jam.full`` is not supported. Again these are only hints; and the normal safety checks will still be performed. '``llvm.loop.unroll_and_jam.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll and jam factor to use, similarly to; ``llvm.loop.unroll.count``. The first operand is the string; ``llvm.loop.unroll_and_jam.count`` and the second operand is a positive integer; specifying the unroll factor. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll_and_jam.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unroll and jammed. '``llvm.loop.unroll_and_jam.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unroll and jamming. The metadata has a single; operand which is the string ``llvm.loop.unroll_and_jam.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll_and_jam.disable""}. '``llvm.loop.unroll_and_jam.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307666,Performance,perform,performed,307666,"re; can be multiple inner remainder loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:309646,Performance,perform,performed,309646,"a>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isolated loops with unsafe; memory dependencies will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_fallback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310477,Performance,load,load,310477,"or details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312879,Performance,optimiz,optimization,312879,"th access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313194,Performance,load,load,313194,"p.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313571,Performance,load,load,313571,"oup referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313681,Performance,load,load,313681,"Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.mustprogress`` metadata indicates that this loop is required to; terminate, unwind, or inter",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:315977,Performance,load,load,315977,"data; ^^^^^^^^^^^^^^^^^^^^^^^. ``irr_loop`` metadata may be attached to the terminator instruction of a basic; block that's an irreducible loop header (note that an irreducible loop has more; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreducible loop; header, the behavior is undefined. The intent of this metadata is to improve the; accuracy of the block frequency propagation. For example, in the code below, the; block ``header0`` may have a loop header weight (relative to the other headers of; the irreducible loop) of 100:. .. code-block:: llvm. header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop header weights are typically based on profile data. .. _md_invariant.group:. '``invariant.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The experimental ``invariant.group`` metadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.grou",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:316135,Performance,optimiz,optimizer,316135,"ore; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreducible loop; header, the behavior is undefined. The intent of this metadata is to improve the; accuracy of the block frequency propagation. For example, in the code below, the; block ``header0`` may have a loop header weight (relative to the other headers of; the irreducible loop) of 100:. .. code-block:: llvm. header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop header weights are typically based on profile data. .. _md_invariant.group:. '``invariant.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The experimental ``invariant.group`` metadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:316158,Performance,load,load,316158,"ore; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreducible loop; header, the behavior is undefined. The intent of this metadata is to improve the; accuracy of the block frequency propagation. For example, in the code below, the; block ``header0`` may have a loop header weight (relative to the other headers of; the irreducible loop) of 100:. .. code-block:: llvm. header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop header weights are typically based on profile data. .. _md_invariant.group:. '``invariant.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The experimental ``invariant.group`` metadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:316226,Performance,load,load,316226,"ore; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreducible loop; header, the behavior is undefined. The intent of this metadata is to improve the; accuracy of the block frequency propagation. For example, in the code below, the; block ``header0`` may have a loop header weight (relative to the other headers of; the irreducible loop) of 100:. .. code-block:: llvm. header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop header weights are typically based on profile data. .. _md_invariant.group:. '``invariant.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The experimental ``invariant.group`` metadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:316631,Performance,load,load,316631," header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop header weights are typically based on profile data. .. _md_invariant.group:. '``invariant.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The experimental ``invariant.group`` metadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalia",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:316793,Performance,load,load,316793,"e typically based on profile data. .. _md_invariant.group:. '``invariant.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The experimental ``invariant.group`` metadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its sema",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:316921,Performance,load,load,316921,"tadata may be attached to; ``load``/``store`` instructions referencing a single metadata with no entries.; The existence of the ``invariant.group`` metadata on the instruction tells; the optimizer that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:317135,Performance,load,load,317135,"er that every ``load`` and ``store`` to the same pointer operand; can be assumed to load or store the same; value (but see the ``llvm.launder.invariant.group`` intrinsic which affects; when two pointers are considered the same). Pointers returned by bitcast or; getelementptr with only zero indices are considered the same. Examples:. .. code-block:: llvm. @unknownPtr = external global i8; ...; %ptr = alloca i8; store i8 42, ptr %ptr, !invariant.group !0; call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF sectio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:317589,Performance,load,load,317589,"call void @foo(ptr %ptr). %a = load i8, ptr %ptr, !invariant.group !0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata sho",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:317701,Performance,load,load,317701,"!0 ; Can assume that value under %ptr didn't change; call void @foo(ptr %ptr). %newPtr = call ptr @getPointer(ptr %ptr); %c = load i8, ptr %newPtr, !invariant.group !0 ; Can't assume anything, because we only have information about %ptr. %unknownValue = load i8, ptr @unknownPtr; store i8 %unknownValue, ptr %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:328841,Performance,perform,performed,328841,"ulting; ``llvm.module.flags`` metadata is the union of the modules' flags. That is, for; each unique metadata ID string, there will be exactly one entry in the merged; modules ``llvm.module.flags`` metadata table, and the value for that entry will; be determined by the merge behavior flag, as described below. The only exception; is that entries with the *Require* behavior are always preserved. The following behaviors are supported:. .. list-table::; :header-rows: 1; :widths: 10 90. * - Value; - Behavior. * - 1; - **Error**; Emits an error if two values disagree, otherwise the resulting value; is that of the operands. * - 2; - **Warning**; Emits a warning if two values disagree. The result value will be the; operand for the flag from the first module being linked, unless the; other module uses **Min** or **Max**, in which case the result will; be **Min** (with the min value) or **Max** (with the max value),; respectively. * - 3; - **Require**; Adds a requirement that another module flag be present and have a; specified value after linking is performed. The value must be a; metadata pair, where the first element of the pair is the ID of the; module flag to be restricted, and the second element of the pair is; the value the module flag should be restricted to. This behavior can; be used to restrict the allowable results (via triggering of an; error) of linking IDs with the **Override** behavior. * - 4; - **Override**; Uses the specified value, regardless of the behavior or value of the; other module. If both modules specify **Override**, but the values; differ, an error will be emitted. * - 5; - **Append**; Appends the two values, which are required to be metadata nodes. * - 6; - **AppendUnique**; Appends the two values, which are required to be metadata; nodes. However, duplicate entries in the second list are dropped; during the append operation. * - 7; - **Max**; Takes the max of the two values, which are required to be integers. * - 8; - **Min**; Takes the min of th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:331031,Performance,perform,performed,331031,"in the case of **Require** (which adds restrictions on another metadata; value) or **Override**. An example of module flags:. .. code-block:: llvm. !0 = !{ i32 1, !""foo"", i32 1 }; !1 = !{ i32 4, !""bar"", i32 37 }; !2 = !{ i32 2, !""qux"", i32 42 }; !3 = !{ i32 3, !""qux"",; !{; !""foo"", i32 1; }; }; !llvm.module.flags = !{ !0, !1, !2, !3 }. - Metadata ``!0`` has the ID ``!""foo""`` and the value '1'. The behavior; if two or more ``!""foo""`` flags are seen is to emit an error if their; values are not equal. - Metadata ``!1`` has the ID ``!""bar""`` and the value '37'. The; behavior if two or more ``!""bar""`` flags are seen is to use the value; '37'. - Metadata ``!2`` has the ID ``!""qux""`` and the value '42'. The; behavior if two or more ``!""qux""`` flags are seen is to emit a; warning if their values are not equal. - Metadata ``!3`` has the ID ``!""qux""`` and the value:. ::. !{ !""foo"", i32 1 }. The behavior is to emit an error if the ``llvm.module.flags`` does not; contain a flag with the ID ``!""foo""`` that has the value '1' after linking is; performed. Synthesized Functions Module Flags Metadata; -------------------------------------------. These metadata specify the default attributes synthesized functions should have.; These metadata are currently respected by a few instrumentation passes, such as; sanitizers. These metadata correspond to a few function attributes with significant code; generation behaviors. Function attributes with just optimization purposes; should not be listed because the performance impact of these synthesized; functions is small. - ""frame-pointer"": **Max**. The value can be 0, 1, or 2. A synthesized function; will get the ""frame-pointer"" function attribute, with value being ""none"",; ""non-leaf"", or ""all"", respectively.; - ""function_return_thunk_extern"": The synthesized function will get the; ``fn_return_thunk_extern`` function attribute.; - ""uwtable"": **Max**. The value can be 0, 1, or 2. If the value is 1, a synthesized; function will get the ``uwtable(syn",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:331437,Performance,optimiz,optimization,331437,"not equal. - Metadata ``!1`` has the ID ``!""bar""`` and the value '37'. The; behavior if two or more ``!""bar""`` flags are seen is to use the value; '37'. - Metadata ``!2`` has the ID ``!""qux""`` and the value '42'. The; behavior if two or more ``!""qux""`` flags are seen is to emit a; warning if their values are not equal. - Metadata ``!3`` has the ID ``!""qux""`` and the value:. ::. !{ !""foo"", i32 1 }. The behavior is to emit an error if the ``llvm.module.flags`` does not; contain a flag with the ID ``!""foo""`` that has the value '1' after linking is; performed. Synthesized Functions Module Flags Metadata; -------------------------------------------. These metadata specify the default attributes synthesized functions should have.; These metadata are currently respected by a few instrumentation passes, such as; sanitizers. These metadata correspond to a few function attributes with significant code; generation behaviors. Function attributes with just optimization purposes; should not be listed because the performance impact of these synthesized; functions is small. - ""frame-pointer"": **Max**. The value can be 0, 1, or 2. A synthesized function; will get the ""frame-pointer"" function attribute, with value being ""none"",; ""non-leaf"", or ""all"", respectively.; - ""function_return_thunk_extern"": The synthesized function will get the; ``fn_return_thunk_extern`` function attribute.; - ""uwtable"": **Max**. The value can be 0, 1, or 2. If the value is 1, a synthesized; function will get the ``uwtable(sync)`` function attribute, if the value is 2,; a synthesized function will get the ``uwtable(async)`` function attribute. Objective-C Garbage Collection Module Flags Metadata; ----------------------------------------------------. On the Mach-O platform, Objective-C stores metadata about garbage; collection in a special section called ""image info"". The metadata; consists of a version number and a bitmask specifying what types of; garbage collection are supported (if any) by the file. If two",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:331493,Performance,perform,performance,331493,"not equal. - Metadata ``!1`` has the ID ``!""bar""`` and the value '37'. The; behavior if two or more ``!""bar""`` flags are seen is to use the value; '37'. - Metadata ``!2`` has the ID ``!""qux""`` and the value '42'. The; behavior if two or more ``!""qux""`` flags are seen is to emit a; warning if their values are not equal. - Metadata ``!3`` has the ID ``!""qux""`` and the value:. ::. !{ !""foo"", i32 1 }. The behavior is to emit an error if the ``llvm.module.flags`` does not; contain a flag with the ID ``!""foo""`` that has the value '1' after linking is; performed. Synthesized Functions Module Flags Metadata; -------------------------------------------. These metadata specify the default attributes synthesized functions should have.; These metadata are currently respected by a few instrumentation passes, such as; sanitizers. These metadata correspond to a few function attributes with significant code; generation behaviors. Function attributes with just optimization purposes; should not be listed because the performance impact of these synthesized; functions is small. - ""frame-pointer"": **Max**. The value can be 0, 1, or 2. A synthesized function; will get the ""frame-pointer"" function attribute, with value being ""none"",; ""non-leaf"", or ""all"", respectively.; - ""function_return_thunk_extern"": The synthesized function will get the; ``fn_return_thunk_extern`` function attribute.; - ""uwtable"": **Max**. The value can be 0, 1, or 2. If the value is 1, a synthesized; function will get the ``uwtable(sync)`` function attribute, if the value is 2,; a synthesized function will get the ``uwtable(async)`` function attribute. Objective-C Garbage Collection Module Flags Metadata; ----------------------------------------------------. On the Mach-O platform, Objective-C stores metadata about garbage; collection in a special section called ""image info"". The metadata; consists of a version number and a bitmask specifying what types of; garbage collection are supported (if any) by the file. If two",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:339066,Performance,optimiz,optimization,339066," the; linker via object files. The list is encoded in the IR using named metadata with the name; ``!llvm.dependent-libraries``. Each operand is expected to be a metadata node; which should contain a single string operand. For example, the following metadata section contains two library specifiers::. !0 = !{!""a library specifier""}; !1 = !{!""another library specifier""}; !llvm.dependent-libraries = !{ !0, !1 }. Each library specifier will be handled independently by the consuming linker.; The effect of the library specifiers are defined by the consuming linker. .. _summary:. ThinLTO Summary; ===============. Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_; causes the building of a compact summary of the module that is emitted into; the bitcode. The summary is emitted into the LLVM assembly and identified; in syntax by a caret ('``^``'). The summary is parsed into a bitcode output, along with the Module; IR, via the ""``llvm-as``"" tool. Tools that parse the Module IR for the purposes; of optimization (e.g. ""``clang -x ir``"" and ""``opt``""), will ignore the; summary entries (just as they currently ignore summary entries in a bitcode; input file). Eventually, the summary will be parsed into a ModuleSummaryIndex object under; the same conditions where summary index is currently built from bitcode.; Specifically, tools that test the Thin Link portion of a ThinLTO compile; (i.e. llvm-lto and llvm-lto2), or when parsing a combined index; for a distributed ThinLTO backend via clang's ""``-fthinlto-index=<>``"" flag; (this part is not yet implemented, use llvm-as to create a bitcode object; before feeding into thin link tools for now). There are currently 3 types of summary entries in the LLVM assembly:; :ref:`module paths<module_path_summary>`,; :ref:`global values<gv_summary>`, and; :ref:`type identifiers<typeid_summary>`. .. _module_path_summary:. Module Path Summary Entry; -------------------------. Each module path summary entry lists a module containing gl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345531,Performance,load,load,345531,"e range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the pointer and passes the result as the argument %1 into ``^3``.; This record itself does not tell us how ``^3`` will access the parameter.; Parameter %3 is not a pointer. .. _refs_summary:. Refs; ^^^^. The optional ``Refs`` field looks like:. .. code-block:: text.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345636,Performance,load,load,345636,"e range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the pointer and passes the result as the argument %1 into ``^3``.; This record itself does not tell us how ``^3`` will access the parameter.; Parameter %3 is not a pointer. .. _refs_summary:. Refs; ^^^^. The optional ``Refs`` field looks like:. .. code-block:: text.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:352321,Performance,optimiz,optimize,352321," in the ``@llvm.used`` list, then the compiler, assembler,; and linker are required to treat the symbol as if there is a reference to the; symbol that it cannot see (which is why they have to be named). For example, if; a variable has internal linkage and no references other than that from the; ``@llvm.used`` list, it cannot be deleted. This is commonly used to represent; references from inline asms and other things the compiler cannot ""see"", and; corresponds to ""``attribute((used))``"" in GNU C. On some targets, the code generator must emit a directive to the; assembler or object file to prevent the assembler and linker from; removing the symbol. .. _gv_llvmcompilerused:. The '``llvm.compiler.used``' Global Variable; --------------------------------------------. The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used``; directive, except that it only prevents the compiler from touching the; symbol. On targets that support it, this allows an intelligent linker to; optimize references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, ptr @ctor, ptr @data }]. The ``@llvm.global_ctors`` array contains a list of constructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in ascending order; of priority (i.e. lowest first) when the module is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global varia",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:353040,Performance,load,loaded,353040,"iler.used``' Global Variable; --------------------------------------------. The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used``; directive, except that it only prevents the compiler from touching the; symbol. On targets that support it, this allows an intelligent linker to; optimize references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, ptr @ctor, ptr @data }]. The ``@llvm.global_ctors`` array contains a list of constructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in ascending order; of priority (i.e. lowest first) when the module is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:365048,Performance,perform,performed,365048,"': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. '``normal label``': the label reached when the called function; executes a '``ret``' instruction.; #. '``exception label``': the label reached when a callee returns via; the :ref:`resume <i_resume>` instruction or other exception handling; mechanism.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with a label, which is used by the runtime; library to unwind the stack. This instruction is used in languages with destructors to ensure that; proper cleanup is performed in the case of either a ``longjmp`` or a; thrown exception. Additionally, this is important for implementation of; '``catch``' clauses in high-level languages that support them. For the purposes of the SSA form, the definition of the value returned; by the '``invoke``' instruction is deemed to occur on the edge from the; current block to the ""normal"" label. If the callee unwinds then no; return value is available. Example:; """""""""""""""". .. code-block:: llvm. %retval = invoke i32 @Test(i32 15) to label %Continue; unwind label %TestCleanup ; i32:retval set; %retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue; unwind label %TestCleanup ; i32:retval set. .. _i_callbr:. '``callbr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = callbr [cconv] [ret attrs] [addrspace(<num>)] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]; [operand bundles] to label <fallthrough label> [indirect labels]. Overview:; """""""""""""""""". The '``callbr``' instruc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:375194,Performance,optimiz,optimizer,375194," an optional successor, ``continue``,; which must be the label of another basic block beginning with either a; ``cleanuppad`` or ``catchswitch`` instruction. This unwind destination must; be a legal target with respect to the ``parent`` links, as described in the; `exception handling documentation\ <ExceptionHandling.html#wineh-constraints>`_. Semantics:; """""""""""""""""""". The '``cleanupret``' instruction indicates to the; :ref:`personality function <personalityfn>` that one; :ref:`cleanuppad <i_cleanuppad>` it transferred control to has ended.; It transfers control to ``continue`` or unwinds out of the function. Example:; """""""""""""""". .. code-block:: text. cleanupret from %cleanup unwind to caller; cleanupret from %cleanup unwind label %continue. .. _i_unreachable:. '``unreachable``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. unreachable. Overview:; """""""""""""""""". The '``unreachable``' instruction has no defined semantics. This; instruction is used to inform the optimizer that a particular portion of; the code is not reachable. This can be used to indicate that the code; after a no-return function cannot be reached, and other facts. Semantics:; """""""""""""""""""". The '``unreachable``' instruction has no defined semantics. .. _unaryops:. Unary Operations; -----------------. Unary operators require a single operand, execute an operation on; it, and produce a single value. The operand might represent multiple; data, as is the case with the :ref:`vector <t_vector>` data type. The; result value has the same type as its operand. .. _i_fneg:. '``fneg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fneg [fast-math flags]* <ty> <op1> ; yields ty:result. Overview:; """""""""""""""""". The '``fneg``' instruction returns the negation of its operand. Arguments:; """""""""""""""""""". The argument to the '``fneg``' instruction must be a; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Semantics:; """""""""""""""""""". The value produced is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:376499,Performance,optimiz,optimization,376499,"-----------. Unary operators require a single operand, execute an operation on; it, and produce a single value. The operand might represent multiple; data, as is the case with the :ref:`vector <t_vector>` data type. The; result value has the same type as its operand. .. _i_fneg:. '``fneg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fneg [fast-math flags]* <ty> <op1> ; yields ty:result. Overview:; """""""""""""""""". The '``fneg``' instruction returns the negation of its operand. Arguments:; """""""""""""""""""". The argument to the '``fneg``' instruction must be a; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Semantics:; """""""""""""""""""". The value produced is a copy of the operand with its sign bit flipped.; The value is otherwise completely identical; in particular, if the input is a; NaN, then the quiet/signaling bit and payload are perfectly preserved. This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fneg float %val ; yields float:result = -%var. .. _binaryops:. Binary Operations; -----------------. Binary operators are used to do most of the computation in a program.; They require two operands of the same type, execute an operation on; them, and produce a single value. The operands might represent multiple; data, as is the case with the :ref:`vector <t_vector>` data type. The; result value has the same type as its operands. There are several different binary operators:. .. _i_add:. '``add``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = add <ty> <op1>, <op2> ; yields ty:result; <result> = add nuw <ty> <op1>, <op2> ; yields ty:result; <result> = add nsw <ty> <op1>, <op2> ; yields ty:result; <result> = add nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``add``' instruction returns the sum of its two",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:376561,Performance,optimiz,optimizations,376561,"-----------. Unary operators require a single operand, execute an operation on; it, and produce a single value. The operand might represent multiple; data, as is the case with the :ref:`vector <t_vector>` data type. The; result value has the same type as its operand. .. _i_fneg:. '``fneg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fneg [fast-math flags]* <ty> <op1> ; yields ty:result. Overview:; """""""""""""""""". The '``fneg``' instruction returns the negation of its operand. Arguments:; """""""""""""""""""". The argument to the '``fneg``' instruction must be a; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Semantics:; """""""""""""""""""". The value produced is a copy of the operand with its sign bit flipped.; The value is otherwise completely identical; in particular, if the input is a; NaN, then the quiet/signaling bit and payload are perfectly preserved. This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fneg float %val ; yields float:result = -%var. .. _binaryops:. Binary Operations; -----------------. Binary operators are used to do most of the computation in a program.; They require two operands of the same type, execute an operation on; them, and produce a single value. The operands might represent multiple; data, as is the case with the :ref:`vector <t_vector>` data type. The; result value has the same type as its operands. There are several different binary operators:. .. _i_add:. '``add``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = add <ty> <op1>, <op2> ; yields ty:result; <result> = add nuw <ty> <op1>, <op2> ; yields ty:result; <result> = add nsw <ty> <op1>, <op2> ; yields ty:result; <result> = add nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``add``' instruction returns the sum of its two",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:379171,Performance,optimiz,optimization,379171,"nd/or ``nsw`` keywords are present, the; result value of the ``add`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = add i32 4, %var ; yields i32:result = 4 + %var. .. _i_fadd:. '``fadd``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fadd [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fadd``' instruction returns the sum of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fadd``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point sum of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fadd float 4.0, %var ; yields float:result = 4.0 + %var. .. _i_sub:. '``sub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sub <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nsw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``sub``' instruction returns the difference of its two operands. Note that the '``sub``' instruction is used to represent the '``neg``'; instruction present in most other intermediate representations. Arguments:; """""""""""""""""""". The two arguments to the '``sub``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer difference of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:379233,Performance,optimiz,optimizations,379233,"nd/or ``nsw`` keywords are present, the; result value of the ``add`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = add i32 4, %var ; yields i32:result = 4 + %var. .. _i_fadd:. '``fadd``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fadd [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fadd``' instruction returns the sum of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fadd``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point sum of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fadd float 4.0, %var ; yields float:result = 4.0 + %var. .. _i_sub:. '``sub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sub <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nsw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``sub``' instruction returns the difference of its two operands. Note that the '``sub``' instruction is used to represent the '``neg``'; instruction present in most other intermediate representations. Arguments:; """""""""""""""""""". The two arguments to the '``sub``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer difference of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:381647,Performance,optimiz,optimization,381647,"s a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = sub i32 4, %var ; yields i32:result = 4 - %var; <result> = sub i32 0, %val ; yields i32:result = -%var. .. _i_fsub:. '``fsub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fsub [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fsub``' instruction returns the difference of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fsub``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point difference of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fsub float 4.0, %var ; yields float:result = 4.0 - %var; <result> = fsub float -0.0, %val ; yields float:result = -%var. .. _i_mul:. '``mul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = mul <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:381709,Performance,optimiz,optimizations,381709,"s a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = sub i32 4, %var ; yields i32:result = 4 - %var; <result> = sub i32 0, %val ; yields i32:result = -%var. .. _i_fsub:. '``fsub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fsub [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fsub``' instruction returns the difference of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fsub``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point difference of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fsub float 4.0, %var ; yields float:result = 4.0 - %var; <result> = fsub float -0.0, %val ; yields float:result = -%var. .. _i_mul:. '``mul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = mul <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:384235,Performance,optimiz,optimization,384235,"nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fmul float 4.0, %var ; yields float:result = 4.0 * %var. .. _i_udiv:. '``udiv``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = udiv <ty> <op1>, <op2> ; yields ty:result; <result> = udiv exact <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``udiv``' instruction returns the quotient of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``udiv``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the unsigned integer quotient of the two operands. Note that unsigned integer division and signed integer division are; distinct operations; for signed integer division, use '``sdiv``'. Division by zero is undefined behavior. For vectors, if any element; of the divisor is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:384297,Performance,optimiz,optimizations,384297,"nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fmul float 4.0, %var ; yields float:result = 4.0 * %var. .. _i_udiv:. '``udiv``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = udiv <ty> <op1>, <op2> ; yields ty:result; <result> = udiv exact <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``udiv``' instruction returns the quotient of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``udiv``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the unsigned integer quotient of the two operands. Note that unsigned integer division and signed integer division are; distinct operations; for signed integer division, use '``sdiv``'. Division by zero is undefined behavior. For vectors, if any element; of the divisor is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:387572,Performance,optimiz,optimization,387572,"483648 by -1. If the ``exact`` keyword is present, the result value of the ``sdiv`` is; a :ref:`poison value <poisonvalues>` if the result would be rounded. Example:; """""""""""""""". .. code-block:: text. <result> = sdiv i32 4, %var ; yields i32:result = 4 / %var. .. _i_fdiv:. '``fdiv``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fdiv [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fdiv``' instruction returns the quotient of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fdiv``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point quotient of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fdiv float 4.0, %var ; yields float:result = 4.0 / %var. .. _i_urem:. '``urem``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = urem <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``urem``' instruction returns the remainder from the unsigned; division of its two arguments. Arguments:; """""""""""""""""""". The two arguments to the '``urem``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". This instruction returns the unsigned integer *remainder* of a division.; This instruction always performs an unsigned division to get the; remainder. Note that unsigned integer remainder and signed integer remainder are; distinct operations; for signed integer remainder, use '``srem``'. Taking the remainder of a division ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:387634,Performance,optimiz,optimizations,387634,"483648 by -1. If the ``exact`` keyword is present, the result value of the ``sdiv`` is; a :ref:`poison value <poisonvalues>` if the result would be rounded. Example:; """""""""""""""". .. code-block:: text. <result> = sdiv i32 4, %var ; yields i32:result = 4 / %var. .. _i_fdiv:. '``fdiv``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fdiv [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fdiv``' instruction returns the quotient of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fdiv``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point quotient of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fdiv float 4.0, %var ; yields float:result = 4.0 / %var. .. _i_urem:. '``urem``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = urem <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``urem``' instruction returns the remainder from the unsigned; division of its two arguments. Arguments:; """""""""""""""""""". The two arguments to the '``urem``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". This instruction returns the unsigned integer *remainder* of a division.; This instruction always performs an unsigned division to get the; remainder. Note that unsigned integer remainder and signed integer remainder are; distinct operations; for signed integer remainder, use '``srem``'. Taking the remainder of a division ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:388338,Performance,perform,performs,388338,"tient of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fdiv float 4.0, %var ; yields float:result = 4.0 / %var. .. _i_urem:. '``urem``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = urem <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``urem``' instruction returns the remainder from the unsigned; division of its two arguments. Arguments:; """""""""""""""""""". The two arguments to the '``urem``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". This instruction returns the unsigned integer *remainder* of a division.; This instruction always performs an unsigned division to get the; remainder. Note that unsigned integer remainder and signed integer remainder are; distinct operations; for signed integer remainder, use '``srem``'. Taking the remainder of a division by zero is undefined behavior.; For vectors, if any element of the divisor is zero, the operation has; undefined behavior. Example:; """""""""""""""". .. code-block:: text. <result> = urem i32 4, %var ; yields i32:result = 4 % %var. .. _i_srem:. '``srem``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = srem <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``srem``' instruction returns the remainder from the signed; division of its two operands. This instruction can also take; :ref:`vector <t_vector>` versions of the values in which case the elements; must be integers. Arguments:; """""""""""""""""""". The two arguments to the '``srem``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:391736,Performance,optimiz,optimization,391736,""""""""""""""". ::. <result> = frem [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``frem``' instruction returns the remainder from the division of; its two operands. .. note::. 	The instruction is implemented as a call to libm's '``fmod``'; 	for some targets, and using the instruction may thus require linking libm. Arguments:; """""""""""""""""""". The two arguments to the '``frem``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point remainder of the two operands.; This is the same output as a libm '``fmod``' function, but without any; possibility of setting ``errno``. The remainder has the same sign as the; dividend.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = frem float 4.0, %var ; yields float:result = 4.0 % %var. .. _bitwiseops:. Bitwise Binary Operations; -------------------------. Bitwise binary operators are used to do various forms of bit-twiddling; in a program. They are generally very efficient instructions and can; commonly be strength reduced from other instructions. They require two; operands of the same type, execute an operation on them, and produce a; single value. The resulting value is the same type as its operands. .. _i_shl:. '``shl``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shl <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nsw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``shl``' instruction returns the first opera",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:391798,Performance,optimiz,optimizations,391798,""""""""""""""". ::. <result> = frem [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``frem``' instruction returns the remainder from the division of; its two operands. .. note::. 	The instruction is implemented as a call to libm's '``fmod``'; 	for some targets, and using the instruction may thus require linking libm. Arguments:; """""""""""""""""""". The two arguments to the '``frem``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point remainder of the two operands.; This is the same output as a libm '``fmod``' function, but without any; possibility of setting ``errno``. The remainder has the same sign as the; dividend.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = frem float 4.0, %var ; yields float:result = 4.0 % %var. .. _bitwiseops:. Bitwise Binary Operations; -------------------------. Bitwise binary operators are used to do various forms of bit-twiddling; in a program. They are generally very efficient instructions and can; commonly be strength reduced from other instructions. They require two; operands of the same type, execute an operation on them, and produce a; single value. The resulting value is the same type as its operands. .. _i_shl:. '``shl``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shl <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nsw <ty> <op1>, <op2> ; yields ty:result; <result> = shl nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``shl``' instruction returns the first opera",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:394580,Performance,perform,performs,394580,"ifts out any bits that disagree with the resultant sign bit. Example:; """""""""""""""". .. code-block:: text. <result> = shl i32 4, %var ; yields i32: 4 << %var; <result> = shl i32 4, 2 ; yields i32: 16; <result> = shl i32 1, 10 ; yields i32: 1024; <result> = shl i32 1, 32 ; undefined; <result> = shl <2 x i32> < i32 1, i32 1>, < i32 1, i32 2> ; yields: result=<2 x i32> < i32 2, i32 4>. .. _i_lshr:. '``lshr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = lshr <ty> <op1>, <op2> ; yields ty:result; <result> = lshr exact <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``lshr``' instruction (logical shift right) returns the first; operand shifted to the right a specified number of bits with zero fill. Arguments:; """""""""""""""""""". Both arguments to the '``lshr``' instruction must be the same; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type.; '``op2``' is treated as an unsigned value. Semantics:; """""""""""""""""""". This instruction always performs a logical shift right operation. The; most significant bits of the result will be filled with zero bits after; the shift. If ``op2`` is (statically or dynamically) equal to or larger; than the number of bits in ``op1``, this instruction returns a :ref:`poison; value <poisonvalues>`. If the arguments are vectors, each vector element; of ``op1`` is shifted by the corresponding shift amount in ``op2``. If the ``exact`` keyword is present, the result value of the ``lshr`` is; a poison value if any of the bits shifted out are non-zero. Example:; """""""""""""""". .. code-block:: text. <result> = lshr i32 4, 1 ; yields i32:result = 2; <result> = lshr i32 4, 2 ; yields i32:result = 1; <result> = lshr i8 4, 3 ; yields i8:result = 0; <result> = lshr i8 -2, 1 ; yields i8:result = 0x7F; <result> = lshr i32 1, 32 ; undefined; <result> = lshr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 2> ; yields: result=<2 x i32> < i32 0x7FFFFFFF, i32 1>. .. _i_ashr:. '``ashr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:396139,Performance,perform,performs,396139," ; yields i32:result = 2; <result> = lshr i32 4, 2 ; yields i32:result = 1; <result> = lshr i8 4, 3 ; yields i8:result = 0; <result> = lshr i8 -2, 1 ; yields i8:result = 0x7F; <result> = lshr i32 1, 32 ; undefined; <result> = lshr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 2> ; yields: result=<2 x i32> < i32 0x7FFFFFFF, i32 1>. .. _i_ashr:. '``ashr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = ashr <ty> <op1>, <op2> ; yields ty:result; <result> = ashr exact <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``ashr``' instruction (arithmetic shift right) returns the first; operand shifted to the right a specified number of bits with sign; extension. Arguments:; """""""""""""""""""". Both arguments to the '``ashr``' instruction must be the same; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type.; '``op2``' is treated as an unsigned value. Semantics:; """""""""""""""""""". This instruction always performs an arithmetic shift right operation,; The most significant bits of the result will be filled with the sign bit; of ``op1``. If ``op2`` is (statically or dynamically) equal to or larger; than the number of bits in ``op1``, this instruction returns a :ref:`poison; value <poisonvalues>`. If the arguments are vectors, each vector element; of ``op1`` is shifted by the corresponding shift amount in ``op2``. If the ``exact`` keyword is present, the result value of the ``ashr`` is; a poison value if any of the bits shifted out are non-zero. Example:; """""""""""""""". .. code-block:: text. <result> = ashr i32 4, 1 ; yields i32:result = 2; <result> = ashr i32 4, 2 ; yields i32:result = 1; <result> = ashr i8 4, 3 ; yields i8:result = 0; <result> = ashr i8 -2, 1 ; yields i8:result = -1; <result> = ashr i32 1, 32 ; undefined; <result> = ashr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 3> ; yields: result=<2 x i32> < i32 -1, i32 0>. .. _i_and:. '``and``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = and <ty> <op1>, <op2> ; yields ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:401847,Performance,scalab,scalable,401847,"uction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = extractelement <n x <ty>> <val>, <ty2> <idx> ; yields <ty>; <result> = extractelement <vscale x n x <ty>> <val>, <ty2> <idx> ; yields <ty>. Overview:; """""""""""""""""". The '``extractelement``' instruction extracts a single scalar element; from a vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``extractelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is an index indicating; the position from which to extract the element. The index may be a; variable of any integer type, and will be treated as an unsigned integer. Semantics:; """""""""""""""""""". The result is a scalar of the same type as the element type of ``val``.; Its value is the value at position ``idx`` of ``val``. If ``idx``; exceeds the length of ``val`` for a fixed-length vector, the result is a; :ref:`poison value <poisonvalues>`. For a scalable vector, if the value; of ``idx`` exceeds the runtime length of the vector, the result is a; :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = extractelement <4 x i32> %vec, i32 0 ; yields i32. .. _i_insertelement:. '``insertelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <n x <ty>>; <result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>. Overview:; """""""""""""""""". The '``insertelement``' instruction inserts a scalar element into a; vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``insertelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is a scalar value whose; type must equal the element type of the first operand. The third operand; is an index indicating the position at which to insert the value. The; index may be a variable of any integer type, and will be treated as an; unsigned inte",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:403223,Performance,scalab,scalable,403223,"result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>. Overview:; """""""""""""""""". The '``insertelement``' instruction inserts a scalar element into a; vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``insertelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is a scalar value whose; type must equal the element type of the first operand. The third operand; is an index indicating the position at which to insert the value. The; index may be a variable of any integer type, and will be treated as an; unsigned integer. Semantics:; """""""""""""""""""". The result is a vector of the same type as ``val``. Its element values; are those of ``val`` except at position ``idx``, where it gets the value; ``elt``. If ``idx`` exceeds the length of ``val`` for a fixed-length vector,; the result is a :ref:`poison value <poisonvalues>`. For a scalable vector,; if the value of ``idx`` exceeds the runtime length of the vector, the result; is a :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = insertelement <4 x i32> %vec, i32 1, i32 0 ; yields <4 x i32>. .. _i_shufflevector:. '``shufflevector``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask> ; yields <m x <ty>>; <result> = shufflevector <vscale x n x <ty>> <v1>, <vscale x n x <ty>> v2, <vscale x m x i32> <mask> ; yields <vscale x m x <ty>>. Overview:; """""""""""""""""". The '``shufflevector``' instruction constructs a permutation of elements; from two input vectors, returning a vector with the same element type as; the input and length that is the same as the shuffle mask. Arguments:; """""""""""""""""""". The first two operands of a '``shufflevector``' instruction are vectors; with the same type. The third argument is a shuffle mask vector constant; whose element type is ``i32``. The mask vector elements must be constant; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:405214,Performance,scalab,scalable,405214,"ues. The result of the instruction is a vector; whose length is the same as the shuffle mask and whose element type is the; same as the element type of the first two operands. Semantics:; """""""""""""""""""". The elements of the two input vectors are numbered from left to right; across both of the vectors. For each element of the result vector, the; shuffle mask selects an element from one of the input vectors to copy; to the result. Non-negative elements in the mask represent an index; into the concatenated pair of input vectors. A ``poison`` element in the mask vector specifies that the resulting element; is ``poison``.; For backwards-compatibility reasons, LLVM temporarily also accepts ``undef``; mask elements, which will be interpreted the same way as ``poison`` elements.; If the shuffle mask selects an ``undef`` element from one of the input; vectors, the resulting element is ``undef``. For scalable vectors, the only valid mask values at present are; ``zeroinitializer``, ``undef`` and ``poison``, since we cannot write all indices as; literals for a vector with a length unknown at compile time. Example:; """""""""""""""". .. code-block:: text. <result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,; <4 x i32> <i32 0, i32 4, i32 1, i32 5> ; yields <4 x i32>; <result> = shufflevector <4 x i32> %v1, <4 x i32> poison,; <4 x i32> <i32 0, i32 1, i32 2, i32 3> ; yields <4 x i32> - Identity shuffle.; <result> = shufflevector <8 x i32> %v1, <8 x i32> poison,; <4 x i32> <i32 0, i32 1, i32 2, i32 3> ; yields <4 x i32>; <result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,; <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 > ; yields <8 x i32>. Aggregate Operations; --------------------. LLVM supports several instructions for working with; :ref:`aggregate <t_aggregate>` values. .. _i_extractvalue:. '``extractvalue``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = extractvalue <aggregate type> <val>, <idx>{, <idx>}*. Overview:; """""""""""""""""". The '``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410183,Performance,scalab,scalable,410183,"this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410258,Performance,scalab,scalable,410258,"this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410528,Performance,load,loading,410528,"runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted; to be one. If a constant alignment is specified, the value result of the; allocation is guaranteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:411826,Performance,load,load,411826,"t have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:411904,Performance,load,load,411904,"ions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412006,Performance,load,load,412006,"returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412236,Performance,load,load,412236,"ddress space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argum",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412555,Performance,load,load,412555,"e-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412650,Performance,load,load,412650,"tr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not grea",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412713,Performance,load,load,412713,"tr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not grea",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412879,Performance,load,load,412879,"!nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:412922,Performance,optimiz,optimizer,412922,"!nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413001,Performance,load,load,413001,"!nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413068,Performance,load,load,413068,"dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]; <result> = load atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignmen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413263,Performance,load,load,413263,"atomic [volatile] <ty>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413292,Performance,load,loads,413292,"nment> [, !invariant.group !<empty_node>]; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}; !<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }; !<align_node> = !{ i64 <value_alignment> }. Overview:; """""""""""""""""". The '``load``' instruction is used to read from memory. Arguments:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value highe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413632,Performance,load,loads,413632,"ents:; """""""""""""""""""". The argument to the ``load`` instruction specifies the memory address from which; to load. The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413786,Performance,perform,performance,413786," The type specified must be a :ref:`first class <t_firstclass>` type of; known size (i.e. not containing an :ref:`opaque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:413864,Performance,load,loads,413864,"aque structural type <t_opaque>`). If; the ``load`` is marked as ``volatile``, then the optimizer is not allowed to; modify the number or order of execution of this ``load`` with other; :ref:`volatile operations <volatile>`. If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414356,Performance,load,loaded,414356,"the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414430,Performance,load,loaded,414430,"the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415088,Performance,optimiz,optimizer,415088," correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The exis",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415128,Performance,load,load,415128," correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The exis",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415169,Performance,cache,cache,415169," correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The exis",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415236,Performance,cache,cache,415236,"ent of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is n",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415322,Performance,load,load,415322,"up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415450,Performance,load,load,415450,"address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metad",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415496,Performance,load,load,415496,"ze_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dere",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:415564,Performance,load,load,415564,"ze_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dere",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:416158,Performance,optimiz,optimizer,416158,"o be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:416183,Performance,load,loaded,416183,"o be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:416406,Performance,load,loads,416406,"sponding to a metadata node with no; entries. If a load instruction tagged with the ``!invariant.load``; metadata is executed, the memory location referenced by the load has; to contain the same value at all points in the program where the; memory location is dereferenceable; otherwise, the behavior is; undefined. The optional ``!invariant.group`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a metadata node with no entries.; See ``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`. The optional ``!nonnull`` metadata must reference a single; metadata name ``<empty_node>`` corresponding to a metadata node with no; entries. The existence of the ``!nonnull`` metadata on the; instruction tells the optimizer that the value loaded is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return val",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:417166,Performance,optimiz,optimizer,417166,"is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:417191,Performance,load,loaded,417191,"is known to; never be null. If the value is null at runtime, a poison value is returned; instead. This is analogous to the ``nonnull`` attribute on parameters and; return values. This metadata can only be applied to loads of a pointer type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:417442,Performance,load,loads,417442," optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata :ref:`dereferenceable <md_dereferenceable>`. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:417769,Performance,optimiz,optimizer,417769,"node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:417795,Performance,load,loaded,417795,"node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata :ref:`dereferenceable_or_null; <md_dereferenceable_or_null>`. The optional ``!align`` metadata must reference a single metadata name; ``<align_node>`` corresponding to a metadata node with one ``i64`` entry.; The existence of the ``!align`` metadata on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418152,Performance,load,loaded,418152,"on the instruction tells the; optimizer that the value loaded is known to be aligned to a boundary specified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <point",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418179,Performance,load,loaded,418179,"ecified; by the integer value in the metadata node. The alignment must be a power of 2.; This is analogous to the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418331,Performance,load,loading,418331," the ''align'' attribute on parameters and return values.; This metadata can only be applied to loads of a pointer type. If the returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <al",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418382,Performance,load,loading,418382,"returned; value is not appropriately aligned at runtime, a poison value is returned; instead. The optional ``!noundef`` metadata must reference a single metadata name; ``<empty_node>`` corresponding to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """"""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418593,Performance,load,loaded,418593,"g to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """""""""""""""""". The '``store``' instruction is used to write to memory. Arguments:; """""""""""""""""""". There are two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418747,Performance,load,loaded,418747,"g to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """""""""""""""""". The '``store``' instruction is used to write to memory. Arguments:; """""""""""""""""""". There are two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418965,Performance,load,load,418965," is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """""""""""""""""". The '``store``' instruction is used to write to memory. Arguments:; """""""""""""""""""". There are two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The type of the ``<pointer>`` operand must be a; pointer to the :ref:`first class <t_firstclass>` type of the ``<value>``; operand. If the ``store`` is marked as ``volatile``, then the optimizer is not; allowed to modify the number or order of execution of this ``store`` with other",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:419852,Performance,optimiz,optimizer,419852," = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """""""""""""""""". The '``store``' instruction is used to write to memory. Arguments:; """""""""""""""""""". There are two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The type of the ``<pointer>`` operand must be a; pointer to the :ref:`first class <t_firstclass>` type of the ``<value>``; operand. If the ``store`` is marked as ``volatile``, then the optimizer is not; allowed to modify the number or order of execution of this ``store`` with other; :ref:`volatile operations <volatile>`. Only values of :ref:`first class; <t_firstclass>` types of known size (i.e. not containing an :ref:`opaque; structural type <t_opaque>`) can be stored. If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:420376,Performance,load,loads,420376,"ode> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """""""""""""""""". The '``store``' instruction is used to write to memory. Arguments:; """""""""""""""""""". There are two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The type of the ``<pointer>`` operand must be a; pointer to the :ref:`first class <t_firstclass>` type of the ``<value>``; operand. If the ``store`` is marked as ``volatile``, then the optimizer is not; allowed to modify the number or order of execution of this ``store`` with other; :ref:`volatile operations <volatile>`. Only values of :ref:`first class; <t_firstclass>` types of known size (i.e. not containing an :ref:`opaque; structural type <t_opaque>`) can be stored. If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value hig",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:420871,Performance,perform,performance,420871,"he ``store`` is marked as ``volatile``, then the optimizer is not; allowed to modify the number or order of execution of this ``store`` with other; :ref:`volatile operations <volatile>`. Only values of :ref:`first class; <t_firstclass>` types of known size (i.e. not containing an :ref:`opaque; structural type <t_opaque>`) can be stored. If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering; <ordering>` and optional ``syncscope(""<target-scope>"")`` argument. The; ``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421442,Performance,load,loaded,421442,"e pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421516,Performance,load,loaded,421516,"e pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:422174,Performance,optimiz,optimizer,422174," correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. If ``<value>`` is; of scalar type then the number of bytes written does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:422213,Performance,load,load,422213," correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. If ``<value>`` is; of scalar type then the number of bytes written does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:422255,Performance,cache,cache,422255," correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. If ``<value>`` is; of scalar type then the number of bytes written does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:422322,Performance,cache,cache,422322,"ent of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. If ``<value>`` is; of scalar type then the number of bytes written does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields pt",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:423368,Performance,load,load,423368,"``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. If ``<value>`` is; of scalar type then the number of bytes written does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:425874,Performance,load,loads,425874,"ring created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-block:: text. fence acquire ; yields void; fence syncscope(""singlethread"") seq_cst ; yields void; fence syncscope(""agent"") seq_cst ; yields void. .. _i_cmpxchg:. '``cmpxchg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. cmpxchg [weak] [volatile] ptr <pointer>, <ty> <cmp>, <ty> <new> [syncscope(""<target-scope>"")] <success ordering> <failure ordering>[, align <alignment>] ; yields { ty, i1 }. Overview:; """""""""""""""""". The '``cmpxchg``' instruction is used to atomically modify memory. It; loads a value in memory and compares it to a given value. If they are; equal, it tries to store a new value into the memory. Arguments:; """""""""""""""""""". There are three arguments to the '``cmpxchg``' instruction: an address; to operate on, a value to compare to the value currently be at that; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:426590,Performance,optimiz,optimizer,426590,"e] ptr <pointer>, <ty> <cmp>, <ty> <new> [syncscope(""<target-scope>"")] <success ordering> <failure ordering>[, align <alignment>] ; yields { ty, i1 }. Overview:; """""""""""""""""". The '``cmpxchg``' instruction is used to atomically modify memory. It; loads a value in memory and compares it to a given value. If they are; equal, it tries to store a new value into the memory. Arguments:; """""""""""""""""""". There are three arguments to the '``cmpxchg``' instruction: an address; to operate on, a value to compare to the value currently be at that; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:427229,Performance,perform,performance,427229,"t; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the location is returned,; together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as ``weak`` then a spurious failure is; permitted: the operation may not write ``<new>`` even if the comparison; match",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:427518,Performance,load,load,427518,">' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the location is returned,; together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as ``weak`` then a spurious failure is; permitted: the operation may not write ``<new>`` even if the comparison; matched. If the cmpxchg operation is strong (the default), the i1 value is 1 if and only; if the value loaded equals ``cmp``. A successful ``cmpxchg`` is a read-modify-write instruction for the purpose of; identifying release sequences. A failed ``cmpxchg`` is equivalent to an atomic; load with an ordering parameter determined the second ord",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:428259,Performance,load,loaded,428259," poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the location is returned,; together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as ``weak`` then a spurious failure is; permitted: the operation may not write ``<new>`` even if the comparison; matched. If the cmpxchg operation is strong (the default), the i1 value is 1 if and only; if the value loaded equals ``cmp``. A successful ``cmpxchg`` is a read-modify-write instruction for the purpose of; identifying release sequences. A failed ``cmpxchg`` is equivalent to an atomic; load with an ordering parameter determined the second ordering parameter. Example:; """""""""""""""". .. code-block:: llvm. entry:; %orig = load atomic i32, ptr %ptr unordered, align 4 ; yields i32; br label %loop. loop:; %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]; %squared = mul i32 %cmp, %cmp; %val_success = cmpxchg ptr %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields { i32, i1 }; %value_loaded = extractvalue { i32, i1 } %val_success, 0; %success = extractvalue { i32, i1 } %val_success, 1; br i1 %success, label %done, label %loop. done:; ... .. _i_atomicrmw:. '``atomicrmw``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. atomicrmw [volatile] <operation> ptr <pointer>, <ty> <value> [syncscope(""<target-scope>"")] <ordering>[, align <alignment",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:428442,Performance,load,load,428442,"ignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the location is returned,; together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as ``weak`` then a spurious failure is; permitted: the operation may not write ``<new>`` even if the comparison; matched. If the cmpxchg operation is strong (the default), the i1 value is 1 if and only; if the value loaded equals ``cmp``. A successful ``cmpxchg`` is a read-modify-write instruction for the purpose of; identifying release sequences. A failed ``cmpxchg`` is equivalent to an atomic; load with an ordering parameter determined the second ordering parameter. Example:; """""""""""""""". .. code-block:: llvm. entry:; %orig = load atomic i32, ptr %ptr unordered, align 4 ; yields i32; br label %loop. loop:; %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]; %squared = mul i32 %cmp, %cmp; %val_success = cmpxchg ptr %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields { i32, i1 }; %value_loaded = extractvalue { i32, i1 } %val_success, 0; %success = extractvalue { i32, i1 } %val_success, 1; br i1 %success, label %done, label %loop. done:; ... .. _i_atomicrmw:. '``atomicrmw``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. atomicrmw [volatile] <operation> ptr <pointer>, <ty> <value> [syncscope(""<target-scope>"")] <ordering>[, align <alignment>] ; yields ty. Overview:; """""""""""""""""". The '``atomicrmw``' instruction is used to atomically modify memory. Arguments:; """""""""""""""""""". There are three arguments to the '``atomicrmw``' instruction: an; operation to apply, an address who",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:428574,Performance,load,load,428574," must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is read and compared to '``<cmp>``'; if the values are equal, '``<new>``' is; written to the location. The original value at the location is returned,; together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as ``weak`` then a spurious failure is; permitted: the operation may not write ``<new>`` even if the comparison; matched. If the cmpxchg operation is strong (the default), the i1 value is 1 if and only; if the value loaded equals ``cmp``. A successful ``cmpxchg`` is a read-modify-write instruction for the purpose of; identifying release sequences. A failed ``cmpxchg`` is equivalent to an atomic; load with an ordering parameter determined the second ordering parameter. Example:; """""""""""""""". .. code-block:: llvm. entry:; %orig = load atomic i32, ptr %ptr unordered, align 4 ; yields i32; br label %loop. loop:; %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]; %squared = mul i32 %cmp, %cmp; %val_success = cmpxchg ptr %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields { i32, i1 }; %value_loaded = extractvalue { i32, i1 } %val_success, 0; %success = extractvalue { i32, i1 } %val_success, 1; br i1 %success, label %done, label %loop. done:; ... .. _i_atomicrmw:. '``atomicrmw``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. atomicrmw [volatile] <operation> ptr <pointer>, <ty> <value> [syncscope(""<target-scope>"")] <ordering>[, align <alignment>] ; yields ty. Overview:; """""""""""""""""". The '``atomicrmw``' instruction is used to atomically modify memory. Arguments:; """""""""""""""""""". There are three arguments to the '``atomicrmw``' instruction: an; operation to apply, an address whose value to modify, an argument to the; operation. The operation must be one of the following keywords:. - xchg; - add; - sub; - and; - nand; - or; -",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/LangRef.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst
