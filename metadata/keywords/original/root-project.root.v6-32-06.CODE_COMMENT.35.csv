id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:29,Modifiability,extend,extendable,29,// Return a reference to the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:40,Modifiability,extend,extendable,40,// Return the implicit alignment of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:44,Modifiability,extend,extendable,44,// Return the number of logical bits of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:24,Testability,log,logical,24,// Return the number of logical bits of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:16,Modifiability,extend,extendable,16,// Check if the extendable operand is signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:40,Modifiability,extend,extendable,40,// Return the max value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:86,Modifiability,extend,extended,86,// Return the max value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:40,Modifiability,extend,extendable,40,// Return the min value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:86,Modifiability,extend,extended,86,// Return the min value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:27,Modifiability,extend,extender,27,// Does the packet have an extender for the instruction at Index,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:55,Modifiability,extend,extended,55,// Return whether the instruction needs to be constant extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:34,Modifiability,extend,extended,34,// Return true if the insn may be extended based on the operand value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:49,Modifiability,extend,extended,49,// Return whether the instruction must be always extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:52,Modifiability,extend,extender,52,// Returns whether this instruction is an immediate extender,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:39,Availability,avail,available,39,// Returns the maximum number of slots available in the given; // subtarget's packets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:60,Modifiability,extend,extend,60,// Would duplexing this instruction create a requirement to extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCShuffler.cpp:94,Modifiability,extend,extender,94,"// if fixups present, make sure we don't insert too many nops that would; // later prevent an extender from being inserted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:3,Security,HasH,HasHvxVer,3,"// HasHvxVer is false, and UseHvx is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Testability,assert,assert,2,//assert(!HexagonMCInstrInfo::isBundle(Inst));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Testability,assert,assert,2,//assert(!HexagonMCInstrInfo::isBundle(Inst));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Testability,assert,assert,2,//assert(!HexagonMCInstrInfo::isBundle(Inst));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h:111,Modifiability,extend,extender,111,"// Maximum number of instructions in a packet before shuffling,; // including a compound one or a duplex or an extender.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h:55,Security,expose,exposed,55,"/// Create a Hexagon MCSubtargetInfo instance. This is exposed so Asm parser,; /// etc. do not need to go through TargetRegistry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:114,Availability,avail,available,114,"// The priority is directly proportional to how restricted the insn is based; // on its flexibility to run on the available slots. So, the fewer slots it; // may run on, the higher its priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Mask,Mask,3,// Mask indicating which slot is unavailable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if the desired slots are already full.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:81,Availability,mask,mask,81,"// If this packet contains an instruction that bars slot-1 stores,; // we should mask off slot 1 from all of the store instructions in; // this packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:42,Availability,mask,masks,42,// These restrictions can modify the slot masks in the instructions; // in the Packet member. They should run unconditionally and their; // order does not matter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:42,Availability,mask,masks,42,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:130,Availability,failure,failures,130,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:112,Safety,detect,detect,112,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Security,validat,validate,3,// validate first jump with this slot rule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Security,validat,validate,3,// validate second jump with this slot rule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:23,Deployability,configurat,configuration,23,"// both valid for this configuration, set new slot rules",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:23,Modifiability,config,configuration,23,"// both valid for this configuration, set new slot rules",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:52,Availability,mask,mask,52,"// if yes, great, if not then restore original slot mask; // restore original values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if insn may not be executed in any slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:12,Performance,load,load,12,// A single load must use slot #0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:11,Performance,load,load,11,// Pin the load to slot #0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:14,Performance,load,loads,14,// Slot1 only loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:20,Performance,Load,Loads,20,// }:mem_noshuf; // Loads must keep the original order ONLY if; // isMemReorderDisabled() == true,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:26,Availability,avail,available,26,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:40,Performance,load,loads,40,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:36,Availability,avail,available,36,// Pin the load to the highest slot available to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:11,Performance,load,load,11,// Pin the load to the highest slot available to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:32,Availability,avail,available,32,// Update the next highest slot available to loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Deployability,Update,Update,3,// Update the next highest slot available to loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:45,Performance,load,loads,45,// Update the next highest slot available to loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if no more slots available for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:26,Availability,avail,available,26,// Error if no more slots available for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:37,Availability,avail,available,37,// Pin the store to the highest slot available to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:32,Availability,avail,available,32,// Update the next highest slot available to stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Deployability,Update,Update,3,// Update the next highest slot available to stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if a single store with another store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:17,Availability,mask,mask,17,// save off slot mask of instruction marked with A_PREFER_SLOT3; // and then pin it to slot #3,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:3,Availability,Mask,Mask,3,// Mask of the slots or units that may execute the insn and; // the weight or priority that the insn requires to be assigned a slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:30,Performance,load,load,30,// Flag whether the insn is a load or a store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:32,Performance,load,loads,32,"// Number of memory operations, loads, solo loads, stores, solo stores,; // single stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:44,Performance,load,loads,44,"// Number of memory operations, loads, solo loads, stores, solo stores,; // single stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:14,Availability,error,error,14,// Return the error code for the last check or shuffling of the bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:28,Integrability,interface,interface,28,"//===-- Lanai.h - Top-level interface for Lanai representation --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // Lanai back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:112,Energy Efficiency,schedul,scheduling,112,"// createLanaiISelDag - This pass converts a legalized DAG into a; // Lanai-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:54,Performance,load,loads,54,// createLanaiMemAluCombinerPass - This pass combines loads/stores and; // arithmetic operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAluCode.h:53,Testability,test,tested,53,// Bits indicating post- and pre-operators should be tested and set using Is*; // and Make* utility functions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAluCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAluCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- LanaiAsmPrinter.cpp - Lanai LLVM assembly writer ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the Lanai assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:9,Usability,clear,cleared,9,// carry cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:12,Usability,clear,cleared,12,// oVerflow cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:12,Usability,clear,cleared,12,// oVerflow cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:9,Usability,clear,cleared,9,// carry cleared | unsigned less than,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:383,Usability,Simpl,Simple,383,"//===-- LanaiDelaySlotFiller.cpp - Lanai delay slot filler ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple pass to fill delay slots with useful instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:131,Safety,safe,safe,131,// RET is generated as part of epilogue generation and hence we know; // what the two instructions preceding it are and that it is safe to; // insert RET above them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:3,Performance,Load,Loads,3,// Loads or stores cannot be moved past a store to the delay slot; // and stores cannot be moved past a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:104,Performance,load,load,104,// Loads or stores cannot be moved past a store to the delay slot; // and stores cannot be moved past a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Deployability,Update,Update,3,// Update maximum call frame size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:145,Energy Efficiency,allocate,allocate,145,"// Generates the following sequence for function entry:; // st %fp,-4[*%sp] !push old FP; // add %sp,8,%fp !generate new FP; // sub %sp,0x4,%sp !allocate stack space (as needed)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:97,Energy Efficiency,allocate,allocate,97,// FIXME: This appears to be overallocating. Needs investigation.; // Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space on the stack if needed; // sub %sp,StackSize,%sp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:36,Integrability,depend,depend,36,"// The function epilogue should not depend on the current stack pointer!; // It should use the frame pointer only. This is mandatory because; // of alloca; we also take advantage of it to omit stack adjustments; // before returning.; //; // Note that when we go to restore the preserved register values we must; // not try to address their slots by using offsets from the stack pointer.; // That's because the stack pointer may have been moved during the function; // execution due to a call to alloca(). Rather, we must restore all; // preserved registers via offsets from the frame pointer value.; //; // Note also that when the current frame is being ""popped"" (by adjusting; // the value of the stack pointer) on function exit, we must (for the; // sake of alloca) set the new value of the stack pointer based upon; // the current value of the frame pointer. We can't just add what we; // believe to be the (static) frame size to the stack pointer because; // if we did that, and alloca() had been called during this function,; // we would end up returning *without* having fully deallocated all of; // the space grabbed by alloca. If that happened, and a function; // containing one or more alloca() calls was called over and over again,; // then the stack would grow without limit!; //; // RET is lowered to; // ld -4[%fp],%pc # modify %pc (two delay slots); // as the return address is in the stack frame and mov to pc is allowed.; // emitEpilogue emits; // mov %fp,%sp # restore the stack pointer; // ld -8[%fp],%fp # restore the caller's frame pointer; // before RET and the delay slot filler will move RET such that these; // instructions execute in the delay slots of the load to PC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:1682,Performance,load,load,1682,"// The function epilogue should not depend on the current stack pointer!; // It should use the frame pointer only. This is mandatory because; // of alloca; we also take advantage of it to omit stack adjustments; // before returning.; //; // Note that when we go to restore the preserved register values we must; // not try to address their slots by using offsets from the stack pointer.; // That's because the stack pointer may have been moved during the function; // execution due to a call to alloca(). Rather, we must restore all; // preserved registers via offsets from the frame pointer value.; //; // Note also that when the current frame is being ""popped"" (by adjusting; // the value of the stack pointer) on function exit, we must (for the; // sake of alloca) set the new value of the stack pointer based upon; // the current value of the frame pointer. We can't just add what we; // believe to be the (static) frame size to the stack pointer because; // if we did that, and alloca() had been called during this function,; // we would end up returning *without* having fully deallocated all of; // the space grabbed by alloca. If that happened, and a function; // containing one or more alloca() calls was called over and over again,; // then the stack would grow without limit!; //; // RET is lowered to; // ld -4[%fp],%pc # modify %pc (two delay slots); // as the return address is in the stack frame and mov to pc is allowed.; // emitEpilogue emits; // mov %fp,%sp # restore the stack pointer; // ld -8[%fp],%fp # restore the caller's frame pointer; // before RET and the delay slot filler will move RET such that these; // instructions execute in the delay slots of the load to PC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,Performance,load,loaded,118,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:218,Security,access,access,218,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:287,Security,access,access,287,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:315,Security,access,accesses,315,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:9,Usability,clear,cleared,9,// carry cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:12,Usability,clear,cleared,12,// oVerflow cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,Availability,redundant,redundant,118,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:158,Availability,redundant,redundant,158,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:237,Availability,redundant,redundant,237,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:92,Deployability,update,update,92,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,Safety,redund,redundant,118,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:158,Safety,redund,redundant,158,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:237,Safety,redund,redundant,237,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:38,Availability,redundant,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:38,Safety,redund,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:91,Deployability,update,updated,91,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on; // CMP needs to be updated to be based on SUB. Push the condition; // code operands to OperandsToUpdate. If it is safe to remove; // CmpInstr, the condition code of these operands will be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:186,Safety,safe,safe,186,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on; // CMP needs to be updated to be based on SUB. Push the condition; // code operands to OperandsToUpdate. If it is safe to remove; // CmpInstr, the condition code of these operands will be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:66,Safety,safe,safe,66,// Z N V; // The instruction uses the V bit or C bit which is not safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:109,Performance,optimiz,optimize,109,"// If SR is not killed nor re-defined, we should check whether it is; // live-out. If it is live-out, do not optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:3,Deployability,Toggle,Toggle,3,// Toggle the optional operand to SR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:64,Safety,detect,detects,64,// Check if MI has any non-dead defs or physreg uses. This also detects; // predicated instructions which will be reading SR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:180,Energy Efficiency,allocate,allocated,180,// The output register value when the predicate is false is an implicit; // register operand tied to the first def. The tie makes the register; // allocator ensure the FalseReg is allocated the same register as operand 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:3,Deployability,Update,Update,3,// Update SeenMIs set: register newly created MI and erase removed DefMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:15,Performance,load,loads,15,// Handle only loads/stores with base register followed by immediate offset; // and with add as ALU op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:78,Energy Efficiency,efficient,efficient,78,"// See if the comparison instruction can be converted into something more; // efficient. E.g., on Lanai register-register instructions can set the flag; // register, obviating the need for a separate compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:323,Performance,optimiz,optimize,323,"// Analyze the given select instruction, returning true if it cannot be; // understood. It is assumed that MI->isSelect() is true.; //; // When successful, return the controlling condition and the operands that; // determine the true and false result values.; //; // Result = SELECT Cond, TrueOp, FalseOp; //; // Lanai can optimize certain select instructions, for example by predicating; // the instruction defining one of the operands and sets Optimizable to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:446,Performance,Optimiz,Optimizable,446,"// Analyze the given select instruction, returning true if it cannot be; // understood. It is assumed that MI->isSelect() is true.; //; // When successful, return the controlling condition and the operands that; // determine the true and false result values.; //; // Result = SELECT Cond, TrueOp, FalseOp; //; // Lanai can optimize certain select instructions, for example by predicating; // the instruction defining one of the operands and sets Optimizable to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:187,Availability,failure,failure,187,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:84,Performance,Optimiz,Optimizable,84,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:115,Performance,optimiz,optimize,115,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:347,Performance,optimiz,optimized,347,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp:80,Performance,Load,Load,80,// Helper functions for ComplexPattern used on LanaiInstrInfo; // Used on Lanai Load/Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp:3,Performance,Load,Loading,3,// Loading from a constant address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp:112,Energy Efficiency,schedul,scheduling,112,"// createLanaiISelDag - This pass converts a legalized DAG into a; // Lanai-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Modifiability,Extend,Extended,3,// Extended load operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:12,Performance,load,load,12,// Extended load operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:171,Performance,perform,performance,171,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:116,Safety,avoid,avoid,116,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:255,Testability,benchmark,benchmarks,255,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:77,Availability,error,error,77,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:56,Integrability,rout,routine,56,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:47,Performance,optimiz,optimization,47,// Lanai target does not yet support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:92,Performance,load,load,92,// LowerCCCArguments - transform physical registers into virtual registers and; // generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:88,Testability,assert,assert,88,"// If this is an 8/16-bit value, it is really passed promoted to 32; // bits. Insert an assert[sz]ext to capture this, then truncate to the; // right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Load,Load,3,// Load the argument to a virtual register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; // from this parameter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:177,Security,access,access,177,// The Lanai ABI for returning structs by value requires that we copy; // the sret argument into rv for the return. Save the argument into; // a virtual register so that we can access it from the return points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.; // TODO: Should return-twice functions be handled?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:477,Usability,Guid,Guide,477,"// Convert to non-adjacent form (NAF) signed-digit representation.; // NAF is a signed-digit form where no adjacent digits are non-zero. It is the; // minimal Hamming weight representation of a number (on average 1/3 of the; // digits will be non-zero vs 1/2 for regular binary representation). And as; // the non-zero digits will be the only digits contributing to the instruction; // count, this is desirable. The next loop converts it to NAF (following the; // approach in 'Guide to Elliptic Curve Cryptography' [ISBN: 038795273X]) by; // choosing the non-zero coefficients such that the resulting quotient is; // divisible by 2 which will cause the next coefficient to be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:214,Availability,down,down,214,"// For Lanai, the outgoing memory arguments area should be on top of the; // alloca area on the stack i.e., the outgoing memory arguments should be; // at a lower address than the alloca area. Move the alloca area down the; // stack by adding back the space reserved for outgoing arguments to SP; // here.; //; // We do not know what the size of the outgoing args is at this point.; // So, we add a pseudo instruction ADJDYNALLOC that will adjust the; // stack pointer. We replace this instruction with on that has the correct,; // known offset in emitPrologue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:40,Modifiability,variab,variable,40,"// If the code model is small or global variable will be placed in the small; // section, then assume address will fit in 21-bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Perform,Performs,3,// Performs the following for (ShOpLo + (ShOpHi << 32)) << ShAmt:; // LoBitsForHi = (ShAmt == 0) ? 0 : (ShOpLo >> (32-ShAmt)); // HiBitsForHi = ShOpHi << ShAmt; // Hi = (ShAmt >= 32) ? (ShOpLo << (ShAmt-32)) : (LoBitsForHi | HiBitsForHi); // Lo = (ShAmt >= 32) ? 0 : (ShOpLo << ShAmt); // return (Hi << 32) | Lo;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:50,Integrability,wrap,wrapped,50,"// Lanai shifts of larger than register sizes are wrapped rather than; // clamped, so we can't just emit ""lo << b"" if b is too big.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:390,Availability,mask,mask,390,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Perform,Performs,3,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:369,Safety,avoid,avoid,369,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:56,Safety,Detect,Detects,56,"// Return true if N is conditionally 0 or all ones.; // Detects these expressions where cc is an i1 value:; //; // (select cc 0, y) [AllOnes=0]; // (select cc y, 0) [AllOnes=0]; // (zext cc) [AllOnes=0]; // (sext cc) [AllOnes=0/1]; // (select cc -1, y) [AllOnes=1]; // (select cc y, -1) [AllOnes=1]; //; // * AllOnes determines whether to check for an all zero (AllOnes false) or an; // all ones operand (AllOnes true).; // * Invert is set when N is the all zero/ones constant when CC is false.; // * OtherOp is set to the alternative value of N.; //; // For example, for (select cc X, Y) and AllOnes = 0 if:; // * X = 0, Invert = False and OtherOp = Y; // * Y = 0, Invert = True and OtherOp = X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Perform,PerformSUBCombine,3,// PerformSUBCombine - Target-specific dag combine xforms for ISD::SUB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:49,Integrability,Interface,Interface,49,"//===-- LanaiISelLowering.h - Lanai DAG Lowering Interface -....-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Lanai uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- LanaiISelLowering.h - Lanai DAG Lowering Interface -....-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Lanai uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:53,Modifiability,variab,variable,53,"// SELECT_CC - Operand 0 and operand 1 are selection variable, operand 3; // is condition code and operand 4 is flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:3,Integrability,Wrap,Wrapper,3,"// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; // and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:15,Integrability,wrap,wrapper,15,"// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; // and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:480,Performance,load,load,480,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:534,Performance,load,load,534,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:585,Performance,load,load,585,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:379,Usability,Simpl,Simple,379,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:79,Testability,test,testing,79,// Determine if the machine instruction is a supported memory operation by; // testing if the computed merge opcode is a valid memory operation opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:30,Security,access,accesses,30,// Don't move volatile memory accesses; // TODO: unclear if we need to be as conservative about atomics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:3,Testability,Test,Test,3,// Test to see if two machine operands are of the same type. This test is less; // strict than the MachineOperand::isIdenticalTo function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:66,Testability,test,test,66,// Test to see if two machine operands are of the same type. This test is less; // strict than the MachineOperand::isIdenticalTo function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:23,Performance,load,load,23,// Insert new combined load/store + alu operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:3,Safety,Abort,Abort,3,// Abort if ALU offset is not a register or immediate,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:156,Security,access,accessing,156,"// Create a pre-op if the ALU operation preceded the memory operation or the; // MemOffset is non-zero (i.e. the memory value should be adjusted before; // accessing it), else create a post-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:81,Performance,load,load,81,// Function determines if ALU operation (in alu_iter) can be combined with; // a load/store with base and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:13,Performance,load,load,13,// Erase old load/store instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:29,Deployability,Configurat,Configuration,29,// Lanai Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:29,Modifiability,Config,Configuration,29,// Lanai Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:82,Energy Efficiency,schedul,scheduling,82,// Run passes after prolog-epilog insertion and before the second instruction; // scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp:21,Performance,load,loaded,21,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section must be addressed using; // gp_rel operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp:111,Security,access,access,111,"// Global values placed in sections starting with .ldata do not fit in; // 21-bits, so always use large memory access for them. FIXME: This is a; // workaround for a tool limitation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h:187,Energy Efficiency,reduce,reduce,187,// This increases the cost associated with multiplication and division; // to 64 times what the baseline arithmetic cost is. The arithmetic; // instruction cost was arbitrarily chosen to reduce the desirability; // of emitting arithmetic instructions that are emulated in software.; // TODO: Investigate the performance impact given specialized lowerings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h:308,Performance,perform,performance,308,// This increases the cost associated with multiplication and division; // to 64 times what the baseline arithmetic cost is. The arithmetic; // instruction cost was arbitrarily chosen to reduce the desirability; // of emitting arithmetic instructions that are emulated in software.; // TODO: Investigate the performance impact given specialized lowerings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:17,Testability,test,testing,17,// Functions for testing operand type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:43,Availability,error,error,43,// Matches memory operand. Returns true if error encountered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:264,Availability,robust,robust,264,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:222,Modifiability,Extend,Extend,222,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:3,Safety,Detect,Detects,3,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:104,Safety,detect,detected,104,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:167,Testability,test,test,167,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp:97,Availability,down,down,97,// Forward declare because the autogenerated code will reference this.; // Definition is further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiAsmBackend.cpp:3,Performance,Load,Load,3,// Load instruction and apply value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiFixupKinds.h:43,Availability,mask,masked,43,"// 21-bit symbol relocation, last two bits masked to 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiFixupKinds.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiFixupKinds.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp:60,Safety,abort,abort,60,// Handle the undefined value here for printing so we don't abort().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp:60,Safety,abort,abort,60,// Handle the undefined value here for printing so we don't abort().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCCodeEmitter.cpp:45,Performance,load,load,45,// Helper function to adjust P and Q bits on load and store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArch.h:32,Integrability,interface,interface,32,"//===-- LoongArch.h - Top-level interface for LoongArch ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // LoongArch back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===- LoongArchAsmPrinter.cpp - LoongArch LLVM Assembly Printer -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format LoongArch assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:3,Usability,Simpl,Simple,3,// Simple pseudo-instructions have their lowering (with expansion to real; // instructions) auto-generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:93,Availability,error,error,93,// The modifier is 'w' but the operand is not an LSX register; Report an; // unknown operand error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:94,Availability,error,error,94,// The modifier is 'u' but the operand is not an LASX register; Report an; // unknown operand error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h:3,Integrability,Wrap,Wrapper,3,// Wrapper needed for tblgenned pseudo lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:536,Safety,avoid,avoiding,536,"//==- LoongArchExpandAtomicPseudoInsts.cpp - Expand atomic pseudo instrs. -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands atomic pseudo instructions into; // target instructions. This pass should be run at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:39,Availability,mask,masktargetdata,39,// res = oldval ^ ((oldval ^ newval) & masktargetdata);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:135,Availability,mask,masktargetdata,135,"// .loop:; // ll.w destreg, (alignedaddr); // binop scratch, destreg, incr; // xor scratch, destreg, scratch; // and scratch, scratch, masktargetdata; // xor scratch, destreg, scratch; // sc.w scratch, scratch, (alignedaddr); // beqz scratch, loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:77,Availability,mask,mask,77,"//; // .loophead:; // ll.w destreg, (alignedaddr); // and scratch2, destreg, mask; // move scratch1, destreg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:76,Availability,mask,mask,76,"// .loopifbody:; // xor scratch1, destreg, incr; // and scratch1, scratch1, mask; // xor scratch1, destreg, scratch1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:63,Availability,mask,mask,63,"// .loophead:; // ll.[w|d] dest, (addr); // and scratch, dest, mask; // bne scratch, cmpval, tail",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:38,Availability,mask,mask,38,"// .looptail:; // andn scratch, dest, mask; // or scratch, scratch, newval; // sc.[w|d] scratch, scratch, (addr); // beqz scratch, loophead; // b done",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,// Emit the 5-insn large address load sequence with the `%pc` family of; // relocs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, loading the result from GOT with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:88,Performance,load,loading,88,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, loading the result from GOT with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%ie_pc` family; // of relocs, loading the result with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:87,Performance,load,loading,87,"// Emit the 5-insn large address load sequence with the `%ie_pc` family; // of relocs, loading the result with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, with the `pcalau12i` insn relocated with `%ld_pc_hi20`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, with the `pcalau12i` insn relocated with `%gd_pc_hi20`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence, either directly or; // indirectly in case of going through the GOT, then JIRL_TAIL or; // JIRL_CALL to $addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:215,Modifiability,variab,variable,215,"// Return true if the specified function should have a dedicated frame; // pointer register. This is true if frame pointer elimination is; // disabled, if it needs dynamic stack realignment, if the function has; // variable sized allocas, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Early exit if there is no need to allocate space in the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:30,Energy Efficiency,reduce,reduce,30,// Split the SP adjustment to reduce the offsets of callee saved spill.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:183,Modifiability,variab,variable,183,"// FP will be used to restore the frame in the epilogue, so we need; // another base register BP to record SP after re-alignment. SP will; // track the current stack after allocating variable sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:47,Energy Efficiency,reduce,reduce,47,"// We would like to split the SP adjustment to reduce prologue/epilogue; // as following instructions. In this way, the offset of the callee saved; // register could fit in a single store.; // e.g.; // addi.d $sp, $sp, -2032; // st.d $ra, $sp, 2024; // st.d $fp, $sp, 2016; // addi.d $sp, $sp, -16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:561,Energy Efficiency,reduce,reduce,561,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:205,Performance,load,load,205,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:530,Testability,log,logic,530,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:60,Modifiability,variab,variables,60,// Do not preserve stack space within prologue for outgoing variables if the; // function contains variable size objects.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:99,Modifiability,variab,variable,99,// Do not preserve stack space within prologue for outgoing variables if the; // function contains variable size objects.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:281,Energy Efficiency,allocate,allocate,281,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:196,Modifiability,variab,variable,196,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:44,Performance,optimiz,optimizing,44,// Keep the conventional code flow when not optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h:3,Availability,Mask,Mask,3,// Mask assignments for floating-point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:78,Availability,mask,mask,78,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:35,Energy Efficiency,power,power,35,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:47,Availability,mask,mask,47,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:33,Performance,optimiz,optimized,33,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:3,Usability,Simpl,SimplifyDemandedBits,3,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:95,Energy Efficiency,schedul,scheduling,95,"// This pass converts a legalized DAG into a LoongArch-specific DAG, ready; // for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:404,Integrability,interface,interfaces,404,"//=- LoongArchISelLowering.cpp - LoongArch DAG Lowering Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that LoongArch uses to lower LLVM code into; // a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Modifiability,extend,extending,36,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:46,Performance,load,loads,46,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:28,Integrability,synchroniz,synchronize,28,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:40,Security,access,access,40,// Use a PC-relative addressing mode to access the dynamic GOT address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,Availability,error,error,30,// Helper function that emits error message for intrinsics with chain and return; // merge values of a UNDEF and the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Integrability,message,message,36,// Helper function that emits error message for intrinsics with chain and return; // merge values of a UNDEF and the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,Availability,error,error,30,// Helper function that emits error message for intrinsics with void return; // value and return the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Integrability,message,message,36,// Helper function that emits error message for intrinsics with void return; // value and return the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,Availability,error,error,30,// Helper function that emits error message for intrinsics with/without chain; // and return a UNDEF or and the chain as the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Integrability,message,message,36,// Helper function that emits error message for intrinsics with/without chain; // and return a UNDEF or and the chain as the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:41,Availability,mask,mask,41,// Op's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,Availability,mask,mask,25,// Return if the shifted mask does not start at bit 0 or the sum of its; // length and lsb exceeds the word's size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:158,Availability,mask,mask,158,"// Pattern match BSTRPICK.; // $dst = and $src, (2**len- 1) , if len > 12; // => BSTRPICK $dst, $src, msb, lsb; // where lsb = 0 and msb = len - 1; // If the mask is <= 0xfff, andi can be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:100,Integrability,depend,depends,100,// Omit if the constant has more than 2 uses. This a conservative; // decision. Whether it is a win depends on the HW microarchitecture.; // However it should always be better for 1 and 2 uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize to; // bstrpick $Rd, $Rs, msb, lsb; // slli $Rd, $Rd, lsb",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,Availability,Mask,Mask,25,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:70,Availability,Mask,MaskIdx,70,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:78,Availability,Mask,MaskLen-,78,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:104,Availability,Mask,Mask,104,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:122,Availability,mask,mask,122,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:132,Availability,Mask,MaskIdx,132,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:152,Availability,Mask,MaskIdx,152,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:160,Availability,Mask,MaskLen-,160,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:92,Availability,mask,mask,92,// The first operand must be an AND and the second operand of the AND must be; // a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Availability,mask,mask,52,"// 4th pattern to match BSTRINS:; // R = or (and X, mask), (shl Y, shamt); // where mask = (2**shamt - 1); // =>; // R = BSTRINS X, Y, ValBits - 1, shamt; // where ValBits = 32 or 64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:84,Availability,mask,mask,84,"// 4th pattern to match BSTRINS:; // R = or (and X, mask), (shl Y, shamt); // where mask = (2**shamt - 1); // =>; // R = BSTRINS X, Y, ValBits - 1, shamt; // where ValBits = 32 or 64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Availability,mask,mask,52,"// 5th pattern to match BSTRINS:; // R = or (and X, mask), const; // where ~mask = (2**size - 1) << lsb, mask & const = 0; // =>; // R = BSTRINS X, (const >> lsb), msb, lsb; // where msb = lsb + size - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:76,Availability,mask,mask,76,"// 5th pattern to match BSTRINS:; // R = or (and X, mask), const; // where ~mask = (2**size - 1) << lsb, mask & const = 0; // =>; // R = BSTRINS X, (const >> lsb), msb, lsb; // where msb = lsb + size - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:105,Availability,mask,mask,105,"// 5th pattern to match BSTRINS:; // R = or (and X, mask), const; // where ~mask = (2**size - 1) << lsb, mask & const = 0; // =>; // R = BSTRINS X, (const >> lsb), msb, lsb; // where msb = lsb + size - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:34,Availability,mask,mask,34,"// 6th pattern.; // a = b | ((c & mask) << shamt), where all positions in b to be overwritten; // by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, shamt + MaskLen - 1, shamt; //; // Note that the 1st pattern is a special situation of the 6th, i.e. the 6th; // pattern is more common than the 1st. So we put the 1st before the 6th in; // order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:178,Availability,Mask,MaskLen,178,"// 6th pattern.; // a = b | ((c & mask) << shamt), where all positions in b to be overwritten; // by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, shamt + MaskLen - 1, shamt; //; // Note that the 1st pattern is a special situation of the 6th, i.e. the 6th; // pattern is more common than the 1st. So we put the 1st before the 6th in; // order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:178,Availability,Mask,MaskIdx,178,"// 7th pattern.; // a = b | ((c << shamt) & shifted_mask), where all positions in b to be; // overwritten by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 7th pattern is more common than the 2nd. So we put the 2nd; // before the 7th in order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:188,Availability,Mask,MaskLen,188,"// 7th pattern.; // a = b | ((c << shamt) & shifted_mask), where all positions in b to be; // overwritten by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 7th pattern is more common than the 2nd. So we put the 2nd; // before the 7th in order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:201,Availability,Mask,MaskIdx,201,"// 7th pattern.; // a = b | ((c << shamt) & shifted_mask), where all positions in b to be; // overwritten by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 7th pattern is more common than the 2nd. So we put the 2nd; // before the 7th in order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:169,Availability,Mask,MaskIdx,169,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:178,Availability,Mask,MaskIdx,178,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:188,Availability,Mask,MaskLen,188,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:201,Availability,Mask,MaskIdx,201,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear Divisor's kill flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,Integrability,depend,dependent,25,// TODO: Add more target-dependent nodes later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:427,Availability,avail,available,427,"//===----------------------------------------------------------------------===//; // Calling Convention Implementation; //===----------------------------------------------------------------------===//; // Eight general-purpose registers a0-a7 used for passing integer arguments,; // with a0-a1 reused to return values. Generally, the GPRs are used to pass; // fixed-point arguments, and floating-point arguments when no FPR is available; // or with soft float ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:66,Availability,failure,failure,66,// Implements the LoongArch calling convention. Returns true upon failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:51,Availability,avail,available,51,"// If passing a variadic argument, or if no FPR is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate to a register if possible, or else a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:33,Performance,load,loading,33,// The caller is responsible for loading the full value if the argument is; // passed with CCValAssign::Indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:78,Performance,load,load,78,"// If the original argument was split and passed by reference, we need to; // load all parts of it here (using the same address).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:23,Modifiability,variab,variable,23,"// Offset of the first variable argument from stack pointer, and size of; // the vararg save area. For now, the varargs save area is either zero or; // large enough to hold a0-a7.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:87,Performance,perform,perform,87,"// Check if the return value is used as only a return value, as otherwise; // we can't perform a tail-call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:91,Performance,perform,perform,91,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:83,Safety,safe,safe,83,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Performance,optimiz,optimization,52,// Check whether the call is eligible for tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:105,Performance,perform,performing,105,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Security,access,access,52,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue node if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:49,Modifiability,extend,extended,49,"// TODO: Add more AtomicRMWInst that needs to be extended.; // Since floating-point operation requires a non-trivial set of data; // operations, use CmpXChg to expand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:152,Availability,mask,mask,152,"// In the case of an atomicrmw xchg with a constant 0/-1 operand, replace; // the atomic instruction with an AtomicRMWInst::And/Or with appropriate; // mask, as this produces better code than the LL/SC loop emitted by; // int_loongarch_masked_atomicrmw_xchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:45,Modifiability,extend,extend,45,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:308,Modifiability,extend,extend,308,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:56,Performance,load,loaded,56,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:82,Performance,perform,performing,82,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:117,Availability,avail,available,117,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:42,Modifiability,config,config,42,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:584,Testability,log,logic,584,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:64,Availability,avail,available,64,// Match those names to the widest floating point register type available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 16-bit signed immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 12-bit signed immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create an integer zero operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 12-bit unsigned immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:12,Performance,optimiz,optimization,12,// Omit the optimization if the data size exceeds GRLen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:33,Performance,optimiz,optimized,33,"// Reject multiplications can be optimized to; // (SLLI (ALSL x, x, 1/2/3/4), s).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:49,Performance,load,load,49,// Zexts are free if they can be combined with a load.; // Don't advertise i32->i64 zextload as being free for LA64. It interacts; // poorly with type legalization of compares preferring sext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:54,Integrability,Interface,Interface,54,"//=- LoongArchISelLowering.h - LoongArch DAG Lowering Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that LoongArch uses to lower LLVM code into; // a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:405,Integrability,interface,interfaces,405,"//=- LoongArchISelLowering.h - LoongArch DAG Lowering Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that LoongArch uses to lower LLVM code into; // a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:37,Availability,mask,mask,37,// Similar to CSRWR but with a write mask.; // Operand 0: A chain pointer.; // Operand 1: The new value to write.; // Operand 2: The write mask.; // Operand 3: The address of the required CSR.; // Result 0: The old value of the CSR.; // Result 1: The new chain pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:139,Availability,mask,mask,139,// Similar to CSRWR but with a write mask.; // Operand 0: A chain pointer.; // Operand 1: The new value to write.; // Operand 2: The write mask.; // Operand 3: The address of the required CSR.; // Result 0: The old value of the CSR.; // Result 1: The new chain pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:9,Security,access,access,9,// IOCSR access operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:12,Deployability,configurat,configuration,12,// Read CPU configuration information operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:12,Modifiability,config,configuration,12,// Read CPU configuration information operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:3,Modifiability,Extend,Extended,3,// Extended vector element extraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:72,Energy Efficiency,allocate,allocate,72,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:85,Modifiability,variab,variable-sized,85,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:131,Testability,test,tested,131,// TODO: this implementation is a temporary placeholder which does just; // enough to allow other aspects of code generation to be tested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp:178,Performance,Tune,TuneCPU,178,"// Initialize CPU specific properties. We should add a tablegen feature for; // this in the future so we can specify it together with the subtarget; // features.; // TODO: Check TuneCPU and override defaults (that are for LA464) once we; // support optimizing for more uarchs.; // Default to the alignment settings empirically confirmed to perform best; // on LA464, with 4-wide instruction fetch and decode stages. These settings; // can also be overridden in initializeProperties.; //; // We default to such higher-than-minimum alignments because we assume that:; //; // * these settings should benefit most existing uarchs/users,; // * future general-purpose LoongArch cores are likely to have issue widths; // equal to or wider than 4,; // * instruction sequences best for LA464 should not pessimize other future; // uarchs, and; // * narrower cores would not suffer much (aside from slightly increased; // ICache footprint maybe), compared to the gains everywhere else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp:249,Performance,optimiz,optimizing,249,"// Initialize CPU specific properties. We should add a tablegen feature for; // this in the future so we can specify it together with the subtarget; // features.; // TODO: Check TuneCPU and override defaults (that are for LA464) once we; // support optimizing for more uarchs.; // Default to the alignment settings empirically confirmed to perform best; // on LA464, with 4-wide instruction fetch and decode stages. These settings; // can also be overridden in initializeProperties.; //; // We default to such higher-than-minimum alignments because we assume that:; //; // * these settings should benefit most existing uarchs/users,; // * future general-purpose LoongArch cores are likely to have issue widths; // equal to or wider than 4,; // * instruction sequences best for LA464 should not pessimize other future; // uarchs, and; // * narrower cores would not suffer much (aside from slightly increased; // ICache footprint maybe), compared to the gains everywhere else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp:340,Performance,perform,perform,340,"// Initialize CPU specific properties. We should add a tablegen feature for; // this in the future so we can specify it together with the subtarget; // features.; // TODO: Check TuneCPU and override defaults (that are for LA464) once we; // support optimizing for more uarchs.; // Default to the alignment settings empirically confirmed to perform best; // on LA464, with 4-wide instruction fetch and decode stages. These settings; // can also be overridden in initializeProperties.; //; // We default to such higher-than-minimum alignments because we assume that:; //; // * these settings should benefit most existing uarchs/users,; // * future general-purpose LoongArch cores are likely to have issue widths; // equal to or wider than 4,; // * instruction sequences best for LA464 should not pessimize other future; // uarchs, and; // * narrower cores would not suffer much (aside from slightly increased; // ICache footprint maybe), compared to the gains everywhere else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule the expansion of AtomicPseudos at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:76,Safety,avoid,avoiding,76,"// Schedule the expansion of AtomicPseudos at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:151,Availability,failure,failure,151,"// Attempts to match Name as a register (either using the default name or; // alternative ABI names), setting RegNo to the matching register. Upon; // failure, returns true and sets RegNo to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:87,Integrability,message,message,87,"// If there is a next operand and it is 0, ignore it. Otherwise print a; // diagnostic message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:127,Availability,error,error,127,"/// Looks at a token type and creates the relevant operand from this; /// information, adding to Operands. Return true upon an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:28,Availability,error,error,28,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:34,Integrability,message,message,34,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/Disassembler/LoongArchDisassembler.cpp:38,Modifiability,extend,extend,38,"// Shift left Imm <S> bits, then sign-extend the number in the bottom <N+S>; // bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/Disassembler/LoongArchDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/Disassembler/LoongArchDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:80,Usability,simpl,simply,80,// Calculate total Nops we need to insert. If there are none to insert; // then simply return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:206,Availability,error,error,206,"// We need record relocation if SecA != SecB. Usually SecB is same as the; // section of Fixup, which will be record the relocation as PCRel. If SecB; // is not same as the section of Fixup, it will report error. Just return; // false and then this work can be finished by handleFixup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:204,Safety,avoid,avoid,204,"// In SecA == SecB case. If the linker relaxation is enabled, we need record; // the ADD, SUB relocations. Otherwise the FixedValue has already been calc-; // ulated out in evaluateFixup, return true and avoid record relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp:6,Safety,avoid,avoid,6,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value. The `last` `S` register (s9) is; // used for FP. So we choose the previous (s8) as BP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h:27,Integrability,interface,interface,27,"//===-- M68k.h - Top-level interface for M68k representation ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the entry points for global functions defined in the; /// M68k target library, as used by the LLVM JIT.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h:92,Energy Efficiency,schedul,scheduling,92,"/// This pass converts a legalized DAG into a M68k-specific DAG, ready for; /// instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kAsmPrinter.cpp:488,Integrability,depend,dependent,488,"//===-- M68kAsmPrinter.cpp - M68k LLVM Assembly Printer ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a printer that converts from our internal representation; /// of machine-dependent LLVM code to GAS-format M68k assembly language.; ///; //===----------------------------------------------------------------------===//; // TODO Conform to Motorola ASM syntax",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h:43,Integrability,Rout,Routines,43,"//===-- M68kCallingConv.h - M68k Custom CC Routines -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the custom routines for the M68k Calling Convention; /// that aren't done by tablegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h:426,Integrability,rout,routines,426,"//===-- M68kCallingConv.h - M68k Custom CC Routines -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the custom routines for the M68k Calling Convention; /// that aren't done by tablegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:487,Availability,mask,mask,487,"//===-- M68kCollapseMOVEMPass.cpp - Expand MOVEM pass -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// `MOVEM` is an instruction that moves multiple registers a time according to; /// the given mask. Thus sometimes it's pretty expensive.; /// This file contains a pass that collapses sequential MOVEM instructions into; /// a single one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:32,Availability,Mask,Mask,32,// You need to call this before Mask update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:37,Deployability,update,update,37,// You need to call this before Mask update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:159,Availability,mask,mask,159,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:407,Availability,redundant,redundant,407,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:232,Performance,perform,perform,232,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:407,Safety,redund,redundant,407,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:178,Security,access,access,178,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:36,Availability,Mask,Mask,36,"// If current Type, Reg, Offset and Mask is in proper order then; // merge in the state",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:501,Energy Efficiency,schedul,scheduling,501,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:544,Performance,optimiz,optimizations,544,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:562,Usability,simpl,simply,562,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:56,Testability,log,logic,56,"// NOTE: this only has a subset of the full frame index logic. In; // particular, the FI < 0 and AfterFPPop logic is handled in; // M68kRegisterInfo::eliminateFrameIndex, but not here. Possibly; // (probably?) it should be moved into here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:108,Testability,log,logic,108,"// NOTE: this only has a subset of the full frame index logic. In; // particular, the FI < 0 and AfterFPPop logic is handled in; // M68kRegisterInfo::eliminateFrameIndex, but not here. Possibly; // (probably?) it should be moved into here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:205,Integrability,depend,depending,205,"// Offset will hold the offset from the stack pointer at function entry to the; // object.; // We need to factor in additional offsets applied during the prologue to the; // frame, base, and stack pointer depending on which is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:189,Performance,perform,perform,189,"// This function is normally used with SP which is Address Register, but AND,; // or any other logical instructions in M68k do not support ARs so we need; // to use a temp Data Register to perform the op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:95,Testability,log,logical,95,"// This function is normally used with SP which is Address Register, but AND,; // or any other logical instructions in M68k do not support ARs so we need; // to use a temp Data Register to perform the op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:173,Integrability,depend,depends,173,"// If we don't have FP, but need to generate unwind information,; // we need to set the correct CFA offset after the stack adjustment.; // How much we adjust the CFA offset depends on whether we're emitting; // CFI only for EH purposes or for debugging. EH only requires the CFA; // offset to be correct at each call site, while for debugging we want; // it to be more precise.; // TODO: When not using precise CFA, we also need to adjust for the; // InternalAmt here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:13,Performance,perform,performing,13,"// If we are performing frame pointer elimination and if the callee pops; // something off the stack pointer, add it back. We do this until we have; // more advanced stack pointer tracking ability.; // We are not tracking the stack pointer adjustment by the callee, so make; // sure we restore the stack pointer immediately after the call, there may; // be spill code inserted between the CALL and ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:73,Performance,load,load,73,"// Rather than emit a long series of instructions for large offsets,; // load the offset into a register and do one sub/add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:9,Deployability,Update,Update,9,// FIXME Update CCR as well. For now we just; // conservatively say CCR implicit def is dead,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:22,Energy Efficiency,allocate,allocate,22,// Number of bytes to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:98,Performance,optimiz,optimized,98,// Insert stack pointer adjustment for later moving of return addr. Only; // applies to tail call optimized functions where the callee argument stack; // size is bigger than the callers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:145,Deployability,Update,Update,145,"// Get the offset of the stack slot for the FP register, which is; // guaranteed to be the last slot by processFunctionBeforeFrameFinalized.; // Update the frame offset adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:151,Energy Efficiency,allocate,allocated,151,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:117,Modifiability,variab,variable,117,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the base pointer with the current stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:69,Integrability,depend,dependence,69,// Stash value of base pointer. Saving SP instead of FP shortens; // dependence chain. Used by SjLj EH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:138,Usability,Clear,Clear,138,"// TODO Interrupt handlers; // M68k Interrupt handling function cannot assume anything about the; // direction flag (DF in CCR register). Clear this flag by creating ""cld""; // instruction in each prologue of interrupt handler function. The ""cld""; // instruction should only in these cases:; // 1. The interrupt handling function uses any of the ""rep"" instructions.; // 2. Interrupt handling function calls another function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:181,Safety,safe,safely,181,"// 'move %FramePtr, SP' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:191,Usability,undo,undone,191,"// 'move %FramePtr, SP' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:164,Safety,avoid,avoiding,164,"// Since emitPrologue and emitEpilogue will handle spilling and restoring of; // the frame register, we can delete it from CSI list and not have to worry; // about avoiding it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:3,Performance,Cache,Cached,3,// Cached subtarget predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:4,Integrability,Wrap,Wraps,4,/// Wraps up getting a CFI index and building a MachineInstr for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:446,Availability,avail,available,446,"/// This method determines which of the registers reported by; /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.; /// The default implementation checks populates the \p SavedRegs bitset with; /// all registers which are modified in the function, targets may override; /// this function to save additional registers.; /// This method also sets up the register scavenger ensuring there is a free; /// register or a frameindex available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:52,Testability,log,logic,52,"/// Allows target to override spill slot assignment logic. If implemented,; /// assignCalleeSavedSpillSlots() should assign frame slots to all CSI; /// entries and return true. If this method returns false, spill slots will; /// be assigned using generic implementation. assignCalleeSavedSpillSlots(); /// may add, delete or rearrange elements of CSI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:157,Performance,load,load,157,/// Issues instruction(s) to restore all callee saved registers and returns; /// true if it isn't possible / profitable to do so by issuing a series of; /// load instructions via loadRegToStackSlot(). Returns false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:179,Performance,load,loadRegToStackSlot,179,/// Issues instruction(s) to restore all callee saved registers and returns; /// true if it isn't possible / profitable to do so by issuing a series of; /// load instructions via loadRegToStackSlot(). Returns false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:128,Modifiability,variab,variable,128,"/// Return true if the specified function should have a dedicated frame; /// pointer register. This is true if the function has variable sized; /// allocas, if it needs dynamic stack realignment, if frame pointer; /// elimination is disabled, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:74,Usability,simpl,simplified,74,"/// If there is a reserved call frame, the call frame pseudos can be; /// simplified. Having a FP, as in the default implementation, is not; /// sufficient here since we can't always use it. Use a more nuanced; /// condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:17,Performance,perform,perform,17,"// Do we need to perform FI resolution for this function. Normally, this is; // required only when the function has any stack objects. However, FI; // resolution actually has another job, not apparent from the title - it; // resolves callframe setup/destroy that were not simplified earlier.; //; // So, this is required for M68k functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:272,Usability,simpl,simplified,272,"// Do we need to perform FI resolution for this function. Normally, this is; // required only when the function has any stack objects. However, FI; // resolution actually has another job, not apparent from the title - it; // resolves callframe setup/destroy that were not simplified earlier.; //; // So, this is required for M68k functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h:773,Integrability,wrap,wrapping,773,"//===-- M68kInstrBuilder.h - Functions to build M68k insts ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file exposes functions that may be used with BuildMI from the; /// MachineInstrBuilder.h file to handle M68k'isms in a clean way.; ///; /// TODO The BuildMem function may be used with the BuildMI function to add; /// entire memory references in a single, typed, function call. M68k memory; /// references can be very complex expressions (described in the README), so; /// wrapping them up behind an easier to use interface makes sense.; /// Descriptions of the functions are included below.; ///; /// For reference, the order of operands for memory references is:; /// (Operand), Base, Scale, Index, Displacement.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h:814,Integrability,interface,interface,814,"//===-- M68kInstrBuilder.h - Functions to build M68k insts ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file exposes functions that may be used with BuildMI from the; /// MachineInstrBuilder.h file to handle M68k'isms in a clean way.; ///; /// TODO The BuildMem function may be used with the BuildMI function to add; /// entire memory references in a single, typed, function call. M68k memory; /// references can be very complex expressions (described in the README), so; /// wrapping them up behind an easier to use interface makes sense.; /// Descriptions of the functions are included below.; ///; /// For reference, the order of operands for memory references is:; /// (Operand), Base, Scale, Index, Displacement.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h:406,Security,expose,exposes,406,"//===-- M68kInstrBuilder.h - Functions to build M68k insts ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file exposes functions that may be used with BuildMI from the; /// MachineInstrBuilder.h file to handle M68k'isms in a clean way.; ///; /// TODO The BuildMem function may be used with the BuildMI function to add; /// entire memory references in a single, typed, function call. M68k memory; /// references can be very complex expressions (described in the README), so; /// wrapping them up behind an easier to use interface makes sense.; /// Descriptions of the functions are included below.; ///; /// For reference, the order of operands for memory references is:; /// (Operand), Base, Scale, Index, Displacement.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:71,Safety,abort,abort,71,"// In practice we should never have an undef CCR operand, if we do; // abort here as we are not prepared to preserve the flag.; // ??? Is this required?; // if (iter->getOperand(1).isUndef()); // return true;; // Working from the bottom, handle the first conditional branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:291,Energy Efficiency,efficient,efficient,291,// And we are allowed to modify the block and the target block of the; // conditional branch is the direct successor of this block:; //; // bcc l1; // bra l2; // l1:; // ...; // l2:; //; // we change it to this if allowed:; //; // bncc l2; // l1:; // ...; // l2:; //; // Which is a bit more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:322,Performance,cache,cache,322,"// We need the subreg of Dst to make instruction verifier happy because the; // real machine instruction consumes and produces values of the same size and; // the registers the will be used here fall into different classes and this; // makes IV cry. We could use a bigger operation, but this will put some; // pressure on cache and memory, so no.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:318,Energy Efficiency,allocate,allocate,318,"// Create the register. The code to initialize it is inserted later,; // by the M68kGlobalBaseReg pass (below).; //; // NOTE; // Normally M68k uses A5 register as global base pointer but this will; // create unnecessary spill if we use less then 4 registers in code; since A5; // is callee-save anyway we could try to allocate caller-save first and if; // lucky get one, otherwise it does not really matter which callee-save to; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:9,Usability,Clear,Clear,9,// Carry Clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:12,Usability,Clear,Clear,12,// Overflow Clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:27,Modifiability,extend,extend,27,/// Move from register and extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:25,Modifiability,extend,extend,25,/// Move from memory and extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:92,Energy Efficiency,schedul,scheduling,92,"/// This pass converts a legalized DAG into a M68k-specific DAG,; /// ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:103,Safety,avoid,avoids,103,"// TODO: Post-processing: Convert lea(,%reg,2) to lea(%reg,%reg), which has; // a smaller encoding and avoids a scaled-index.; // And make sure it is an indexed mode; // TODO: Post-processing: Convert foo to foo(%pc), even in non-PIC mode,; // because it has a smaller encoding.; // Make sure this must be done only if PC* modes are currently being matched",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:129,Availability,down,down,129,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:26,Integrability,Wrap,Wrapper,26,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:47,Integrability,Wrap,WrapperPC,47,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:99,Integrability,wrap,wrap,99,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:8,Integrability,wrap,wrapper,8,// This wrapper requires 32bit disp/imm field for Medium CM,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:93,Usability,simpl,simply,93,"// TODO: The ordering of the following SelectXXX is relatively...arbitrary,; // right now we simply sort them by descending complexity. Maybe we should; // adjust this by code model and/or relocation mode in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:418,Integrability,interface,interfaces,418,"//===-- M68kISelLowering.cpp - M68k DAG Lowering Impl -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that M68k uses to lower LLVM code into a; /// selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:59,Integrability,depend,dependences,59,// Add/Sub overflow ops with MVT::Glues are lowered to CCR dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:60,Availability,avail,available,60,/// Return true if the given stack call argument is already available in the; /// same position (relatively) of the caller's incoming argument stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Load,Load,3,"// Load the ""old"" Return address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:39,Performance,load,load,39,// Create the nodes corresponding to a load from this parameter slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:65,Performance,load,loading,65,// Because we are dealing with BE architecture we need to offset loading of; // partial types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:267,Performance,optimiz,optimization,267,"// TODO Interrupt handlers; // Calculate SP offset of interrupt parameter, re-arrange the slot normally; // taken by a return address.; // FIXME For now, all byval parameter objects are marked mutable. This can; // be changed with more analysis. In case of tail call optimization mark all; // arguments mutable. Since they could be overwritten by lowering of arguments; // in case of a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,Safety,detect,detected,30,// Sibcalls are automatically detected tailcalls which do not require; // ABI changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:46,Availability,avail,available,46,// This is a sibcall. The memory operands are available in caller's; // own caller's stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:69,Energy Efficiency,allocate,allocated,69,"// If we have an inalloca argument, all stack space has already been allocated; // for us and be right at the top of the stack. We don't support multiple; // arguments passed in memory when using inalloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Load,Load,3,// Load return address for tail calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads. In the case; // of tail call optimization arguments are handle later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:94,Performance,optimiz,optimization,94,"// Walk the register/memloc assignments, inserting copies/loads. In the case; // of tail call optimization arguments are handle later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:359,Integrability,depend,depends,359,"// Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:48,Performance,load,loaded,48,"// Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Performance,load,load,23,// We should use extra load for direct calls to dllimported functions in; // non-JIT mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:9,Integrability,wrap,wrapper,9,// Add a wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:91,Testability,assert,assert,91,"// If this is an 8 or 16-bit value, it is really passed promoted to 32; // bits. Insert an assert[sz]ext to capture this, then truncate to the; // right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:41,Performance,load,load,41,// If value is passed via pointer - do a load.; // TODO Make sure this handling on indirect arguments is correct,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:167,Security,access,access,167,// ABI require that for returning structs by value we copy the sret argument; // into %D0 for the return. Save the argument into a virtual register so; // that we can access it from the return points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start. We; // can skip this if there are no va_start calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:39,Energy Efficiency,schedul,schedule,39,// FIXME Can we use a less constrained schedule?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Deployability,update,updated,23,// Operand #0 = Chain (updated below),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:308,Security,access,access,308,"// Swift calling convention does not require we copy the sret argument; // into %d0 for the return, and SRetReturnReg is not set for Swift.; // ABI require that for returning structs by value we copy the sret argument; // into %D0 for the return. Save the argument into a virtual register so that; // we can access it from the return points.; //; // Checking Function.hasStructRetAttr() here is insufficient because the IR; // may not have an explicit sret argument. If MFI.CanLowerReturn is; // false, then an sret argument may be implicitly inserted in the SelDAG. In; // either case MFI->setSRetReturnReg() will have been called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:208,Deployability,update,updated,208,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:744,Integrability,depend,dependency,744,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:791,Integrability,depend,dependency,791,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:888,Integrability,depend,dependency,888,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:421,Performance,optimiz,optimization,421,"//===----------------------------------------------------------------------===//; // Fast Calling Convention (tail call) implementation; //===----------------------------------------------------------------------===//; // Like std call, callee cleans arguments, convention except that ECX is; // reserved for storing the tail called function address. Only 2 registers are; // free for argument passing (inreg). Tail call optimization is performed; // provided:; // * tailcallopt is enabled; // * caller/callee are fastcc; // On M68k_64 architecture with GOT-style position independent code only; // local (within module) calls are supported at the moment. To keep the stack; // aligned according to platform abi the function GetAlignedArgumentStackSize; // ensures that argument delta is always multiples of stack alignment. (Dynamic; // linkers need this - darwin's dyld for example) If a tail called function; // callee has more arguments than the caller the caller needs to make sure that; // there is room to move the RETADDR to. This is achieved by reserving an area; // the size of the argument delta right after the original RETADDR, but before; // the saved framepointer or the spilled registers e.g. caller(arg1, arg2); // calls callee(arg1, arg2,arg3,arg4) stack layout:; // arg1; // arg2; // RETADDR; // [ new RETADDR; // move area ]; // (possible EBP); // ESI; // EDI; // local1 ..; /// Make the stack size align e.g 16n + 12 aligned for a 16-byte align; /// requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:437,Performance,perform,performed,437,"//===----------------------------------------------------------------------===//; // Fast Calling Convention (tail call) implementation; //===----------------------------------------------------------------------===//; // Like std call, callee cleans arguments, convention except that ECX is; // reserved for storing the tail called function address. Only 2 registers are; // free for argument passing (inreg). Tail call optimization is performed; // provided:; // * tailcallopt is enabled; // * caller/callee are fastcc; // On M68k_64 architecture with GOT-style position independent code only; // local (within module) calls are supported at the moment. To keep the stack; // aligned according to platform abi the function GetAlignedArgumentStackSize; // ensures that argument delta is always multiples of stack alignment. (Dynamic; // linkers need this - darwin's dyld for example) If a tail called function; // callee has more arguments than the caller the caller needs to make sure that; // there is room to move the RETADDR to. This is achieved by reserving an area; // the size of the argument delta right after the original RETADDR, but before; // the saved framepointer or the spilled registers e.g. caller(arg1, arg2); // calls callee(arg1, arg2,arg3,arg4) stack layout:; // arg1; // arg2; // RETADDR; // [ new RETADDR; // move area ]; // (possible EBP); // ESI; // EDI; // local1 ..; /// Make the stack size align e.g 16n + 12 aligned for a 16-byte align; /// requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Availability,Mask,Mask,3,"// Mask out lower bits, add stackalignment once plus the 12 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:53,Performance,optimiz,optimization,53,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:106,Performance,optimiz,optimization,106,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:34,Performance,perform,perform,34,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:52,Performance,optimiz,optimization,52,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:20,Safety,safe,safe,20,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:22,Performance,optimiz,optimization,22,// Also avoid sibcall optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:8,Safety,avoid,avoid,8,// Also avoid sibcall optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:18,Performance,optimiz,optimize,18,// Do not sibcall optimize vararg calls unless all arguments are passed via; // registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:94,Energy Efficiency,allocate,allocate,94,"// If the tailcall address may be in a register, then make sure it's; // possible to register allocate for it. The call address can; // only target %A0 or %A1 since the tail call must be scheduled after; // callee-saved registers are restored. These happen to be the same; // registers used to pass 'inreg' arguments so watch out for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:187,Energy Efficiency,schedul,scheduled,187,"// If the tailcall address may be in a register, then make sure it's; // possible to register allocate for it. The call address can; // only target %A0 or %A1 since the tail call must be scheduled after; // callee-saved registers are restored. These happen to be the same; // registers used to pass 'inreg' arguments so watch out for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:254,Safety,safe,safer,254,"// Shifts and add instructions in M68000 and M68010 support; // up to 32 bits, but mul only has 16-bit variant. So it's almost; // certainly beneficial to lower 8/16/32-bit mul to their; // add / shifts counterparts. But for 64-bits mul, it might be; // safer to just leave it to compiler runtime implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Testability,Test,Test,23,/// Create a BTST (Bit Test) node - Test bit \p BitNo in \p Src and set; /// condition according to equal/not-equal condition code \p CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:36,Testability,Test,Test,36,/// Create a BTST (Bit Test) node - Test bit \p BitNo in \p Src and set; /// condition according to equal/not-equal condition code \p CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:34,Modifiability,extend,extend,34,"// If the operand types disagree, extend the shift amount to match. Since; // BTST ignores high bits (like shifts) we can use anyextend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:51,Testability,TEST,TEST,51,// Use BTST if the immediate can't be encoded in a TEST instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:101,Performance,load,load,101,"// First determine if it is required or is profitable to flip the operands.; // If LHS is a foldable load, but RHS is not, flip the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:84,Testability,TEST,TEST,84,"// See if we can use the CCR value from the operand instead of; // doing a separate TEST. TEST always sets OF and CF to 0, so unless; // we prove that the arithmetic won't overflow, we can't use OF or CF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:90,Testability,TEST,TEST,90,"// See if we can use the CCR value from the operand instead of; // doing a separate TEST. TEST always sets OF and CF to 0, so unless; // we prove that the arithmetic won't overflow, we can't use OF or CF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:35,Testability,TEST,TEST,35,"// Emit a CMP with 0, which is the TEST pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:193,Energy Efficiency,reduce,reduced,193,// Truncate operations may prevent the merge of the SETCC instruction; // and the arithmetic instruction before it. Attempt to truncate the operands; // of the arithmetic instruction and use a reduced bit-width instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:127,Modifiability,variab,variable,127,"// NOTICE: In the code below we use ArithOp to hold the arithmetic operation; // which may be the result of a CAST. We use the variable 'Op', which is the; // non-casted variable when we check for possible users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:170,Modifiability,variab,variable,170,"// NOTICE: In the code below we use ArithOp to hold the arithmetic operation; // which may be the result of a CAST. We use the variable 'Op', which is the; // non-casted variable when we check for possible users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:25,Testability,log,logical,25,// If we have a constant logical shift that's only used in a comparison; // against zero turn it into an equivalent AND. This allows turning it into; // a TEST instruction later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:155,Testability,TEST,TEST,155,// If we have a constant logical shift that's only used in a comparison; // against zero turn it into an equivalent AND. This allows turning it into; // a TEST instruction later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid undefined shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid large immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:90,Testability,TEST,TEST,90,"// If the primary 'and' result isn't used, don't bother using; // M68kISD::AND, because a TEST instruction will be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:113,Performance,load,load-modify-store,113,"// Due to the ISEL shortcoming noted above, be conservative if this op is; // likely to be selected as part of a load-modify-store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:77,Deployability,update,update,77,"// If we found that truncation is beneficial, perform the truncation and; // update 'Op'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:46,Performance,perform,perform,46,"// If we found that truncation is beneficial, perform the truncation and; // update 'Op'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:65,Performance,optimiz,optimizations,65,// Use a target machine opcode to prevent further DAGCombine; // optimizations that may separate the arithmetic operations; // from the setcc node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:35,Testability,TEST,TEST,35,"// Emit a CMP with 0, which is the TEST pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:117,Safety,avoid,avoided,117,// Only promote the compare up to I32 if it is a 16 bit operation; // with an immediate. 16 bit immediates are to be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize to BTST if possible.; // Lower (X & (1 << N)) == 0 to BTST(X, N).; // Lower ((X >>u N) & 1) != 0 to BTST(X, N).; // Lower ((X >>s N) & 1) != 0 to BTST(X, N).; // Lower (trunc (X >> N) to i1) to BTST(X, N).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:54,Usability,simpl,simplify,54,"// Look for X == 0, X == 1, X != 0, or X != 1. We can simplify some forms of; // these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:36,Testability,log,logical,36,/// Return true if opcode is a M68k logical comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:17,Performance,optimiz,optimizations,17,"// Apply further optimizations for special cases; // (select (x != 0), -1, 0) -> neg & sbb; // (select (x == 0), 0, -1) -> neg & sbb",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:134,Safety,avoid,avoids,134,// M68k doesn't have an i8 cmov. If both operands are the result of a; // truncate widen the cmov and push the truncate through. This avoids; // introducing a new branch during isel and doesn't add any extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:52,Safety,avoid,avoided,52,// Block CopyFromReg so partial register stalls are avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,Performance,optimiz,optimization,10,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:50,Safety,avoid,avoid,50,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:144,Testability,test,test,144,"// Also, recognize the pattern generated by an FCMP_UNE. We can emit; // two branches instead of an explicit OR instruction with a; // separate test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:158,Testability,test,test,158,"// ISD::AND; // Also, recognize the pattern generated by an FCMP_OEQ. We can emit; // two branches instead of an explicit AND instruction with a; // separate test. However, we only do this if this block doesn't; // have a fall-through edge, because this requires an explicit; // jmp when the condition is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:104,Integrability,wrap,wrapped,104,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:128,Integrability,Wrap,Wrapper,128,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:206,Integrability,wrap,wrapped,206,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:352,Integrability,wrap,wrapped,352,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,Performance,load,load,30,"// For symbols that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:80,Performance,load,load,80,"// For symbols that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:42,Testability,stub,stub,42,"// For symbols that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,Performance,load,load,30,"// For globals that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:80,Performance,load,load,80,"// For globals that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:42,Testability,stub,stub,42,"// For globals that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:27,Deployability,update,update,27,// Should have kill-flag - update below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:789,Performance,perform,perform,789,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:922,Usability,simpl,simple,922,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:1035,Usability,clear,clearly,1035,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:139,Energy Efficiency,reduce,reduces,139,"// Check for case 1, where there are multiple CMOVs with the same condition; // first. Of the two cases of multiple CMOV lowerings, case 1 reduces the; // number of jumps the most.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Modifiability,rewrite,rewrite,23,// Add this PHI to the rewrite table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:303,Energy Efficiency,allocate,allocated,303,// Lower dynamic stack allocation to _alloca call for Cygwin/Mingw targets.; // Calls to _alloca are needed to probe the stack when allocating more than 4k; // bytes in one go. Touching the stack at 4K increments is necessary to ensure; // that the guard pages used by the OS virtual memory manager are allocated in; // correct sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a CCR definition used according to the condition code \p CC into; /// a simpler CCR value, potentially returning a new \p CC and replacing uses; /// of chain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:85,Usability,simpl,simpler,85,"/// Optimize a CCR definition used according to the condition code \p CC into; /// a simpler CCR value, potentially returning a new \p CC and replacing uses; /// of chain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize RES = M68kISD::SETCC CONDCODE, CCR_INPUT",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,Usability,simpl,simplify,10,// Try to simplify the CCR and condition code operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,Usability,simpl,simplify,10,"// Try to simplify the CCR and condition code operands.; // Make sure to not keep references to operands, as combineSetCCCCR can; // RAUW them under us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize RES, CCR = M68kISD::ADDX LHS, RHS, CCR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:47,Integrability,Interface,Interface,47,"//===-- M68kISelLowering.h - M68k DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that M68k uses to lower LLVM code into a; /// selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:418,Integrability,interface,interfaces,418,"//===-- M68kISelLowering.h - M68k DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that M68k uses to lower LLVM code into a; /// selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:21,Testability,log,logical,21,/// M68k compare and logical compare instructions. Subtracts the source; /// operand from the destination data register and sets the condition; /// codes according to the result. Immediate always goes first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:13,Testability,test,test,13,/// M68k bit-test instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:212,Testability,TEST,TEST,212,"// R = carry_bit ? ~0 : 0; /// M68k conditional moves. Operand 0 and operand 1 are the two values; /// to select from. Operand 2 is the condition code, and operand 3 is the; /// flag operand produced by a CMP or TEST instruction. It also writes a; /// flag result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:221,Testability,TEST,TEST,221,"/// M68k conditional branches. Operand 0 is the chain operand, operand 1; /// is the block to branch if condition is true, operand 2 is the; /// condition code, and operand 3 is the flag operand produced by a CMP; /// or TEST instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:6,Integrability,wrap,wrapper,6,"/// A wrapper node for TargetConstantPool,; /// TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:12,Integrability,wrap,wrapper,12,/// Special wrapper used under M68k PIC mode for PC; /// relative displacements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:18,Modifiability,variab,variable,18,"// For allocating variable amounts of stack space when using; // segmented stacks. Check if the current stacklet has enough space, and; // falls back to heap allocation if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:11,Performance,load,load,11,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:52,Performance,optimiz,optimization,52,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:68,Performance,perform,performed,68,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:57,Performance,optimiz,optimization,57,/// Emit a store of the return address if tail call; /// optimization is performed and it is required (FPDiff!=0).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:73,Performance,perform,performed,73,/// Emit a store of the return address if tail call; /// optimization is performed and it is required (FPDiff!=0).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:97,Performance,load,load,97,/// LowerFormalArguments - transform physical registers into virtual; /// registers and generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:41,Testability,test,test,41,"/// Emit nodes that will be selected as ""test Op0,Op0"", or something; /// equivalent, for use with the given M68k condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:53,Performance,optimiz,optimization,53,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:106,Performance,optimiz,optimization,106,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h:100,Performance,optimiz,optimization,100,/// The number of bytes by which return address stack slot is moved as the; /// result of tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp:26,Energy Efficiency,efficient,efficient,26,"// FIXME We would like an efficient form for this, so we don't have to do a; // lot of extra uniquing. This fixme is originally from X86",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.cpp:171,Modifiability,variab,variables,171,"// When we need stack realignment, we can't address the stack from the frame; // pointer. When we have dynamic allocas or stack-adjusting inline asm, we; // can't address variables from the stack pointer. MS inline asm can; // reference locals while also adjusting the stack pointer. When we can't; // use both the SP and the FP, we need a separate base pointer register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.h:129,Modifiability,variab,variable,129,"/// Physical register used as a base ptr in complex stack frames. I.e., when; /// we need a 3rd base, not just SP and FP, due to variable size stack; /// objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:78,Performance,load,loads,78,"// If the function is marked as non-lazy, generate an indirect call; // which loads from the GOT directly. This avoids run-time overhead; // at the cost of eager binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:112,Safety,avoid,avoids,112,"// If the function is marked as non-lazy, generate an indirect call; // which loads from the GOT directly. This avoids run-time overhead; // at the cost of eager binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h:22,Modifiability,variab,variable,22,/// Classify a global variable reference for the current subtarget according; /// to how we should reference it in a non-pcrel context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h:22,Modifiability,variab,variable,22,/// Classify a global variable reference for the current subtarget according; /// to how we should reference it in a non-pcrel context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h:24,Modifiability,variab,variable,24,/// Classify a external variable reference for the current subtarget according; /// to how we should reference it in a non-pcrel context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:164,Performance,perform,performance,164,"// M68k pointers are always 32 bit wide even for 16-bit CPUs.; // The ABI only specifies 16-bit alignment.; // On at least the 68020+ with a 32-bit bus, there is a performance benefit; // to having 32-bit alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:90,Deployability,Pipeline,Pipeline,90,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:99,Deployability,Configurat,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:99,Modifiability,Config,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:109,Availability,mask,mask,109,"// These variables are used for the following forms:; // Addr: (OuterDisp); // RegMask: RegMask (as register mask); // Reg: %OuterReg; // RegIndirect: (%OuterReg); // RegPostIncrement: (%OuterReg)+; // RegPreDecrement: -(%OuterReg); // RegIndirectDisplacement: OuterDisp(%OuterReg); // RegIndirectDisplacementIndex:; // OuterDisp(%OuterReg, %InnerReg.Size * Scale, InnerDisp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:9,Modifiability,variab,variables,9,"// These variables are used for the following forms:; // Addr: (OuterDisp); // RegMask: RegMask (as register mask); // Reg: %OuterReg; // RegIndirect: (%OuterReg); // RegPostIncrement: (%OuterReg)+; // RegPreDecrement: -(%OuterReg); // RegIndirectDisplacement: OuterDisp(%OuterReg); // RegIndirectDisplacementIndex:; // OuterDisp(%OuterReg, %InnerReg.Size * Scale, InnerDisp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:80,Availability,mask,masks,80,// Only regular address / data registers are allowed to be used; // in register masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:9,Usability,simpl,simple,9,// Parse simple general-purpose registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:42,Availability,mask,mask,42,// Check for a plain register or register mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:46,Usability,simpl,simplify,46,"// First register range is a single register, simplify to just Reg; // so that it matches more operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:83,Availability,mask,mask,83,// This is the second register being specified - expand the Reg operand; // into a mask first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:169,Usability,simpl,simple,169,/// Returns the minimum size of a nop in bytes on this target. The assembler; /// will use this to emit excess padding in situations where the padding; /// required for simple alignment would be less than the minimum nop size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:118,Availability,failure,failure,118,"/// Write a sequence of optimal nops to the output, covering \p Count bytes.; /// \return - true on success, false on failure",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:41,Usability,clear,clear,41,// end anonymous namespace; /// ccCarry clear GEGreater than or equal; /// LSLower or same PLPlus; /// CSCarry set GTGreater than; /// LTLess than; /// EQEqual HIHigher; /// MIMinus VCOverflow clear; /// LELess than or equal; /// NENot equal VSOverflow set,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:204,Usability,clear,clear,204,// end anonymous namespace; /// ccCarry clear GEGreater than or equal; /// LSLower or same PLPlus; /// CSCarry set GTGreater than; /// LTLess than; /// EQEqual HIHigher; /// MIMinus VCOverflow clear; /// LELess than or equal; /// NENot equal VSOverflow set,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:153,Modifiability,variab,variable,153,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Global Dynamic mode.; /// name@TLSGD",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:130,Security,access,accessing,130,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Global Dynamic mode.; /// name@TLSGD",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:81,Modifiability,variab,variable,81,"/// On a symbol operand, this indicates that the immediate is the offset to; /// variable within the thread local storage when operating in Local Dynamic; /// mode.; /// name@TLSLD",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:153,Modifiability,variab,variable,153,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Local Dynamic mode.; /// name@TLSLDM",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:130,Security,access,accessing,130,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Local Dynamic mode.; /// name@TLSLDM",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:85,Modifiability,variab,variable,85,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the variable within the thread local storage when operating in Initial; /// Exec mode.; /// name@TLSIE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:85,Modifiability,variab,variable,85,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the variable within in the thread local storage when operating in Local; /// Exec mode.; /// name@TLSLE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:85,Testability,stub,stub,85,"// enum TOF; /// Return true if the specified TargetFlag operand is a reference to a stub; /// for a global, not the global itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:1074,Deployability,integrat,integrated,1074,"//===-- M68kInstPrinter.cpp - Convert M68k MCInst to asm --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains definitions for an M68k MCInst printer.; ///; //===----------------------------------------------------------------------===//; // TODO Conform with all supported Motorola ASM syntax; // Motorola's assembly has several syntax variants, especially on; // addressing modes.; // For example, you can write pc indirect w/ displacement as; // `x(%pc)`, where `x` is the displacement imm, or `(x,%pc)`.; // Currently we're picking the variant that is different from; // GCC, albeit being recognizable by GNU AS.; // Not sure what is the impact now (e.g. some syntax might; // not be recognized by some old consoles' toolchains, in which; // case we can not use our integrated assembler), but either way,; // it will be great to support all of the variants in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:1074,Integrability,integrat,integrated,1074,"//===-- M68kInstPrinter.cpp - Convert M68k MCInst to asm --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains definitions for an M68k MCInst printer.; ///; //===----------------------------------------------------------------------===//; // TODO Conform with all supported Motorola ASM syntax; // Motorola's assembly has several syntax variants, especially on; // addressing modes.; // For example, you can write pc indirect w/ displacement as; // `x(%pc)`, where `x` is the displacement imm, or `(x,%pc)`.; // Currently we're picking the variant that is different from; // GCC, albeit being recognizable by GNU AS.; // Not sure what is the impact now (e.g. some syntax might; // not be recognized by some old consoles' toolchains, in which; // case we can not use our integrated assembler), but either way,; // it will be great to support all of the variants in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:10,Availability,mask,mask,10,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:258,Availability,mask,mask,258,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:199,Deployability,continuous,continuous,199,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:516,Usability,intuit,intuitive,516,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:533,Usability,simpl,simply,533,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:27,Availability,avail,available,27,"// NOTE forcing (W,L) size available since M68020 only",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h:19,Availability,mask,mask,19,"/// Print register mask for MOVEM instruction in order D0-D7,A0-A7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h:19,Availability,mask,mask,19,"/// Print register mask for MOVEM instruction in order A7-A0,D7-D0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp:10,Deployability,patch,patch,10,"// If the patch point is at the first word, PC is pointing at the; // next word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp:38,Testability,log,logics,38,// TODO Implement feature set parsing logics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp:71,Testability,test,tests,71,// Initial state of the frame pointer is SP+StackGrowth.; // TODO: Add tests for `cfi_*` directives,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMemOperandPrinter.h:439,Testability,log,logics,439,"//===-- M68kMemOperandPrinter.h - Memory operands printing ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains memory operand printing logics shared between AsmPrinter; // and MCInstPrinter.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMemOperandPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMemOperandPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:409,Energy Efficiency,reduce,reduce,409,"//=== MicroMipsSizeReduction.cpp - MicroMips size reduction pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///\file; /// This pass is used to reduce the size of instructions where applicable.; ///; /// TODO: Implement microMIPS64 support.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:52,Modifiability,extend,extended,52,/// Order of operands to transfer; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:77,Performance,optimiz,optimizations,77,/// Order of operands to transfer; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:37,Modifiability,extend,extended,37,/// Reduction type; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:62,Performance,optimiz,optimizations,62,/// Reduction type; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:5,Energy Efficiency,Reduce,Reduce,5,///< Reduce two instructions into one instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:5,Energy Efficiency,Reduce,Reduce,5,///< Reduce one instruction into a smaller instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:49,Modifiability,extend,extended,49,/// Information about operands; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:74,Performance,optimiz,optimizations,74,/// Information about operands; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceTable,4,/// ReduceTable - A static table with information on mapping from wide; /// opcodes to narrow,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:16,Energy Efficiency,reduce,reduce,16,///< Pointer to reduce function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:26,Energy Efficiency,Reduce,ReduceFunction,26,// Function arguments for ReduceFunction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:4,Energy Efficiency,Reduce,Reduces,4,/// Reduces width of instructions in the specified basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:16,Energy Efficiency,reduce,reduce,16,"/// Attempts to reduce MI, returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce LW/SW instruction into LWSP/SWSP,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce two LW/SW instructions into LWP/SWP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce LBU/LHU instruction into LBU16/LHU16,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce SB/SH instruction into SB16/SH16,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce two MOVE instructions into MOVEP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce arithmetic instructions, returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce ADDIU into ADDIUSP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce ADDIU into ADDIUR1SP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce XOR into XOR16 instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:137,Integrability,depend,depending,137,"// Changes opcode of an instruction, replaces an instruction with a; // new one, or replaces two instructions with a new instruction; // depending on their order i.e. if these are consecutive forward; // or consecutive backward",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:68,Energy Efficiency,Reduce,ReduceType,68,// This table must be sorted by WideOpc as a main criterion and; // ReduceType as a sub-criterion (when wide opcodes are the same).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:3,Energy Efficiency,Reduce,ReduceType,3,"// ReduceType, OpCodes, ReduceFunction,; // OpInfo(TransferOperands),; // ImmField(Shift, LBound, HBound, ImmFieldPosition)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:24,Energy Efficiency,Reduce,ReduceFunction,24,"// ReduceType, OpCodes, ReduceFunction,; // OpInfo(TransferOperands),; // ImmField(Shift, LBound, HBound, ImmFieldPosition)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:96,Modifiability,variab,variable,96,// Returns true if the operand Op is an immediate value; // and writes the immediate value into variable Imm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:23,Modifiability,variab,variable,23,// Returns true if the variable Value has the number of least-significant zero; // bits equal to Shift and if the shifted value is between the bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:29,Energy Efficiency,reduce,reduced,29,// Returns true if MI can be reduced to lwp/swp instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:3,Energy Efficiency,Reduce,ReduceToLwp,3,// ReduceToLwp = true/false - reduce to LWP/SWP instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:30,Energy Efficiency,reduce,reduce,30,// ReduceToLwp = true/false - reduce to LWP/SWP instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:9,Energy Efficiency,reduce,reduce,9,// Don't reduce bundled instructions or pseudo operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:10,Energy Efficiency,reduce,reduce,10,// Try to reduce 32-bit instruction into 16-bit instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips.h:27,Integrability,interface,interface,27,"//===-- Mips.h - Top-level interface for Mips representation ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM Mips back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate space on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp:114,Modifiability,variab,variable,114,// Reserve call frame if the size of the maximum call frame fits into 15-bit; // immediate field and there are no variable sized objects on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:91,Modifiability,variab,variables,91,// Figure out if we need float point based on the function parameters.; // We need to move variables in and/or out of floating point; // registers because of the ABI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:44,Testability,stub,stub,44,// Make sure that we know we already need a stub for this function.; // Having called needsFPHelperFromSig,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:34,Testability,stub,stub,34,//; // see if we already have the stub; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:153,Testability,stub,stubs,153,"// This pass only makes sense when the underlying chip has floating point but; // we are compiling as mips16.; // For all mips16 functions (that are not stubs we have already generated), or; // declared via attributes as nomips16, we must:; // 1) fixup all returns of float, double, single and double complex; // by calling a helper function before the actual return.; // 2) generate helper functions (stubs) that can be called by mips32; // functions that will move parameters passed normally passed in; // floating point; // registers the soft float equivalents.; // 3) in the case of static relocation, generate helper functions so that; // mips16 functions can call extern functions of unknown type (mips16 or; // mips32).; // 4) TBD. For pic, calls to extern functions of unknown type are handled by; // predefined helper functions in libc but this work is currently done; // during call lowering but it should be moved here in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:402,Testability,stub,stubs,402,"// This pass only makes sense when the underlying chip has floating point but; // we are compiling as mips16.; // For all mips16 functions (that are not stubs we have already generated), or; // declared via attributes as nomips16, we must:; // 1) fixup all returns of float, double, single and double complex; // by calling a helper function before the actual return.; // 2) generate helper functions (stubs) that can be called by mips32; // functions that will move parameters passed normally passed in; // floating point; // registers the soft float equivalents.; // 3) in the case of static relocation, generate helper functions so that; // mips16 functions can call extern functions of unknown type (mips16 or; // mips32).; // 4) TBD. For pic, calls to extern functions of unknown type are handled by; // predefined helper functions in libc but this work is currently done; // during call lowering but it should be moved here in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:184,Safety,safe,safe,184,// Adjust SP by Amount bytes where bytes can be up to 32bit number.; // This can only be called at times that we know that there is at least one free; // register.; // This is clearly safe at prologue and epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:176,Usability,clear,clearly,176,// Adjust SP by Amount bytes where bytes can be up to 32bit number.; // This can only be called at times that we know that there is at least one free; // register.; // This is clearly safe at prologue and epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:37,Performance,load,load,37,/// Emit a series of instructions to load an immediate.; // This is to adjust some FrameReg. We return the new register to be used; // in place of FrameReg and the adjusted immediate field (&NewImm),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp:15,Performance,Load,Load,15,// on PIC code Load GA,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp:8,Performance,load,loading,8,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp:37,Performance,load,load,37,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:51,Integrability,Interface,Interface,51,"//===-- Mips16ISelLowering.h - Mips16 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips16.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:16,Performance,optimiz,optimization,16,// No tail call optimization for mips16.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:46,Modifiability,inherit,inherited,46,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:556,Modifiability,inherit,inherited,556,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1008,Performance,load,load,1008,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1397,Testability,stub,stub,1397,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1527,Testability,assert,assert,1527,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:45,Integrability,depend,depending,45,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:271,Integrability,depend,dependent,271,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:32,Testability,stub,stub,32,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:290,Testability,stub,stub,290,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:631,Deployability,patch,patch,631,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:426,Performance,optimiz,optimize,426,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:586,Performance,optimiz,optimization,586,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:35,Testability,stub,stub,35,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:187,Testability,stub,stub,187,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:229,Testability,stub,stub,229,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:269,Testability,stub,stub,269,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:451,Testability,stub,stub,451,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.h:51,Integrability,Interface,Interface,51,"//===-- Mips16ISelLowering.h - Mips16 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips16.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:137,Energy Efficiency,allocate,allocated,137,// The following stack frame objects are always; // referenced relative to $sp:; // 1. Outgoing arguments.; // 2. Pointer to dynamically allocated stack space.; // 3. Locations for callee-saved registers.; // Everything else is referenced relative to whatever register; // getFrameRegister() returns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:171,Energy Efficiency,allocate,allocated,171,"// Calculate final offset.; // - There is no need to change the offset if the frame object; // is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following,; // its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:407,Modifiability,variab,variable,407,"// Calculate final offset.; // - There is no need to change the offset if the frame object; // is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following,; // its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:32,Usability,clear,cleared,32,// Shift if the lower 16-bit is cleared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:16,Usability,clear,cleared,16,"// If bit 15 is cleared, it doesn't make a difference whether the last; // instruction is an ADDiu or ORi. In that case, do not call GetInstSeqLsORi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:8,Modifiability,extend,extend,8,// Sign-extend and shift operand of ADDiu and see if it still fits in 16-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:45,Performance,load,load,45,/// Analyze - Get an instruction sequence to load immediate Imm. The last; /// instruction in the sequence must be an ADDiu if LastInstrIsADDiu is; /// true;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:82,Performance,load,load,82,/// GetInstSeqLsADDiu - Get instruction sequences which end with an ADDiu to; /// load immediate Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:78,Performance,load,load,78,/// GetInstSeqLsORi - Get instrutcion sequences which end with an ORi to; /// load immediate Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:77,Performance,load,load,77,/// GetInstSeqLsSLL - Get instruction sequences which end with a SLL to; /// load immediate Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:48,Performance,load,load,48,/// GetInstSeqLs - Get instruction sequences to load immediate Imm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===- MipsAsmPrinter.cpp - Mips LLVM Assembly Printer --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format MIPS assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:128,Performance,optimiz,optimization,128,"// If there is an MO_JALR operand, insert:; //; // .reloc tmplabel, R_{MICRO}MIPS_JALR, symbol; // tmplabel:; //; // This is an optimization hint for the linker which may then replace; // an indirect call with a direct branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:55,Testability,test,test,55,"// FIXME: Enable feature predicate checks once all the test pass.; // Mips_MC::verifyInstructionPredicates(MI->getOpcode(),; // getSubtargetInfo().getFeatureBits());",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:265,Availability,down,downstream,265,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:22,Testability,test,test,22,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:123,Testability,test,test,123,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:241,Testability,test,test,241,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:221,Availability,Mask,Mask,221,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:241,Availability,mask,mask,241,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:455,Availability,mask,mask,455,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:751,Availability,mask,mask,751,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:860,Availability,mask,mask,860,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:1111,Availability,mask,mask,1111,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:1331,Availability,Mask,Mask,1331,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:64,Availability,mask,masked,64,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:8,Modifiability,sandbox,sandboxing,8,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:8,Testability,sandbox,sandboxing,8,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:131,Testability,log,logic,131,"// There are instruction for this macros, but they must; // always be at the function end, and we can't emit and; // break with BB logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:3,Performance,Load,Load,3,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction has reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:75,Performance,load,loaded,75,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction has reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:38,Performance,load,load,38,// when using stack locations for not load/store instructions; // print the same way as all normal 3 operand instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:97,Testability,test,test,97,"// FIXME: This condition should be a lot more complicated that it is here.; // Ideally it should test for properties of the ABI and not the ABI; // itself.; // For the moment, I'm only correcting enough to make MIPS-IV work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:259,Integrability,depend,depends,259,"// GCC's choice of assembler options for inline assembly code ('at', 'macro'; // and 'reorder') is different from LLVM's choice for generated code ('noat',; // 'nomacro' and 'noreorder').; // In order to maintain compatibility with inline assembly code which depends; // on GCC's assembler options being used, we have to switch to those options; // for the duration of the inline assembly block and then switch back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:99,Testability,stub,stub,99,//; // make the comment field identifying the return and parameter; // types of the floating point stub; // # Stub function to call rettype xxxx (params); //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:110,Testability,Stub,Stub,110,//; // make the comment field identifying the return and parameter; // types of the floating point stub; // # Stub function to call rettype xxxx (params); //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:120,Deployability,patch,patch,120,"//; // We need to add a MipsMCExpr class to MCTargetDesc to fully implement; // stubs without raw text but this current patch is for compiler generated; // functions and they all return some value.; // The calling sequence for non pic is different in that case and we need; // to implement %lo and %hi in order to handle the case of no return value; // See the corresponding method in Mips16HardFloat for details.; //; // mov the return address to S2.; // we have no stack space to store it and we are about to make another call.; // We need to make sure that the enclosing function knows to save S2; // This should have already been handled.; //; // Mov $18, $31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:80,Testability,stub,stubs,80,"//; // We need to add a MipsMCExpr class to MCTargetDesc to fully implement; // stubs without raw text but this current patch is for compiler generated; // functions and they all return some value.; // The calling sequence for non pic is different in that case and we need; // to implement %lo and %hi in order to handle the case of no return value; // See the corresponding method in Mips16HardFloat for details.; //; // mov the return address to S2.; // we have no stack space to store it and we are about to make another call.; // We need to make sure that the enclosing function knows to save S2; // This should have already been handled.; //; // Mov $18, $31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:99,Testability,stub,stubs,99,"//; // do the return; // if (Signature->RetSig == NoFPRet); // llvm_unreachable(""should not be any stubs here with no return value"");; // else",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:15,Testability,stub,stubs,15,// Emit needed stubs; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:243,Deployability,patch,patching,243,"// For mips32 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 11 NOP instructions (44 bytes); // ADDIU T9, T9, 52; // .tmpN; //; // We need the 44 bytes (11 instructions) because at runtime, we'd; // be patching over the full 48 bytes (12 instructions) with the following; // pattern:; //; // ADDIU SP, SP, -8; // NOP; // SW RA, 4(SP); // SW T9, 0(SP); // LUI T9, %hi(__xray_FunctionEntry/Exit); // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ORI T0, T0, %lo(function_id); // LW T9, 0(SP); // LW RA, 4(SP); // ADDIU SP, SP, 8; //; // We add 52 bytes to t9 because we want to adjust the function pointer to; // the actual start of function i.e. the address just after the noop sled.; // We do this because gp displacement relocation is emitted at the start of; // of the function i.e after the nop sled and to correctly calculate the; // global offset table address, t9 must hold the address of the instruction; // containing the gp displacement relocation.; // FIXME: Is this correct for the static relocation model?; //; // For mips64 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 15 NOP instructions (60 bytes); // .tmpN; //; // We need the 60 bytes (15 instructions) because at runtime, we'd; // be patching over the full 64 bytes (16 instructions) with the following; // pattern:; //; // DADDIU SP, SP, -16; // NOP; // SD RA, 8(SP); // SD T9, 0(SP); // LUI T9, %highest(__xray_FunctionEntry/Exit); // ORI T9, T9, %higher(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %hi(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ADDIU T0, T0, %lo(function_id); // LD T9, 0(SP); // LD RA, 8(SP); // DADDIU SP, SP, 16; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:1328,Deployability,patch,patching,1328,"// For mips32 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 11 NOP instructions (44 bytes); // ADDIU T9, T9, 52; // .tmpN; //; // We need the 44 bytes (11 instructions) because at runtime, we'd; // be patching over the full 48 bytes (12 instructions) with the following; // pattern:; //; // ADDIU SP, SP, -8; // NOP; // SW RA, 4(SP); // SW T9, 0(SP); // LUI T9, %hi(__xray_FunctionEntry/Exit); // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ORI T0, T0, %lo(function_id); // LW T9, 0(SP); // LW RA, 4(SP); // ADDIU SP, SP, 8; //; // We add 52 bytes to t9 because we want to adjust the function pointer to; // the actual start of function i.e. the address just after the noop sled.; // We do this because gp displacement relocation is emitted at the start of; // of the function i.e after the nop sled and to correctly calculate the; // global offset table address, t9 must hold the address of the instruction; // containing the gp displacement relocation.; // FIXME: Is this correct for the static relocation model?; //; // For mips64 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 15 NOP instructions (60 bytes); // .tmpN; //; // We need the 60 bytes (15 instructions) because at runtime, we'd; // be patching over the full 64 bytes (16 instructions) with the following; // pattern:; //; // DADDIU SP, SP, -16; // NOP; // SD RA, 8(SP); // SD T9, 0(SP); // LUI T9, %highest(__xray_FunctionEntry/Exit); // ORI T9, T9, %higher(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %hi(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ADDIU T0, T0, %lo(function_id); // LD T9, 0(SP); // LD RA, 8(SP); // DADDIU SP, SP, 16; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3038,Deployability,pipeline,pipeline,3038,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3246,Deployability,pipeline,pipeline,3246,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2979,Modifiability,extend,extended,2979,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1955,Performance,load,load,1955," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:601,Safety,hazard,hazards,601,"//===----------------------- MipsBranchExpansion.cpp ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:929,Safety,hazard,hazard,929,"//===----------------------- MipsBranchExpansion.cpp ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1213,Safety,hazard,hazard,1213,"ns.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1402,Safety,hazard,hazard,1402,"; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Rese",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1845,Safety,hazard,hazard,1845," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1874,Safety,Hazard,Hazards,1874," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2010,Safety,hazard,hazard,2010,"d, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor er",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2613,Safety,hazard,hazards,2613,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2812,Safety,hazard,hazards,2812,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2892,Safety,hazard,hazards,2892,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3047,Safety,hazard,hazards,3047,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3078,Safety,hazard,hazards,3078,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3255,Safety,hazard,hazards,3255,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3286,Safety,hazard,hazard,3286,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3313,Safety,hazard,hazard,3313,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2209,Usability,PAUSE,PAUSE,2209,"d, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor er",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:31,Deployability,pipeline,pipeline,31,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:40,Safety,hazard,hazards,40,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:24,Usability,clear,clears,24,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:166,Integrability,wrap,wrapping,166,// We must select between the MIPS32r6/MIPS64r6 BALC (which is a normal; // instruction) and the pre-MIPS32r6/MIPS64r6 definition (which is an; // pseudo-instruction wrapping BGEZAL).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:241,Performance,load,load,241,"// At this point, offset where we need to branch does not fit into; // immediate field of the branch instruction and is not in the same; // segment as jump instruction. Therefore we will break it into couple; // instructions, where we first load the offset into register, and then we; // do branch register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:14,Safety,hazard,hazard,14,// Delay slot hazard handling. Use lookahead over state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:18,Safety,hazard,hazards,18,// Forbidden slot hazards are only defined for MIPSR6 but not microMIPSR6.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3,Performance,Load,Load,3,// Load delay slot hazards are only for MIPS1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:19,Safety,hazard,hazards,19,// Load delay slot hazards are only for MIPS1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:43,Modifiability,sandbox,sandboxing,43,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:182,Modifiability,sandbox,sandboxing,182,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:43,Testability,sandbox,sandboxing,43,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:182,Testability,sandbox,sandboxing,182,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp:229,Integrability,depend,dependent,229,/// Handle cases when f64 is split into 2 32-bit GPRs. This is a custom; /// assignment because generic code assumes getNumRegistersForCallingConv is; /// accurate. In this case it is not because the type/number are context; /// dependent on other arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp:77,Integrability,depend,depends,77,"// FIXME: Should use MipsCCState::getSpecialCallingConvForCallee, but it; // depends on looking directly at the call target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp:82,Integrability,rout,routine,82,"// If the Ty is i128 and the function being called is a long double emulation; // routine, then the original type is f128.; // FIXME: This is unsound because these functions could be indirectly called",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:69,Integrability,rout,routine,69,/// This function returns true if CallSym is a long double emulation routine.; ///; /// FIXME: Changing the ABI based on the callee name is unsound. The lib func; /// address could be captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:96,Security,access,accessing,96,// The AnalyzeCallOperands in the base class is not usable since we must; // provide a means of accessing ArgListEntry::IsFixed. Delete them from this; // class. This doesn't stop them being used via the base class though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:52,Usability,usab,usable,52,// The AnalyzeCallOperands in the base class is not usable since we must; // provide a means of accessing ArgListEntry::IsFixed. Delete them from this; // class. This doesn't stop them being used via the base class though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:53,Performance,load,loads,53,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:421,Performance,load,loads,421,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:489,Performance,Load,Loading,489,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:630,Performance,load,loaded,630,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:662,Performance,load,load,662,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:648,Usability,simpl,simple,648,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:72,Testability,test,testing,72,// FIXME: This option should be removed once it has received sufficient testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:29,Testability,test,tests,29,"// Rather than do make check tests with huge amounts of code, we force; // the test to use this amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:79,Testability,test,test,79,"// Rather than do make check tests with huge amounts of code, we force; // the test to use this amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:54,Performance,load,load,54,// For testing purposes we tell it to not use relaxed load forms so that it; // will split blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:7,Testability,test,testing,7,// For testing purposes we tell it to not use relaxed load forms so that it; // will split blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:258,Integrability,rout,routine,258,// FIXME: need to go through this whole constant islands port and check; // the math for branch ranges and clean this up and make some functions; // to calculate things that are done many times identically.; // Need to refactor some of the code to call this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:219,Modifiability,refactor,refactor,219,// FIXME: need to go through this whole constant islands port and check; // the math for branch ranges and clean this up and make some functions; // to calculate things that are done many times identically.; // Need to refactor some of the code to call this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:742,Usability,resume,resume,742,"/// CPUser - One user of a constant pool, keeping the machine instruction; /// pointer, the constant pool being referenced, and the max displacement; /// allowed from the instruction to the CP. The HighWaterMark records the; /// highest basic block where a new CPEntry can be placed. To ensure this; /// pass terminates, the CP entries are initially placed at the end of the; /// function and then move monotonically to lower addresses. The; /// exception to this rule is when the current CP entry for a particular; /// CPUser is out of range, but there is another CP entry for the same; /// constant value in range. We want to use the existing in-range CP; /// entry, but if it later moves out of range, the search for new water; /// should resume where it left off. The HighWaterMark is used to record; /// that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Performance,Perform,Perform,3,"// Perform the initial placement of the constant pool entries. To start with,; // we put them all at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Usability,Clear,Clear,3,"// Clear NewWaterList now. If we split a block for branches, it should; // appear as ""new water"" for the next iteration of constant pool placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:25,Performance,Perform,Perform,25,"/// doInitialPlacement - Perform the initial placement of the constant pool; /// entries. To start with, we put them all at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:99,Deployability,update,updates,99,/// computeBlockSize - Compute the size and some alignment information for MBB.; /// This function updates BBInfo directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:4,Deployability,update,updateForInsertedWaterBlock,4,"/// updateForInsertedWaterBlock - When a block is newly inserted into the; /// machine function, it upsets all of the block numbers. Renumber the blocks; /// and update the arrays that parallel this numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:162,Deployability,update,update,162,"/// updateForInsertedWaterBlock - When a block is newly inserted into the; /// machine function, it upsets all of the block numbers. Renumber the blocks; /// and update the arrays that parallel this numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:77,Availability,avail,available,77,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:9,Deployability,update,update,9,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:107,Deployability,Update,Update,107,"/// Split the basic block containing MI into two blocks, which are joined by; /// an unconditional branch. Update data structures and renumber blocks to; /// account for this change and returns the newly created block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:164,Availability,avail,available,164,// Add an unconditional branch from OrigBB to NewBB.; // Note the new unconditional branch is not being recorded.; // There doesn't seem to be meaningful DebugInfo available; this doesn't; // correspond to anything in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Deployability,Update,Update,3,// Update the CFG. All succs of OrigBB are now succs of NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Deployability,Update,Update,3,"// Update internal data structures to account for the newly inserted MBB.; // This is almost the same as updateForInsertedWaterBlock, except that; // the Water goes after OrigBB, not NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:105,Deployability,update,updateForInsertedWaterBlock,105,"// Update internal data structures to account for the newly inserted MBB.; // This is almost the same as updateForInsertedWaterBlock, except that; // the Water goes after OrigBB, not NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:78,Availability,avail,available,78,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:9,Deployability,update,update,9,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:146,Deployability,update,updated,146,"// If the original WaterList entry was ""new water"" on this iteration,; // propagate that to the new island. This is just keeping NewWaterList; // updated to match the WaterList, which will be updated below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:192,Deployability,update,updated,192,"// If the original WaterList entry was ""new water"" on this iteration,; // propagate that to the new island. This is just keeping NewWaterList; // updated to match the WaterList, which will be updated below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:28,Deployability,Update,Update,28,// We are adding new water. Update NewWaterList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:156,Energy Efficiency,reduce,reduces,156,// Remove the original WaterList entry; we want subsequent insertions in; // this vicinity to go after the one we're about to insert. This; // considerably reduces the number of times we have to move the same CPE; // more than once and is also important to ensure the algorithm terminates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Deployability,Update,Update,3,// Update internal data structures to account for the newly inserted MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:69,Deployability,Update,Update,69,/// removeDeadCPEMI - Remove a dead constant pool entry instruction. Update; /// sizes and offsets of impacted basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:245,Deployability,update,updated,245,"// Add an unconditional branch to the destination and invert the branch; // condition to jump over it:; // bteqz L1; // =>; // bnez L2; // b L1; // L2:; // If the branch is at the end of its MBB and that has a fall-through block,; // direct the updated conditional branch to the fall-through block. Otherwise,; // split the MBB before the next instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:56,Usability,simpl,simply,56,// Last MI in the BB is an unconditional branch. Can we simply invert the; // condition and swap destinations:; // beqz L1; // b L2; // =>; // bnez L2; // b L1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:76,Deployability,update,update,76,// Insert a new conditional branch and a new unconditional branch.; // Also update the ImmBranch as well as adding a new entry for the new branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:383,Usability,Simpl,Simple,383,"//===- MipsDelaySlotFiller.cpp - Mips Delay Slot Filler -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple pass to fill delay slots with useful instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:30,Performance,load,loads,30,/// Base class for inspecting loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,Performance,load,loads,29,/// Flags indicating whether loads or stores have been seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:26,Performance,load,loads,26,/// This subclass accepts loads from stacks and constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:57,Performance,load,loads,57,/// This subclass accepts loads from stacks and constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:30,Integrability,depend,dependence,30,/// This subclass uses memory dependence information to determine whether a; /// memory instruction can be moved to a delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:4,Deployability,Update,Update,4,/// Update Defs and Uses. Return true if there exist dependences that; /// disqualify the delay slot candidate between V and values in Uses and; /// Defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:53,Integrability,depend,dependences,53,/// Update Defs and Uses. Return true if there exist dependences that; /// disqualify the delay slot candidate between V and values in Uses and; /// Defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,Performance,load,loads,29,/// Flags indicating whether loads or stores with no underlying objects have; /// been seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:119,Deployability,update,updates,119,/// This function checks if it is valid to move Candidate to the delay slot; /// and returns true if it isn't. It also updates memory and register; /// dependence information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:152,Integrability,depend,dependence,152,/// This function checks if it is valid to move Candidate to the delay slot; /// and returns true if it isn't. It also updates memory and register; /// dependence information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:84,Performance,load,loads,84,"// If MI is an ordered or volatile memory reference, disallow moving; // subsequent loads and stores to delay slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:3,Deployability,Update,Update,3,// Update call site info for the Branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:513,Safety,avoid,avoid,513,"// For microMIPS if instruction is BEQ or BNE with one ZERO register, then; // instead of adding NOP replace this instruction with the corresponding; // compact branch instruction, i.e. BEQZC or BNEZC. Additionally; // PseudoReturn and PseudoIndirectBranch are expanded to JR_MM, so they can; // be replaced with JRC16_MM.; // For MIPSR6 attempt to produce the corresponding compact (no delay slot); // form of the CTI. For indirect jumps this will not require inserting a; // NOP and for branches will hopefully avoid requiring a NOP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,Deployability,update,update,29,"// However, we still need to update the register def-use information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:38,Availability,mask,masked,38,"// In NaCl, instructions that must be masked are forbidden in delay slots.; // We only check for loads, stores and SP changes. Calls, returns and; // branches are not checked because non-NaCl targets never put them in; // delay slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:97,Performance,load,loads,97,"// In NaCl, instructions that must be masked are forbidden in delay slots.; // We only check for loads, stores and SP changes. Calls, returns and; // branches are not checked because non-NaCl targets never put them in; // delay slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:40,Performance,optimiz,optimization,40,// This is complicated by the tail call optimization. For non-PIC code; // there is only a 32bit sized unconditional branch which can be assumed; // to be able to reach the target. b16 only has a range of +/- 1 KB.; // It's entirely possible that the target function is reachable with b16; // but we don't have enough information to make that decision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:21,Performance,load,loads,21,// Only allow moving loads from stack or constants if any of the SuccBB's; // predecessors have multiple successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:487,Energy Efficiency,schedul,scheduling,487,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:631,Energy Efficiency,schedul,scheduling,631,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:533,Performance,optimiz,optimizations,533,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:758,Safety,avoid,avoid,758,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:886,Safety,abort,abort,886,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:41,Availability,Mask,Mask,41,"// loop1MBB:; // ll dest, 0(ptr); // and Mask', dest, Mask; // bne Mask', ShiftCmpVal, exitMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:54,Availability,Mask,Mask,54,"// loop1MBB:; // ll dest, 0(ptr); // and Mask', dest, Mask; // bne Mask', ShiftCmpVal, exitMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:67,Availability,Mask,Mask,67,"// loop1MBB:; // ll dest, 0(ptr); // and Mask', dest, Mask; // bne Mask', ShiftCmpVal, exitMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:28,Availability,Mask,Mask,28,"// sinkMBB:; // srl srlres, Mask', shiftamt; // sign_extend dest,srlres",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:84,Availability,mask,mask,84,"// and andres, oldval, incr2; // nor binopres, $0, andres; // and newval, binopres, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:32,Usability,clear,clear,32,// For little endian we need to clear uninterested bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:23,Availability,Mask,Mask,23,"// and OldVal, OldVal, Mask; // and Incr, Incr, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:48,Availability,Mask,Mask,48,"// and OldVal, OldVal, Mask; // and Incr, Incr, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:27,Availability,Mask,Mask,27,"// and BinOpRes, BinOpRes, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:61,Availability,mask,mask,61,"// <binop> binopres, oldval, incr2; // and newval, binopres, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:38,Availability,mask,mask,38,"// atomic.swap; // and newval, incr2, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:41,Availability,mask,mask,41,"// sinkMBB:; // and maskedoldval1,oldval,mask; // srl srlres,maskedoldval1,shiftamt; // sign_extend dest,srlres",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Modifiability,variab,variables,15,// Convenience variables to avoid some queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,Safety,avoid,avoid,28,// Convenience variables to avoid some queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:13,Integrability,rout,routines,13,// Selection routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:18,Integrability,rout,routines,18,// Utility helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Integrability,rout,routines,15,// Emit helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:17,Integrability,rout,routines,17,// Call handling routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:46,Modifiability,extend,extended,46,// If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:34,Deployability,patch,patch,34,// We will extend this in a later patch:; // If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:11,Modifiability,extend,extend,11,// We will extend this in a later patch:; // If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:88,Modifiability,extend,extended,88,// We will extend this in a later patch:; // If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:76,Availability,redundant,redundant,76,"// Because of how EmitCmp is called with fast-isel, you can; // end up with redundant ""andi"" instructions after the sequences emitted below.; // We should try and solve this issue in the future.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:76,Safety,redund,redundant,76,"// Because of how EmitCmp is called with fast-isel, you can; // end up with redundant ""andi"" instructions after the sequences emitted below.; // We should try and solve this issue in the future.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:52,Deployability,patch,patches,52,//; // more cases will be handled here in following patches.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:52,Deployability,patch,patches,52,//; // more cases will be handled here in following patches.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:10,Performance,load,loads,10,// Atomic loads need special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:20,Availability,redundant,redundant,20,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:99,Deployability,patch,patch,99,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:20,Safety,redund,redundant,20,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:36,Availability,mask,mask,36,"// For the general case, we need to mask with 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:43,Modifiability,extend,extend,43,// Attempt to fast-select a floating-point extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:202,Deployability,patch,patch,202,//; // FIXME: This path will currently return false. It was copied; // from the AArch64 port and should be essentially fine for Mips too.; // The work to finish up this path will be done in a follow-on patch.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:24,Modifiability,extend,extended,24,// Special handling for extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple cases. i.e. All arguments are directly mapped to; // registers of the appropriate type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:18,Modifiability,extend,extend,18,"// It must be any extend, this shouldn't happen for clang-generated IR; // so just fall back on SelectionDAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:38,Modifiability,extend,extended,38,// The O32 ABI does not permit a zero-extended i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,Energy Efficiency,allocate,allocates,28,"// Allocating an FGR32 also allocates the super-register AFGR64, and; // ABI rules require us to skip the corresponding GPR32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,Energy Efficiency,allocate,allocates,28,"// Allocating an FGR32 also allocates the super-register AFGR64, and; // ABI rules require us to skip the corresponding GPR32 pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:23,Usability,simpl,simple,23,// FIXME: Only handle *simple* calls for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:18,Availability,mask,mask,18,// Add a register mask with the call-preserved registers.; // Proper defs for return values will be added by setPhysRegsDeadExcept().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:3,Safety,Avoid,Avoid,3,// Avoid a cross-class copy. This is very unlikely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:24,Modifiability,extend,extended,24,// Special handling for extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:108,Testability,test,test,108,"// FastISel does not have plumbing to deal with extensions where the SrcVT or; // DestVT are odd things, so test to make sure that they are both types we can; // handle (i1/i8/i16/i32 for SrcVT and i8/i16/i32/i64 for DestVT), otherwise; // bail out to SelectionDAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:67,Modifiability,extend,extended,67,"// If AShr or LShr, then we need to make sure the operand0 is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:176,Energy Efficiency,allocate,allocated,176,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:1358,Performance,load,load,1358,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:1729,Safety,detect,detect,1729,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:134,Modifiability,variab,variable,134,"// hasFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas,; // if it needs dynamic stack realignment, if frame pointer elimination is; // disabled, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:25,Safety,hazard,hazard,25,/// insertNoop - If data hazard condition is found insert the target nop; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:165,Safety,unsafe,unsafe,165,/// Predicate for distingushing between control transfer instructions and all; /// other instructions for handling forbidden slots. Consider inline assembly; /// as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:70,Performance,load,load,70,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:55,Safety,hazard,hazardous,55,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:120,Safety,unsafe,unsafe,120,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:55,Performance,load,load,55,/// Predicate for distingushing instructions that have load delay slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:15,Modifiability,Variab,Variable,15,// Inline Asm: Variable size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:416,Deployability,update,updated,416,"// Certain branches have two forms: e.g beq $1, $zero, dest vs beqz $1, dest; // Pick the zero form of the branch for readable assembly and for greater; // branch distance in non-microMIPS mode.; // Additional MIPSR6 does not permit the use of register $zero for compact; // branches.; // FIXME: Certain atomic sequences on mips64 generate 32bit references to; // Mips::ZERO, which is incorrect. This test should be updated to use; // Subtarget.getABI().GetZeroReg() when those atomic sequences and others; // are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:401,Testability,test,test,401,"// Certain branches have two forms: e.g beq $1, $zero, dest vs beqz $1, dest; // Pick the zero form of the branch for readable assembly and for greater; // branch distance in non-microMIPS mode.; // Additional MIPSR6 does not permit the use of register $zero for compact; // branches.; // FIXME: Certain atomic sequences on mips64 generate 32bit references to; // Mips::ZERO, which is incorrect. This test should be updated to use; // Subtarget.getABI().GetZeroReg() when those atomic sequences and others; // are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:3,Performance,Perform,Perform,3,// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:31,Performance,load,loaded,31,"// When SrcReg is $zero, treat loaded value as immediate only.; // Ex. $a2 = ADDiu $zero, 10",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:57,Performance,load,load,57,/// Predicate to determine if an instruction can go in a load delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:51,Performance,load,load,51,/// Predicate to determine if an instruction has a load delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:32,Safety,hazard,hazard,32,/// Insert nop instruction when hazard condition is found,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:4,Performance,Perform,Perform,4,/// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:12,Modifiability,extend,extends,12,// Ori zero extends immediate. Used for values with zeros in high 16 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:14,Modifiability,extend,extends,14,// ADDiu sign extends immediate. Used for values with 1s in high 17 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:15,Modifiability,extend,extending,15,// Unspecified extending load is selected into zeroExtending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:25,Performance,load,load,25,// Unspecified extending load is selected into zeroExtending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:61,Performance,load,load,61,// Unspecified extending load is selected into zeroExtending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:15,Performance,load,load,15,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:173,Performance,Load,LoadResult,173,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:196,Performance,load,load,196,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:232,Performance,Load,LoadResult,232,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:20,Security,access,access,20,// Unaligned memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:183,Testability,log,logically,183,"// Default compare result in gpr register will be `true`.; // We will move `false` (MIPS::Zero) to gpr result when fcmp gives false; // using MOVF_I. When orignal predicate (Cond) is logically negated; // MipsFCMPCondCode, result is inverted i.e. MOVT_I is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:67,Deployability,pipeline,pipeline,67,// There are multiple MipsDAGToDAGISel instances added to the pass pipeline.; // We need to preserve StackProtector for the next one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:59,Performance,Load,Load,59,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:116,Safety,avoid,avoid,116,"/// Convert vector addition with vector subtraction if that allows to encode; /// constant as an immediate and thus avoid extra 'ldi' instruction.; /// add X, <-1, -1...> --> sub X, <1, 1...>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h:51,Energy Efficiency,power,power,51,/// Select constant vector splats whose value is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h:71,Energy Efficiency,power,power,71,/// Select constant vector splats whose value is the inverse of a; /// power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h:116,Safety,avoid,avoid,116,"/// Convert vector addition with vector subtraction if that allows to encode; /// constant as an immediate and thus avoid extra 'ldi' instruction.; /// add X, <-1, -1...> --> sub X, <1, 1...>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:405,Integrability,interface,interfaces,405,"//===- MipsISelLowering.cpp - Mips DAG Lowering Implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Mips uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:117,Integrability,depend,dependant,117,// The MIPS MSA ABI passes vector arguments in the integer register set.; // The number of integer registers used is dependant on the ABI used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Performance,Load,Load,3,// Load extented operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:21,Modifiability,extend,extending,21,"// MIPS doesn't have extending float->double load/store. Set LoadExtAction; // for f32, f16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:45,Performance,load,load,45,"// MIPS doesn't have extending float->double load/store. Set LoadExtAction; // for f32, f16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:61,Performance,Load,LoadExtAction,61,"// MIPS doesn't have extending float->double load/store. Set LoadExtAction; // for f32, f16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:7,Performance,Load,LoadExtAction,7,// Set LoadExtAction for f16 vectors to Expand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:246,Performance,load,load,246,"// If the RHS (False) is 0, we swap the order of the operands; // of ISD::SELECT (obviously also inverting the condition) so that we can; // take advantage of conditional moves using the $0 register.; // Example:; // return (a != 0) ? x : 0;; // load $reg, x; // movz $reg, $0, a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:100,Performance,optimiz,optimizations,100,// If both operands are integer constants there's a possibility that we; // can do some interesting optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:47,Performance,optimiz,optimizations,47,// We'll also ignore MVT::i64 operands as this optimizations proves; // to be ineffective because of the required sign extensions as the result; // of a SETCC operator is always MVT::i32 for non-vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Performance,optimiz,optimize,13,// Could not optimize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:241,Performance,load,load,241,"// Since RHS (False) is 0, we swap the order of the True/False operands; // (obviously also inverting the condition) so that we can; // take advantage of conditional moves using the $0 register.; // Example:; // return (a != 0) ? x : 0;; // load $reg, x; // movz $reg, $0, a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:41,Availability,mask,mask,41,// Op's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,mask,mask,25,// Return if the shifted mask does not start at bit 0 or the sum of its size; // and Pos exceeds the word's size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:56,Availability,mask,mask,56,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:99,Availability,mask,mask,99,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:117,Availability,mask,mask,117,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:126,Availability,mask,mask,126,"// Pattern match EXT.; // $dst = and $src, (2**size - 1) , if size > 16; // => ext $dst, $src, pos, size , pos = 0; // If the mask is <= 0xffff, andi can be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:17,Availability,mask,mask,17,// Return if the mask doesn't start at position 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Availability,mask,masks,13,// The shift masks must have the same position and size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:60,Availability,mask,mask,60,// Return if the shift amount and the first bit position of mask are not the; // same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:71,Usability,clear,cleared,71,// Don't generate INS if constant OR operand doesn't fit into bits; // cleared by constant AND operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:758,Modifiability,extend,extended,758,"// For MIPS64, madd / msub instructions are inefficent to use with 64 bit; // arithmetic. E.g.; // (add (mul a b) c) =>; // let res = (madd (mthi (drotr c 32))x(mtlo c) a b) in; // MIPS64: (or (dsll (mfhi res) 32) (dsrl (dsll (mflo res) 32) 32); // or; // MIPS64R2: (dins (mflo res) (mfhi res) 32 32); //; // The overhead of setting up the Hi/Lo registers and reassembling the; // result makes this a dubious optimzation for MIPS64. The core of the; // problem is that Hi/Lo contain the upper and lower 32 bits of the; // operand and result.; //; // It requires a chain of 4 add/mul for MIPS64R2 to get better code; // density than doing it naively, 5 for MIPS64. Additionally, using; // madd/msub on MIPS64 requires the operands actually be 32 bit sign; // extended operands, not true 64 bit values.; //; // FIXME: For the moment, disable this completely for MIPS64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:114,Modifiability,extend,extended,114,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:225,Performance,perform,perform,225,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:238,Performance,optimiz,optimization,238,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:288,Performance,perform,performing,288,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:308,Performance,optimiz,optimization,308,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:42,Availability,mask,mask,42,// AND's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,mask,mask,25,// Return if the shifted mask does not start at bit 0 or the sum of its size; // and Pos exceeds the word's size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:34,Testability,test,test,34,"// We can use ANDI+SLTIU as a bit test. Y contains the bit position.; // For MIPSR2 or later, we may be able to use the `ext` instruction or its'; // double-word variants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear Divisor's kill flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:97,Integrability,inject,inject,97,// We would normally delete the original instruction here but in this case; // we only needed to inject an additional instruction rather than replace it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:97,Security,inject,inject,97,// We would normally delete the original instruction here but in this case; // we only needed to inject an additional instruction rather than replace it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1591,Integrability,synchroniz,synchronizable,1591,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1705,Integrability,depend,dependent,1705,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1294,Performance,load,load,1294,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:141,Availability,mask,maskupper,141,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:173,Availability,mask,mask,173,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:178,Availability,mask,maskupper,178,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:214,Availability,mask,mask,214,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:265,Performance,load,load,265,"// Lower atomic compare and swap to a pseudo instruction, taking care to; // define a scratch register for the pseudo instruction's expansion. The; // instruction is expanded after the register allocator as to prevent; // the insertion of stores between the linked load and the store conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:283,Availability,error,errors,283,"// We need to create copies of the various registers and kill them at the; // atomic pseudo. If the copies are not made, when the atomic is expanded; // after fast register allocation, the spills will end up outside of the; // blocks that their values are defined in, causing livein errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:182,Availability,mask,maskupper,182,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:214,Availability,mask,mask,214,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:219,Availability,mask,maskupper,219,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:255,Availability,mask,mask,255,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:269,Availability,mask,maskedcmpval,269,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:315,Availability,mask,maskedcmpval,315,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:346,Availability,mask,maskednewval,346,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:392,Availability,mask,maskednewval,392,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:129,Performance,load,loads,129,"// Every other architecture would use shouldAssumeDSOLocal in here, but; // mips is special.; // * In PIC code mips requires got loads even for local statics!; // * To save on got entries, for local statics the got entry contains the; // page and an additional add instruction takes care of the low bits.; // * It is legal to access a hidden symbol with a non hidden undefined,; // so one cannot guarantee that all access to a hidden symbol will know; // it is hidden.; // * Mips linkers don't support creating a page and a full got entry for; // the same symbol.; // * Given all that, we have to use a full got entry for hidden symbols :-(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:326,Security,access,access,326,"// Every other architecture would use shouldAssumeDSOLocal in here, but; // mips is special.; // * In PIC code mips requires got loads even for local statics!; // * To save on got entries, for local statics the got entry contains the; // page and an additional add instruction takes care of the low bits.; // * It is legal to access a hidden symbol with a non hidden undefined,; // so one cannot guarantee that all access to a hidden symbol will know; // it is hidden.; // * Mips linkers don't support creating a page and a full got entry for; // the same symbol.; // * Given all that, we have to use a full got entry for hidden symbols :-(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:415,Security,access,access,415,"// Every other architecture would use shouldAssumeDSOLocal in here, but; // mips is special.; // * In PIC code mips requires got loads even for local statics!; // * To save on got entries, for local statics the got entry contains the; // page and an additional add instruction takes care of the low bits.; // * It is legal to access a hidden symbol with a non hidden undefined,; // so one cannot guarantee that all access to a hidden symbol will know; // it is hidden.; // * Mips linkers don't support creating a page and a full got entry for; // the same symbol.; // * Given all that, we have to use a full got entry for hidden symbols :-(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:322,Availability,down,down,322,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:125,Energy Efficiency,reduce,reduce,125,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:273,Energy Efficiency,reduce,reduce,273,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:58,Performance,load,load,58,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear MSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:209,Modifiability,rewrite,rewrite,209,"// FIXME: For mips32r2, the sequence of (BuildPairF64 (ins (ExtractElementF64; // Op 1), $zero, 31 1) (ExtractElementF64 Op 0)) and the Op has one use, we; // should be able to drop the usage of mfc1/mtc1 and rewrite the register in; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear MSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:44,Performance,load,load,44,// Expand an unaligned 32 or 64-bit integer load node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Performance,load,load,13,// Return if load is aligned or if MemVT is neither i32 nor i64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:30,Performance,load,load,30,"// Expand; // (set dst, (i64 (load baseptr))); // to; // (set tmp, (ldl (add baseptr, 7), undef)); // (set dst, (ldr baseptr, tmp))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:30,Performance,load,load,30,"// Expand; // (set dst, (i32 (load baseptr))) or; // (set dst, (i64 (sextload baseptr))) or; // (set dst, (i64 (extload baseptr))); // to; // (set tmp, (lwl (add baseptr, 3), undef)); // (set dst, (lwr baseptr, tmp))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:770,Availability,avail,available,770,"//===----------------------------------------------------------------------===//; // Calling Convention Implementation; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // TODO: Implement a generic logic using tblgen that can support this.; // Mips O32 ABI rules:; // ---; // i32 - Passed in A0, A1, A2, A3 and stack; // f32 - Only passed in f32 registers if no int reg has been used yet to hold; // an argument. Otherwise, passed in A1, A2, A3 and stack.; // f64 - Only passed in two aliased f32 registers if no int reg has been used; // yet to hold an argument. Otherwise, use A2, A3 and stack. If A1 is; // not used, it must be shadowed. If only A3 is available, shadow it and; // go to stack.; // vXiX - Received as scalarized i32s, passed in A0 - A3 and the stack.; // vXf32 - Passed in either a pair of registers {A0, A1}, {A2, A3} or {A0 - A3}; // with the remainder spilled to the stack.; // vXf64 - Passed in either {A0, A1, A2, A3} or {A2, A3} and in both cases; // spilling the remainder to the stack.; //; // For vararg functions, all arguments are passed in A0, A1, A2, A3 and stack.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:313,Testability,log,logic,313,"//===----------------------------------------------------------------------===//; // Calling Convention Implementation; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // TODO: Implement a generic logic using tblgen that can support this.; // Mips O32 ABI rules:; // ---; // i32 - Passed in A0, A1, A2, A3 and stack; // f32 - Only passed in f32 registers if no int reg has been used yet to hold; // an argument. Otherwise, passed in A1, A2, A3 and stack.; // f64 - Only passed in two aliased f32 registers if no int reg has been used; // yet to hold an argument. Otherwise, use A2, A3 and stack. If A1 is; // not used, it must be shadowed. If only A3 is available, shadow it and; // go to stack.; // vXiX - Received as scalarized i32s, passed in A0 - A3 and the stack.; // vXf32 - Passed in either a pair of registers {A0, A1}, {A2, A3} or {A0 - A3}; // with the remainder spilled to the stack.; // vXf64 - Passed in either {A0, A1, A2, A3} or {A2, A3} and in both cases; // spilling the remainder to the stack.; //; // For vararg functions, all arguments are passed in A0, A1, A2, A3 and stack.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:19,Energy Efficiency,allocate,allocated,19,"// f32 and f64 are allocated in A0, A1, A2, A3 when either of the following; // is true: function is vararg, argument is 3rd or higher, there is previous; // argument which is not f32 or f64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:134,Energy Efficiency,Allocate,Allocate,134,"// This is the start of an vector that was scalarized into an unknown number; // of components. It doesn't matter how many there are. Allocate one of the; // notional 8 byte aligned registers which map onto the argument stack, and; // shadow the register lost to alignment requirements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:79,Energy Efficiency,allocate,allocate,79,"// If we're an intermediate component of the split, we can just attempt to; // allocate a register directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:52,Energy Efficiency,allocate,allocated,52,"// If this is the first part of an i64 arg,; // the allocated register must be either A0 or A2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:68,Availability,avail,available,68,"// Allocate int register and shadow next int register. If first; // available register is Mips::A1 or Mips::A3, shadow it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate int register and shadow next int register. If first; // available register is Mips::A1 or Mips::A3, shadow it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:32,Availability,avail,available,32,// we are guaranteed to find an available float register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:224,Testability,stub,stub,224,"// Insert node ""GP copy globalreg"" before call to function.; //; // R_MIPS_CALL* operators (emitted when non-internal functions are called; // in PIC mode) allow symbols to be resolved via lazy binding.; // The lazy binding stub requires GP to point to the GOT.; // Note that we don't need GP to point to the GOT for indirect calls; // (when R_MIPS_CALL* is not used for the call) because Mips linker generates; // lazy binding stub for a function only when R_MIPS_CALL* are the only relocs; // used for the function (that is, Mips linker doesn't generate lazy binding; // stub for a function whose address is taken in the program).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:428,Testability,stub,stub,428,"// Insert node ""GP copy globalreg"" before call to function.; //; // R_MIPS_CALL* operators (emitted when non-internal functions are called; // in PIC mode) allow symbols to be resolved via lazy binding.; // The lazy binding stub requires GP to point to the GOT.; // Note that we don't need GP to point to the GOT for indirect calls; // (when R_MIPS_CALL* is not used for the call) because Mips linker generates; // lazy binding stub for a function only when R_MIPS_CALL* are the only relocs; // used for the function (that is, Mips linker doesn't generate lazy binding; // stub for a function whose address is taken in the program).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:573,Testability,stub,stub,573,"// Insert node ""GP copy globalreg"" before call to function.; //; // R_MIPS_CALL* operators (emitted when non-internal functions are called; // in PIC mode) allow symbols to be resolved via lazy binding.; // The lazy binding stub requires GP to point to the GOT.; // Note that we don't need GP to point to the GOT for indirect calls; // (when R_MIPS_CALL* is not used for the call) because Mips linker generates; // lazy binding stub for a function only when R_MIPS_CALL* are the only relocs; // used for the function (that is, Mips linker doesn't generate lazy binding; // stub for a function whose address is taken in the program).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:215,Energy Efficiency,allocate,allocate,215,"// There is one case where CALLSEQ_START..CALLSEQ_END can be nested, which; // is during the lowering of a call with a byval argument which produces; // a call to memcpy. For the O32 case, this causes the caller to allocate; // stack space for the reserved argument area for the callee, then recursively; // again for the memcpy call. In the NEWABI case, this doesn't occur as those; // ABIs mandate that the callee allocates the reserved argument area. We do; // still produce nested CALLSEQ_START..CALLSEQ_END with zero space though.; //; // If the callee has a byval argument and memcpy is used, we are mandated; // to already have produced a reserved argument area for the callee for O32.; // Therefore, the reserved argument area can be reused for both calls.; //; // Other cases of calling memcpy cannot have a chain with a CALLSEQ_START; // present, as we have yet to hook that node onto the chain.; //; // Hence, the CALLSEQ_START and CALLSEQ_END nodes can be eliminated in this; // case. GCC does a similar trick, in that wherever possible, it calculates; // the maximum out going argument area (including the reserved area), and; // preallocates the stack space on entrance to the caller.; //; // FIXME: We should do the same for efficiency and space.; // Note: The check on the calling convention below must match; // MipsABIInfo::GetCalleeAllocdArgSizeInBytes().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:416,Energy Efficiency,allocate,allocates,416,"// There is one case where CALLSEQ_START..CALLSEQ_END can be nested, which; // is during the lowering of a call with a byval argument which produces; // a call to memcpy. For the O32 case, this causes the caller to allocate; // stack space for the reserved argument area for the callee, then recursively; // again for the memcpy call. In the NEWABI case, this doesn't occur as those; // ABIs mandate that the callee allocates the reserved argument area. We do; // still produce nested CALLSEQ_START..CALLSEQ_END with zero space though.; //; // If the callee has a byval argument and memcpy is used, we are mandated; // to already have produced a reserved argument area for the callee for O32.; // Therefore, the reserved argument area can be reused for both calls.; //; // Other cases of calling memcpy cannot have a chain with a CALLSEQ_START; // present, as we have yet to hook that node onto the chain.; //; // Hence, the CALLSEQ_START and CALLSEQ_END nodes can be eliminated in this; // case. GCC does a similar trick, in that wherever possible, it calculates; // the maximum out going argument area (including the reserved area), and; // preallocates the stack space on entrance to the caller.; //; // FIXME: We should do the same for efficiency and space.; // Note: The check on the calling convention below must match; // MipsABIInfo::GetCalleeAllocdArgSizeInBytes().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the reserved argument area. It seems strange to do this from the; // caller side but removing it breaks the frame size calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:41,Performance,Load,Load,41,// Chain is the output chain of the last Load/Store or CopyToReg node.; // ByValChain is the output chain of the last Memcpy node created for copying; // byval arguments to the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:92,Safety,avoid,avoid,92,"// If the parameter is passed through reg $D, which splits into; // two physical registers, avoid creating call site info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:210,Testability,assert,assertions,210,"// If this is an value smaller than the argument slot size (32-bit for O32,; // 64-bit for N32/N64), it has been promoted in some way to the argument slot; // size. Extract the value and insert any appropriate assertions regarding; // sign/zero extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:316,Performance,load,load,316,//===----------------------------------------------------------------------===//; // Formal Arguments Calling Convention Implementation; //===----------------------------------------------------------------------===//; /// LowerFormalArguments - transform physical registers into virtual registers; /// and generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:10,Performance,load,load,10,// Create load nodes to retrieve arguments from the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:178,Security,access,access,178,// The mips ABIs for returning structs by value requires that we copy; // the sret argument into $v0 for the return. Save the argument into; // a virtual register so that we can access it from the return points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:37,Modifiability,config,config,37,// Mips specific constraints; // GCC config/mips/constraints.md; //; // 'd' : An address register. Equivalent to r; // unless generating MIPS16 code.; // 'y' : Equivalent to r; retained for; // backwards compatibility.; // 'c' : A register suitable for use in an indirect; // jump. This will always be $25 for -mabicalls.; // 'l' : The lo register. 1 word storage.; // 'x' : The hilo register pair. Double word storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:21,Security,access,access,21,// Parse $msa(ir|csr|access|save|modify|request|map|unmap); // No numeric characters follow the name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:158,Availability,error,error,158,// use the concatenated `hi` and `lo` registers; // to store doubleword values; // Fixme: Not triggering the use of both hi and low; // This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:164,Integrability,message,message,164,// use the concatenated `hi` and `lo` registers; // to store doubleword values; // Fixme: Not triggering the use of both hi and low; // This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:77,Availability,error,error,77,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:56,Integrability,rout,routine,56,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:218,Energy Efficiency,Schedul,ScheduleDAGInstrs,218,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:110,Integrability,depend,dependencies,110,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:298,Integrability,depend,dependencies,298,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:55,Performance,load,load,55,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:315,Performance,load,loads,315,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:174,Usability,clear,clears,174,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:58,Performance,load,loads,58,// Copy the remainder of the byval argument with sub-word loads and shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Performance,Load,Load,3,// Load subword.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Performance,load,loaded,13,// Shift the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:23,Modifiability,variab,variable,23,// Offset of the first variable argument from stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:141,Energy Efficiency,allocate,allocated,141,"// Copy the integer registers that have not been used for argument passing; // to the argument register save area. For O32, the save area is allocated; // in the caller's stack frame, while for N32/64, it is allocated in the; // callee's stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:208,Energy Efficiency,allocate,allocated,208,"// Copy the integer registers that have not been used for argument passing; // to the argument register save area. For O32, the save area is allocated; // in the caller's stack frame, while for N32/64, it is allocated in the; // callee's stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:161,Testability,test,test,161,"// If Alignment > RegSizeInBytes, the first arg register must be even.; // FIXME: This condition happens to do the right thing but it's not the; // right way to test it. We want to check that the stack frame offset; // of the register is aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Energy Efficiency,allocate,allocated,22,// Mark the registers allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:176,Energy Efficiency,reduce,reduces,176,"// D_SELECT substitutes two SELECT nodes that goes one after another and; // have the same condition operand. On machines which don't have; // conditional-move instruction, it reduces unnecessary branch instructions; // which are result of using two diamond patterns that are result of two; // SELECT pseudo instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Performance,load,load,22,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:53,Performance,load,load,53,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Performance,load,load,22,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:53,Performance,load,load,53,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can store to adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can store to an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can store to adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can store to an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:46,Integrability,Interface,Interface,46,"//===- MipsISelLowering.h - Mips DAG Lowering Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Mips uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:405,Integrability,interface,interfaces,405,"//===- MipsISelLowering.h - Mips DAG Lowering Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Mips uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:52,Security,access,accessing,52,// Get the High 16 bits from a 32 bit immediate for accessing the GOT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:52,Security,access,accessing,52,// Get the High 16 bits from a 32-bit immediate for accessing TLS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:25,Availability,error,error,25,"// Interrupt, exception, error trap Return",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:23,Availability,mask,mask,23,// Vector Shuffle with mask as an operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Modifiability,Extend,Extended,3,// Extended vector element extraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Performance,Load,Load,3,// Load/Store Left/Right nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:10,Availability,down,down,10,/// Break down vectors to the correct number of gpr sized integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:128,Integrability,wrap,wrapper,128,"// This method creates the following nodes, which are necessary for; // computing a local symbol's address:; //; // (add (load (wrapper $gp, %got(sym)), %lo(sym))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:122,Performance,load,load,122,"// This method creates the following nodes, which are necessary for; // computing a local symbol's address:; //; // (add (load (wrapper $gp, %got(sym)), %lo(sym))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:124,Integrability,wrap,wrapper,124,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address:; //; // (load (wrapper $gp, %got(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:118,Performance,load,load,118,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address:; //; // (load (wrapper $gp, %got(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:142,Integrability,wrap,wrapper,142,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address in large-GOT mode:; //; // (load (wrapper (add %hi(sym), $gp), %lo(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:136,Performance,load,load,136,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address in large-GOT mode:; //; // (load (wrapper (add %hi(sym), $gp), %lo(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Performance,Cache,Cache,3,"// Cache the ABI from the TargetMachine, we use it everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:94,Performance,optimiz,optimization,94,/// isEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:28,Modifiability,variab,variable,28,/// writeVarArgRegs - Write variable function arguments passed in registers; /// to the stack. Also create a stack frame object for the first variable; /// argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:142,Modifiability,variab,variable,142,/// writeVarArgRegs - Write variable function arguments passed in registers; /// to the stack. Also create a stack frame object for the first variable; /// argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:105,Availability,failure,failure,105,"/// This function parses registers that appear in inline-asm constraints.; /// It returns pair (0, 0) on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:11,Energy Efficiency,power,power,11,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:105,Performance,perform,perform,105,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:90,Security,access,access,90,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:7,Energy Efficiency,power,power,7,// Non power of two memory access is never legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:27,Security,access,access,27,// Non power of two memory access is never legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:248,Performance,perform,performs,248,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:324,Performance,load,load,324,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:60,Security,access,access,60,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:102,Security,access,access,102,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:274,Security,access,access,274,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:68,Energy Efficiency,power,power-of-,68,"// Custom lower scalar memory access, up to 8 bytes, for:; // - non-power-of-2 MemSizes; // - unaligned 2 or 8 byte MemSizes for MIPS32r5 and older",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:30,Security,access,access,30,"// Custom lower scalar memory access, up to 8 bytes, for:; // - non-power-of-2 MemSizes; // - unaligned 2 or 8 byte MemSizes for MIPS32r5 and older",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:52,Energy Efficiency,power,power,52,"// Split MemSize into two, P2HalfMemSize is largest power of two smaller; // then MemSize. e.g. 8 = 4 + 4 , 6 = 4 + 2, 3 = 2 + 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:24,Performance,load,load,24,"// This is anyextending load, use 4 byte lwr/lwl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:183,Availability,mask,mask,183,"// Let 0xABCDEFGH be given unsigned in MI.getOperand(1). First let's convert; // unsigned to double. Mantissa has 52 bits so we use following trick:; // First make floating point bit mask 0x43300000ABCDEFGH.; // Mask represents 2^52 * 0x1.00000ABCDEFGH i.e. 0x100000ABCDEFGH.0 .; // Next, subtract 2^52 * 0x1.0000000000000 i.e. 0x10000000000000.0 from it.; // Done. Trunc double to float if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:212,Availability,Mask,Mask,212,"// Let 0xABCDEFGH be given unsigned in MI.getOperand(1). First let's convert; // unsigned to double. Mantissa has 52 bits so we use following trick:; // First make floating point bit mask 0x43300000ABCDEFGH.; // Mask represents 2^52 * 0x1.00000ABCDEFGH i.e. 0x100000ABCDEFGH.0 .; // Next, subtract 2^52 * 0x1.0000000000000 i.e. 0x10000000000000.0 from it.; // Done. Trunc double to float if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:497,Safety,avoid,avoid,497,"// For O32 ABI, the following instruction sequence is emitted to initialize; // the global base register:; //; // 0. lui $2, %hi(_gp_disp); // 1. addiu $2, $2, %lo(_gp_disp); // 2. addu $globalbasereg, $2, $t9; //; // We emit only the last instruction here.; //; // GNU linker requires that the first two instructions appear at the beginning; // of a function and no instructions be inserted before or between them.; // The two instructions are emitted during lowering to MC layer in order to; // avoid any reordering.; //; // Register $2 (Mips::V0) is added to the list of live-in registers to ensure; // the value instruction 1 (addiu) defines is valid when instruction 2 (addu); // reads it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:41,Availability,Error,ErrorPC,41,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:173,Availability,Error,ErrorPC,173,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:198,Integrability,depend,dependent,198,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.h:55,Integrability,Rout,Routine,55,/// ISR - Whether the function is an Interrupt Service Routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:33,Performance,Optimiz,Optimize,33,"//===- MipsOptimizePICCall.cpp - Optimize PIC Calls -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass eliminates unnecessary instructions that set up $gp and replace; // instructions that load target function addresses with copy instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:479,Performance,load,load,479,"//===- MipsOptimizePICCall.cpp - Optimize PIC Calls -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass eliminates unnecessary instructions that set up $gp and replace; // instructions that load target function addresses with copy instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:4,Testability,Test,Test,4,"/// Test if MI jumps to a function via a register.; ///; /// Also, return the virtual register containing the target function's address; /// and the underlying object in Reg and Val respectively, if the function's; /// address can be resolved lazily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:85,Performance,load,load,85,/// Return the number of instructions that dominate the current; /// instruction and load the function address from object Entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:78,Performance,load,loads,78,/// Return the destination virtual register of the last instruction; /// that loads from object Entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:4,Deployability,Update,Update,4,/// Update ScopedHT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:3,Performance,Optimiz,OptimizePICCall,3,// OptimizePICCall methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:79,Performance,load,load,79,"// If a function has been called more than twice, we do not have to emit a; // load instruction to get the function address from the GOT, but can; // instead reuse the address that has been loaded before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:190,Performance,load,loaded,190,"// If a function has been called more than twice, we do not have to emit a; // load instruction to get the function address from the GOT, but can; // instead reuse the address that has been loaded before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:169,Testability,stub,stub,169,// Erase the $gp operand if this isn't the first time a function has; // been called. $gp needs to be set up only if the function call can go; // through a lazy binding stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:28,Performance,load,loads,28,// Get the instruction that loads the function address from the GOT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:39,Performance,load,loads,39,// See if DefMI is an instruction that loads from a GOT entry that holds the; // address of a lazy binding stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:107,Testability,stub,stub,107,// See if DefMI is an instruction that loads from a GOT entry that holds the; // address of a lazy binding stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:14,Performance,Optimiz,OptimizeCall,14,/// Return an OptimizeCall object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp:382,Performance,optimiz,optimization,382,"//===---- MipsOs16.cpp for Mips Option -Os16 --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an optimization phase for the MIPS target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp:90,Modifiability,variab,variables,90,// Figure out if we need float point based on the function signature.; // We need to move variables in and/or out of floating point; // registers because of the ABI; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:32,Energy Efficiency,power,power,32,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:43,Performance,load,loads,43,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:62,Performance,load,loads,62,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:315,Availability,avail,available,315,"// Excluding WaitingForTypeOfMI, MI is either connected to chains of ambiguous; // instructions or has no other adjacent instructions. Anyway InstType could; // not be determined. There could be unexplored path from some of; // WaitingForTypeOfMI's adjacent instructions to an instruction with only one; // mapping available.; // We are done with this branch, add MI to WaitingForTypeOfMI's WaitingQueue,; // this way when WaitingForTypeOfMI figures out its InstType same InstType; // will be assigned to all instructions in this branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:26,Availability,avail,available,26,"// Only 64 bit mapping is available in fprb and will be marked as custom, i.e.; // will be split into two 32 bit registers in gprb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:37,Availability,avail,available,37,// Check if LLT sizes match sizes of available register banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:141,Safety,avoid,avoid,141,/// Some instructions are used with both floating point and integer operands.; /// We assign InstType to such instructions as it helps us to avoid cross bank; /// copies. InstType deppends on context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:95,Safety,avoid,avoid,95,/// Connected with instruction that interprets 'bags of bits' as integers.; /// Select gprb to avoid cross bank copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:109,Safety,avoid,avoid,109,/// Connected with instruction that interprets 'bags of bits' as floating; /// point numbers. Select fprb to avoid cross bank copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:87,Safety,avoid,avoid,87,/// Represents moving 'bags of bits' around. Select same bank for entire; /// chain to avoid cross bank copies. Currently we select fprb for s64 and; /// gprb for s32 Ambiguous operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:107,Usability,clear,clear,107,"/// MI is about to get destroyed (using narrow scalar). Internal data is; /// saved based on MI's address, clear it since it is no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:34,Modifiability,sandbox,sandbox,34,// Reserve registers for the NaCl sandbox.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:34,Testability,sandbox,sandbox,34,// Reserve registers for the NaCl sandbox.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:29,Availability,mask,mask,29,// Reserved for control flow mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:30,Availability,mask,mask,30,// Reserved for memory access mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:23,Security,access,access,23,// Reserved for memory access mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:74,Energy Efficiency,allocate,allocate,74,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:83,Modifiability,variab,variable-sized,83,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:130,Testability,test,test,130,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:109,Availability,error,error,109,"// Avoid realigning functions that explicitly do not want to be realigned.; // Normally, we should report an error when a function should be dynamically; // realigned but also has the attribute no-realign-stack. Unfortunately,; // with this attribute, MachineFrameInfo clamps each new object's alignment; // to that of the stack's alignment as specified by the ABI. As a result,; // the information of whether we have objects with larger alignment; // requirement than the stack's alignment is already lost at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:3,Safety,Avoid,Avoid,3,"// Avoid realigning functions that explicitly do not want to be realigned.; // Normally, we should report an error when a function should be dynamically; // realigned but also has the attribute no-realign-stack. Unfortunately,; // with this attribute, MachineFrameInfo clamps each new object's alignment; // to that of the stack's alignment as specified by the ABI. As a result,; // the information of whether we have objects with larger alignment; // requirement than the stack's alignment is already lost at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:12,Performance,perform,perform,12,// We can't perform dynamic stack realignment if we can't reserve the; // frame pointer register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:89,Modifiability,variab,variable,89,// We can realign the stack if we know the maximum call frame size and we; // don't have variable sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:67,Modifiability,variab,variable,67,// We have to reserve the base pointer register in the presence of variable; // sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,load,load,3,"// load $vr, FI; // copy ccond, $vr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,load,load,3,"// load $vr0, FI; // copy lo, $vr0; // load $vr1, FI + 4; // copy hi, $vr1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:39,Performance,load,load,39,"// load $vr0, FI; // copy lo, $vr0; // load $vr1, FI + 4; // copy hi, $vr1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:150,Availability,avail,available,150,"/// This method expands the same instruction that MipsSEInstrInfo::; /// expandBuildPairF64 does, for the case when ABI is fpxx and mthc1 is not; /// available and the case where the ABI is FP64A. It is implemented here; /// because frame indexes are eliminated before MipsSEInstrInfo::; /// expandBuildPairF64 is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:34,Availability,avail,available,34,"// For fpxx and when mthc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mtc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:110,Availability,avail,available,110,"// For fpxx and when mthc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mtc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:108,Availability,avail,available,108,// It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are; // the cases where mthc1 is not available). 64-bit architectures and; // MIPS32r2 or later can use FGR64 though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:155,Availability,avail,available,155,"/// This method expands the same instruction that MipsSEInstrInfo::; /// expandExtractElementF64 does, for the case when ABI is fpxx and mfhc1 is not; /// available and the case where the ABI is FP64A. It is implemented here; /// because frame indexes are eliminated before MipsSEInstrInfo::; /// expandExtractElementF64 is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:34,Availability,avail,available,34,"// For fpxx and when mfhc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmfc1 is available doesn't need to be handled here; // because it never creates a ExtractElementF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mfc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:110,Availability,avail,available,110,"// For fpxx and when mfhc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmfc1 is available doesn't need to be handled here; // because it never creates a ExtractElementF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mfc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:108,Availability,avail,available,108,// It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are; // the cases where mfhc1 is not available). 64-bit architectures and; // MIPS32r2 or later can use FGR64 though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate space on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,Availability,error,error,13,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:316,Deployability,configurat,configuration,316,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:316,Modifiability,config,configuration,316,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:136,Safety,hazard,hazards,136,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:239,Safety,hazard,hazard,239,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:265,Safety,hazard,hazard,265,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:116,Usability,clear,clear,116,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:219,Usability,clear,clear,219,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:276,Usability,clear,clearing,276,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:59,Performance,perform,perform,59,"// The GP register contains the ""user"" value, so we cannot perform; // any gp relative loads until we restore the ""kernel"" or ""system"" gp; // value. Until support is written we shall only accept the static; // relocation model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:87,Performance,load,loads,87,"// The GP register contains the ""user"" value, so we cannot perform; // any gp relative loads until we restore the ""kernel"" or ""system"" gp; // value. Until support is written we shall only accept the static; // relocation model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,Perform,Perform,3,// Perform ISR handling like GCC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:102,Availability,mask,masked,102,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,Deployability,configurat,configuration,13,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,Modifiability,config,configuration,13,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:76,Availability,mask,masking,76,"// If the interrupt we're tied to is the EIC, switch the source for the; // masking off interrupts to the cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Availability,Mask,Mask,3,"// Mask off KSU, ERL, EXL",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,Perform,Perform,3,// Perform ISR handling like GCC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:114,Modifiability,variab,variable,114,// Reserve call frame if the size of the maximum call frame fits into 16-bit; // immediate field and there are no variable sized objects on the stack.; // Make sure the second register scavenger spill slot can be accessed with one; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:213,Security,access,accessed,213,// Reserve call frame if the size of the maximum call frame fits into 16-bit; // immediate field and there are no variable sized objects on the stack.; // Make sure the second register scavenger spill slot can be accessed with one; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:36,Performance,load,load,36,"// Expand pseudo instructions which load, store or copy accumulators.; // Add an emergency spill slot if a pseudo was expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:61,Modifiability,variab,variable,61,"// MSA has a minimum offset of 10 bits signed. If there is a variable; // sized object on the stack, the estimation cannot account for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:3,Performance,Load,Load,3,// Load HI/LO through K0. Notably the DestReg is encoded into the; // instruction itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:707,Energy Efficiency,schedul,scheduler,707,"// FIXME: Strictly speaking MFHC1 only reads the top 32-bits however, we; // claim to read the whole 64-bits as part of a white lie used to; // temporarily work around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MFHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:680,Integrability,depend,dependency,680,"// FIXME: Strictly speaking MFHC1 only reads the top 32-bits however, we; // claim to read the whole 64-bits as part of a white lie used to; // temporarily work around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MFHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:17,Availability,avail,available,17,"// When mthc1 is available, use:; // mtc1 Lo, $fp; // mthc1 Hi, $fp; //; // Otherwise, for O32 FPXX ABI:; // spill + reload via ldc1; // This case is handled by the frame lowering code.; //; // Otherwise, for FP32:; // mtc1 Lo, $fp; // mtc1 Hi, $fp + 1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; // FPXX on MIPS-II or MIPS32r1 should have been handled with a spill/reload; // in MipsSEFrameLowering.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:285,Availability,avail,available,285,"// When mthc1 is available, use:; // mtc1 Lo, $fp; // mthc1 Hi, $fp; //; // Otherwise, for O32 FPXX ABI:; // spill + reload via ldc1; // This case is handled by the frame lowering code.; //; // Otherwise, for FP32:; // mtc1 Lo, $fp; // mtc1 Hi, $fp + 1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; // FPXX on MIPS-II or MIPS32r1 should have been handled with a spill/reload; // in MipsSEFrameLowering.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:620,Energy Efficiency,schedul,scheduler,620,// FIXME: The .addReg(DstReg) is a white lie used to temporarily work; // around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MTHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:593,Integrability,depend,dependency,593,// FIXME: The .addReg(DstReg) is a white lie used to temporarily work; // around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MTHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:37,Performance,load,load,37,"/// Emit a series of instructions to load an immediate. If NewImm is a; /// non-NULL parameter, the last instruction is not emitted, but instead; /// its immediate operand is returned in NewImm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:266,Safety,avoid,avoid,266,"/// Expand pseudo Int-to-FP conversion instructions.; ///; /// For example, the following pseudo instruction; /// PseudoCVT_D32_W D2, A5; /// gets expanded into these two instructions:; /// MTC1 F4, A5; /// CVT_D32_W D2, F4; ///; /// We do this expansion post-RA to avoid inserting a floating point copy; /// instruction between MTC1 and CVT_D32_W.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:58,Usability,clear,clear,58,// My reading of the MIPS DSP 3.01 specification isn't as clear as I; // would like about whether bit 20 always gets overwritten by addwc.; // Hence take an extremely conservative view and presume it's sticky. We; // therefore need to clear it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:235,Usability,clear,clear,235,// My reading of the MIPS DSP 3.01 specification isn't as clear as I; // would like about whether bit 20 always gets overwritten by addwc.; // Hence take an extremely conservative view and presume it's sticky. We; // therefore need to clear it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:59,Performance,Load,Load,59,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:15,Performance,Load,Load,15,// on PIC code Load GA,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:8,Performance,load,loading,8,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:37,Performance,load,load,37,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:59,Performance,Load,Load,59,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:22,Performance,Load,Load,22,/// Used on microMIPS Load/Store unaligned instructions (12-bit offset),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:50,Energy Efficiency,power,power,50,"// Select constant vector splats whose value is a power of 2.; //; // In addition to the requirements of selectVSplat(), this function returns; // true and sets Imm if:; // * The splat value is the same width as the elements of the vector; // * The splat value is a power of two.; //; // This function looks through ISD::BITCAST nodes.; // TODO: This might not be appropriate for big-endian MSA since BITCAST is; // sometimes a shuffle in big-endian mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:266,Energy Efficiency,power,power,266,"// Select constant vector splats whose value is a power of 2.; //; // In addition to the requirements of selectVSplat(), this function returns; // true and sets Imm if:; // * The splat value is the same width as the elements of the vector; // * The splat value is a power of two.; //; // This function looks through ISD::BITCAST nodes.; // TODO: This might not be appropriate for big-endian MSA since BITCAST is; // sometimes a shuffle in big-endian mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:100,Testability,test,test,100,"// Extract the run of set bits starting with bit zero from the bitwise; // inverse of ImmValue, and test that the inverse of this is the same; // as the original value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:59,Testability,test,test,59,"// Extract the run of set bits starting with bit zero, and test that the; // result is the same as the original value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:344,Testability,test,test,344,"// Manually match MipsISD::Ins nodes to get the correct instruction. It has; // to be done in this fashion so that we respect the differences between; // dins and dinsm, as the difference is that the size operand has the range; // 0 < size <= 32 for dins while dinsm has the range 2 <= size <= 64 which; // means SelectionDAGISel would have to test all the operands at once to; // match the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:3,Security,Validat,Validating,3,// Validating the node operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:352,Performance,load,load,352,"// Select appropriate ldi.[bhwd] instructions for constant splats of; // 128-bit when MSA is enabled. Fixup any register class mismatches that; // occur as a result.; //; // This allows the compiler to use a wider range of immediates than would; // otherwise be allowed. If, for example, v4i32 could only use ldi.h then; // it would not be possible to load { 0x01010101, 0x01010101, 0x01010101,; // 0x01010101 } without using a constant pool. This would be sub-optimal; // when // 'ldi.b wd, 1' is capable of producing that bit-pattern in the; // same set/ of registers. Similarly, ldi.h isn't capable of producing {; // 0x00000000, 0x00000001, 0x00000000, 0x00000001 } but 'ldi.d wd, 1' can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:19,Performance,perform,perform,19,// N32 and N64 can perform some tricks that O32 can't for signed 32 bit; // integers due to having 64bit registers. lui will cause the necessary; // zero/sign extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:39,Performance,perform,perform,39,"// If we have a 64 bit Splat value, we perform a similar sequence to the; // above:; //; // MIPS32: MIPS64:; // lui $res, %highest(val) lui $res, %highest(val); // ori $res, $res, %higher(val) ori $res, $res, %higher(val); // lui $res2, %hi(val) lui $res2, %hi(val); // ori $res2, %res2, %lo(val) ori $res2, %res2, %lo(val); // $res3 = fill $res2 dinsu $res, $res2, 0, 32; // $res4 = insert.w $res3[1], $res fill.d $res; // splat.d $res4, 0; //; // The ability to use dinsu is guaranteed as MSA requires MIPSR5.; // This saves having to materialize the value by shifts and ors.; //; // FIXME: Implement the preferred sequence for MIPS64R6:; //; // MIPS64R6:; // ori $res, $zero, %lo(val); // daui $res, $res, %hi(val); // dahi $res, $res, %higher(val); // dati $res, $res, %highest(cal); // fill.d $res; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:179,Performance,optimiz,optimization,179,"// Independent of whether we're targeting MIPS64 or not, the basic; // operations are the same. Also, directly use the $zero register if; // the 16 bit chunk is zero.; //; // For optimization purposes we always synthesize the splat value as; // an i32 value, then if we're targetting MIPS64, use SUBREG_TO_REG; // just before combining the values with dinsu to produce an i64. This; // enables SelectionDAG to aggressively share components of splat values; // where possible.; //; // FIXME: This is the general constant synthesis problem. This code; // should be factored out into a class shared between all the; // classes that need it. Specifically, for a splat size of 64; // bits that's a negative number we can do better than LUi/ORi; // for the upper 32bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h:51,Energy Efficiency,power,power,51,/// Select constant vector splats whose value is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h:71,Energy Efficiency,power,power,71,/// Select constant vector splats whose value is the inverse of a; /// power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:52,Integrability,Interface,Interface,52,"//===- MipsSEISelLowering.cpp - MipsSE DAG Lowering Interface -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips32/64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:36,Modifiability,extend,extending,36,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:46,Performance,load,loads,46,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:54,Security,access,access,54,"// MIPS32r6/MIPS64r6 is required to support unaligned access. It's; // implementation defined whether this is handled by hardware, software, or; // a hybrid of the two but it's expected that most implementations will; // handle the majority of cases in hardware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:286,Availability,redundant,redundant,286,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:67,Performance,Perform,Performs,67,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:241,Performance,perform,performed,241,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:312,Performance,perform,performed,312,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:286,Safety,redund,redundant,286,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Availability,Mask,Mask,3,// Mask+1 is not a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:19,Energy Efficiency,power,power,19,// Mask+1 is not a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the given node is an all-ones build_vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Testability,Test,Test,3,// Test whether N is the bitwise inverse of OfNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:120,Availability,mask,mask,120,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:161,Availability,mask,mask,161,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:222,Availability,mask,mask,222,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Performance,Perform,Perform,3,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:60,Performance,Perform,Performs,60,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:31,Availability,mask,mask,31,"// If Op0Op0 is an appropriate mask, try to find it's inverse in either; // Op1Op0, or Op1Op1. Keep track of the Cond, IfSet, and IfClr nodes, while; // looking.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:57,Availability,mask,mask,57,"// If IfClr is not yet set, and Op0Op1 is an appropriate mask, try the same; // thing again using this mask.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:103,Availability,mask,mask,103,"// If IfClr is not yet set, and Op0Op1 is an appropriate mask, try the same; // thing again using this mask.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:202,Availability,down,down,202,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:160,Energy Efficiency,power,powers,160,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:318,Performance,optimiz,optimization,318,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:394,Performance,optimiz,optimization,394,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:999,Performance,perform,perform,999,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1012,Performance,optimiz,optimization,1012,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1175,Performance,optimiz,optimization,1175,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:11,Energy Efficiency,power,power,11,"// If c is power of 2, return (shl x, log2(c)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:376,Availability,redundant,redundant,376,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:138,Performance,Perform,Performs,138,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:312,Performance,perform,performed,312,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:402,Performance,perform,performed,402,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:466,Performance,perform,performDSPShiftCombine,466,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:376,Safety,redund,redundant,376,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:23,Usability,clear,cleared,23,// Exception has to be cleared with eret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:30,Performance,load,load,30,// Replace a double precision load with two i32 loads and a buildpair64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:48,Performance,load,loads,48,// Replace a double precision load with two i32 loads and a buildpair64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:7,Performance,load,load,7,// i32 load from lower address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:7,Performance,load,load,7,// i32 load from higher address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:30,Performance,perform,performed,30,// v2i64 BUILD_VECTOR must be performed via v4i32 so split into i32's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:59,Modifiability,Extend,Extend,59,"// We couldnt constant fold, do a vector shift instead; // Extend i32 to i64 if necessary. Sign or zero extend doesn't matter since; // only values 0-63 are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:104,Modifiability,extend,extend,104,"// We couldnt constant fold, do a vector shift instead; // Extend i32 to i64 if necessary. Sign or zero extend doesn't matter since; // only values 0-63 are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:10,Availability,Mask,Mask,10,"// bsel_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:44,Availability,Mask,Mask,44,"// bsel_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:11,Availability,Mask,Mask,11,"// bseli_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:45,Availability,Mask,Mask,45,"// bseli_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:66,Availability,down,down,66,// If ResTy is v2i64 then the type legalizer will break this node down into; // an equivalent v4i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:78,Availability,mask,masks,78,"// We can't lower via VECTOR_SHUFFLE because it requires constant shuffle; // masks, nor can we lower via BUILD_VECTOR & EXTRACT_VECTOR_ELT because; // EXTRACT_VECTOR_ELT can't extract i64's on MIPS32.; // Instead we lower to MipsISD::VSHF and match from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:169,Modifiability,extend,extend,169,// Lower ISD::EXTRACT_VECTOR_ELT into MipsISD::VEXTRACT_SEXT_ELT.; //; // The non-value bits resulting from ISD::EXTRACT_VECTOR_ELT are undefined. We; // choose to sign-extend but we could have equally chosen zero-extend. The; // DAGCombiner will fold any sign/zero extension of the ISD::EXTRACT_VECTOR_ELT; // result into this node later (possibly changing it to a zero-extend in the; // process).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:214,Modifiability,extend,extend,214,// Lower ISD::EXTRACT_VECTOR_ELT into MipsISD::VEXTRACT_SEXT_ELT.; //; // The non-value bits resulting from ISD::EXTRACT_VECTOR_ELT are undefined. We; // choose to sign-extend but we could have equally chosen zero-extend. The; // DAGCombiner will fold any sign/zero extension of the ISD::EXTRACT_VECTOR_ELT; // result into this node later (possibly changing it to a zero-extend in the; // process).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:371,Modifiability,extend,extend,371,// Lower ISD::EXTRACT_VECTOR_ELT into MipsISD::VEXTRACT_SEXT_ELT.; //; // The non-value bits resulting from ISD::EXTRACT_VECTOR_ELT are undefined. We; // choose to sign-extend but we could have equally chosen zero-extend. The; // DAGCombiner will fold any sign/zero extension of the ISD::EXTRACT_VECTOR_ELT; // result into this node later (possibly changing it to a zero-extend in the; // process).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:205,Energy Efficiency,power,power,205,// Lowers ISD::BUILD_VECTOR into appropriate SelectionDAG nodes for the; // backend.; //; // Lowers according to the following rules:; // - Constant splats are legal as-is as long as the SplatBitSize is a power of; // 2 less than or equal to 64 and the value fits into a signed 10-bit; // immediate; // - Constant splats are lowered to bitconverted BUILD_VECTORs if SplatBitSize; // is a power of 2 less than or equal to 64 and the value does not fit into a; // signed 10-bit immediate; // - Non-constant splats are legal as-is.; // - Non-constant non-splats are lowered to sequences of INSERT_VECTOR_ELT.; // - All others are illegal and must be expanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:388,Energy Efficiency,power,power,388,// Lowers ISD::BUILD_VECTOR into appropriate SelectionDAG nodes for the; // backend.; //; // Lowers according to the following rules:; // - Constant splats are legal as-is as long as the SplatBitSize is a power of; // 2 less than or equal to 64 and the value fits into a signed 10-bit; // immediate; // - Constant splats are lowered to bitconverted BUILD_VECTORs if SplatBitSize; // is a power of 2 less than or equal to 64 and the value does not fit into a; // signed 10-bit immediate; // - Non-constant splats are legal as-is.; // - Non-constant non-splats are lowered to sequences of INSERT_VECTOR_ELT.; // - All others are illegal and must be expanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:269,Availability,mask,mask,269,"// Lower VECTOR_SHUFFLE into SHF (if possible).; //; // SHF splits the vector into blocks of four elements, then shuffles these; // elements according to a <4 x i2> constant (encoded as an integer immediate).; //; // It is therefore possible to lower into SHF when the mask takes the form:; // <a, b, c, d, a+4, b+4, c+4, d+4, a+8, b+8, c+8, d+8, ...>; // When undef's appear they are treated as if they were whatever value is; // necessary in order to fit the above forms.; //; // For example:; // %2 = shufflevector <8 x i16> %0, <8 x i16> undef,; // <8 x i32> <i32 3, i32 2, i32 1, i32 0,; // i32 7, i32 6, i32 5, i32 4>; // is lowered to:; // (SHF_H $w0, $w1, 27); // where the 27 comes from:; // 3 + (2 << 2) + (1 << 4) + (0 << 6)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask has an undef, replace it with the current index.; // Note that it might still be undef if the current index is also undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:54,Availability,mask,mask,54,// Check that non-undef values are the same as in the mask. If they; // aren't then give up,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:81,Availability,mask,mask,81,"// Determine whether VECTOR_SHUFFLE is a SPLATI.; //; // It is a SPLATI when the mask is:; // <x, x, x, ...>; // where x is any valid index.; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:176,Availability,mask,mask,176,"// Determine whether VECTOR_SHUFFLE is a SPLATI.; //; // It is a SPLATI when the mask is:; // <x, x, x, ...>; // where x is any valid index.; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:164,Availability,mask,mask,164,"// Lower VECTOR_SHUFFLE into ILVEV (if possible).; //; // ILVEV interleaves the even elements from each vector.; //; // It is possible to lower into ILVEV when the mask consists of two of the; // following forms interleaved:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 2, 2, 4, 4, ...>; // <0, n, 2, n+2, 4, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:432,Availability,mask,mask,432,"// Lower VECTOR_SHUFFLE into ILVEV (if possible).; //; // ILVEV interleaves the even elements from each vector.; //; // It is possible to lower into ILVEV when the mask consists of two of the; // following forms interleaved:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 2, 2, 4, 4, ...>; // <0, n, 2, n+2, 4, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:163,Availability,mask,mask,163,"// Lower VECTOR_SHUFFLE into ILVOD (if possible).; //; // ILVOD interleaves the odd elements from each vector.; //; // It is possible to lower into ILVOD when the mask consists of two of the; // following forms interleaved:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 1, 3, 3, 5, 5, ...>; // <1, n+1, 3, n+3, 5, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:435,Availability,mask,mask,435,"// Lower VECTOR_SHUFFLE into ILVOD (if possible).; //; // ILVOD interleaves the odd elements from each vector.; //; // It is possible to lower into ILVOD when the mask consists of two of the; // following forms interleaved:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 1, 3, 3, 5, 5, ...>; // <1, n+1, 3, n+3, 5, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:203,Availability,mask,mask,203,"// Lower VECTOR_SHUFFLE into ILVR (if possible).; //; // ILVR interleaves consecutive elements from the right (lowest-indexed) half of; // each vector.; //; // It is possible to lower into ILVR when the mask consists of two of the; // following forms interleaved:; // <0, 1, 2, ...>; // <n, n+1, n+2, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 1, 1, 2, 2, ...>; // <0, n, 1, n+1, 2, n+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:471,Availability,mask,mask,471,"// Lower VECTOR_SHUFFLE into ILVR (if possible).; //; // ILVR interleaves consecutive elements from the right (lowest-indexed) half of; // each vector.; //; // It is possible to lower into ILVR when the mask consists of two of the; // following forms interleaved:; // <0, 1, 2, ...>; // <n, n+1, n+2, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 1, 1, 2, 2, ...>; // <0, n, 1, n+1, 2, n+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:203,Availability,mask,mask,203,"// Lower VECTOR_SHUFFLE into ILVL (if possible).; //; // ILVL interleaves consecutive elements from the left (highest-indexed) half; // of each vector.; //; // It is possible to lower into ILVL when the mask consists of two of the; // following forms interleaved:; // <x, x+1, x+2, ...>; // <n+x, n+x+1, n+x+2, ...>; // where n is the number of elements in the vector and x is half n.; // For example:; // <x, x, x+1, x+1, x+2, x+2, ...>; // <x, n+x, x+1, n+x+1, x+2, n+x+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:515,Availability,mask,mask,515,"// Lower VECTOR_SHUFFLE into ILVL (if possible).; //; // ILVL interleaves consecutive elements from the left (highest-indexed) half; // of each vector.; //; // It is possible to lower into ILVL when the mask consists of two of the; // following forms interleaved:; // <x, x+1, x+2, ...>; // <n+x, n+x+1, n+x+2, ...>; // where n is the number of elements in the vector and x is half n.; // For example:; // <x, x, x+1, x+1, x+2, x+2, ...>; // <x, n+x, x+1, n+x+1, x+2, n+x+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:180,Availability,mask,mask,180,"// Lower VECTOR_SHUFFLE into PCKEV (if possible).; //; // PCKEV copies the even elements of each vector into the result vector.; //; // It is possible to lower into PCKEV when the mask consists of two of the; // following forms concatenated:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 2, 4, ..., 0, 2, 4, ...>; // <0, 2, 4, ..., n, n+2, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:459,Availability,mask,mask,459,"// Lower VECTOR_SHUFFLE into PCKEV (if possible).; //; // PCKEV copies the even elements of each vector into the result vector.; //; // It is possible to lower into PCKEV when the mask consists of two of the; // following forms concatenated:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 2, 4, ..., 0, 2, 4, ...>; // <0, 2, 4, ..., n, n+2, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:179,Availability,mask,mask,179,"// Lower VECTOR_SHUFFLE into PCKOD (if possible).; //; // PCKOD copies the odd elements of each vector into the result vector.; //; // It is possible to lower into PCKOD when the mask consists of two of the; // following forms concatenated:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 3, 5, ..., 1, 3, 5, ...>; // <1, 3, 5, ..., n+1, n+3, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:462,Availability,mask,mask,462,"// Lower VECTOR_SHUFFLE into PCKOD (if possible).; //; // PCKOD copies the odd elements of each vector into the result vector.; //; // It is possible to lower into PCKOD when the mask consists of two of the; // following forms concatenated:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 3, 5, ..., 1, 3, 5, ...>; // <1, 3, 5, ..., n+1, n+3, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:467,Energy Efficiency,reduce,reduces,467,"// Lower VECTOR_SHUFFLE into VSHF.; //; // This mostly consists of converting the shuffle indices in Indices into a; // BUILD_VECTOR and adding it as an operand to the resulting VSHF. There is; // also code to eliminate unused operands of the VECTOR_SHUFFLE. For example,; // if the type is v8i16 and all the indices are less than 8 then the second; // operand is unused and can be replaced with anything. We choose to replace it; // with the used operand since this reduces the number of instructions overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:61,Integrability,depend,depending,61,// Lower VECTOR_SHUFFLE into one of a number of instructions depending on the; // indices in the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:182,Performance,perform,performed,182,"// Emit the COPY_FW pseudo instruction.; //; // copy_fw_pseudo $fd, $ws, n; // =>; // copy_u_w $rt, $ws, $n; // mtc1 $rt, $fd; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is never valid; // for lane 1 because it would require FR=0 mode which isn't supported by MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:264,Performance,optimiz,optimization,264,"// Emit the COPY_FW pseudo instruction.; //; // copy_fw_pseudo $fd, $ws, n; // =>; // copy_u_w $rt, $ws, $n; // mtc1 $rt, $fd; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is never valid; // for lane 1 because it would require FR=0 mode which isn't supported by MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:189,Performance,perform,performed,189,"// Emit the COPY_FD pseudo instruction.; //; // copy_fd_pseudo $fd, $ws, n; // =>; // splati.d $wt, $ws, $n; // copy $fd, $wt:sub_64; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is always; // valid because FR=1 mode which is the only supported mode in MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:271,Performance,optimiz,optimization,271,"// Emit the COPY_FD pseudo instruction.; //; // copy_fd_pseudo $fd, $ws, n; // =>; // splati.d $wt, $ws, $n; // copy $fd, $wt:sub_64; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is always; // valid because FR=1 mode which is the only supported mode in MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:320,Energy Efficiency,allocate,allocated,320,"// Emit the ST_F16_PSEDUO instruction to store a f16 value from an MSA; // register.; //; // STF16 MSA128F16:$wd, mem_simm10:$addr; // =>; // copy_u.h $rtemp,$wd[0]; // sh $rtemp, $addr; //; // Safety: We can't use st.h & co as they would over write the memory after; // the destination. It would require half floats be allocated 16 bytes(!) of; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:194,Safety,Safe,Safety,194,"// Emit the ST_F16_PSEDUO instruction to store a f16 value from an MSA; // register.; //; // STF16 MSA128F16:$wd, mem_simm10:$addr; // =>; // copy_u.h $rtemp,$wd[0]; // sh $rtemp, $addr; //; // Safety: We can't use st.h & co as they would over write the memory after; // the destination. It would require half floats be allocated 16 bytes(!) of; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:14,Performance,load,load,14,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:64,Performance,load,load,64,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:342,Availability,fault,fault,342,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:41,Performance,load,load,41,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:355,Performance,load,load,355,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:441,Performance,load,load,441,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:186,Safety,Safe,Safety,186,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:14,Performance,load,load,14,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:64,Performance,load,load,64,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:97,Safety,Safe,Safety,97,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1297,Safety,Safe,Safety,1297,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1537,Safety,avoid,avoid,1537,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:477,Security,access,accessed,477,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the register class copy as mentioned above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:107,Safety,Safe,Safety,107,"// Emit the FPEXTEND_PSEUDO instruction.; //; // Expand an f16 to either a FGR32Opnd or FGR64Opnd.; //; // Safety: Cycle the result through the GPRs so the result always ends up; // the correct floating point register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fd; // / FGR64Opnd:$Fd and MSA128F16:$Ws to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship. I; // haven't checked.; //; // For FGR32Opnd:; //; // FPEXTEND FGR32Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // copy_s.w $rtemp, $ws[0]; // mtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips64:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.d $rtemp, $wtemp2s[0]; // dmtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips32:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.w $rtemp, $wtemp2[0]; // mtc1 $rtemp, $ftemp; // copy_s.w $rtemp2, $wtemp2[1]; // $fd = mthc1 $rtemp2, $ftemp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:497,Security,access,accessed,497,"// Emit the FPEXTEND_PSEUDO instruction.; //; // Expand an f16 to either a FGR32Opnd or FGR64Opnd.; //; // Safety: Cycle the result through the GPRs so the result always ends up; // the correct floating point register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fd; // / FGR64Opnd:$Fd and MSA128F16:$Ws to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship. I; // haven't checked.; //; // For FGR32Opnd:; //; // FPEXTEND FGR32Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // copy_s.w $rtemp, $ws[0]; // mtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips64:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.d $rtemp, $wtemp2s[0]; // dmtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips32:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.w $rtemp, $wtemp2[0]; // mtc1 $rtemp, $ftemp; // copy_s.w $rtemp2, $wtemp2[1]; // $fd = mthc1 $rtemp2, $ftemp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the safety regclass copy mentioned above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:15,Safety,safe,safety,15,// Perform the safety regclass copy mentioned above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h:50,Integrability,Interface,Interface,50,"//===- MipsSEISelLowering.h - MipsSE DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips32/64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h:67,Integrability,depend,depending,67,/// Lower VECTOR_SHUFFLE into one of a number of instructions; /// depending on the indices in the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:54,Performance,load,load,54,/// Get the size of the offset supported by the given load/store/inline asm.; /// The result includes the effects of any scale factors applied to the; /// instruction immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:63,Performance,load,load,63,/// Get the scale factor applied to the immediate in the given load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:133,Energy Efficiency,allocate,allocated,133,// The following stack frame objects are always referenced relative to $sp:; // 1. Outgoing arguments.; // 2. Pointer to dynamically allocated stack space.; // 3. Locations for callee-saved registers.; // 4. Locations for eh data registers.; // 5. Locations for ISR saved Coprocessor 0 registers 12 & 14.; // Everything else is referenced relative to whatever register; // getFrameRegister() returns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:167,Energy Efficiency,allocate,allocated,167,"// Calculate final offset.; // - There is no need to change the offset if the frame object is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following, its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:399,Modifiability,variab,variable,399,"// Calculate final offset.; // - There is no need to change the offset if the frame object is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following, its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:42,Availability,avail,available,42,"// Make sure Offset fits within the field available.; // For MSA instructions, this is a 10-bit signed immediate (scaled by; // element size), otherwise it is a 16-bit signed immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:23,Testability,test,tested,23,// MIPS-I has not been tested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:107,Deployability,integrat,integrated,107,// Don't even attempt to generate code for MIPS-V. It has not; // been tested and currently exists for the integrated assembler only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:107,Integrability,integrat,integrated,107,// Don't even attempt to generate code for MIPS-V. It has not; // been tested and currently exists for the integrated assembler only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:71,Testability,test,tested,71,// Don't even attempt to generate code for MIPS-V. It has not; // been tested and currently exists for the integrated assembler only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing dsp warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing msa warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing crc warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing ginv warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing Mips1 warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing virt warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:3,Performance,Optimiz,Optimize,3,// Optimize for space by compiling all functions as Mips 16 unless; // it needs floating point. Functions needing floating point are; // compiled as Mips32,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:7,Safety,hazard,hazard,7,// Use hazard variants of the jump register instructions for indirect; // function calls and jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:198,Integrability,rout,routines,198,// Hard float for mips16 means essentially to compile as soft float; // but to use a runtime library for soft float that is written with; // native mips32 floating point instructions (those runtime routines; // run in mips32 hard float mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:45,Security,access,access,45,"/// Does the system support unaligned memory access.; ///; /// MIPS32r6/MIPS64r6 require full unaligned access support but does not; /// specify which component of the system provides it. Hardware, software, and; /// hybrid implementations are all valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:104,Security,access,access,104,"/// Does the system support unaligned memory access.; ///; /// MIPS32r6/MIPS64r6 require full unaligned access support but does not; /// specify which component of the system provides it. Hardware, software, and; /// hybrid implementations are all valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:31,Availability,avail,available,31,// 32 bit registers are always available and the stack is at least 64 bit; // aligned. On N64 64 bit registers are also available and the stack is; // 128 bit aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:120,Availability,avail,available,120,// 32 bit registers are always available and the stack is at least 64 bit; // aligned. On N64 64 bit registers are also available and the stack is; // 128 bit aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:29,Deployability,Configurat,Configuration,29,/// Mips Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:29,Modifiability,Config,Configuration,29,/// Mips Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:94,Availability,avail,available,94,"// The current implementation of long branch pass requires a scratch; // register ($at) to be available before branch instructions. Tail merging; // can break this requirement, so disable it when long branch pass is; // enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector pass using; // the ISelDag to gen Mips code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:37,Performance,perform,performs,37,// The microMIPS size reduction pass performs instruction reselection for; // instructions which can be remapped to a 16 bit instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:69,Safety,hazard,hazards,69,// The delay slot filler pass can potientially create forbidden slot hazards; // for MIPSR6 and therefore it should go before MipsBranchExpansion pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:221,Modifiability,extend,extending,221,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:70,Safety,hazard,hazards,70,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:140,Safety,hazard,hazards,140,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:180,Safety,hazard,hazard,180,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:460,Safety,hazard,hazards,460,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:21,Performance,load,loaded,21,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section must be addressed using; // gp_rel operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:34,Availability,avail,available,34,// Return if small section is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:15,Modifiability,variab,variables,15,"// Only global variables, not functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:10,Modifiability,variab,variable,10,"// If the variable has an explicit section, it is placed in that section but; // it's addressing mode may change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:26,Modifiability,variab,variable,26,// Explicitly placing any variable in the small data section overrides; // the global -G value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:20,Security,access,accessing,20,"// Otherwise reject accessing it through the gp pointer. There are some; // historic cases which GCC doesn't appear to respect any more. These; // are .lit4, .lit8 and .srdata. For the moment reject these as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.h:19,Modifiability,variab,variable,19,/// Describe a TLS variable address within debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:360,Availability,avail,available,360,/// Emit a store instruction with an offset. If the offset is out of range; /// then it will be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:402,Availability,error,error,402,/// Emit a store instruction with an offset. If the offset is out of range; /// then it will be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:348,Availability,avail,available,348,/// Emit a .cprestore directive. If the offset is out of range then it will; /// be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:390,Availability,error,error,390,/// Emit a .cprestore directive. If the offset is out of range then it will; /// be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:241,Availability,mask,mask,241,// Set of features that are either architecture features or referenced; // by them (e.g.: FeatureNaN2008 implied by FeatureMips32r6).; // The full table can be found in MipsGenSubtargetInfo.inc (MipsFeatureKV[]).; // The reason we need this mask is explained in the selectArch function.; // FIXME: Ideally we would like TableGen to generate this information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,Integrability,message,message,41,// Print a warning along with its fix-it message at the given range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:136,Availability,error,error,136,/// Returns the internal register number for the current AT. Also checks if; /// the current AT is unavailable (set to $0) and gives an error if it is.; /// This should be used in pseudo-instruction expansions which need AT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:233,Deployability,Toggle,ToggleFeature,233,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:400,Deployability,Toggle,ToggleFeature,400,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:104,Integrability,depend,dependencies,104,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:316,Integrability,depend,dependencies,316,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:137,Usability,clear,clears,137,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:348,Usability,clear,clear,348,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:423,Usability,clear,clears,423,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:472,Usability,clear,cleared,472,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:534,Usability,clear,cleared,534,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:1062,Usability,Clear,Clearing,1062,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:1094,Usability,clear,clear,1094,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:21,Integrability,depend,depending,21,/// GPR32 and GPR64 (depending on isGP64bit()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:26,Integrability,depend,depending,26,"/// FGR32, FGR64, AFGR64 (depending on context and; /// isFP64bit())",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:36,Integrability,depend,depending,36,"/// HI32DSP, LO32DSP, and ACC64DSP (depending on; /// context).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:6,Usability,simpl,simple,6,/// A simple token,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:52,Testability,Assert,Asserts,52,"/// Render the operand to an MCInst as a GPR32; /// Asserts if the wrong number of operands are requested, or the operand; /// is not a k_RegisterIndex compatible with RegKind_GPR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:52,Testability,Assert,Asserts,52,"/// Render the operand to an MCInst as a GPR64; /// Asserts if the wrong number of operands are requested, or the operand; /// is not a k_RegisterIndex compatible with RegKind_GPR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:109,Availability,failure,failure,109,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Deployability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Integrability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Deployability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Integrability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:9,Performance,optimiz,optimization,9,"// As an optimization hint for the linker, before the JALR we add:; // .reloc tmplabel, R_{MICRO}MIPS_JALR, symbol; // tmplabel:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:36,Performance,load,load,36,// Try to create 16-bit GP relative load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:6,Performance,load,load,6,// if load; // TODO: Handle this with the AsmOperandClass.PredicateMethod.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:152,Safety,avoid,avoiding,152,"// When 'FillDelaySlot' is true, the existing logic will add; // noreorder before instruction and reorder after it. So there; // need exclude this case avoiding two '.set reorder'.; // The format of the first case is:; // .set noreorder; // bnezc; // nop; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:46,Testability,log,logic,46,"// When 'FillDelaySlot' is true, the existing logic will add; // noreorder before instruction and reorder after it. So there; // need exclude this case avoiding two '.set reorder'.; // The format of the first case is:; // .set noreorder; // bnezc; // nop; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:201,Integrability,wrap,wrap,201,// Save current instruction`s forbidden slot and whether set reorder.; // This is the judgment condition for whether to add nop.; // We would add a couple of '.set noreorder' and '.set reorder' to; // wrap the current instruction and the next instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,Availability,recover,recover,41,"// When current instruction was not CTI, recover reorder state.; // The format of the second case is:; // .set noreoder; // bnezc; // add; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,Safety,recover,recover,41,"// When current instruction was not CTI, recover reorder state.; // The format of the second case is:; // .set noreoder; // bnezc; // add; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Performance,Load,Load,3,// Load the $gp from the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:47,Availability,recover,recover,47,"// If has pending forbidden slot, fill nop and recover reorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:47,Safety,recover,recover,47,"// If has pending forbidden slot, fill nop and recover reorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4,Performance,Load,Load,4,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:91,Performance,load,load,91,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:244,Usability,simpl,simple,244,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:8,Modifiability,extend,extend,8,"// Sign extend up to 64-bit so that the predicates match the hardware; // behaviour. In particular, isInt<16>(0xffff8000) and similar should be; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Availability,avail,available,83,// At this point we need AT to perform the expansions and we exit if it is; // not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,Performance,perform,perform,31,// At this point we need AT to perform the expansions and we exit if it is; // not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:99,Availability,mask,masks,99,// Traditional behaviour seems to special case this particular value. It's; // not clear why other masks are handled differently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Usability,clear,clear,83,// Traditional behaviour seems to special case this particular value. It's; // not clear why other masks are handled differently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:51,Modifiability,extend,extending,51,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:40,Safety,avoid,avoid,40,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:200,Performance,load,load,200,// The remaining case is packed with a sequence of dsll and ori with zeros; // being omitted and any neighbouring dsll's being coalesced.; // The highest 32-bit's are equivalent to a 32-bit immediate load.; // Load bits 32-63 of ImmValue into bits 0-31 of the temporary register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:210,Performance,Load,Load,210,// The remaining case is packed with a sequence of dsll and ori with zeros; // being omitted and any neighbouring dsll's being coalesced.; // The highest 32-bit's are equivalent to a 32-bit immediate load.; // Load bits 32-63 of ImmValue into bits 0-31 of the temporary register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:22,Usability,usab,usable,22,// la can't produce a usable address when addresses are 64-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:66,Availability,avail,available,66,"// If $rs is the same as $rd, we need to use AT.; // If it is not available we exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:73,Performance,load,loaded,73,"// FIXME: In case of N32 / N64 ABI and emabled XGOT, local addresses; // loaded using R_MIPS_GOT_PAGE / R_MIPS_GOT_OFST pair of relocations.; // FIXME: Implement XGOT for microMIPS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:255,Availability,redundant,redundant,255,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Performance,Load,Loading,3,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:255,Safety,redund,redundant,255,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:197,Availability,redundant,redundant,197,"// The remaining cases are:; // Small offset: ld $tmp, %got_disp(symbol)($gp); // >daddiu $tmp, $tmp, offset; // >daddu $rd, $tmp, $rs; // The daddiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:197,Safety,redund,redundant,197,"// The remaining cases are:; // Small offset: ld $tmp, %got_disp(symbol)($gp); // >daddiu $tmp, $tmp, offset; // >daddu $rd, $tmp, $rs; // The daddiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:110,Modifiability,extend,extended,110,// FIXME: Offsets greater than 16 bits are not yet implemented.; // FIXME: The correct range is a 32-bit sign-extended number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:311,Availability,redundant,redundant,311,"// The remaining cases are:; // External GOT: lw $tmp, %got(symbol)($gp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // Local GOT: lw $tmp, %got(symbol+offset)($gp); // addiu $tmp, $tmp, %lo(symbol+offset)($gp); // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:311,Safety,redund,redundant,311,"// The remaining cases are:; // External GOT: lw $tmp, %got(symbol)($gp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // Local GOT: lw $tmp, %got(symbol+offset)($gp); // addiu $tmp, $tmp, %lo(symbol+offset)($gp); // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:184,Availability,avail,available,184,// We need AT for the 64-bit expansion in the cases where the optional; // source register is the destination register and for the superscalar; // scheduled form.; //; // If it is not available we exit if the destination is the same as the; // source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:147,Energy Efficiency,schedul,scheduled,147,// We need AT for the 64-bit expansion in the cases where the optional; // source register is the destination register and for the superscalar; // scheduled form.; //; // If it is not available we exit if the destination is the same as the; // source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:82,Availability,avail,available,82,"// If the $rs is different from $rd or if $rs isn't specified and we; // have $at available:; // (d)la $rd, sym/sym($rs) => lui $rd, %highest(sym); // lui $at, %hi(sym); // daddiu $rd, $rd, %higher(sym); // daddiu $at, $at, %lo(sym); // dsll32 $rd, $rd, 0; // daddu $rd, $rd, $at; // (daddu $rd, $rd, $rs); //; // Which is preferred for superscalar issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:67,Availability,avail,available,67,"// We have a case where SrcReg == DstReg and we don't have $at; // available. We can't expand this case, so error out appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:108,Availability,error,error,108,"// We have a case where SrcReg == DstReg and we don't have $at; // available. We can't expand this case, so error out appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:66,Availability,avail,available,66,"// If $rs is the same as $rd, we need to use AT.; // If it is not available we exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:198,Integrability,depend,depending,198,"// Each double-precision register DO-D15 overlaps with two of the single; // precision registers F0-F31. As an example, all of the following hold true:; // D0 + 1 == F1, F1 + 1 == D1, F1 + 1 == F2, depending on the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:399,Performance,load,load,399,"// FIXME: This method is too general. In principle we should compute the number; // of instructions required to synthesize the immediate inline compared to; // synthesizing the address inline and relying on non .text sections.; // For static O32 and N32 this may yield a small benefit, for static N64 this is; // likely to yield a much larger benefit as we have to synthesize a 64bit; // address to load a 64 bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:367,Modifiability,extend,extended,367,"// FIXME: This is technically correct but gives a different result to gas,; // but gas is incomplete there (it has a fixme noting it doesn't work with; // 64-bit addresses).; // FIXME: With -msym32 option, the address expansion for N64 should probably; // use the O32 / N32 case. It's safe to use the 64 address expansion as the; // symbol's value is considered sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:285,Safety,safe,safe,285,"// FIXME: This is technically correct but gives a different result to gas,; // but gas is incomplete there (it has a fixme noting it doesn't work with; // 64-bit addresses).; // FIXME: With -msym32 option, the address expansion for N64 should probably; // use the O32 / N32 case. It's safe to use the 64 address expansion as the; // symbol's value is considered sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:10,Modifiability,Enhance,Enhance,10,// FIXME: Enhance this expansion to use the .lit4 & .lit8 sections; // where appropriate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:10,Modifiability,Enhance,Enhance,10,// FIXME: Enhance this expansion to use the .lit4 & .lit8 sections; // where appropriate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Availability,avail,available,83,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,Performance,perform,perform,31,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:215,Energy Efficiency,reduce,reduce,215,// FIXME:; // c) Check that immediates of R_MIPS_GOT16/R_MIPS_LO16 relocations; // do not exceed 16-bit.; // d) Use R_MIPS_GOT_PAGE/R_MIPS_GOT_OFST relocations instead; // of R_MIPS_GOT_DISP in appropriate cases to reduce number; // of GOT entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:12,Performance,load,load,12,// Emit the load or store with the adjusted base and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Availability,avail,available,83,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,Performance,perform,perform,31,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:138,Energy Efficiency,efficient,efficient,138,"// FIXME: All of these Opcode-specific if's are needed for compatibility; // with GAS' behaviour. However, they may not generate the most efficient; // code in some circumstances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:557,Modifiability,variab,variable,557,"// If the $rs is $0 and the pseudo-branch is BLTU (0 < x) or; // if the $rt is $0 and the pseudo-branch is BGTU (x > 0),; // the pseudo-branch will be taken only when the non-zero register is; // different from 0, so we emit a BNEZ.; //; // If the $rs is $0 and the pseudo-branch is BGEU (0 >= x) or; // if the $rt is $0 and the pseudo-branch is BLEU (x <= 0),; // the pseudo-branch will be taken only when the non-zero register is; // equal to 0, so we emit a BEQZ.; //; // Because only BLEU and BGEU branch on equality, we can use the; // AcceptsEquality variable to decide when to emit the BEQZ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:103,Availability,avail,available,103,"// If neither the SrcReg nor the TrgReg are $0, we need AT to perform the; // expansions. If it is not available, we return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:62,Performance,perform,perform,62,"// If neither the SrcReg nor the TrgReg are $0, we need AT to perform the; // expansions. If it is not available, we return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:540,Modifiability,variab,variable,540,"// SLT fits well with 2 of our 4 pseudo-branches:; // BLT, where $rs < $rt, translates into ""slt $at, $rs, $rt"" and; // BGT, where $rs > $rt, translates into ""slt $at, $rt, $rs"".; // If the result of the SLT is 1, we branch, and if it's 0, we don't.; // This is accomplished by using a BNEZ with the result of the SLT.; //; // The other 2 pseudo-branches are opposites of the above 2 (BGE with BLT; // and BLE with BGT), so we change the BNEZ into a BEQZ.; // Because only BGE and BLE branch on equality, we can use the; // AcceptsEquality variable to decide when to emit the BEQZ.; // Note that the order of the SLT arguments doesn't change between; // opposites.; //; // The same applies to the unsigned variants, except that SLTu is used; // instead of SLT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:190,Performance,optimiz,optimization,190,"// If the macro expansion of (d)div(u) or (d)rem(u) would always trap or; // break, insert the trap/break and exit. This gives a different result to; // GAS. GAS has an inconsistency/missed optimization in that not all cases; // are handled equivalently. As the observed behaviour is the same, we're ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:22,Performance,load,load,22,// Compute left/right load/store offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:7,Performance,load,loads,7,"// For loads, clobber the base register with the second load instead of the; // first if the BaseReg == FirstReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:56,Performance,load,load,56,"// For loads, clobber the base register with the second load instead of the; // first if the BaseReg == FirstReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:293,Performance,perform,performs,293,"// As described the MIPSR6 spec, the compact branches that compare registers; // must:; // a) Not use the zero register.; // b) Not use the same register twice.; // c) rs < rt for bnec, beqc.; // NB: For this case, the encoding will swap the operands as their; // ordering doesn't matter. GAS performs this transformation too.; // Hence, that constraint does not have to be enforced.; //; // The compact branches that branch iff the signed addition of two registers; // would overflow must have rs >= rt. That can be handled like beqc/bnec with; // operand swapping. They do not have restriction of using the zero register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:84,Safety,avoid,avoid,84,// This is used on UImm5 operands that have a corresponding UImm5_32; // operand to avoid confusing the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:181,Availability,error,error,181,"// AFAIK, we only support numeric registers and named GPR's in CFI; // directives.; // Don't worry about eating tokens before failing. Using an unrecognised; // register is a parse error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:75,Integrability,rout,routine,75,"// If symbol is unset, it might be created in the `parseSetAssignment`; // routine as an alias for a numeric register name.; // Lookup in the aliases list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:12,Availability,error,error,12,"// Show the error, but treat invalid register; // number as a normal one to continue parsing; // and catch other possible errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:122,Availability,error,errors,122,"// Show the error, but treat invalid register; // number as a normal one to continue parsing; // and catch other possible errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:20,Performance,load,load,20,"/// Sometimes (i.e. load/stores) the operand may be followed immediately by; /// either this.; /// ::= '(', register, ')'; /// handle it before we iterate so we don't get tripped up by the lack of; /// a comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:206,Availability,error,error,206,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:115,Testability,test,tested,115,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:125,Testability,test,test,125,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:179,Testability,test,test,179,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:70,Availability,error,error,70,"// Eat ""noat"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:69,Availability,error,error,69,"// Eat ""reg"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:71,Availability,error,error,71,"// Eat ""nodsp"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:74,Availability,error,error,74,"// Eat ""nomips3d"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,Availability,error,error,72,"// Eat ""mips16"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:74,Availability,error,error,74,"// Eat ""nomips16"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:68,Availability,error,error,68,"// Eat ""mt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:70,Availability,error,error,70,"// Eat ""nomt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:71,Availability,error,error,71,"// Eat ""nocrc"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,Availability,error,error,72,"// Eat ""novirt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,Availability,error,error,72,"// Eat ""noginv"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:113,Availability,error,error,113,"// If we don't recognize the option passed to the .nan; // directive (e.g. no option or unknown option), emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:23,Integrability,message,message,23,// TODO : get a better message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated abiflags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted at the end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated abiflags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted at the end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated abiflags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted at the end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:135,Availability,error,error,135,// This returns false if this function recognizes the directive; // regardless of whether it is successfully handles or reports an; // error. Otherwise it returns true to give the generic parser a; // chance at recognizing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:14,Usability,undo,undocumented,14,"// There's an undocumented extension that allows an integer to; // follow the name of the procedure which AFAICS is ignored by GAS.; // Example: .ent foo,2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:287,Availability,error,error,287,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:293,Integrability,message,messages,293,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:263,Modifiability,extend,extended,263,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:30,Usability,undo,undocumented,30,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:110,Availability,error,error,110,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:116,Integrability,message,messages,116,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:48,Modifiability,extend,extended,48,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4,Availability,mask,mask,4,"// .mask bitmask, frame_offset; // bitmask: One bit for each register used.; // frame_offset: Offset from Canonical Frame Address ($sp on entry) where; // first register is expected to be saved.; // Examples:; // .mask 0x80000000, -4; // .fmask 0x80000000, -4; //; // Parse the bitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:214,Availability,mask,mask,214,"// .mask bitmask, frame_offset; // bitmask: One bit for each register used.; // frame_offset: Offset from Canonical Frame Address ($sp on entry) where; // first register is expected to be saved.; // Examples:; // .mask 0x80000000, -4; // .fmask 0x80000000, -4; //; // Parse the bitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:133,Availability,down,down,133,// end anonymous namespace; // Forward declare these because the autogenerated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:27,Integrability,depend,depends,27,// The size of the n field depends on the element size; // The register class also depends on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:83,Integrability,depend,depends,83,// The size of the n field depends on the element size; // The register class also depends on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:132,Testability,log,logic,132,"// Attempt to read the instruction so that we can attempt to decode it. If; // the buffer is not 4 bytes long, let the higher level logic figure out; // what to do with a size of zero and MCDisassembler::Fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h:3,Availability,Mask,Mask,3,// Mask of ASEs used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h:33,Modifiability,variab,variable,33,/// The registers to use for the variable argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h:32,Energy Efficiency,allocate,allocated,32,/// Obtain the size of the area allocated by the callee for arguments.; /// CallingConv::FastCall affects the value for O32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:164,Availability,error,error,164,"/// WriteNopData - Write an (optimal) nop sequence of Count bytes; /// to the given output. If the target cannot generate such a sequence,; /// it should return an error.; ///; /// \return - True on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h:28,Integrability,Interface,Interfaces,28,/// @name Target Relaxation Interfaces; /// @{; /// fixupNeedsRelaxation - Target specific predicate for whether a given; /// fixup requires the associated instruction to be relaxed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsBaseInfo.h:338,Availability,toler,tolerated,338,"//===------------------------------------------------------------------===//; // Instruction encodings. These are the standard/most common forms for; // Mips instructions.; //; // Pseudo - This represents an instruction that is a pseudo instruction; // or one that has not been implemented yet. It is illegal to code generate; // it, but tolerated for intermediate implementation stages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:1578,Performance,load,loading,1578,"equired by the MIPS ABI.; ///; /// MIPS has a few relocations that have an AHL component in the expression used; /// to evaluate them. This AHL component is an addend with the same number of; /// bits as a symbol value but not all of our ABI's are able to supply a; /// sufficiently sized addend in a single relocation.; ///; /// The O32 ABI for example, uses REL relocations which store the addend in the; /// section data. All the relocations with AHL components affect 16-bit fields; /// so the addend for a single relocation is limited to 16-bit. This ABI; /// resolves the limitation by linking relocations (e.g. R_MIPS_HI16 and; /// R_MIPS_LO16) and distributing the addend between the linked relocations. The; /// ABI mandates that such relocations must be next to each other in a; /// particular order (e.g. R_MIPS_HI16 must be immediately followed by a; /// matching R_MIPS_LO16) but the rule is less strict in practice.; ///; /// The de facto standard is lenient in the following ways:; /// - 'Immediately following' does not refer to the next relocation entry but; /// the next matching relocation.; /// - There may be multiple high parts relocations for one low part relocation.; /// - There may be multiple low part relocations for one high part relocation.; /// - The AHL addend in each part does not have to be exactly equal as long as; /// the difference does not affect the carry bit from bit 15 into 16. This is; /// to allow, for example, the use of %lo(foo) and %lo(foo+4) when loading; /// both halves of a long long.; ///; /// See getMatchingLoType() for a description of which high part relocations; /// match which low part relocations. One particular thing to note is that; /// R_MIPS_GOT16 and similar only have AHL addends if they refer to local; /// symbols.; ///; /// It should also be noted that this function is not affected by whether; /// the symbol was kept or rewritten into a section-relative equivalent. We; /// always match using the expressions from the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:194,Safety,safe,safe,194,"// On REL ABI's (e.g. O32), these relocations form pairs. The pairing is done; // by the static linker by matching the symbol and offset.; // We only see one relocation at a time but it's still safe to relocate with; // the section so long as both relocations make the same decision.; //; // Some older linkers may require the symbol for particular cases. Such cases; // are not supported yet but can be added as required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:23,Safety,safe,safe,23,// FIXME: It should be safe to return false for the STO_MIPS_MICROMIPS but; // we neglect to handle the adjustment to the LSB of the addend that; // it causes in applyFixup() and similar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:106,Safety,safe,safe,106,// FIXME: Many of these relocations should probably return false but this; // hasn't been confirmed to be safe yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:91,Deployability,integrat,integrated,91,// FIXME: Many of these should probably return false but MIPS16 isn't; // supported by the integrated assembler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:91,Integrability,integrat,integrated,91,// FIXME: Many of these should probably return false but MIPS16 isn't; // supported by the integrated assembler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h:43,Safety,avoid,avoid,43,// Overriding these functions allows us to avoid recording of these labels; // in EmitLabel and later marking them as microMIPS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp:3,Performance,Load,Load,3,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction had reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp:75,Performance,load,loaded,75,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction had reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp:38,Performance,load,load,38,// when using stack locations for not load/store instructions; // print the same way as all normal 3 operand instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h:116,Integrability,depend,dependencies,116,// These enumeration declarations were originally in MipsInstrInfo.h but; // had to be moved here to avoid circular dependencies between; // LLVMMipsCodeGen and LLVMMipsAsmPrinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h:101,Safety,avoid,avoid,101,// These enumeration declarations were originally in MipsInstrInfo.h but; // had to be moved here to avoid circular dependencies between; // LLVMMipsCodeGen and LLVMMipsAsmPrinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:121,Integrability,rout,routine,121,"// end namespace llvm; // If the D<shift> instruction has a shift amount that is greater; // than 31 (checked in calling routine), lower it to a D<shift>32 instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:27,Integrability,synchroniz,synchronized,27,// Calling function is not synchronized,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:217,Energy Efficiency,efficient,efficient,217,"// Non-pseudo instructions that get changed for direct object; // only based on operand values.; // If this list of instructions get much longer we will move; // the check to a function call. Until then, this is more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h:13,Modifiability,sandbox,sandbox,13,// NaCl MIPS sandbox's instruction bundle size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h:13,Testability,sandbox,sandbox,13,// NaCl MIPS sandbox's instruction bundle size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:516,Availability,mask,masking,516,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:626,Availability,mask,masking,626,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:721,Availability,mask,mask,721,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:488,Modifiability,sandbox,sandbox,488,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:582,Security,access,access,582,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:488,Testability,sandbox,sandbox,488,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:58,Availability,mask,mask,58,/// Extend the generic MCELFStreamer class so that it can mask dangerous; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:4,Modifiability,Extend,Extend,4,/// Extend the generic MCELFStreamer class so that it can mask dangerous; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:26,Modifiability,sandbox,sandboxing,26,// Whether we started the sandboxing sequence for calls. Calls are bundled; // with branch delays and aligned to the bundle end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:26,Testability,sandbox,sandboxing,26,// Whether we started the sandboxing sequence for calls. Calls are bundled; // with branch delays and aligned to the bundle end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:62,Availability,mask,mask,62,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:46,Availability,mask,mask,46,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:18,Security,access,access,18,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:18,Security,access,access,18,// Sandbox memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox SP change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox SP change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:105,Availability,mask,mask,105,/// This function is the one used to emit instruction data into the ELF; /// streamer. We override it to mask dangerous instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox indirect jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox indirect jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,"// Sandbox loads, stores and SP changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:11,Performance,load,loads,11,"// Sandbox loads, stores and SP changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,"// Sandbox loads, stores and SP changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:103,Availability,mask,mask,103,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:13,Modifiability,sandbox,sandboxing,13,// Start the sandboxing sequence by emitting call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:13,Testability,sandbox,sandboxing,13,// Start the sandboxing sequence by emitting call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:14,Modifiability,sandbox,sandboxing,14,// Finish the sandboxing sequence by emitting branch delay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:14,Testability,sandbox,sandboxing,14,// Finish the sandboxing sequence by emitting branch delay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:15,Modifiability,sandbox,sandboxing,15,"// None of the sandboxing applies, just emit the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:15,Testability,sandbox,sandboxing,15,"// None of the sandboxing applies, just emit the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Performance,Load,Load,3,// Load instructions with base address register in position 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:65,Availability,mask,masking,65,// The contents of SP and thread pointer register do not require masking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:11,Performance,load,load,11,/// Emit a load instruction with an immediate offset. DstReg and TmpReg are; /// permitted to be the same register iff DstReg is distinct from BaseReg and; /// DstReg is a GPR. It is the callers responsibility to identify such cases; /// and pass the appropriate register in TmpReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:12,Performance,load,load,12,// Emit the load with the adjusted base and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:495,Integrability,depend,dependency,495,"// Set the header flags that we can in the constructor.; // FIXME: This is a fairly terrible hack. We set the rest; // of these in the destructor. The problem here is two-fold:; //; // a: Some of the eflags can be set/reset by directives.; // b: There aren't any usage paths that initialize the ABI; // pointer until after we initialize either an assembler; // or the target machine.; // We can fix this by making the target streamer construct; // the ABI, but this is fraught with wide ranging dependency; // issues as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:260,Availability,failure,failure,260,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:16,Integrability,depend,dependency,16,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:250,Testability,assert,assertion,250,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:3,Deployability,Update,Update,3,// Update e_header flags. See the FIXME and comment above in; // the constructor for a full rundown on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:65,Security,access,access,65,"// The ELFObjectWriter can determine the absolute size as it has access to; // the layout information of the assembly file, so a size expression rather; // than an absolute value is ok here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:99,Security,access,accessed,99,"// There's a GNU extension controlled by -mno-shared that allows; // locally-binding symbols to be accessed using absolute addresses.; // This is currently not supported. When supported -mno-shared makes; // .cpload expand to:; // lui $gp, %hi(__gnu_local_gp); // addiu $gp, $gp, %lo(__gnu_local_gp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430.h:28,Integrability,interface,interface,28,"//==-- MSP430.h - Top-level interface for MSP430 representation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM MSP430 backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430AsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- MSP430AsmPrinter.cpp - MSP430 LLVM assembly writer ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the MSP430 assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:36,Usability,Guid,Guide,36,"// According to CC430 Family User's Guide, Section 4.5.1.3, branch; // instructions have the signed 10-bit word offset field, so first we need to; // convert the distance from bytes to words, then check if it fits in 10-bit; // signed integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:3,Deployability,Update,Update,3,// Update the successor lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:73,Safety,safe,safer,73,"// It may be not necessary to start all over at this point, but it's; // safer do this anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:148,Deployability,Update,Update,148,// Get the offset of the stack slot for the EBP register... which is; // guaranteed to be the last slot by processFunctionBeforeFrameFinalized.; // Update the frame offset adjustment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:3,Deployability,Update,Update,3,// Update FP with the new base value...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:13,Performance,perform,performing,13,"// If we are performing frame pointer elimination and if the callee pops; // something off the stack pointer, add it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.h:4,Integrability,Wrap,Wraps,4,/// Wraps up getting a CFI index and building a MachineInstr for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:116,Energy Efficiency,schedul,scheduling,116,"/// createMSP430ISelDag - This pass converts a legalized DAG into a; /// MSP430-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:122,Availability,down,down,122,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:43,Integrability,Wrap,Wrapper,43,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:92,Integrability,wrap,wrap,92,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:59,Usability,clear,clear,59,"// Handle ""X | C"" as ""X + C"" iff X is known to have C bits clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:56,Performance,load,loads,56,// FIXME: Is this correct?; // We have post-incremented loads / stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:20,Energy Efficiency,efficient,efficiently,20,// FIXME: Implement efficiently multiplication by a constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:25,Testability,test,test,25,// Implemented to verify test case assertions in; // tests/codegen/msp430/shift-amount-threshold-b.ll,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:35,Testability,assert,assertions,35,// Implemented to verify test case assertions in; // tests/codegen/msp430/shift-amount-threshold-b.ll,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:53,Testability,test,tests,53,// Implemented to verify test case assertions in; // tests/codegen/msp430/shift-amount-threshold-b.ll,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:48,Performance,optimiz,optimization,48,// MSP430 target does not yet support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:94,Performance,load,load,94,/// LowerCCCArguments - transform physical registers into virtual registers and; /// generate load operations for arguments places on the stack.; // FIXME: struct return stuff,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:85,Testability,assert,assert,85,"// If this is an 8-bit value, it is really passed promoted to 16; // bits. Insert an assert[sz]ext to capture this, then truncate to the; // right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Performance,Load,Load,3,// Load the argument to a virtual register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; //from this parameter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:61,Safety,avoid,avoiding,61,"// Guarantee that all emitted copies are stuck together,; // avoiding something bad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:24,Performance,optimiz,optimization,24,"// aka COND_Z; // Minor optimization: if LHS is a constant, swap operands, then the; // constant can be folded into comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:25,Performance,optimiz,optimization,25,"// aka COND_NZ; // Minor optimization: if LHS is a constant, swap operands, then the; // constant can be folded into comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:30,Testability,test,testing,30,"// If we are doing an AND and testing against zero, then the CMP; // will not be generated. The AND (or BIT) will generate the condition codes,; // but they are different from CMP.; // FIXME: since we're doing a post-processing, use a pseudoinstr here, so; // lowering & isel wouldn't diverge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:8,Performance,load,load,8,// Just load the return address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:167,Performance,load,load,167,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:203,Performance,load,load,203,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:26,Modifiability,extend,extends,26,// MSP430 implicitly zero-extends 8-bit results in 16-bit registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:26,Modifiability,extend,extends,26,// MSP430 implicitly zero-extends 8-bit results in 16-bit registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the block containing instructions after shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi node for the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:51,Integrability,Interface,Interface,51,"//===-- MSP430ISelLowering.h - MSP430 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that MSP430 uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- MSP430ISelLowering.h - MSP430 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that MSP430 uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:39,Usability,clear,cleared,39,"/// Rotate right via carry, carry gets cleared beforehand by clrc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; /// and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:16,Integrability,wrap,wrapper,16,"/// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; /// and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:54,Modifiability,variab,variable,54,"/// SELECT_CC - Operand 0 and operand 1 are selection variable, operand 3; /// is condition code and operand 4 is flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:107,Modifiability,extend,extends,107,"/// isZExtFree - Return true if any actual instruction that defines a value; /// of type Ty1 implicit zero-extends the value to Ty2 in the result; /// register. This does not necessarily include registers defined in unknown; /// ways, such as incoming arguments, or copies from unknown virtual; /// registers. Also, if isTruncateFree(Ty2, Ty1) is true, this does not; /// necessarily apply to truncate instructions. e.g. on msp430, all; /// instructions that define 8-bit values implicit zero-extend the result; /// out to 16 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:493,Modifiability,extend,extend,493,"/// isZExtFree - Return true if any actual instruction that defines a value; /// of type Ty1 implicit zero-extends the value to Ty2 in the result; /// register. This does not necessarily include registers defined in unknown; /// ways, such as incoming arguments, or copies from unknown virtual; /// registers. Also, if isTruncateFree(Ty2, Ty1) is true, this does not; /// necessarily apply to truncate instructions. e.g. on msp430, all; /// instructions that define 8-bit values implicit zero-extend the result; /// out to 16 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430MCInstLower.cpp:27,Energy Efficiency,efficient,efficient,27,"// FIXME: We would like an efficient form for this, so we don't have to do a; // lot of extra uniquing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430MCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430MCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp:21,Performance,load,load,21,"// This is actually ""load effective address"" of the stack slot; // instruction. We have only two-address instructions, thus we need to; // expand it into mov + add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp:31,Deployability,Configurat,Configuration,31,/// MSP430 Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp:31,Modifiability,Config,Configuration,31,/// MSP430 Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp:3,Availability,Mask,Mask,3,// Mask 10 bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCAsmInfo.cpp:197,Testability,test,tested,197,"// Since MSP430-GCC already generates 32-bit DWARF information, we will; // also store 16-bit pointers as 32-bit pointers in DWARF, because using; // 32-bit DWARF pointers is already a working and tested path for LLDB; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCAsmInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCAsmInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h:10,Integrability,synchroniz,synchronization,10,// Memory synchronization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h:28,Integrability,interface,interface,28,"//===-- NVPTX.h - Top-level interface for NVPTX representation --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM NVPTX back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h:46,Availability,mask,mask,46,"// A field inside TSFlags needs a shift and a mask. The usage is; // always as follows :; // ((TSFlags & fieldMask) >> fieldShift); // The enum keeps the mask, the shift, and all valid values of the; // field in one place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h:154,Availability,mask,mask,154,"// A field inside TSFlags needs a shift and a mask. The usage is; // always as follows :; // ((TSFlags & fieldMask) >> fieldShift); // The enum keeps the mask, the shift, and all valid values of the; // field in one place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the NVPTXAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h:3,Integrability,Wrap,Wrapper,3,// Wrapper around ExternalAAWrapperPass so that the default; // constructor gets the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- NVPTXAsmPrinter.cpp - NVPTX LLVM assembly writer ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to NVPTX assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:82,Integrability,depend,depends,82,/// DiscoverDependentGlobals - Return a set of GlobalVariables on which \p V; /// depends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:126,Integrability,depend,dependents,126,"/// VisitGlobalVariableForEmission - Add \p GV to the list of GlobalVariable; /// instances to be emitted, but only after any dependents have been added; /// first.s",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:25,Integrability,depend,dependency,25,// Do we have a circular dependency?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:26,Integrability,depend,dependents,26,// Make sure we visit all dependents first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:17,Performance,load,load,17,"// For a surface load of vector size N, the Nth operand will be the surfref",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:24,Modifiability,variab,variable,24,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:108,Modifiability,variab,variables,108,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:219,Modifiability,variab,variable,219,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:307,Modifiability,variab,variable,307,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:48,Modifiability,variab,variable,48,"// The use is in the initialization of a global variable; // that is a function pointer, so print a declaration; // for the original function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,error,error,3,// error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,error,error,3,// error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:220,Integrability,depend,dependent,220,"// As ptxas does not support forward references of globals, we need to first; // sort the list of module-level globals in def-use order. We visit each; // global variable in order, and ensure that we emit it *after* its dependent; // globals. We use a little extra memory maintaining both a set and a list to; // have fast searches while maintaining a strict ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:162,Modifiability,variab,variable,162,"// As ptxas does not support forward references of globals, we need to first; // sort the list of module-level globals in def-use order. We visit each; // global variable in order, and ensure that we emit it *after* its dependent; // globals. We use a little extra memory maintaining both a set and a list to; // have fast searches while maintaining a strict ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:21,Modifiability,variab,variable,21,"// Visit each global variable, in order",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:33,Modifiability,variab,variables,33,// Print out module-level global variables in proper order,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:83,Modifiability,variab,variables,83,"// This function emits appropriate linkage directives for; // functions and global variables.; //; // extern function declaration -> .extern; // extern function definition -> .visible; // external global variable with init -> .visible; // external without init -> .extern; // appending -> not allowed, assert.; // for any linkage other than; // internal, private, linker_private,; // linker_private_weak, linker_private_weak_def_auto,; // we emit -> .weak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:204,Modifiability,variab,variable,204,"// This function emits appropriate linkage directives for; // functions and global variables.; //; // extern function declaration -> .extern; // extern function definition -> .visible; // external global variable with init -> .visible; // external without init -> .extern; // appending -> not allowed, assert.; // for any linkage other than; // internal, private, linker_private,; // linker_private_weak, linker_private_weak_def_auto,; // we emit -> .weak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:302,Testability,assert,assert,302,"// This function emits appropriate linkage directives for; // functions and global variables.; //; // extern function declaration -> .extern; // extern function definition -> .visible; // external global variable with init -> .visible; // external without init -> .extern; // appending -> not allowed, assert.; // for any linkage other than; // internal, private, linker_private,; // linker_private_weak, linker_private_weak_def_auto,; // we emit -> .weak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:30,Modifiability,variab,variables,30,// Skip LLVM intrinsic global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:46,Safety,avoid,avoid,46,// FIXME - need better way (e.g. Metadata) to avoid generating this global,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:14,Modifiability,variab,variable,14,// Ptx allows variable initilization only for constant and global state; // spaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:61,Modifiability,variab,variables,61,"// The frontend adds zero-initializer to device and constant variables; // that don't have an initial value, and UndefValue to shared; // variables, so skip warning for this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:138,Modifiability,variab,variables,138,"// The frontend adds zero-initializer to device and constant variables; // that don't have an initial value, and UndefValue to shared; // variables, so skip warning for this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:192,Security,access,accesses,192,"// Although PTX has direct support for struct type and array type and; // LLVM IR is very similar to PTX, the LLVM CodeGen does not support for; // targets that support these high level field accesses. Structs, arrays; // and vectors are lowered into arrays of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:14,Modifiability,variab,variable,14,// Ptx allows variable initilization only for constant and; // global state spaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:30,Availability,mask,mask,30,// Print in bytes and use the mask() operator for pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:23,Availability,mask,mask,23,"// Generate a per-byte mask() operator for the symbol, which looks like:; // .global .u8 addr[] = {0xFF(foo), 0xFF00(foo), 0xFF0000(foo), ...};; // See https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#initializers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:192,Security,access,accesses,192,"// Although PTX has direct support for struct type and array type and LLVM IR; // is very similar to PTX, the LLVM CodeGen does not support for targets that; // support these high level field accesses. Structs and arrays are lowered; // into arrays of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:96,Energy Efficiency,allocate,allocated,96,"// Non-zero Bytes indicates that we need to zero-fill everything. Otherwise,; // only the space allocated by CPV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:25,Integrability,depend,depend,25,"// We emit the value and depend on the assembler to truncate the generated; // expression properly. This is important for differences between; // blockaddress labels. Since the two labels are in the same function, it; // is reasonable to treat their delta as a 32-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:128,Usability,simpl,simplifies,128,// Handle casts to pointers by changing them into casts to the appropriate; // integer type. This promotes constant folding and simplifies this code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:64,Availability,mask,mask,64,"// Otherwise the pointer is smaller than the resultant integer, mask off; // the high bits so we are sure to get a proper truncation if the input is; // a constant expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:21,Performance,optimiz,optimized,21,"// If the code isn't optimized, there may be outstanding folding; // opportunities. Attempt to fold the expression using DataLayout as a; // last resort before giving up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:474,Integrability,depend,dependent,474,"//===-- NVPTXAsmPrinter.h - NVPTX LLVM assembly writer ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to NVPTX assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:143,Integrability,interface,interface,143,"// The ptx syntax and format is very different from that usually seem in a .s; // file,; // therefore we are not able to use the MCAsmStreamer interface here.; //; // We are handcrafting the output method here.; //; // A better approach is to clone the MCAsmStreamer to a MCPTXAsmStreamer; // (subclass of MCStreamer).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:416,Availability,mask,mask,416,"// Used to buffer the emitted string for initializing global aggregates.; //; // Normally an aggregate (array, vector, or structure) is emitted as a u8[].; // However, if either element/field of the aggregate is a non-NULL address,; // and all such addresses are properly aligned, then the aggregate is; // emitted as u32[] or u64[]. In the case of unaligned addresses, the; // aggregate is emitted as u8[], and the mask() operator is used for all; // pointers.; //; // We first layout the aggregate in 'buffer' in bytes, except for those; // symbol addresses. For the i-th symbol address in the aggregate, its; // corresponding 4-byte or 8-byte elements in 'buffer' are filled with 0s.; // symbolPosInBuffer[i-1] records its position in 'buffer', and Symbols[i-1]; // records the Value*.; //; // Once we have this AggBuffer setup, we can choose how to print it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:296,Integrability,depend,depending,296,"// SymbolsBeforeStripping[i] is the original form of Symbols[i] before; // stripping pointer casts, i.e.,; // Symbols[i] == SymbolsBeforeStripping[i]->stripPointerCasts().; //; // We need to keep these values because AggBuffer::print decides whether to; // emit a ""generic()"" cast for Symbols[i] depending on the address space of; // SymbolsBeforeStripping[i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:11,Modifiability,variab,variables,11,// List of variables demoted to a function scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:86,Modifiability,variab,variables,86,"// Used to control the need to emit .generic() in the initializer of; // module scope variables.; // Although ptx supports the hybrid mode like the following,; // .global .u32 a;; // .global .u32 b;; // .global .u32 addr[] = {a, generic(b)}; // we have difficulty representing the difference in the NVVM IR.; //; // Since the address value should always be generic in CUDA C and always; // be specific in OpenCL, we use this simple control here.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:425,Usability,simpl,simple,425,"// Used to control the need to emit .generic() in the initializer of; // module scope variables.; // Although ptx supports the hybrid mode like the following,; // .global .u32 a;; // .global .u32 b;; // .global .u32 addr[] = {a, generic(b)}; // we have difficulty representing the difference in the NVVM IR.; //; // Since the address value should always be generic in CUDA C and always; // be specific in OpenCL, we use this simple control here.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:57,Modifiability,variab,variables,57,// Make emitGlobalVariable() no-op for NVPTX.; // Global variables have been already emitted by the time the base AsmPrinter; // attempts to do so in doFinalization() (see NVPTXAsmPrinter::emitGlobals()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:412,Modifiability,variab,variables,412,"//===-- NVPTXAssignValidGlobalNames.cpp - Assign valid names to globals ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Clean up the names of global variables in the module to not contain symbols; // that are invalid in PTX.; //; // Currently NVPTX, like other backends, relies on generic symbol name; // sanitizing done by MC. However, the ptxas assembler is more stringent and; // disallows some additional characters in symbol names. This pass makes sure; // such names do not reach MC at all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:568,Security,sanitiz,sanitizing,568,"//===-- NVPTXAssignValidGlobalNames.cpp - Assign valid names to globals ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Clean up the names of global variables in the module to not contain symbols; // that are invalid in PTX.; //; // Currently NVPTX, like other backends, relies on generic symbol name; // sanitizing done by MC. However, the ptxas assembler is more stringent and; // disallows some additional characters in symbol names. This pass makes sure; // such names do not reach MC at all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:212,Safety,avoid,avoid,212,"// setName doesn't do extra work if the name does not change.; // Note: this does not create collisions - if setName is asked to set the; // name to something that already exists, it adds a proper postfix to; // avoid collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp:423,Performance,load,load,423,"//===-- NVPTXAtomicLower.cpp - Lower atomics of local memory ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp:416,Usability,simpl,simple,416,"//===-- NVPTXAtomicLower.cpp - Lower atomics of local memory ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h:423,Performance,load,load,423,"//===-- NVPTXAtomicLower.h - Lower atomics of local memory ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h:416,Usability,simpl,simple,416,"//===-- NVPTXAtomicLower.h - Lower atomics of local memory ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:28,Modifiability,variab,variables,28,"// NVPTX has no way to emit variables at specific sections or support for; // the traditional constructor sections. Instead, we emit mangled global; // names so the runtime can build the list manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:27,Security,hash,hash,27,// We append a semi-unique hash and the priority to the global name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:35,Usability,simpl,simply,35,"// This isn't respected by Nvidia, simply put here for clarity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp:79,Security,access,accesses,79,"// Emits; // mov %SPL, %depot;; // cvta.local %SP, %SPL;; // for local address accesses in MF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp:3,Usability,Simpl,Simply,3,"// Simply discard ADJCALLSTACKDOWN,; // ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:406,Modifiability,variab,variables,406,"//===-- GenericToNVVM.cpp - Convert generic module to NVVM module - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Convert generic global variables into either .global or .const access based; // on the variable's ""constant"" qualifier.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:470,Modifiability,variab,variable,470,"//===-- GenericToNVVM.cpp - Convert generic module to NVVM module - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Convert generic global variables into either .global or .const access based; // on the variable's ""constant"" qualifier.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:446,Security,access,access,446,"//===-- GenericToNVVM.cpp - Convert generic module to NVVM module - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Convert generic global variables into either .global or .const access based; // on the variable's ""constant"" qualifier.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:33,Modifiability,variab,variable,33,"// Create a clone of each global variable that has the default address space.; // The clone is created with the global address space specifier, and the pair; // of original global variable and its clone is placed in the GVMap for later; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:180,Modifiability,variab,variable,180,"// Create a clone of each global variable that has the default address space.; // The clone is created with the global address space specifier, and the pair; // of original global variable and its clone is placed in the GVMap for later; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:39,Modifiability,variab,variable,39,"// Return immediately, if every global variable has a specific address space; // specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:101,Modifiability,variab,variables,101,"// Walk through the instructions in function defitinions, and replace any use; // of original global variables in GVMap with a use of the corresponding; // copies in GVMap. If necessary, promote constants to instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:27,Modifiability,variab,variable,27,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:93,Modifiability,variab,variables,93,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:218,Modifiability,variab,variable,218,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:270,Modifiability,variab,variable,270,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:78,Modifiability,variab,variable,78,"// At this point, the remaining uses of GV should be found only in global; // variable initializers, as other uses have been already been removed; // while walking through the instructions in function definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:33,Modifiability,variab,variable,33,"// If the constant C is a global variable and is found in GVMap, substitute; //; // addrspacecast GVMap[C] to addrspace(0); //; // for our use of C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:80,Modifiability,variab,variable,80,"// If any element in the constant vector or aggregate C is or uses a global; // variable in GVMap, the constant C needs to be reconstructed, using a set; // of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:67,Modifiability,variab,variable,67,"// If any operand in the constant expression C is or uses a global variable; // in GVMap, the constant expression C needs to be reconstructed, using a; // set of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:44,Modifiability,variab,variable,44,"// Check if any element is or uses a global variable in GVMap, and thus; // converted to another value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:44,Modifiability,variab,variable,44,"// Check if any operand is or uses a global variable in GVMap, and thus; // converted to another value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:40,Performance,optimiz,optimization,40,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:413,Performance,optimiz,optimizations,413,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:436,Security,access,access,436,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:515,Security,access,access,515,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:117,Integrability,interface,interface,117,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:202,Performance,load,load,202,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:623,Performance,load,loadRegFromStackSlot,623,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:135,Testability,log,logic,135,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// createNVPTXISelDag - This pass converts a legalized DAG into a; /// NVPTX-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:88,Performance,load,load,88,"// There's no way to specify FP16 and BF16 immediates in .(b)f16 ops, so we; // have to load them into an .(b)f16 register first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:53,Security,access,access,53,// There's no point scattering f16x2 if we only ever access one; // element of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:450,Energy Efficiency,power,powerful,450,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:308,Modifiability,variab,variables,308,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:48,Performance,load,loads,48,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:139,Performance,load,loads,139,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:146,Performance,Load,Loads,146,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:275,Performance,load,loads,275,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:435,Performance,Perform,Perform,435,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:650,Performance,load,loads,650,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:218,Modifiability,variab,variables,218,// We use getUnderlyingObjects() here instead of getUnderlyingObject() mainly; // because the former looks through phi nodes while the latter does not. We; // need to look through phi nodes to handle pointer induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:31,Energy Efficiency,reduce,reduce,31,// Helper function template to reduce amount of boilerplate code for; // opcode selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,Performance,load,loads,28,// In order to lower atomic loads with stronger guarantees we would need to; // use load.acquire or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:84,Performance,load,load,84,// In order to lower atomic loads with stronger guarantees we would need to; // use load.acquire or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,available,44,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Integrability,synchroniz,synchronization,114,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:25,Performance,load,loaded,25,// v2f16/v2bf16/v2i16 is loaded using ld.b32,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,availalble,44,// Volatile Setting; // - .volatile is only availalble for .global and .shared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:39,Performance,Load,LoadSDNode,39,// The last operand holds the original LoadSDNode::getExtensionType() value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:126,Performance,load,load,126,"// v8x16 is a special case. PTX doesn't have ld.v8.16; // instruction. Instead, we split the vector into v2x16 chunks and; // load them with ld.v4.b32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:30,Performance,load,loaded,30,// vectors of 16bits type are loaded/stored as multiples of v2x16 elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:46,Performance,load,load,46,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:69,Performance,load,loading,69,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:147,Security,expose,expose,147,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:104,Modifiability,extend,extending,104,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Performance,load,load,114,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:142,Performance,load,load,142,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:266,Performance,load,load,266,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:566,Safety,redund,redundancies,566,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:240,Testability,log,logic,240,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:14,Modifiability,extend,extending-load,14,"// We have an extending-load. The instruction we selected operates on the; // smaller type, but the SDNode we are replacing has the larger type. We; // need to emit a CVT to make the types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:24,Performance,load,load,24,"// We have an extending-load. The instruction we selected operates on the; // smaller type, but the SDNode we are replacing has the larger type. We; // need to emit a CVT to make the types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:98,Performance,load,load,98,"// For each output value, apply the manual sign/zero-extension and make sure; // all users of the load go through that CVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:90,Deployability,release,release,90,// In order to lower atomic loads with stronger guarantees we would need to; // use store.release or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,Performance,load,loads,28,// In order to lower atomic loads with stronger guarantees we would need to; // use store.release or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,available,44,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Integrability,synchroniz,synchronization,114,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,availalble,44,// Volatile Setting; // - .volatile is only availalble for .global and .shared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:35,Modifiability,extend,extend,35,"// Special case: if we have a sign-extend/zero-extend node, insert the; // conversion instruction first, and use that as the value operand to; // the selected StoreParam node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:47,Modifiability,extend,extend,47,"// Special case: if we have a sign-extend/zero-extend node, insert the; // conversion instruction first, and use that as the value operand to; // the selected StoreParam node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:69,Energy Efficiency,efficient,efficient,69,/// SelectBFE - Look for instruction sequences that can be made more efficient; /// by using the 'bfe' (bit-field extract) PTX instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:53,Availability,mask,mask,53,"// Canonicalize the operands; // We want 'and %val, %mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:22,Availability,mask,mask,22,// We need a constant mask on the RHS of the AND,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:15,Availability,mask,mask,15,// Extract the mask bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:29,Availability,mask,masks,29,"// We *could* handle shifted masks here, but doing so would require an; // 'and' operation to fix up the low-order bits so we would trade; // shr+and for bfe+and, which has the same throughput",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:182,Performance,throughput,throughput,182,"// We *could* handle shifted masks here, but doing so would require an; // 'and' operation to fix up the low-order bits so we would trade; // shr+and for bfe+and, which has the same throughput",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,Availability,mask,mask,28,// How many bits are in our mask?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:165,Testability,log,logic,165,"// Do not handle the case where the shift amount (can be zero if no srl; // was found) is not constant. We could handle this case, but it would; // require run-time logic that would be more expensive than just; // emitting the srl/and pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:183,Performance,throughput,throughput,183,"// Do not handle the case where the LHS of the and is not a shift. While; // it would be trivial to handle this case, it would just transform; // 'and' -> 'bfe', but 'and' has higher-throughput.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:36,Availability,mask,mask,36,// Canonicalize the AND to have the mask on the RHS,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask must be constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:121,Availability,mask,mask,121,// The number of bits in the result bitfield will be the number of; // trailing zeros plus the number of set bits in the mask minus the; // number of bits we shift off,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:17,Availability,mask,mask,17,// This is not a mask we can handle,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:42,Testability,log,logic,42,// Handling this case would require extra logic that would make this; // transformation non-profitable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:128,Energy Efficiency,efficient,efficiently,128,"// Here, we have a pattern like:; //; // (sra (shl val, NN), MM); // or; // (srl (shl val, NN), MM); //; // If MM >= NN, we can efficiently optimize this with bfe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:140,Performance,optimiz,optimize,140,"// Here, we have a pattern like:; //; // (sra (shl val, NN), MM); // or; // (srl (shl val, NN), MM); //; // If MM >= NN, we can efficiently optimize this with bfe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:6,Safety,avoid,avoid,6,"// To avoid extra codegen and be profitable, we need Outer >= Inner",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:405,Integrability,interface,interfaces,405,"//===-- NVPTXISelLowering.cpp - NVPTX DAG Lowering Implementation ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that NVPTX uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:30,Performance,load,loads,30,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:144,Performance,load,load,144,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:336,Performance,load,load,336,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:438,Security,Access,AccessSize,438,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:22,Security,Access,AccessBytes,22,// Can't vectorize if AccessBytes if not a multiple of EltSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:57,Performance,load,loads,57,// Flags for tracking per-element vectorization state of loads/stores; // of a flattened function parameter or return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:49,Performance,load,loads,49,"// Computes whether and how we can vectorize the loads/stores of a; // flattened function parameter or return value.; //; // The flattened parameter is represented as the list of ValueVTs and; // Offsets, and is aligned to ParamAlignment bytes. We return a vector; // of the same size as ValueVTs indicating how each piece should be; // loaded/stored (i.e. as a scalar, or as part of a vector; // load/store).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:337,Performance,load,loaded,337,"// Computes whether and how we can vectorize the loads/stores of a; // flattened function parameter or return value.; //; // The flattened parameter is represented as the list of ValueVTs and; // Offsets, and is aligned to ParamAlignment bytes. We return a vector; // of the same size as ValueVTs indicating how each piece should be; // loaded/stored (i.e. as a scalar, or as part of a vector; // load/store).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:397,Performance,load,load,397,"// Computes whether and how we can vectorize the loads/stores of a; // flattened function parameter or return value.; //; // The flattened parameter is represented as the list of ValueVTs and; // Offsets, and is aligned to ParamAlignment bytes. We return a vector; // of the same size as ValueVTs indicating how each piece should be; // loaded/stored (i.e. as a scalar, or as part of a vector; // load/store).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:51,Security,access,accesses,51,// Check what we can vectorize using 128/64/32-bit accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:90,Security,Access,AccessSize,90,// Break out of the inner loop because we've already succeeded; // using largest possible AccessSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:58,Performance,load,load,58,"// always lower memset, memcpy, and memmove intrinsics to load/store; // instructions, rather; // then generating calls to memset, mempcy or memmove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:40,Energy Efficiency,reduce,reduce,40,// Wide divides are _very_ slow. Try to reduce the width of the divide if; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:30,Energy Efficiency,schedul,scheduling,30,"// By default, use the Source scheduling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Availability,avail,available,24,// Few instructions are available on sm_90 only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:20,Availability,avail,available,20,// instructions are available on sm_90 only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:8,Testability,log,logical,8,"// Only logical ops can be done on v4i8 directly, others must be done; // elementwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Performance,load,load,24,// Turn FP extload into load/fpextend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Performance,load,load,24,// PTX does not support load / store predicate registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:81,Availability,error,error,81,// Lowering of DYNAMIC_STACKALLOC is unsupported.; // Custom lower to produce an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:39,Performance,load,loads,39,// Register custom handling for vector loads/stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Testability,log,logic,24,// Other arithmetic and logic ops are unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,Availability,avail,available,50,"// Promote fp16 arithmetic if fp16 hardware isn't available or the; // user passed --nvptx-no-fp16-math. The flag is useful because,; // although sm_53+ GPUs have some sort of FP16 support in; // hardware, only sm_53 and sm_60 have full implementation. Others; // only have token amount of hardware and are likely to run faster; // by using fp32 units instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Deployability,update,update,3,// update the index for Outs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:35,Availability,avail,available,35,"// If alignment information is not available, fall back to the; // default function param optimized type alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:90,Performance,optimiz,optimized,90,"// If alignment information is not available, fall back to the; // default function param optimized type alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:390,Deployability,patch,patched,390,"// Variadic arguments.; //; // Normally, for each argument, we declare a param scalar or a param; // byte array in the .param space, and store the argument value to that; // param scalar or array starting at offset 0.; //; // In the case of the first variadic argument, we declare a vararg byte array; // with size 0. The exact size of this array isn't known at this point, so; // it'll be patched later. All the variadic arguments will be stored to this; // array at a certain offset (which gets tracked by 'VAOffset'). The offset is; // initially set to 0, so it can be used for non-variadic arguments (which use; // 0 offset) to simplify the code.; //; // After all vararg is processed, 'VAOffset' holds the size of the; // vararg byte array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:632,Usability,simpl,simplify,632,"// Variadic arguments.; //; // Normally, for each argument, we declare a param scalar or a param; // byte array in the .param space, and store the argument value to that; // param scalar or array starting at offset 0.; //; // In the case of the first variadic argument, we declare a vararg byte array; // with size 0. The exact size of this array isn't known at this point, so; // it'll be patched later. All the variadic arguments will be stored to this; // array at a certain offset (which gets tracked by 'VAOffset'). The offset is; // initially set to 0, so it can be used for non-variadic arguments (which use; // 0 offset) to simplify the code.; //; // After all vararg is processed, 'VAOffset' holds the size of the; // vararg byte array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:79,Performance,load,loaded,79,"// PTX ABI requires integral types to be at least 32 bits in; // size. FP16 is loaded/stored using i16, so it's handled; // here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Integrability,Interoperab,Interoperability,7,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:116,Integrability,depend,depending,116,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:89,Modifiability,extend,extended,89,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:106,Modifiability,extend,extended,106,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Usability,Guid,Guide,24,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:40,Modifiability,extend,extended,40,// Adjust type of the store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:12,Performance,load,loads,12,// Generate loads from param memory/moves from registers for result,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:53,Integrability,Interoperab,Interoperability,53,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:162,Integrability,depend,depending,162,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:135,Modifiability,extend,extended,135,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:152,Modifiability,extend,extended,152,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:70,Usability,Guid,Guide,70,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:85,Performance,optimiz,optimization,85,"// set isTailCall to false for now, until we figure out how to express; // tail call optimization in PTX",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:116,Performance,load,loads,116,"// We can init constant f16x2/v2i16/v4i8 with a single .b32 move. Normally it; // would get lowered as two constant loads and vector-packing move.; // Instead we want just a constant move:; // mov.b32 %r2, 0x40003C00",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:84,Performance,optimiz,optimize,84,"// Lower non-const v4i8 vector as byte-wise constructed i32, which allows us; // to optimize calculation of constant parts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:167,Testability,log,logic,167,"// {dHi, dLo} = {aHi, aLo} >> Amt; // - if (Amt>=size) then; // dLo = aHi >> (Amt-size); // dHi = aHi >> Amt (this is either all 0 or all 1); // else; // dLo = (aLo >>logic Amt) | (aHi << (size-Amt)); // dHi = aHi >> Amt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:110,Performance,load,loads,110,// This function is almost a copy of SelectionDAG::expandVAArg().; // The only diff is that this one produces loads from local address space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:92,Performance,load,loads,92,"// v2f16/v2bf16/v2i16/v4i8 are legal, so we can't rely on legalizer to handle; // unaligned loads and have to handle it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:77,Performance,load,load,77,"// The legalizer (the caller) is expecting two values from the legalized; // load, so we build a MergeValues node for it. See ExpandUnalignedLoad(); // in LegalizeDAG.cpp which also uses MergeValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:227,Modifiability,variab,variable,227,// This creates target external symbol for a function parameter.; // Name of the symbol is composed from its index and the function name.; // Negative index corresponds to special parameter (unsized array) used for; // passing variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,Performance,load,loaded,9,// i1 is loaded/stored as i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:115,Performance,load,load,115,"// getLoad needs a vector type, but it can't handle; // vectors which contain v2f16 or v2bf16 elements. So we must load; // using i32 here and then bitcast back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,Performance,load,loaded,9,// We've loaded i1 as an i8 and now must truncate it back to i1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:13,Performance,load,loaded,13,// v2f16 was loaded as an i32. Now we must bitcast it back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:48,Availability,down,down,48,"// If a promoted integer type is used, truncate down to the original",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend the element if necessary (e.g. an i8 is loaded; // into an i16 register),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,Performance,load,loaded,50,// Extend the element if necessary (e.g. an i8 is loaded; // into an i16 register),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:272,Integrability,depend,dependent,272,"// Param has ByVal attribute; // Return MoveParam(param symbol).; // Ideally, the param symbol can be returned directly,; // but when SDNode builder decides to use it in a CopyToReg(),; // machine instruction fails because TargetExternalSymbol; // (not lowered) is target dependent, and CopyToReg assumes; // the source is lowered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Integrability,Interoperab,Interoperability,7,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:116,Integrability,depend,depending,116,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:89,Modifiability,extend,extended,89,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:106,Modifiability,extend,extended,106,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Usability,Guid,Guide,24,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Performance,load,load,7,// New load/store. Record chain and offset operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:34,Performance,load,load-stores,34,// Use 16-bit registers for small load-stores as it's the; // smallest general purpose register size supported by NVPTX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:41,Modifiability,extend,extended,41,// Adjust type of load/store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:18,Performance,load,load,18,// Adjust type of load/store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:143,Availability,avail,available,143,"// llvm.ptx.memcpy.const and llvm.ptx.memmove.const need to be modeled as; // TgtMemIntrinsic; // because we need the information that is only available in the ""Value"" type; // of destination; // pointer. In particular, the address space information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:135,Performance,perform,perform,135,"// memVT is bogus. These intrinsics have IntrInaccessibleMemOnly attribute; // in order to model data exchange with other threads, but perform no real; // memory accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:162,Security,access,accesses,162,"// memVT is bogus. These intrinsics have IntrInaccessibleMemOnly attribute; // in order to model data exchange with other threads, but perform no real; // memory accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:14,Integrability,depend,depends,14,// Our result depends on both our and other thread's arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:203,Performance,load,loads,203,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:425,Performance,load,loads,425,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:32,Modifiability,enhance,enhance,32,// Try to increase alignment to enhance vectorization options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:231,Security,access,access,231,"// Old ptx versions have a bug. When PTX code takes address of; // byval parameter with alignment < 4, ptxas generates code to; // spill argument into memory. Alas on sm_50+ ptxas generates; // SASS code that fails with misaligned access. To work around; // the problem, make sure that we align byval parameters by at; // least 4. This bug seems to be fixed at least starting from; // ptxas > 9.0.; // TODO: remove this after verifying the bug is not reproduced; // on non-deprecated ptxas versions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:193,Modifiability,variab,variable,193,// Helper for getting a function parameter name. Name is composed from; // its index and the function name. Negative index corresponds to special; // parameter (unsized array) used for passing variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:187,Performance,optimiz,optimizations,187,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:272,Performance,optimiz,optimization,272,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:165,Usability,guid,guide,165,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:10,Integrability,contract,contract,10,// Do not contract if we're not optimizing the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:32,Performance,optimiz,optimizing,32,// Do not contract if we're not optimizing the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:49,Safety,unsafe,unsafe,49,// Honor TargetOptions flags that explicitly say unsafe math is okay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,Safety,unsafe,unsafe,9,// Allow unsafe math if unsafe-fp-math attribute explicitly says so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Safety,unsafe,unsafe-fp-math,24,// Allow unsafe math if unsafe-fp-math attribute explicitly says so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformADDCombineWithOperands,4,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:119,Performance,Perform,PerformADDCombine,119,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:79,Testability,log,logics,79,"// simple heuristics here for considering potential register; // pressure, the logics here is that the differnce are used; // to measure the distance between def and use, the longer distance; // more likely cause register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Usability,simpl,simple,3,"// simple heuristics here for considering potential register; // pressure, the logics here is that the differnce are used; // to measure the distance between def and use, the longer distance; // more likely cause register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformADDCombine,4,/// PerformADDCombine - Target-specific dag combine xforms for ISD::ADD.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:37,Performance,load,load,37,"// The type legalizer turns a vector load of i8 values into a zextload to i16; // registers, optionally ANY_EXTENDs it (if target type is integer),; // and ANDs off the high 8 bits. Since we turn this load into a; // target-specific DAG node, the DAG combiner fails to eliminate these AND; // nodes. Do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:201,Performance,load,load,201,"// The type legalizer turns a vector load of i8 values into a zextload to i16; // registers, optionally ANY_EXTENDs it (if target type is integer),; // and ANDs off the high 8 bits. Since we turn this load into a; // target-specific DAG node, the DAG combiner fails to eliminate these AND; // nodes. Do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:26,Performance,load,load,26,"// If for some reason the load is a sextload, the and is needed to zero; // out the high 8 bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:68,Performance,load,load,68,"// If we get here, the AND is unnecessary. Just replace it with the load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformMULCombine,4,/// PerformMULCombine - Runs PTX-specific DAG combine patterns on MUL nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformSHLCombine,4,/// PerformSHLCombine - Runs PTX-specific DAG combine patterns on SHL nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:17,Performance,load,loads,17,"// Native vector loads already combine nicely w/; // extract_vector_elt, except for v4i8.; // Don't mess with singletons or v2*16 types, we already handle them OK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:216,Safety,avoid,avoid,216,"// We need to split vselect into individual per-element operations Because we; // use BFE/BFI instruction for byte extraction/insertion, we do end up with; // 32-bit values, so we may as well do comparison as i32 to avoid conversions; // to/from i16 normally used for i8 values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:17,Performance,load,load,17,"// Lower a v16i8 load into a LoadV4 operation with i32 results instead of; // letting ReplaceLoadVector split it into smaller loads during legalization.; // This is done at dag-combine1 time, so that vector operations with i8; // elements can be optimised away instead of being needlessly split during; // legalization, which involves storing to the stack and loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:126,Performance,load,loads,126,"// Lower a v16i8 load into a LoadV4 operation with i32 results instead of; // letting ReplaceLoadVector split it into smaller loads during legalization.; // This is done at dag-combine1 time, so that vector operations with i8; // elements can be optimised away instead of being needlessly split during; // legalization, which involves storing to the stack and loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:360,Performance,load,loading,360,"// Lower a v16i8 load into a LoadV4 operation with i32 results instead of; // letting ReplaceLoadVector split it into smaller loads during legalization.; // This is done at dag-combine1 time, so that vector operations with i8; // elements can be optimised away instead of being needlessly split during; // legalization, which involves storing to the stack and loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:25,Performance,load,load,25,"// Create a v4i32 vector load operation, effectively <4 x v4i8>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:61,Performance,load,load,61,// Create a vector of the same type returned by the original load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:39,Performance,load,loads,39,/// ReplaceVectorLoad - Convert vector loads into multi-output scalar loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:70,Performance,load,loads,70,/// ReplaceVectorLoad - Convert vector loads into multi-output scalar loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:123,Performance,load,loads,123,"// We only handle ""native"" vector sizes for now, e.g. <4 x double> is not; // legal. We can (and should) split that into 2 loads of <2 x double> here; // but I'm leaving that as a TODO for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:8,Performance,load,load,8,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:78,Performance,load,load,78,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:156,Performance,load,loads,156,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:186,Performance,load,loading,186,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:154,Performance,load,loaded,154,"// Since LoadV2 is a target node, we cannot rely on DAG type legalization.; // Therefore, we must ensure the type is legal. For i1 and i8, we set the; // loaded type to i16 and propagate the ""real"" type as the memory type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:127,Performance,load,load,127,"// v8f16 is a special case. PTX doesn't have ld.v8.f16; // instruction. Instead, we split the vector into v2f16 chunks and; // load them with ld.v4.b32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:14,Integrability,rout,routine,14,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,Performance,Load,LoadSDNode,50,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:36,Security,access,access,36,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:159,Performance,load,loaded,159,"// Since LDU/LDG are target nodes, we cannot rely on DAG type; // legalization.; // Therefore, we must ensure the type is legal. For i1 and i8, we set the; // loaded type to i16 and propagate the ""real"" type as the memory type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:49,Integrability,Interface,Interface,49,"//===-- NVPTXISelLowering.h - NVPTX DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that NVPTX uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- NVPTXISelLowering.h - NVPTX DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that NVPTX uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:203,Performance,load,loads,203,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:425,Performance,load,loads,425,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:193,Modifiability,variab,variable,193,// Helper for getting a function parameter name. Name is composed from; // its index and the function name. Negative index corresponds to special; // parameter (unsized array) used for passing variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:186,Performance,optimiz,optimizations,186,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:271,Performance,optimiz,optimization,271,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:164,Usability,guid,guide,164,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:238,Availability,avail,available,238,"// Get the degree of precision we want from 32-bit floating point division; // operations.; //; // 0 - Use ptx div.approx; // 1 - Use ptx.div.full (approximate, but less so than div.approx); // 2 - Use IEEE-compliant div instructions, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:166,Safety,avoid,avoids,166,"// The default is to transform llvm.ctlz(x, false) (where false indicates that; // x == 0 is not undefined behavior) into a branch that checks whether x is 0; // and avoids calling ctlz in that case. We have a dedicated ctlz; // instruction, so we say that ctlz is cheap to speculate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:3,Performance,cache,cache,3,// cache the subtarget here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:25,Performance,load,loads,25,// Collect all aggregate loads and mem* calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:32,Modifiability,variab,variable,32,// Convert intrinsic calls with variable size or with constant size; // larger than the MaxAggrCopySize threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:40,Performance,load,load,40,//; // Do the transformation of an aggr load/copy/set to a loop; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:258,Availability,redundant,redundant,258,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:9,Performance,Load,Load,9,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:258,Safety,redund,redundant,258,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:119,Security,expose,expose,119,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1416,Performance,optimiz,optimizations,1416,"ctions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global addre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1573,Performance,load,load,1573,"te-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1820,Performance,load,load,1820,"o generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1914,Performance,optimiz,optimize,1914,"m.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: mer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2045,Performance,load,load,2045,"m.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: mer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2588,Performance,load,load,2588,"nity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't; // cancel the addrspacecast pair this pass emits.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2787,Performance,load,load,2787,"nity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't; // cancel the addrspacecast pair this pass emits.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:612,Security,access,accessible,612,"//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Arguments to kernel and device functions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast fl",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:811,Security,access,accessible,811,"//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Arguments to kernel and device functions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast fl",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1470,Security,access,accessing,1470,"strictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:212,Performance,load,loads,212,"// Knowing Ptr must point to the global address space, this function; // addrspacecasts Ptr to global and then back to generic. This allows; // NVPTXInferAddressSpaces to fold the global-to-generic cast into; // loads/stores that appear later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:520,Energy Efficiency,allocate,allocates,520,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:213,Performance,load,loads,213,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:408,Performance,load,load,408,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:722,Performance,Load,Loads,722,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:982,Performance,Load,Load,982,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:200,Security,access,accesses,200,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:792,Security,access,access,792,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:36,Performance,Queue,Queue,36,"// We've created a new instruction. Queue users of the old instruction to; // be converted and the instruction itself to be deleted. We can't delete; // the old instruction yet, because it's still in use by a load somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:209,Performance,load,load,209,"// We've created a new instruction. Queue users of the old instruction to; // be converted and the instruction itself to be deleted. We can't delete; // the old instruction yet, because it's still in use by a load somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:161,Energy Efficiency,schedul,scheduled,161,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:33,Performance,load,loads,33,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:251,Performance,load,load,251,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:338,Performance,Load,Load,338,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:185,Performance,load,loads,185,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:220,Performance,load,loads,220,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:381,Performance,load,load,381,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:15,Performance,load,loads,15,// Convert all loads and intermediate operations to use parameter AS and; // skip creation of a local copy of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:85,Performance,load,load,85,"// Set the alignment to alignment of the byval parameter. This is because,; // later load/stores assume that alignment, and we are going to replace; // the use of the byval parameter with this alloca instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:42,Performance,load,load,42,"// Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX; // addrspacecast preserves alignment. Since params are constant, this load is; // definitely not volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:148,Performance,load,load,148,"// Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX; // addrspacecast preserves alignment. Since params are constant, this load is; // definitely not volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:67,Performance,load,loaded,67,"// Copying of byval aggregates + SROA may result in pointers being loaded as; // integers, followed by intotoptr. We may want to mark those as global, too,; // but only if the loaded integer is used exclusively for conversion to a; // pointer with inttoptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:176,Performance,load,loaded,176,"// Copying of byval aggregates + SROA may result in pointers being loaded as; // integers, followed by intotoptr. We may want to mark those as global, too,; // but only if the loaded integer is used exclusively for conversion to a; // pointer with inttoptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:11,Performance,load,load,11,// LI is a load from a pointer within a byval kernel parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp:178,Testability,log,logic,178,// =============================================================================; // Returns whether a `trap` intrinsic should be emitted before I.; //; // This is a copy of the logic in SelectionDAGBuilder::visitUnreachable().; // =============================================================================,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMachineFunctionInfo.h:458,Integrability,depend,dependent,458,"//===-- NVPTXMachineFunctionInfo.h - NVPTX-specific Function Info --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class is attached to a MachineFunction instance and tracks target-; // dependent information; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.cpp:96,Performance,load,load,96,// ptxas does not have a way to specify half-precision floats.; // Instead we have to print and load fp16 constants as .b16,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:6,Integrability,wrap,wrapper,6,/// A wrapper for MCSymbolRefExpr that tells the assembly printer that the; /// symbol should be enclosed by generic().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:43,Performance,Optimiz,Optimiztions,43,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:772,Performance,load,load,772,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:889,Performance,Perform,Performance,889,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:1039,Performance,optimiz,optimizes,1039,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:923,Safety,avoid,avoid,923,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:82,Usability,simpl,simply,82,// Frame indices in debug values are encoded in a target independent; // way with simply the frame index and offset rather than any; // target-specific addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:22,Availability,down,down,22,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:108,Energy Efficiency,allocate,allocated,108,"// If there are fixed sized objects that are preallocated in the local area,; // non-fixed objects can't be allocated right at the start of local area.; // We currently don't support filling in holes in between fixed sized; // objects, so we adjust 'Offset' to point to the end of last fixed sized; // preallocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:118,Availability,down,down,118,"// The maximum distance from the stack pointer is at lower address of; // the object -- which is given by offset. For down growing stack; // the offset is negative, so we negate the offset to get the distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:225,Performance,optimiz,optimization,225,"// No scavenger; // FIXME: Once this is working, then enable flag will change to a target; // check for whether the frame is large enough to want to use virtual; // frame index registers. Functions which don't want/need this optimization; // will continue to use the existing code path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the local block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:3,Deployability,Update,Update,3,// Update frame info to pretend that this is part of the stack...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp:103,Integrability,depend,depend,103,"// We use untyped (.b) integer registers here as NVCC does.; // Correctness of generated code does not depend on register type,; // but using .s/.u registers runs into ptxas bug that prevents; // assembly of otherwise valid PTX into SASS. Despite PTX ISA; // specifying only argument size for fp16 instructions, ptxas does; // not allow using .s16 or .u16 arguments for .fp16; // instructions. At the same time it allows using .s32/.u32; // arguments for .fp16v2 instructions:; //; // .reg .b16 rb16; // .reg .s16 rs16; // add.f16 rb16,rb16,rb16; // OK; // add.f16 rs16,rs16,rs16; // Arguments mismatch for instruction 'add'; // but:; // .reg .b32 rb32; // .reg .s32 rs32; // add.f16v2 rb32,rb32,rb32; // OK; // add.f16v2 rs32,rs32,rs32; // OK",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:550,Availability,reliab,reliably,550,"//===-- NVPTXReplaceImageHandles.cpp - Replace image handles for Fermi ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // On Fermi, image handles are not supported. To work around this, we traverse; // the machine code and replace image handles with concrete symbols. For this; // to work reliably, inlining of all function call must be performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:598,Performance,perform,performed,598,"//===-- NVPTXReplaceImageHandles.cpp - Replace image handles for Fermi ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // On Fermi, image handles are not supported. To work around this, we traverse; // the machine code and replace image handles with concrete symbols. For this; // to work reliably, inlining of all function call must be performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:27,Security,access,access,27,"// Now clean up any handle-access instructions; // This is needed in debug mode when code cleanup passes are not executed,; // but we need the handle access to be eliminated because they are not; // valid instructions when image handles are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:150,Security,access,access,150,"// Now clean up any handle-access instructions; // This is needed in debug mode when code cleanup passes are not executed,; // but we need the handle access to be eliminated because they are not; // valid instructions when image handles are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:17,Performance,load,load,17,"// For a surface load of vector size N, the Nth operand will be the surfref",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:41,Performance,load,loaded,41,"// The handle is a parameter value being loaded, replace with the; // parameter symbol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:35,Performance,load,loads,35,"// For CUDA, we preserve the param loads coming from function arguments",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:26,Modifiability,variab,variable,26,"// The handle is a global variable, replace with the global variable name",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:60,Modifiability,variab,variable,60,"// The handle is a global variable, replace with the global variable name",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:63,Performance,optimiz,optimization,63,"// FIXME: This pass is really intended to be invoked during IR optimization,; // but it's very NVPTX-specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:19,Performance,perform,perform,19,// Add passes that perform straight-line scalar optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:48,Performance,optimiz,optimizations,48,// Add passes that perform straight-line scalar optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:19,Security,expose,exposes,19,// ReassociateGEPs exposes more opportunites for SLSR. See; // the example in reassociate-geps-and-slsr.ll.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:177,Testability,benchmark,benchmarks,177,// SeparateConstOffsetFromGEP and SLSR creates common expressions which GVN or; // EarlyCSE can reuse. GVN generates significantly better code than EarlyCSE; // for some of our benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:35,Availability,redundant,redundant,35,"// NaryReassociate on GEPs creates redundant common expressions, so run; // EarlyCSE after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:35,Safety,redund,redundant,35,"// NaryReassociate on GEPs creates redundant common expressions, so run; // EarlyCSE after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:217,Deployability,pipeline,pipeline,217,"// NVVMReflectPass is added in addEarlyAsPossiblePasses, so hopefully running; // it here does nothing. But since we need it for correctness when lowering; // to NVPTX, run it here too, in case whoever built our pass pipeline didn't; // call addEarlyAsPossiblePasses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:72,Availability,alive,alive,72,// Remove Proxy Register pseudo instructions used to keep `callseq_end` alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:21,Energy Efficiency,schedul,scheduling,21,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:3,Performance,Optimiz,Optimize,3,// Optimize PHIs before DCE: removing dead PHI cycles may make more; // instructions dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:8,Performance,optimiz,optimization,8,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:250,Testability,test,test,250,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h:27,Security,access,accessing,27,// Use 32-bit pointers for accessing const/local/short AS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:61,Performance,load,loaded,61,"// Without pointer analysis, we conservatively assume values loaded from; // generic or local address space are divergent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:30,Usability,simpl,simplify,30,"// Each NVVM intrinsic we can simplify can be replaced with one of:; //; // * an LLVM intrinsic,; // * an LLVM cast operation,; // * an LLVM binary operation, or; // * ad-hoc LLVM IR for the particular operation.; // Some transformations are only valid when the module's; // flush-denormals-to-zero (ftz) setting is true/false, whereas other; // transformations are valid regardless of the module's ftz setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:155,Usability,simpl,simplify,155,"// Classes of NVVM intrinsics that can't be replaced one-to-one with a; // target-generic intrinsic, cast op, or binary op but that we can nonetheless; // simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,SimplifyAction,3,// SimplifyAction is a poor-man's variant (plus an additional flag) that; // represents how to replace an NVVM intrinsic with target-generic LLVM IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:56,Integrability,depend,depending,56,"// Denormal handling is guarded by different attributes depending on the; // type (denormal-fp-math vs denormal-fp-math-f32), take note of halfs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:21,Usability,Simpl,SimplifyAction,21,// Try to generate a SimplifyAction describing how to replace our; // IntrinsicInstr with target-generic LLVM IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:23,Usability,simpl,simplify,23,"// We do not currently simplify intrinsics that give an approximate; // answer. These include:; //; // - nvvm_cos_approx_{f,ftz_f}; // - nvvm_ex2_approx_{d,f,ftz_f}; // - nvvm_lg2_approx_{d,f,ftz_f}; // - nvvm_sin_approx_{f,ftz_f}; // - nvvm_sqrt_approx_{f,ftz_f}; // - nvvm_rsqrt_approx_{d,f,ftz_f}; // - nvvm_div_approx_{ftz_d,ftz_f,f}; // - nvvm_rcp_approx_ftz_d; //; // Ideally we'd encode them as e.g. ""fast call @llvm.cos"", where ""fast""; // means that fastmath is enabled in the intrinsic. Unfortunately only; // binary operators (currently) have a fastmath bit in SelectionDAG, so; // this information gets lost and we can't select on it.; //; // TODO: div and rcp are lowered to a binary op, so these we could in; // theory lower them to ""fast fdiv"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify to target-generic intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify to target-generic binary op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify to target-generic cast op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify reciprocal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:55,Energy Efficiency,reduce,reduce,55,"// Enable partial unrolling and runtime unrolling, but reduce the; // threshold. This partially unrolls small loops which are often; // unrolled by the PTX to SASS compiler and unrolling earlier can be; // beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:3,Performance,Load,Loads,3,// Loads and stores can be vectorized if the alignment is at least as big as; // the load/store we want to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:85,Performance,load,load,85,// Loads and stores can be vectorized if the alignment is at least as big as; // the load/store we want to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:202,Availability,error,errors,202,"// We don't want to prevent inlining because of target-cpu and -features; // attributes that were added to newer versions of LLVM/Clang: There are; // no incompatible functions in PTX, ptxas will throw errors in such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:12,Performance,load,loads,12,"// Volatile loads/stores are only supported for shared and global address; // spaces, or for generic AS that maps to them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.cpp:39,Modifiability,variab,variable,39,"// start index = 1, to skip the global variable key; // increment = 2, to skip the value for each property-value pairs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h:80,Energy Efficiency,power,power,80,// PTX ABI requires all scalar argument/return values to have; // bit-size as a power of two of at least 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:721,Safety,predict,predict,721,"//===- NVVMReflect.cpp - NVVM Emulate conditional compilation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces occurrences of __nvvm_reflect(""foo"") and llvm.nvvm.reflect; // with an integer.; //; // We choose the value we use by looking at metadata in the module itself. Note; // that we intentionally only have one way to choose these values, because other; // parts of LLVM (particularly, InstCombineCall) rely on being able to predict; // the values chosen by this pass.; //; // If we see an unknown string, we replace its call with 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:157,Security,validat,validate,157,"// Go through the calls in this function. Each call to __nvvm_reflect or; // llvm.nvvm.reflect should be a CallInst with a ConstantArray argument.; // First validate that. If the c-string corresponding to the ConstantArray can; // be found successfully, see if it can be found in VarMap. If so, replace the; // uses of CallInst with the value found in VarMap. If not, replace the use; // with value 0.; // The IR for __nvvm_reflect calls differs between CUDA versions.; //; // CUDA 6.5 and earlier uses this sequence:; // %ptr = tail call i8* @llvm.nvvm.ptr.constant.to.gen.p0i8.p4i8; // (i8 addrspace(4)* getelementptr inbounds; // ([8 x i8], [8 x i8] addrspace(4)* @str, i32 0, i32 0)); // %reflect = tail call i32 @__nvvm_reflect(i8* %ptr); //; // The value returned by Sym->getOperand(0) is a Constant with a; // ConstantDataSequential operand which can be converted to string and used; // for lookup.; //; // CUDA 7.0 does it slightly differently:; // %reflect = call i32 @__nvvm_reflect(i8* addrspacecast; // (i8 addrspace(1)* getelementptr inbounds; // ([8 x i8], [8 x i8] addrspace(1)* @str, i32 0, i32 0) to i8*)); //; // In this case, we get a Constant with a GlobalVariable operand and we need; // to dig deeper to find its initializer with the string we'll use for lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:18,Availability,error,error,18,// FIXME: Improve error handling here and elsewhere in this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:14,Testability,assert,assertions,14,// FIXME: Add assertions about ConvCall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:53,Integrability,wrap,wrapping,53,// Pre opaque pointers we have a constant expression wrapping the constant; // string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:161,Safety,detect,detect,161,"// Try to pull __CUDA_FTZ from the nvvm-reflect-ftz module flag. Our; // choice here must be kept in sync with AutoUpgrade, which uses the same; // technique to detect whether ftz is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid using parens for identifiers starting with $ - ptxas does; // not expect them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXTargetStreamer.cpp:102,Deployability,patch,patch,102,// FIXME: the checks for the DWARF sections are very fragile and should be; // fixed up in a followup patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:40,Energy Efficiency,Power,PowerPC,40,"//===-- PPC.h - Top-level interface for PowerPC Target ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // PowerPC back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:464,Energy Efficiency,Power,PowerPC,464,"//===-- PPC.h - Top-level interface for PowerPC Target ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // PowerPC back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:26,Integrability,interface,interface,26,"//===-- PPC.h - Top-level interface for PowerPC Target ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // PowerPC back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:92,Performance,optimiz,optimization,92,/// MO_PCREL_OPT_FLAG - If this bit is set the operand is part of a; /// PC Relative linker optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:124,Modifiability,variab,variable,124,/// MO_TLSGD_FLAG - If this bit is set the symbol reference is relative to; /// TLS General Dynamic model for Linux and the variable offset of TLS; /// General Dynamic model for AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:52,Energy Efficiency,Power,PowerPC,52,"//===-- PPCAsmPrinter.cpp - Print machine instrs to PowerPC assembly ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to PowerPC assembly language. This printer is; // the output mechanism used by `llc'.; //; // Documentation at http://developer.apple.com/documentation/DeveloperTools/; // Reference/Assembler/ASMIntroduction/chapter_1_section_1.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:497,Energy Efficiency,Power,PowerPC,497,"//===-- PPCAsmPrinter.cpp - Print machine instrs to PowerPC assembly ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to PowerPC assembly language. This printer is; // the output mechanism used by `llc'.; //; // Documentation at http://developer.apple.com/documentation/DeveloperTools/; // Reference/Assembler/ASMIntroduction/chapter_1_section_1.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- PPCAsmPrinter.cpp - Print machine instrs to PowerPC assembly ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to PowerPC assembly language. This printer is; // the output mechanism used by `llc'.; //; // Documentation at http://developer.apple.com/documentation/DeveloperTools/; // Reference/Assembler/ASMIntroduction/chapter_1_section_1.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:26,Energy Efficiency,Power,PowerPC,26,// GNU attribute tags for PowerPC ABI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:28,Energy Efficiency,Power,PowerPC,28,"// GNU attribute values for PowerPC float ABI, as combination of two parts",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:25,Energy Efficiency,Power,PowerPC,25,"/// PPCLinuxAsmPrinter - PowerPC assembly printer, customized for Linux",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:108,Integrability,rout,routine,108,"// At the moment, all inline asm memory operands are a single register.; // In any case, the output of this routine should always be just one; // assembler operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:17,Deployability,update,update,17,// Print 'u' for update form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:352,Availability,toler,tolerate,352,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:138,Deployability,update,update,138,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:56,Energy Efficiency,Power,PowerPC,56,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:91,Performance,load,loaded,91,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:274,Performance,load,load,274,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:302,Performance,load,load,302,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:11,Deployability,patch,patchpoint,11,"// Lower a patchpoint of the form:; // [<def>], <id>, <numBytes>, <target>, <numArgs>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:38,Performance,load,load,38,"// If we're on ELFv1, then we need to load the actual function pointer; // from the function descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:3,Performance,Load,Load,3,"// Load the new TOC pointer and the function address, but not r11; // (needing this is rare, and loading it here would prevent passing it; // via a 'nest' parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:97,Performance,load,loading,97,"// Load the new TOC pointer and the function address, but not r11; // (needing this is rare, and loading it here would prevent passing it; // via a 'nest' parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:15,Modifiability,variab,variable,15,"// On AIX, the variable offset should already be in R4 and the region handle; // should already be in R3.; // For TLSGD, which currently is the only supported access model, we only; // need to generate an absolute branch to .__tls_get_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:159,Security,access,access,159,"// On AIX, the variable offset should already be in R4 and the region handle; // should already be in R3.; // For TLSGD, which currently is the only supported access model, we only; // need to generate an absolute branch to .__tls_get_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:42,Energy Efficiency,Power,PowerPC,42,/// EmitInstruction -- Print out a single PowerPC MI in Darwin syntax to; /// the current output stream.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:3,Security,Validat,Validate,3,// Validate that SPE and FPU are mutually exclusive in codegen,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:107,Modifiability,variab,variable,107,"// For TLS initial-exec and local-exec accesses on AIX, we have one TOC; // entry for the symbol (with the variable offset), which is differentiated; // by MO_TPREL_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:39,Security,access,accesses,39,"// For TLS initial-exec and local-exec accesses on AIX, we have one TOC; // entry for the symbol (with the variable offset), which is differentiated; // by MO_TPREL_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:85,Modifiability,variab,variable,85,"// For GD TLS access on AIX, we have two TOC entries for the symbol (one for; // the variable offset and the other for the region handle). They are; // differentiated by MO_TLSGD_FLAG and MO_TLSGDM_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:14,Security,access,access,14,"// For GD TLS access on AIX, we have two TOC entries for the symbol (one for; // the variable offset and the other for the region handle). They are; // differentiated by MO_TLSGD_FLAG and MO_TLSGDM_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:27,Energy Efficiency,efficient,efficient,27,"// FIXME: We would like an efficient form for this, so we; // don't have to do a lot of extra uniquing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:19,Deployability,Update,UpdateGBR,19,"// Transform %rd = UpdateGBR(%rt, %ri); // Into: lwz %rt, .L0$poff - .L0$pb(%ri); // add %rd, %rt, %ri; // or into (if secure plt mode is on):; // addis r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@ha; // addi r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@l; // Get the offset from the GOT Base Register to the GOT",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:119,Security,secur,secure,119,"// Transform %rd = UpdateGBR(%rt, %ri); // Into: lwz %rt, .L0$poff - .L0$pb(%ri); // add %rd, %rt, %ri; // or into (if secure plt mode is on):; // addis r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@ha; // addi r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@l; // Get the offset from the GOT Base Register to the GOT",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:83,Energy Efficiency,allocate,allocated,83,"// Otherwise, use the TOC. 'TOCEntry' is a label used to reference the; // storage allocated in the TOC which contains the address of; // 'MOSymbol'. Said TOC entry will be synthesized later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:24,Performance,load,load,24,// Change the opcode to load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:178,Energy Efficiency,allocate,allocated,178,// Always use TOC on AIX. Map the global address operand to be a reference; // to the TOC entry we will synthesize later. 'TOCEntry' is a label used to; // reference the storage allocated in the TOC which contains the address of; // 'MOSymbol'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:178,Energy Efficiency,allocate,allocated,178,// Always use TOC on AIX. Map the global address operand to be a reference; // to the TOC entry we will synthesize later. 'TOCEntry' is a label used to; // reference the storage allocated in the TOC which contains the address of; // 'MOSymbol'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:27,Energy Efficiency,efficient,efficient,27,"// FIXME: We would like an efficient form for this, so we don't have to do; // a lot of extra uniquing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:48,Availability,mask,mask,48,"// Transform: %cr7 = MTOCRF %r3; // Into: MTCRF mask, %r3 ;; cr7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:161,Deployability,Update,Update,161,"// .begin:; // b .end # lis 0, FuncId[16..32]; // nop # li 0, FuncId[0..15]; // std 0, -8(1); // mflr 0; // bl __xray_FunctionEntry; // mtlr 0; // .end:; //; // Update compiler-rt/lib/xray/xray_powerpc64.cc accordingly when number; // of instructions change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:239,Deployability,Update,Update,239,"// Before:; // bgtlr cr0; //; // After:; // ble cr0, .end; // .p2align 3; // .begin:; // blr # lis 0, FuncId[16..32]; // nop # li 0, FuncId[0..15]; // std 0, -8(1); // mflr 0; // bl __xray_FunctionExit; // mtlr 0; // blr; // .end:; //; // Update compiler-rt/lib/xray/xray_powerpc64.cc accordingly when number; // of instructions change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:176,Deployability,Update,Update,176,"// .p2align 3; // .begin:; // b(lr)? # lis 0, FuncId[16..32]; // nop # li 0, FuncId[0..15]; // std 0, -8(1); // mflr 0; // bl __xray_FunctionExit; // mtlr 0; // b(lr)?; //; // Update compiler-rt/lib/xray/xray_powerpc64.cc accordingly when number; // of instructions change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:32,Integrability,synchroniz,synchronized,32,// Note: The logic here must be synchronized with the code in the; // branch-selection pass which sets the offset of the first block in the; // function. This matters because it affects the alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:13,Testability,log,logic,13,// Note: The logic here must be synchronized with the code in the; // branch-selection pass which sets the offset of the first block in the; // function. This matters because it affects the alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:277,Security,access,access,277,"// If ShouldEmitEHBlock returns true, then the eh info table; // will be emitted via `AIXException::endFunction`. Otherwise, we; // need to emit a dumy eh info table when VRs are saved. We could not; // consolidate these two places into one because there is no easy way; // to access register information in `AIXException` class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:167,Integrability,rout,routine,167,"// There is a lack of information in the IR to assist with determining the; // source language. AIX exception handling mechanism would only search for; // personality routine and LSDA area when such language supports exception; // handling. So to be conservatively correct and allow runtime to do its job,; // we need to set it to C++ for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:17,Modifiability,Variab,Variable,17,"// If the Global Variable has the toc-data attribute, it needs to be emitted; // when we emit the .toc section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:31,Modifiability,variab,variable,31,// Emit linkage for the global variable and its aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:49,Modifiability,variab,variable,49,// Emit alias label and element value for global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:473,Energy Efficiency,allocate,allocated,473,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:1111,Safety,safe,safe,1111,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:1200,Testability,log,logical,1200,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:1398,Usability,Simpl,SimplifyCFG,1398,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3505,Availability,down,down,3505," to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// Branch Coalescing does not split blocks, it moves everything in the same; /// direction ensuring it does not break use/definition semantics.; ///; /// PHI nodes and its corresponding use instructions are moved to its successor; /// block if there are no uses within the successor block PHI nodes. PHI; /// node ordering cannot be assumed.; ///; /// Non-PHI can be moved up to the predecessor basic block or down to the; /// successor basic block following any PHI instructions. Whether it moves; /// up or down depends on whether the register(s) defined in the instructions; /// are used in current block or in any PHI instructions at the beginning of; /// the successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3604,Availability,down,down,3604," to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// Branch Coalescing does not split blocks, it moves everything in the same; /// direction ensuring it does not break use/definition semantics.; ///; /// PHI nodes and its corresponding use instructions are moved to its successor; /// block if there are no uses within the successor block PHI nodes. PHI; /// node ordering cannot be assumed.; ///; /// Non-PHI can be moved up to the predecessor basic block or down to the; /// successor basic block following any PHI instructions. Whether it moves; /// up or down depends on whether the register(s) defined in the instructions; /// are used in current block or in any PHI instructions at the beginning of; /// the successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:205,Energy Efficiency,schedul,scheduling,205,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:244,Integrability,depend,depend,244,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3609,Integrability,depend,depends,3609," to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// Branch Coalescing does not split blocks, it moves everything in the same; /// direction ensuring it does not break use/definition semantics.; ///; /// PHI nodes and its corresponding use instructions are moved to its successor; /// block if there are no uses within the successor block PHI nodes. PHI; /// node ordering cannot be assumed.; ///; /// Non-PHI can be moved up to the predecessor basic block or down to the; /// successor basic block following any PHI instructions. Whether it moves; /// up or down depends on whether the register(s) defined in the instructions; /// are used in current block or in any PHI instructions at the beginning of; /// the successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:2046,Safety,detect,detected,2046,"/// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:745,Testability,test,test,745,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:793,Testability,test,test,793,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:854,Testability,test,test,854,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:224,Deployability,update,updated,224,"// The analyzeBranch method does not include any implicit operands.; // This is not an issue on PPC but must be handled on other targets.; // For this pass to be made target-independent, the analyzeBranch API; // need to be updated to support implicit operands and there would; // need to be a way to verify that any implicit operands would not be; // clobbered by merging blocks. This would include identifying the; // implicit operands as well as the basic block they are defined in.; // This could be done by changing the analyzeBranch API to have it also; // record and return the implicit operands and the blocks where they are; // defined. Alternatively, the BranchCoalescing code would need to be; // extended to identify the implicit operands. The analysis in canMerge; // must then be extended to prove that none of the implicit operands are; // changed in the blocks that are combined during coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:708,Modifiability,extend,extended,708,"// The analyzeBranch method does not include any implicit operands.; // This is not an issue on PPC but must be handled on other targets.; // For this pass to be made target-independent, the analyzeBranch API; // need to be updated to support implicit operands and there would; // need to be a way to verify that any implicit operands would not be; // clobbered by merging blocks. This would include identifying the; // implicit operands as well as the basic block they are defined in.; // This could be done by changing the analyzeBranch API to have it also; // record and return the implicit operands and the blocks where they are; // defined. Alternatively, the BranchCoalescing code would need to be; // extended to identify the implicit operands. The analysis in canMerge; // must then be extended to prove that none of the implicit operands are; // changed in the blocks that are combined during coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:794,Modifiability,extend,extended,794,"// The analyzeBranch method does not include any implicit operands.; // This is not an issue on PPC but must be handled on other targets.; // For this pass to be made target-independent, the analyzeBranch API; // need to be updated to support implicit operands and there would; // need to be a way to verify that any implicit operands would not be; // clobbered by merging blocks. This would include identifying the; // implicit operands as well as the basic block they are defined in.; // This could be done by changing the analyzeBranch API to have it also; // record and return the implicit operands and the blocks where they are; // defined. Alternatively, the BranchCoalescing code would need to be; // extended to identify the implicit operands. The analysis in canMerge; // must then be extended to prove that none of the implicit operands are; // changed in the blocks that are combined during coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:84,Deployability,update,update,84,///; /// Moves ALL PHI instructions in SourceMBB to beginning of TargetMBB; /// and update them to refer to the new block. PHI node ordering; /// cannot be assumed so it does not matter where the PHI instructions; /// are moved to in TargetMBB.; ///; /// \param[in] SourceMBB block to move PHI instructions from; /// \param[in] TargetMBB block to move PHI instructions to; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3,Deployability,Update,Update,3,// Update all PHI instructions in SourceMBB and move to top of TargetMBB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:385,Safety,safe,safe,385,"///; /// This function checks if MI can be moved to the beginning of the TargetMBB; /// following PHI instructions. A MI instruction can be moved to beginning of; /// the TargetMBB if there are no uses of it within the TargetMBB PHI nodes.; ///; /// \param[in] MI the machine instruction to move.; /// \param[in] TargetMBB the machine basic block to move to; /// \return true if it is safe to move MI to beginning of TargetMBB,; /// false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:395,Safety,safe,safe,395,"///; /// This function checks if MI can be moved to the end of the TargetMBB,; /// immediately before the first terminator. A MI instruction can be moved; /// to then end of the TargetMBB if no PHI node defines what MI uses within; /// it's own MBB.; ///; /// \param[in] MI the machine instruction to move.; /// \param[in] TargetMBB the machine basic block to move to; /// \return true if it is safe to move MI to end of TargetMBB,; /// false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:494,Availability,down,down,494,"///; /// This method determines whether the two coalescing candidates can be merged.; /// In order to be merged, all instructions must be able to; /// 1. Move to the beginning of the SourceRegion.BranchTargetBlock;; /// 2. Move to the end of the TargetRegion.BranchBlock.; /// Merging involves moving the instructions in the; /// TargetRegion.BranchTargetBlock (also SourceRegion.BranchBlock).; ///; /// This function first try to move instructions from the; /// TargetRegion.BranchTargetBlock down, to the beginning of the; /// SourceRegion.BranchTargetBlock. This is not possible if any register defined; /// in TargetRegion.BranchTargetBlock is used in a PHI node in the; /// SourceRegion.BranchTargetBlock. In this case, check whether the statement; /// can be moved up, to the end of the TargetRegion.BranchBlock (immediately; /// before the branch statement). If it cannot move, then these blocks cannot; /// be merged.; ///; /// Note that there is no analysis for moving instructions past the fall-through; /// blocks because they are confirmed to be empty. An assert is thrown if they; /// are not.; ///; /// \param[in] SourceRegion The candidate to move statements from; /// \param[in] TargetRegion The candidate to move statements to; /// \return true if all instructions in SourceRegion.BranchBlock can be merged; /// into a block in TargetRegion, false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:1068,Testability,assert,assert,1068,"///; /// This method determines whether the two coalescing candidates can be merged.; /// In order to be merged, all instructions must be able to; /// 1. Move to the beginning of the SourceRegion.BranchTargetBlock;; /// 2. Move to the end of the TargetRegion.BranchBlock.; /// Merging involves moving the instructions in the; /// TargetRegion.BranchTargetBlock (also SourceRegion.BranchBlock).; ///; /// This function first try to move instructions from the; /// TargetRegion.BranchTargetBlock down, to the beginning of the; /// SourceRegion.BranchTargetBlock. This is not possible if any register defined; /// in TargetRegion.BranchTargetBlock is used in a PHI node in the; /// SourceRegion.BranchTargetBlock. In this case, check whether the statement; /// can be moved up, to the end of the TargetRegion.BranchBlock (immediately; /// before the branch statement). If it cannot move, then these blocks cannot; /// be merged.; ///; /// Note that there is no analysis for moving instructions past the fall-through; /// blocks because they are confirmed to be empty. An assert is thrown if they; /// are not.; ///; /// \param[in] SourceRegion The candidate to move statements from; /// \param[in] TargetRegion The candidate to move statements to; /// \return true if all instructions in SourceRegion.BranchBlock can be merged; /// into a block in TargetRegion, false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:129,Availability,down,down,129,// Walk through the MI to see if they should be merged into; // TargetRegion.BranchBlock (up) or SourceRegion.BranchTargetBlock (down),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:309,Deployability,update,updated,309,"/// Merge the instructions from SourceRegion.BranchBlock,; /// SourceRegion.BranchTargetBlock, and SourceRegion.FallThroughBlock into; /// TargetRegion.BranchBlock, TargetRegion.BranchTargetBlock and; /// TargetRegion.FallThroughBlock respectively.; ///; /// The successors for blocks in TargetRegion will be updated to use the; /// successors from blocks in SourceRegion. Finally, the blocks in SourceRegion; /// will be removed from the function.; ///; /// A region consists of a BranchBlock, a FallThroughBlock, and a; /// BranchTargetBlock. Branch coalesce works on patterns where the; /// TargetRegion's BranchTargetBlock must also be the SourceRegions's; /// BranchBlock.; ///; /// Before mergeCandidates:; ///; /// +---------------------------+; /// | TargetRegion.BranchBlock |; /// +---------------------------+; /// / |; /// / +--------------------------------+; /// | | TargetRegion.FallThroughBlock |; /// \ +--------------------------------+; /// \ |; /// +----------------------------------+; /// | TargetRegion.BranchTargetBlock |; /// | SourceRegion.BranchBlock |; /// +----------------------------------+; /// / |; /// / +--------------------------------+; /// | | SourceRegion.FallThroughBlock |; /// \ +--------------------------------+; /// \ |; /// +----------------------------------+; /// | SourceRegion.BranchTargetBlock |; /// +----------------------------------+; ///; /// After mergeCandidates:; ///; /// +-----------------------------+; /// | TargetRegion.BranchBlock |; /// | SourceRegion.BranchBlock |; /// +-----------------------------+; /// / |; /// / +---------------------------------+; /// | | TargetRegion.FallThroughBlock |; /// | | SourceRegion.FallThroughBlock |; /// \ +---------------------------------+; /// \ |; /// +----------------------------------+; /// | SourceRegion.BranchTargetBlock |; /// +----------------------------------+; ///; /// \param[in] SourceRegion The candidate to move blocks from; /// \param[in] TargetRegion The candidate to move blo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:110,Availability,down,down,110,// Start the merging process by first handling the BranchBlock.; // Move any PHIs in SourceRegion.BranchBlock down to the branch-taken block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3,Deployability,Update,Update,3,"// Update branch in TargetRegion.BranchBlock to jump to; // SourceRegion.BranchTargetBlock; // In this case, TargetRegion.BranchTargetBlock == SourceRegion.BranchBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:48,Availability,down,down,48,// Transfer successor information and move PHIs down to the; // branch-taken block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:323,Integrability,synchroniz,synchronized,323,"/// We need to be careful about the offset of the first block in the function; /// because it might not have the function's alignment. This happens because,; /// under the ELFv2 ABI, for functions which require a TOC pointer, we add a; /// two-instruction sequence to the start of the function.; /// Note: This needs to be synchronized with the check in; /// PPCLinuxAsmPrinter::EmitFunctionBodyStart.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:647,Safety,safe,safe,647,// All 8 byte instructions may require alignment. Each 8 byte; // instruction may be aligned by another 4 bytes.; // This means that an 8 byte instruction may require 12 bytes; // (8 for the instruction itself and 4 for the alignment nop).; // This will happen if an 8 byte instruction can be aligned to 64 bytes; // by only adding a 4 byte nop.; // We don't know the alignment at this point in the code so we have to; // adopt a more pessimistic approach. If an instruction may need; // alignment we assume that it does need alignment and add 4 bytes to; // it. As a result we may end up with more long branches than before; // but we are in the safe position where if we need a long branch we; // have one.; // The if statement checks to make sure that two 8 byte instructions; // are at least 64 bytes away from each other. It is not possible for; // two instructions that both need alignment to be within 64 bytes of; // each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:2011,Safety,safe,safety,2011," estimate code size due to large alignment and; // inline assembly. Usually it causes larger computed branch offset.; // But sometimes it may also causes smaller computed branch offset; // than actual branch offset. If the offset is close to the limit of; // encoding, it may cause problem at run time.; // Following is a simplified example.; //; // actual estimated; // address address; // ...; // bne Far 100 10c; // .p2align 4; // Near: 110 110; // ...; // Far: 8108 8108; //; // Actual offset: 0x8108 - 0x100 = 0x8008; // Computed offset: 0x8108 - 0x10c = 0x7ffc; //; // This example also shows when we can get the largest gap between; // estimated offset and actual offset. If there is an aligned block; // ABB between branch and target, assume its alignment is <align>; // bits. Now consider the accumulated function size FSIZE till the end; // of previous block PBB. If the estimated FSIZE is multiple of; // 2^<align>, we don't need any padding for the estimated address of; // ABB. If actual FSIZE at the end of PBB is 4 bytes more than; // multiple of 2^<align>, then we need (2^<align> - 4) bytes of; // padding. It also means the actual branch offset is (2^<align> - 4); // larger than computed offset. Other actual FSIZE needs less padding; // bytes, so causes smaller gap between actual and computed offset.; //; // On the other hand, if the inline asm or large alignment occurs; // between the branch block and destination block, the estimated address; // can be <delta> larger than actual address. If padding bytes are; // needed for a later aligned block, the actual number of padding bytes; // is at most <delta> more than estimated padding bytes. So the actual; // aligned block address is less than or equal to the estimated aligned; // block address. So the actual branch offset is less than or equal to; // computed branch offset.; //; // The computed offset is at most ((1 << alignment) - 4) bytes smaller; // than actual offset. So we add this number to the offset for safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:340,Usability,simpl,simplified,340,"// We tend to over estimate code size due to large alignment and; // inline assembly. Usually it causes larger computed branch offset.; // But sometimes it may also causes smaller computed branch offset; // than actual branch offset. If the offset is close to the limit of; // encoding, it may cause problem at run time.; // Following is a simplified example.; //; // actual estimated; // address address; // ...; // bne Far 100 10c; // .p2align 4; // Near: 110 110; // ...; // Far: 8108 8108; //; // Actual offset: 0x8108 - 0x100 = 0x8008; // Computed offset: 0x8108 - 0x10c = 0x7ffc; //; // This example also shows when we can get the largest gap between; // estimated offset and actual offset. If there is an aligned block; // ABB between branch and target, assume its alignment is <align>; // bits. Now consider the accumulated function size FSIZE till the end; // of previous block PBB. If the estimated FSIZE is multiple of; // 2^<align>, we don't need any padding for the estimated address of; // ABB. If actual FSIZE at the end of PBB is 4 bytes more than; // multiple of 2^<align>, then we need (2^<align> - 4) bytes of; // padding. It also means the actual branch offset is (2^<align> - 4); // larger than computed offset. Other actual FSIZE needs less padding; // bytes, so causes smaller gap between actual and computed offset.; //; // On the other hand, if the inline asm or large alignment occurs; // between the branch block and destination block, the estimated address; // can be <delta> larger than actual address. If padding bytes are; // needed for a later aligned block, the actual number of padding bytes; // is at most <delta> more than estimated padding bytes. So the actual; // aligned block address is less than or equal to the estimated aligned; // block address. So the actual branch offset is less than or equal to; // computed branch offset.; //; // The computed offset is at most ((1 << alignment) - 4) bytes smaller; // than actual offset. So we add this number to the o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:52,Deployability,update,updated,52,"// If we're going to iterate again, make sure we've updated our; // padding-based contributions to the block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:54,Deployability,Release,Release,54,// gracefully fallback to PPC C calling convention on Release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:254,Energy Efficiency,allocate,allocated,254,"// For vector and __float128 (which is represents the ""vector"" section; // in 2.2.4.1), shadow two even GPRs (skipping the odd one if it is next; // in the allocation order). To check if the GPR is even, the specific; // condition checks if the register allocated is odd, because the even; // physical registers are odd values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:126,Availability,avail,available,126,"// Skip one register if the first unallocated register has an even register; // number and there are still argument registers available which have not been; // allocated yet. RegNum is actually an index into ArgRegs, which means we; // need to skip a register if RegNum is odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:160,Energy Efficiency,allocate,allocated,160,"// Skip one register if the first unallocated register has an even register; // number and there are still argument registers available which have not been; // allocated yet. RegNum is actually an index into ArgRegs, which means we; // need to skip a register if RegNum is odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:155,Energy Efficiency,allocate,allocate,155,"// Always return false here, as this function only makes sure that the first; // unallocated register has an odd register number and does not actually; // allocate a register for the current argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:205,Energy Efficiency,allocate,allocate,205,"// Always return false here, as this function only makes sure that the two f64; // values a ppc_fp128 value is split into are both passed in registers or both; // passed on the stack and does not actually allocate a register for the; // current argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:49,Energy Efficiency,allocate,allocate,49,"// Same as above, but for return values, so only allocate for R3 and R4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h:55,Integrability,Rout,Routines,55,"//=== PPCCallingConv.h - PPC Custom Calling Convention Routines -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the PPC Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h:413,Integrability,rout,routines,413,"//=== PPCCallingConv.h - PPC Custom Calling Convention Routines -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the PPC Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.cpp:40,Energy Efficiency,Power,PowerPC,40,"//===---- PPCCCState.cpp - CCState with PowerPC specific extensions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.h:38,Energy Efficiency,Power,PowerPC,38,"//===---- PPCCCState.h - CCState with PowerPC specific extensions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp:1060,Energy Efficiency,allocate,allocate,1060,"//===-- PPCCTRLoops.cpp - Generate CTR loops ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass generates machine instructions for the CTR loops related pseudos:; // 1: MTCTRloop/DecreaseCTRloop; // 2: MTCTR8loop/DecreaseCTR8loop; //; // If a CTR loop can be generated:; // 1: MTCTRloop/MTCTR8loop will be converted to ""mtctr""; // 2: DecreaseCTRloop/DecreaseCTR8loop will be converted to ""bdnz/bdz"" and; // its user branch instruction can be deleted.; //; // If a CTR loop can not be generated due to clobber of CTR:; // 1: MTCTRloop/MTCTR8loop can be deleted.; // 2: DecreaseCTRloop/DecreaseCTR8loop will be converted to ""addi -1"" and; // a ""cmplwi/cmpldi"".; //; // This pass runs just before register allocation, because we don't want; // register allocator to allocate register for DecreaseCTRloop if a CTR can be; // generated or if a CTR loop can not be generated, we don't have any condition; // register for the new added ""cmplwi/cmpldi"".; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp:816,Deployability,Release,Release,816,"//===-- PPCCTRLoops.cpp - Verify CTR loops -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass verifies that all bdnz/bdz instructions are dominated by a loop; // mtctr before any other instructions that might clobber the ctr register.; //; //===----------------------------------------------------------------------===//; // CTR loops are produced by the HardwareLoops pass and this pass is simply a; // verification that no invalid CTR loops are produced. As such, it isn't; // something that needs to be run (or even defined) for Release builds so the; // entire file is guarded by NDEBUG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp:675,Usability,simpl,simply,675,"//===-- PPCCTRLoops.cpp - Verify CTR loops -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass verifies that all bdnz/bdz instructions are dominated by a loop; // mtctr before any other instructions that might clobber the ctr register.; //; //===----------------------------------------------------------------------===//; // CTR loops are produced by the HardwareLoops pass and this pass is simply a; // verification that no invalid CTR loops are produced. As such, it isn't; // something that needs to be run (or even defined) for Release builds so the; // entire file is guarded by NDEBUG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp:125,Safety,avoid,avoid,125,"// PPCEarlyReturn pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp:29,Usability,simpl,simple,29,"// PPCEarlyReturn pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:76,Availability,redundant,redundant,76,"// Special case 1, all registers used by ISEL are the same one.; // The non-redundant isel 0, 0, 0, N would not satisfy these conditions; // as it would be ISEL %R0, %ZERO, %R0, %CRN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:76,Safety,redund,redundant,76,"// Special case 1, all registers used by ISEL are the same one.; // The non-redundant isel 0, 0, 0, N would not satisfy these conditions; // as it would be ISEL %R0, %ZERO, %R0, %CRN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:213,Safety,safe,safe,213,"// Special case 2, the two input registers used by ISEL are the same.; // Note: the non-foldable isel RX, 0, 0, N would not satisfy this; // condition as it would be ISEL %RX, %ZERO, %R0, %CRN, which makes it; // safe to fold ISEL to MR(OR) instead of ADDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:133,Availability,redundant,redundant,133,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:221,Availability,down,downstream,221,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:133,Safety,redund,redundant,133,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:248,Testability,test,test,248,"// Special case 2, the two input registers used by ISEL are the same.; // Note 1: We favor merging ISEL expansions over folding a single one. If; // the passed list has multiple merge-able ISEL's, we won't fold any.; // Note 2: There is no need to test for PPC::R0/PPC::X0 because PPC::ZERO/; // PPC::ZERO8 will be used for the first operand if the value is meant to; // be zero. In this case, the useSameRegister method will return false,; // thereby preventing this ISEL from being folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:3,Deployability,Update,Update,3,// Update the liveins for NewSuccessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:3,Deployability,Update,Update,3,// Update the liveins for TrueBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:3,Deployability,Update,Update,3,// Update the liveins for FalseBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:26,Energy Efficiency,Power,PowerPC,26,"//===-- PPCFastISel.cpp - PowerPC FastISel implementation -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PowerPC-specific support for the FastISel class. Some; // of the target-specific code is generated by tablegen in the file; // PPCGenFastISel.inc, which is #included here.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:405,Energy Efficiency,Power,PowerPC-specific,405,"//===-- PPCFastISel.cpp - PowerPC FastISel implementation -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PowerPC-specific support for the FastISel class. Some; // of the target-specific code is generated by tablegen in the file; // PPCGenFastISel.inc, which is #included here.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:284,Performance,Optimiz,Optimize,284,//===----------------------------------------------------------------------===//; //; // TBD:; // fastLowerArguments: Handle simple cases.; // PPCMaterializeGV: Handle TLS.; // SelectCall: Handle function pointers.; // SelectCall: Handle multi-register return values.; // SelectCall: Optimize away nops for local calls.; // processCallArgs: Handle bit-converted arguments.; // finishCall: Handle multi-register return values.; // PPCComputeAddress: Handle parameter references as FrameIndex's.; // PPCEmitCmp: Handle immediate as operand 1.; // SelectCall: Handle small byval arguments.; // SelectIntrinsicCall: Implement.; // SelectSelect: Implement.; // Consider factoring isTypeLegal into the base class.; // Implement switches and jump tables.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:125,Usability,simpl,simple,125,//===----------------------------------------------------------------------===//; //; // TBD:; // fastLowerArguments: Handle simple cases.; // PPCMaterializeGV: Handle TLS.; // SelectCall: Handle function pointers.; // SelectCall: Handle multi-register return values.; // SelectCall: Optimize away nops for local calls.; // processCallArgs: Handle bit-converted arguments.; // finishCall: Handle multi-register return values.; // PPCComputeAddress: Handle parameter references as FrameIndex's.; // PPCEmitCmp: Handle immediate as operand 1.; // SelectCall: Handle small byval arguments.; // SelectIntrinsicCall: Implement.; // SelectSelect: Implement.; // Consider factoring isTypeLegal into the base class.; // Implement switches and jump tables.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:25,Integrability,rout,routines,25,// Instruction selection routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:11,Integrability,rout,routines,11,// Utility routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:17,Integrability,rout,routines,17,// Call handling routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:623,Testability,test,tested,623,"// Major concern about the following 6 cases is NaN result. The comparison; // result consists of 4 bits, indicating lt, eq, gt and un (unordered),; // only one of which will be set. The result is generated by fcmpu; // instruction. However, bc instruction only inspects one of the first 3; // bits, so when un is set, bc instruction may jump to an undesired; // place.; //; // More specifically, if we expect an unordered comparison and un is set, we; // expect to always go to true branch; in such case UEQ, UGT and ULT still; // give false, which are undesired; but UNE, UGE, ULE happen to give true,; // since they are tested by inspecting !eq, !lt, !gt, respectively.; //; // Similarly, for ordered comparison, when un is set, we always expect the; // result to be false. In such case OGT, OLT and OEQ is good, since they are; // actually testing GT, LT, and EQ respectively, which are false. OGE, OLE; // and ONE are tested through !lt, !gt and !eq, and these are true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:844,Testability,test,testing,844,"// Major concern about the following 6 cases is NaN result. The comparison; // result consists of 4 bits, indicating lt, eq, gt and un (unordered),; // only one of which will be set. The result is generated by fcmpu; // instruction. However, bc instruction only inspects one of the first 3; // bits, so when un is set, bc instruction may jump to an undesired; // place.; //; // More specifically, if we expect an unordered comparison and un is set, we; // expect to always go to true branch; in such case UEQ, UGT and ULT still; // give false, which are undesired; but UNE, UGE, ULE happen to give true,; // since they are tested by inspecting !eq, !lt, !gt, respectively.; //; // Similarly, for ordered comparison, when un is set, we always expect the; // result to be false. In such case OGT, OLT and OEQ is good, since they are; // actually testing GT, LT, and EQ respectively, which are false. OGE, OLE; // and ONE are tested through !lt, !gt and !eq, and these are true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:923,Testability,test,tested,923,"// Major concern about the following 6 cases is NaN result. The comparison; // result consists of 4 bits, indicating lt, eq, gt and un (unordered),; // only one of which will be set. The result is generated by fcmpu; // instruction. However, bc instruction only inspects one of the first 3; // bits, so when un is set, bc instruction may jump to an undesired; // place.; //; // More specifically, if we expect an unordered comparison and un is set, we; // expect to always go to true branch; in such case UEQ, UGT and ULT still; // give false, which are undesired; but UNE, UGE, ULE happen to give true,; // since they are tested by inspecting !eq, !lt, !gt, respectively.; //; // Similarly, for ordered comparison, when un is set, we always expect the; // result to be false. In such case OGT, OLT and OEQ is good, since they are; // actually testing GT, LT, and EQ respectively, which are false. OGE, OLE; // and ONE are tested through !lt, !gt and !eq, and these are true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:36,Usability,simpl,simple,36,"// Determine whether the type Ty is simple enough to be handled by; // fast-isel, and return its equivalent machine type in VT.; // FIXME: Copied directly from ARM -- factor into base class?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:86,Performance,load,load,86,"// Determine whether the type Ty is simple enough to be handled by; // fast-isel as a load target, and return its equivalent machine type in VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:36,Usability,simpl,simple,36,"// Determine whether the type Ty is simple enough to be handled by; // fast-isel as a load target, and return its equivalent machine type in VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:46,Modifiability,extend,extended,46,// If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:77,Performance,load,loads,77,"// Prevent assignment of base register to X0, which is inappropriate; // for loads and stores alike.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:57,Usability,simpl,simplified,57,"// If this is a stack pointer and the offset needs to be simplified then; // put the alloca address into a register, set the base type back to; // register and continue. This should almost never happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:10,Performance,load,load,10,"// Emit a load instruction if possible, returning true if we succeeded,; // otherwise false. See commentary below for how the register class of; // the load is determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:152,Performance,load,load,152,"// Emit a load instruction if possible, returning true if we succeeded,; // otherwise false. See commentary below for how the register class of; // the load is determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:66,Performance,load,load,66,"// If ResultReg is given, it determines the register class of the load.; // Otherwise, RC is the register class to use. If the result of the; // load isn't anticipated in this block, both may be zero, in which; // case we must make a conservative guess. In particular, don't assign; // R0 or X0 to the result register, as the result may be used in a load,; // store, add-immediate, or isel that won't permit this. (Though; // perhaps the spill and reload of live-exit values would handle this?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:145,Performance,load,load,145,"// If ResultReg is given, it determines the register class of the load.; // Otherwise, RC is the register class to use. If the result of the; // load isn't anticipated in this block, both may be zero, in which; // case we must make a conservative guess. In particular, don't assign; // R0 or X0 to the result register, as the result may be used in a load,; // store, add-immediate, or isel that won't permit this. (Though; // perhaps the spill and reload of live-exit values would handle this?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:350,Performance,load,load,350,"// If ResultReg is given, it determines the register class of the load.; // Otherwise, RC is the register class to use. If the result of the; // load isn't anticipated in this block, both may be zero, in which; // case we must make a conservative guess. In particular, don't assign; // R0 or X0 to the result register, as the result may be used in a load,; // store, add-immediate, or isel that won't permit this. (Though; // perhaps the spill and reload of live-exit values would handle this?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,Performance,load,load,30,"// If this is a potential VSX load with an offset of 0, a VSX indexed load can; // be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:70,Performance,load,load,70,"// If this is a potential VSX load with an offset of 0, a VSX indexed load can; // be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:32,Performance,load,load,32,// VSX only provides an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:32,Performance,load,load,32,// VSX only provides an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:28,Performance,load,load,28,// Attempt to fast-select a load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:20,Performance,load,loads,20,// FIXME: No atomic loads are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:21,Performance,load,loads,21,// FIXME: No atomics loads are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:25,Usability,simpl,simplest,25,"// For now, just try the simplest case where it's fed by a compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:164,Availability,avail,available,164,"// FIXME: ARM looks for a case where the block containing the compare; // has been split from the block containing the branch. If this happens,; // there is a vreg available containing the result of the compare. I'm; // not sure we can do much, as we've lost the predicate information with; // the compare instruction -- we have a 4-bit CR but don't know which bit; // to test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:372,Testability,test,test,372,"// FIXME: ARM looks for a case where the block containing the compare; // has been split from the block containing the branch. If this happens,; // there is a vreg available containing the result of the compare. I'm; // not sure we can do much, as we've lost the predicate information with; // the compare instruction -- we have a 4-bit CR but don't know which bit; // to test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:72,Energy Efficiency,Power,PowerPC,72,// Only 16-bit integer constants can be represented in compares for; // PowerPC. Others will be materialized into a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:43,Modifiability,extend,extend,43,// Attempt to fast-select a floating-point extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:33,Modifiability,extend,extend,33,// No code is generated for a FP extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:123,Energy Efficiency,Power,PowerISA,123,"// Move an i32 or i64 value in a GPR to an f64 value in an FPR.; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.; // FIXME: The code here is sloppy for the 4-byte case. Can use a 4-byte; // stack slot and 4-byte store/load sequence. Or just sext the 4-byte; // case to 8 bytes which produces tighter code but wastes stack space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:336,Performance,load,load,336,"// Move an i32 or i64 value in a GPR to an f64 value in an FPR.; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.; // FIXME: The code here is sloppy for the 4-byte case. Can use a 4-byte; // stack slot and 4-byte store/load sequence. Or just sext the 4-byte; // case to 8 bytes which produces tighter code but wastes stack space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:17,Modifiability,extend,extend,17,"// If necessary, extend 32-bit int to 64-bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:61,Integrability,depend,depends,61,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:3,Performance,Load,Load,3,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:51,Performance,load,load,51,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:43,Performance,load,load,43,"// Shortcut for SPE. Doesn't need to store/load, since it's all in the GPRs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:237,Safety,avoid,avoid,237,"// FIXME: For now we require the newer floating-point conversion operations; // (which are present only on P7 and A2 server models) when converting; // to single-precision float. Otherwise we have to generate a lot of; // fiddly code to avoid double rounding. If necessary, the fiddly code; // can be found in PPCTargetLowering::LowerINT_TO_FP().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:3,Modifiability,Extend,Extend,3,// Extend the input if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:201,Energy Efficiency,Power,PowerISA,201,"// Move the floating-point value in SrcReg into an integer destination; // register, and return the register (or zero if we can't handle it).; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:94,Availability,avail,available,94,"// Get a stack slot 8 bytes wide, aligned on an 8-byte boundary.; // Note that if have STFIWX available, we could use a 4-byte stack; // slot for i32, but this being fast-isel we'll just go with the; // easiest code gen possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:111,Performance,load,load,111,"// Reload it into a GPR. If we want an i32 on big endian, modify the; // address to have a 4-byte offset so we load from the right place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:417,Energy Efficiency,allocate,allocate,417,"// The prolog code of the callee may store up to 8 GPR argument registers to; // the stack, allowing va_start to index over them in memory if its varargs.; // Because we cannot tell if this is needed on the caller side, we have to; // conservatively assume that it is needed. As such, make sure we have at; // least enough stack space for the caller to store the 8 GPRs.; // FIXME: On ELFv2, it may be unnecessary to allocate the parameter area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,Integrability,protocol,protocol,74,// Prepare to assign register arguments. Every argument uses up a; // GPR protocol register even if it's passed in a floating-point; // register (unless we're using the fast calling convention).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:184,Availability,down,downstream,184,"// If only the low half of a general register is needed, generate; // a GPRC copy instead of a G8RC copy. (EXTRACT_SUBREG can't be; // used along the fast-isel path (not lowered), and downstream logic; // also doesn't like a direct subreg copy on a physical reg.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:195,Testability,log,logic,195,"// If only the low half of a general register is needed, generate; // a GPRC copy instead of a G8RC copy. (EXTRACT_SUBREG can't be; // used along the fast-isel path (not lowered), and downstream logic; // also doesn't like a direct subreg copy on a physical reg.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:82,Modifiability,extend,extended,82,"// Handle simple calls for now, with legal return types and; // those that can be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:10,Usability,simpl,simple,10,"// Handle simple calls for now, with legal return types and; // those that can be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:37,Usability,simpl,simple,37,"// FIXME: FastISel cannot handle non-simple types yet, including 128-bit FP; // types, which is passed through vector register. Skip these types and; // fallback to default SelectionDAG based selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:3,Deployability,patch,patchpoints,3,"// patchpoints are a special case; they always dispatch to a pointer value.; // However, we don't actually want to generate the indirect call sequence; // here (that will be generated, as necessary, during asm printing), and; // the call we generate here will be erased by FastISel::selectPatchpoint,; // so don't try very hard...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:76,Performance,optimiz,optimize,76,// Build direct call with NOP for TOC restore.; // FIXME: We can and should optimize away the NOP for local calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:18,Availability,mask,mask,18,// Add a register mask with the call-preserved registers. Proper; // defs for return values will be added by setPhysRegsDeadExcept().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:41,Modifiability,extend,extending,41,"// We still need to worry about properly extending the sign. For example,; // we could have only a single bit or a constant that needs zero; // extension rather than sign extension. Make sure we pass the return; // value extension property to integer materialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,Modifiability,extend,extend,30,// Attempt to emit an integer extend of SrcReg into DestReg. Both; // signed and zero extensions are supported. Return false if we; // can't handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:37,Modifiability,extend,extend,37,// Attempt to fast-select an integer extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:207,Availability,down,downstream,207,"// If we know the register class needed for the result of this; // instruction, use it. Otherwise pick the register class of the; // correct size that does not contain X0/R0, since we don't know; // whether downstream uses permit that assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:24,Performance,load,loaded,24,// All FP constants are loaded from the constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:156,Integrability,depend,depend,156,"// Global values may be plain old object addresses, TLS object; // addresses, constant pool entries, or jump tables. How we generate; // code for these may depend on small, medium, or large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:47,Performance,load,load,47,"// For small code model, generate a simple TOC load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:36,Usability,simpl,simple,36,"// For small code model, generate a simple TOC load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:90,Availability,avail,available,90,"// If the address is an externally defined symbol, a symbol with common; // or externally available linkage, a non-local function address, or a; // jump table address (not yet needed), or if we are generating code; // for large code model, we generate:; // LDtocL(GV, ADDIStocHA8(%x2, GV)); // Otherwise we generate:; // ADDItocL(ADDIStocHA8(%x2, GV), GV); // Either way, start with the ADDIStocHA8:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:77,Modifiability,extend,extend,77,"// If the constant is in range, use a load-immediate.; // Since LI will sign extend the constant we need to make sure that for; // our zeroext constants that the sign extended constant fits into 16-bits -; // a range of 0..0x7fff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:167,Modifiability,extend,extended,167,"// If the constant is in range, use a load-immediate.; // Since LI will sign extend the constant we need to make sure that for; // our zeroext constants that the sign extended constant fits into 16-bits -; // a range of 0..0x7fff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:38,Performance,load,load-immediate,38,"// If the constant is in range, use a load-immediate.; // Since LI will sign extend the constant we need to make sure that for; // our zeroext constants that the sign extended constant fits into 16-bits -; // a range of 0..0x7fff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:138,Availability,failure,failure,138,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:124,Modifiability,extend,extended,124,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:206,Modifiability,extend,extend,206,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,Availability,redundant,redundant,74,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:304,Availability,redundant,redundant,304,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:427,Energy Efficiency,Power,PowerPC,427,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:19,Modifiability,extend,extends,19,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:84,Modifiability,extend,extend,84,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:163,Modifiability,Extend,Extend,163,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:8,Performance,load,loads,8,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:126,Performance,load,load,126,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,Safety,redund,redundant,74,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:304,Safety,redund,redundant,304,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:414,Testability,test,test,414,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:501,Testability,test,tests,501,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:42,Modifiability,extend,extend,42,// Combine load followed by zero- or sign-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:11,Performance,load,load,11,// Combine load followed by zero- or sign-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:20,Modifiability,extend,extending,20,/* There is no sign-extending load-byte instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,Performance,load,load-byte,30,/* There is no sign-extending load-byte instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:66,Energy Efficiency,efficient,efficient,66,"// Defer to normal argument lowering for now. It's reasonably; // efficient. Consider doing something like ARM to handle the; // case where all args fit in registers, no varargs, no float; // or vector args.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:103,Energy Efficiency,Power,PowerPC,103,"// Handle materializing integer constants into a register. This is not; // automatically generated for PowerPC, so must be explicitly created here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:466,Safety,Avoid,Avoid,466,"// Override for ADDI and ADDI8 to set the correct register class; // on RHS operand 0. The automatic infrastructure naively assumes; // GPRC for i32 and G8RC for i64; the concept of ""no R0"" is lost; // for these cases. At the moment, none of the other automatically; // generated RI instructions require special treatment. However, once; // SelectSelect is implemented, ""isel"" requires similar handling.; //; // Also be conservative about the output register class. Avoid; // assigning R0 or X0 to the output register for GPRC and G8RC; // register classes, as any such result could be used in ADDI, etc.,; // where those regs have another meaning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:58,Safety,avoid,avoid,58,// Override for instructions with one register operand to avoid use of; // R0/X0. The automatic infrastructure isn't aware of the context so; // we must be conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:59,Safety,avoid,avoid,59,// Override for instructions with two register operands to avoid use; // of R0/X0. The automatic infrastructure isn't aware of the context; // so we must be conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:8,Availability,avail,available,8,// Only available on 64-bit for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:174,Energy Efficiency,allocate,allocate,174,"// CR save area offset. We map each of the nonvolatile CR fields; // to the slot for CR2, which is the first of the nonvolatile CR; // fields to be assigned, so that we only allocate one save slot.; // See PPCRegisterInfo::hasReservedSpillSlot() for more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:102,Deployability,Update,Update,102,/// determineFrameLayoutAndUpdate - Determine the size of the frame and maximum; /// call frame size. Update the MachineFunction object with the stack size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:121,Energy Efficiency,allocate,allocated,121,"// No special alignment.; // Note: for PPC32 SVR4ABI, we can still generate stackless; // code if all local vars are reg-allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the new max call frame size if the caller passes in a valid pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:182,Integrability,depend,depending,182,"// FIXME: This is pretty much broken by design: hasFP() might be called really; // early, before the stack layout was calculated and thus hasFP() might return; // true or false here depending on the time of call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:136,Modifiability,variab,variable,136,// needsFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas or; // if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:252,Availability,avail,available,252,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:305,Availability,avail,available,305,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:437,Availability,avail,available,437,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:837,Availability,avail,available,837,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:28,Availability,avail,available,28,"// If the two registers are available, we're all good.; // Note that we only return here if both R0 and R12 are available because; // although the function may not require two unique registers, it may benefit; // from having two so we should try to provide them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:112,Availability,avail,available,112,"// If the two registers are available, we're all good.; // Note that we only return here if both R0 and R12 are available because; // although the function may not require two unique registers, it may benefit; // from having two so we should try to provide them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:15,Availability,avail,available,15,// Get all the available registers in the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:83,Availability,avail,available,83,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:160,Availability,avail,available,160,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:139,Integrability,wrap,wrapping,139,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Availability,avail,available,47,// Set the first scratch register to the first available one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:27,Availability,avail,available,27,"// If there is another one available, set the second scratch register to that.; // Otherwise, set it to either PPC::NoRegister if this function requires two; // or to whatever SR1 is set to if this function doesn't require two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:174,Availability,avail,available,174,"// We need a scratch register for spilling LR and for spilling CR. By default,; // we use two scratch registers to hide latency. However, if only one scratch; // register is available, we can adjust for that by not overlapping the spill; // code. However, if we need to realign the stack (i.e. have a base pointer); // and the stack frame is large, we need two scratch registers.; // Also, stack probe requires two scratch registers, one for old sp, one for; // large frame and large probe size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:120,Performance,latency,latency,120,"// We need a scratch register for spilling LR and for spilling CR. By default,; // we use two scratch registers to hide latency. However, if only one scratch; // register is available, we can adjust for that by not overlapping the spill; // code. However, if we need to realign the stack (i.e. have a base pointer); // and the stack frame is large, we need two scratch registers.; // Also, stack probe requires two scratch registers, one for old sp, one for; // large frame and large probe size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Safety,Abort,Abort,3,// Abort if there is no register info or function info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:23,Deployability,update,update,23,// Only move the stack update on ELFv2 ABI and PPC64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:220,Deployability,update,update,220,// Check the frame size first and return false if it does not fit the; // requirements.; // We need a non-zero frame size as well as a frame that will fit in the red; // zone. This is because by moving the stack pointer update we are now storing; // to the red zone until the stack pointer is updated. If we get an interrupt; // inside the prologue but before the stack update we now have a number of; // stores to the red zone and those stores must all fit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:293,Deployability,update,updated,293,// Check the frame size first and return false if it does not fit the; // requirements.; // We need a non-zero frame size as well as a frame that will fit in the red; // zone. This is because by moving the stack pointer update we are now storing; // to the red zone until the stack pointer is updated. If we get an interrupt; // inside the prologue but before the stack update we now have a number of; // stores to the red zone and those stores must all fit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:370,Deployability,update,update,370,// Check the frame size first and return false if it does not fit the; // requirements.; // We need a non-zero frame size as well as a frame that will fit in the red; // zone. This is because by moving the stack pointer update we are now storing; // to the red zone until the stack pointer is updated. If we get an interrupt; // inside the prologue but before the stack update we now have a number of; // stores to the red zone and those stores must all fit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:213,Deployability,update,updates,213,// Frame pointers and base pointers complicate matters so don't do anything; // if we have them. For example having a frame pointer will sometimes require; // a copy of r1 into r31 and that makes keeping track of updates to r1 more; // difficult. Similar situation exists with setjmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:253,Deployability,update,update,253,// Calls to fast_cc functions use different rules for passing parameters on; // the stack from the ABI and using PIC base in the function imposes; // similar restrictions to using the base pointer. It is not generally safe; // to move the stack pointer update in these situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:218,Safety,safe,safe,218,// Calls to fast_cc functions use different rules for passing parameters on; // the stack from the ABI and using PIC base in the function imposes; // similar restrictions to using the base pointer. It is not generally safe; // to move the stack pointer update in these situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:33,Deployability,update,update,33,// Finally we can move the stack update if we do not require register; // scavenging. Register scavenging can introduce more spills and so; // may make the frame size larger than we have computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:18,Testability,assert,assert,18,"// Regarding this assert: Even though LR is saved in the caller's frame (i.e.,; // LROffset is positive), that slot is callee-owned. Because PPC32 SVR4 has no; // Red Zone, an asynchronous event (a form of ""callee"") could claim a frame &; // overwrite it, so PPC32 SVR4 must claim at least a minimal frame to save LR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:23,Modifiability,variab,variable,23,// Using the same bool variable as below to suppress compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:99,Usability,simpl,simple,99,// Frames of 32KB & larger require special handling because they cannot be; // indexed into with a simple STDU/STWU/STD/STW immediate offset operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:60,Availability,down,down,60,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:34,Deployability,update,update,34,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:185,Deployability,update,update,185,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:210,Deployability,update,update,210,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:125,Safety,avoid,avoid,125,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:34,Deployability,update,update,34,// Check if we can move the stack update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:198,Deployability,update,update,198,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:342,Deployability,update,update,342,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:480,Deployability,update,update,480,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:569,Deployability,update,update,569,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:546,Safety,abort,abort,546,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:194,Deployability,update,update,194,// If the frame index is not negative the callee saved info belongs to a; // stack object that is not a fixed stack object. We ignore non-fixed; // stack objects because we won't move the stack update pointer past them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:82,Safety,abort,abort,82,"// We need all of the Frame Indices to meet these conditions.; // If they do not, abort the whole operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:41,Deployability,update,update,41,// If the operation was not aborted then update the object offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:28,Safety,abort,aborted,28,// If the operation was not aborted then update the object offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Integrability,depend,depends,47,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:169,Safety,avoid,avoid,169,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:191,Testability,log,logic,191,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:114,Energy Efficiency,efficient,efficient,114,"// In the ELFv2 ABI, we are not required to save all CR fields.; // If only one CR field is clobbered, it is more efficient to use; // mfocrf to selectively save just that field, because mfocrf has short; // latency compares to mfcr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:208,Performance,latency,latency,208,"// In the ELFv2 ABI, we are not required to save all CR fields.; // If only one CR field is clobbered, it is more efficient to use; // mfocrf to selectively save just that field, because mfocrf has short; // latency compares to mfcr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:86,Availability,avail,available,86,"// If we need to spill the CR and the LR but we don't have two separate; // registers available, we must spill them one at a time",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:173,Security,hash,hash,173,// Generate the instruction to store the LR. In the case where ROP protection; // is required the register holding the LR should not be killed as it will be; // used by the hash store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:26,Security,Hash,Hash,26,"// Add the ROP protection Hash Store instruction.; // NOTE: This is technically a violation of the ABI. The hash can be saved; // up to 512 bytes into the Protected Zone. This can be outside of the; // initial 288 byte volatile program storage region in the Protected Zone.; // However, this restriction will be removed in an upcoming revision of the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:108,Security,hash,hash,108,"// Add the ROP protection Hash Store instruction.; // NOTE: This is technically a violation of the ABI. The hash can be saved; // up to 512 bytes into the Protected Zone. This can be outside of the; // initial 288 byte volatile program storage region in the Protected Zone.; // However, this restriction will be removed in an upcoming revision of the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:21,Deployability,update,update,21,"// If we use STUX to update the stack pointer, we need the two scratch; // registers TempReg and ScratchReg, we have to save LR here which is stored; // in ScratchReg.; // If the offset can not be encoded into the store instruction, we also have; // to save LR here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:49,Energy Efficiency,POWER,POWER,49,"// If FrameSize <= TLI.getStackProbeSize(MF), as POWER ABI requires backchain; // pointer is always stored at SP, we will get a free probe due to an essential; // STU(X) instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:78,Deployability,update,update,78,"// FIXME: HasSTUX is only read if HasRedZone is not set, in such case, we; // update the ScratchReg to meet the assumption that ScratchReg contains; // the NegFrameSize. This solution is rather tricky.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:49,Deployability,update,update,49,// Save the TOC register after the stack pointer update if a prologue TOC; // save is required for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:367,Availability,avail,available,367,"// The negated frame size is in ScratchReg, and the SPReg has been; // decremented by the frame size: SPReg = old SPReg + ScratchReg.; // Since FPOffset, PBPOffset, etc. are relative to the beginning of; // the stack frame (i.e. the old SP), ideally, we would put the old; // SP into a register and use it as the base for the stores. The; // problem is that the only available register may be ScratchReg,; // which could be R0, and R0 cannot be used as a base address.; // First, set ScratchReg to the old SP. This may need to be modified; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:168,Energy Efficiency,allocate,allocated,168,"// ScratchReg is not R0, so use it as the base register. It is; // already set to the old SP, so we can use the offsets directly.; // Now that the stack frame has been allocated, save all the necessary; // registers using ScratchReg as the base address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:132,Usability,undo,undo,132,// We have changed the object offset above but we do not want to change; // the actual offsets in the CFI instruction so we have to undo the; // offset change here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:192,Deployability,update,update,192,"// Used to probe stack when realignment is required.; // Note that, according to ABI's requirement, *sp must always equals the; // value of back-chain pointer, only st(w|d)u(x) can be used to update sp.; // Following is pseudo code:; // final_sp = (sp & align) + negframesize;; // neg_gap = final_sp - sp;; // while (neg_gap < negprobesize) {; // stdu fp, negprobesize(sp);; // neg_gap -= negprobesize;; // }; // stdux fp, sp, neg_gap; //; // When HasBP & HasRedzone, back-chain pointer is already saved in BPReg; // before probe code, we don't need to save it, so we get one additional reg; // that can be used to materialize the probeside if needed to use xform.; // Otherwise, we can NOT materialize probeside, so we can only use Dform for; // now.; //; // The allocations are:; // if (HasBP && HasRedzone) {; // r0: materialize the probesize if needed so that we can use xform.; // r12: `neg_gap`; // } else {; // r0: back-chain pointer; // r12: `neg_gap`.; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Deployability,Update,Update,3,// Update liveins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:64,Performance,perform,performing,64,"// For case HasBP && MaxAlign > 1, we have to realign the SP by performing; // SP = SP - SP % MaxAlign, thus make the probe more like dynamic probe since; // the offset subtracted from SP is determined by SP's runtime value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:131,Safety,safe,safe,131,"// Since CTR is a volatile register and current shrinkwrap implementation; // won't choose an MBB in a loop as the PrologMBB, it's safe to synthesize a; // CTR loop to probe.; // Calculate trip count and stores it in CTRReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Deployability,Update,Update,3,// Update liveins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:27,Energy Efficiency,allocate,allocated,27,// Get the number of bytes allocated from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:23,Modifiability,variab,variable,23,// Using the same bool variable as below to suppress compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:99,Usability,simpl,simple,99,// Frames of 32KB & larger require special handling because they cannot be; // indexed into with a simple LD/LWZ immediate offset operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:555,Deployability,update,update,555,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:302,Usability,simpl,simple,302,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:430,Usability,simpl,simply,430,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:616,Usability,simpl,simplify,616,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:34,Deployability,update,update,34,// Check if we can move the stack update instruction up the epilogue; // past the callee saves. This will allow the move to LR instruction; // to be executed before the restores of the callee saves which means; // that the callee saves can hide the latency from the MTLR instrcution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:249,Performance,latency,latency,249,// Check if we can move the stack update instruction up the epilogue; // past the callee saves. This will allow the move to LR instruction; // to be executed before the restores of the callee saves which means; // that the callee saves can hide the latency from the MTLR instrcution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:83,Deployability,update,update,83,// If the callee saved register is spilled to another register abort the; // stack update movement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:63,Safety,abort,abort,63,// If the callee saved register is spilled to another register abort the; // stack update movement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:188,Deployability,update,update,188,// If the frame index is not negative the callee saved info belongs to a; // stack object that is not a fixed stack object. We ignore non-fixed; // stack objects because we won't move the update of the stack pointer; // past them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:35,Deployability,update,update,35,// Abort the operation as we can't update all CSR restores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Safety,Abort,Abort,3,// Abort the operation as we can't update all CSR restores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:24,Performance,load,loaded,24,"// In the prologue, the loaded (or persistent) stack pointer value is; // offset by the STDU/STDUX/STWU/STWUX instruction. For targets with red; // zone add this offset back now.; // If the function has a base pointer, the stack pointer has been copied; // to it so we can restore it by copying in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:239,Availability,avail,available,239,"// If there is no red zone, ScratchReg may be needed for holding a useful; // value (although not the base register). Make sure it is not overwritten; // too early.; // If we need to restore both the LR and the CR and we only have one; // available scratch register, we must do them one at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:31,Performance,load,loaded,31,"// There is nothing more to be loaded from the stack, so now we can; // restore SP: SP = RBReg + SPAdd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:7,Performance,load,load,7,// Now load the LR from the caller's stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:81,Security,hash,hash,81,"// If ROP protection is required, an extra instruction is added to compute a; // hash and then compare it to the hash stored in the prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:113,Security,hash,hash,113,"// If ROP protection is required, an extra instruction is added to compute a; // hash and then compare it to the hash stored in the prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:85,Performance,optimiz,optimization,85,// Callee pop calling convention. Pop parameter/linkage area. Used for tail; // call optimization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:12,Usability,clear,clear,12,// Save and clear the LR state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for the base pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate the nonvolatile CR spill slot iff the function uses CR 2, 3, or 4.; // For 64-bit SVR4, and all flavors of AIX we create a FixedStack; // object at the offset of the CR-save slot in the linkage area. The actual; // save and restore of the condition register will be created as part of the; // prologue and epilogue insertion, but the FixedStack object is needed to; // keep the CalleSavedInfo valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:29,Integrability,wrap,wrapped,29,"// If the function is shrink-wrapped, and if the function has a tail call, the; // tail call might not be in the new RestoreBlock, so real branch instruction; // won't be generated by emitEpilogue(), because shrink-wrap has chosen new; // RestoreBlock. So we handle this case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:215,Integrability,wrap,wrap,215,"// If the function is shrink-wrapped, and if the function has a tail call, the; // tail call might not be in the new RestoreBlock, so real branch instruction; // won't be generated by emitEpilogue(), because shrink-wrap has chosen new; // RestoreBlock. So we handle this case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Energy Efficiency,allocate,allocated,47,"// Check whether the frame pointer register is allocated. If so, make sure it; // is spilled to the correct offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:32,Deployability,update,update,32,"// FP is R31/X31, so no need to update MinGPR/MinG8R.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Availability,down,down,47,"// Move general register save area spill slots down, taking into account; // the size of the Floating-point register save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Availability,down,down,47,"// Move general register save area spill slots down, taking into account; // the size of the Floating-point register save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:206,Availability,down,downward,206,"// Insert alignment padding, we need 16-byte alignment. Note: for positive; // number the alignment formula is : y = (x + (n-1)) & (~(n-1)). But since; // we are using negative number here (the stack grows downward). We should; // use formula : y = x & (~(n-1)). Where x is the size before aligning, n; // is the alignment size ( n = 16 here) and y is the size after aligning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:257,Availability,error,error,257,// Add the callee-saved register as live-in; it's killed at the spill.; // Do not do this for callee-saved registers that are live-in to the; // function because they will already be marked live-in and this will be; // adding it for a second time. It is an error to add the same register; // to the set more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Usability,Simpl,Simply,3,"// Simply discard ADJCALLSTACKDOWN, ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:30,Testability,log,logic,30,// Initialize insertion-point logic; we will be restoring in reverse; // order of spill.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:109,Deployability,release,release,109,"// On PPC64, we use `stux r1, r1, <scratch_reg>` to extend the stack;; // use `add r1, r1, <scratch_reg>` to release the stack frame.; // Scratch register contains a signed 64-bit number, which is negative; // when extending the stack and is positive when releasing the stack frame.; // To make `stux` and `add` paired, the absolute value of the number contained; // in the scratch register should be the same. Thus the maximum stack size; // is (2^63)-1, i.e., LONG_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:52,Modifiability,extend,extend,52,"// On PPC64, we use `stux r1, r1, <scratch_reg>` to extend the stack;; // use `add r1, r1, <scratch_reg>` to release the stack frame.; // Scratch register contains a signed 64-bit number, which is negative; // when extending the stack and is positive when releasing the stack frame.; // To make `stux` and `add` paired, the absolute value of the number contained; // in the scratch register should be the same. Thus the maximum stack size; // is (2^63)-1, i.e., LONG_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:215,Modifiability,extend,extending,215,"// On PPC64, we use `stux r1, r1, <scratch_reg>` to extend the stack;; // use `add r1, r1, <scratch_reg>` to release the stack frame.; // Scratch register contains a signed 64-bit number, which is negative; // when extending the stack and is positive when releasing the stack frame.; // To make `stux` and `add` paired, the absolute value of the number contained; // in the scratch register should be the same. Thus the maximum stack size; // is (2^63)-1, i.e., LONG_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:55,Energy Efficiency,Power,PowerPC,55,"//===-- PPCFrameLowering.h - Define frame lowering for PowerPC --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:112,Safety,avoid,avoid,112,// Map each group of one or two GPRs to corresponding VSR for spilling.; // TODO: Use local table in methods to avoid this mutable member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:258,Availability,avail,available,258,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:314,Availability,avail,available,314,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:490,Availability,avail,available,490,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:710,Availability,avail,available,710,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:1202,Availability,avail,available,1202,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:1434,Availability,avail,available,1434,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:1527,Availability,avail,available,1527,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:425,Integrability,depend,depending,425,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:66,Deployability,update,update,66,/**; * Check if the conditions are correct to allow for the stack update; * to be moved past the CSR save/restore code.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:38,Deployability,update,update,38,/**; * Determine the frame layout and update the machine function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:45,Deployability,update,update,45,/**; * Determine the frame layout but do not update the machine function.; * The MachineFunction object can be const in this case as it is not; * modified.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:44,Energy Efficiency,Power,PowerPC,44,/// getLinkageSize - Return the size of the PowerPC ABI linkage area.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:27,Integrability,wrap,wrapping,27,/// Methods used by shrink wrapping to determine if MBB can be used for the; /// function prologue/epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp:491,Energy Efficiency,Power,PowerPC,491,"//===-- PPCGenScalarMASSEntries.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation converts standard math functions into their; // corresponding MASS (scalar) entries for PowerPC targets.; // Following are examples of such conversion:; // tanh ---> __xl_tanh_finite; // Such lowering is legal under the fast-math option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp:158,Deployability,update,updated,158,/// Lowers scalar math functions to scalar MASS functions.; /// e.g.: tanh --> __xl_tanh_finite or __xl_tanh; /// Both function prototype and its callsite is updated during lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:35,Energy Efficiency,Power,PowerPC,35,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:427,Energy Efficiency,schedul,scheduling,427,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:441,Energy Efficiency,Power,PowerPC,441,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:43,Safety,Hazard,Hazard,43,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:404,Safety,hazard,hazard,404,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:118,Integrability,depend,dependency,118,"// SU is a load; for any predecessors in this dispatch group, that are stores,; // and with which we have an ordering dependency, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:11,Performance,load,load,11,"// SU is a load; for any predecessors in this dispatch group, that are stores,; // and with which we have an ordering dependency, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:94,Integrability,depend,dependence,94,"// SU is a branch; for any predecessors in this dispatch group, with which we; // have a data dependence and set the counter register, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:6,Testability,log,logicals,6,// cr logicals,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:130,Energy Efficiency,schedul,scheduling,130,"// If we're using a special group-terminating nop, then we need only one.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:183,Energy Efficiency,schedul,scheduling,183,"// If the group has now filled all of its slots, or if we're using a special; // group-terminating nop, the group is complete.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:814,Availability,recover,recovery,814,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:85,Energy Efficiency,Power,PowerPC,85,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:770,Performance,perform,performance,770,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:992,Performance,load,loading,992,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:97,Safety,Hazard,Hazard,97,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:714,Safety,hazard,hazards,714,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:814,Safety,recover,recovery,814,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:1050,Safety,avoid,avoid,1050,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:839,Testability,log,logic,839,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:14,Safety,hazard,hazard,14,// Structural hazard info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:41,Performance,load,load,41,"/// isLoadOfStoredAddress - If we have a load from the previously stored pointer; /// as indicated by StorePtr1/StorePtr2/StoreSize, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:86,Performance,load,load,86,"// Okay the base pointers match, so we have [c1+r] vs [c2+r]. Check; // to see if the load and store actually overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:226,Deployability,pipeline,pipeline,226,/// getHazardType - We return hazard for any non-branch instruction that would; /// terminate the dispatch group. We turn NoopHazard for any; /// instructions that wouldn't terminate the dispatch group that would cause a; /// pipeline flush.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:30,Safety,hazard,hazard,30,/// getHazardType - We return hazard for any non-branch instruction that would; /// terminate the dispatch group. We turn NoopHazard for any; /// instructions that wouldn't terminate the dispatch group that would cause a; /// pipeline flush.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:16,Performance,load,load,16,"// If this is a load following a store, make sure it's not to the same or; // overlapping address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:3,Deployability,Update,Update,3,// Update structural hazard information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:21,Safety,hazard,hazard,21,// Update structural hazard information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:33,Energy Efficiency,Power,PowerPC,33,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:424,Energy Efficiency,schedul,scheduling,424,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:438,Energy Efficiency,Power,PowerPC,438,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:41,Safety,Hazard,Hazard,41,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:401,Safety,hazard,hazard,401,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:87,Safety,hazard,hazard,87,/// PPCDispatchGroupSBHazardRecognizer - This class implements a scoreboard-based; /// hazard recognizer for PPC ooo processors with dispatch-group hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:148,Safety,hazard,hazards,148,/// PPCDispatchGroupSBHazardRecognizer - This class implements a scoreboard-based; /// hazard recognizer for PPC ooo processors with dispatch-group hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:115,Energy Efficiency,Power,PowerPC,115,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:282,Performance,perform,performance,282,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:413,Performance,load,loading,413,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:234,Safety,avoid,avoid,234,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:251,Safety,hazard,hazards,251,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:102,Testability,log,logic,102,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:101,Safety,hazard,hazard,101,"// Number of insts issued, including advanced cycles.; // Various things that can cause a structural hazard.; // HasCTRSet - If the CTR register is set in this group, disallow BCTRL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:67,Performance,load,load,67,"// StoredPtr - Keep track of the address of any store. If we see a load from; // the same address (or one that aliases it), disallow the store. We can have; // up to four stores in one dispatch group, hence we track up to 4.; //; // This is null if we haven't seen a store yet. We keep track of both; // operands of the store here, since we support [r+r] and [r+i] addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:79,Deployability,pipeline,pipeline,79,/// GetInstrType - Classify the specified powerpc opcode according to its; /// pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:42,Energy Efficiency,power,powerpc,42,/// GetInstrType - Classify the specified powerpc opcode according to its; /// pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h:393,Security,expose,exposes,393,"//===-- PPCInstrBuilder.h - Aides for building PPC insts --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to simplify generating frame and constant pool; // references.; //; // For reference, the order of operands for memory references is:; // (Operand), Dest Reg, Base Reg, and either Reg Index or Immediate; // Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h:484,Usability,simpl,simplify,484,"//===-- PPCInstrBuilder.h - Aides for building PPC insts --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to simplify generating frame and constant pool; // references.; //; // For reference, the order of operands for memory references is:; // (Operand), Dest Reg, Base Reg, and either Reg Index or Immediate; // Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:27,Energy Efficiency,Power,PowerPC,27,"//===-- PPCInstrInfo.cpp - PowerPC Instruction Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCInstrInfo.cpp - PowerPC Instruction Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:97,Energy Efficiency,schedul,scheduling,97,/// CreateTargetHazardRecognizer - Return the hazard recognizer to use for; /// this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:46,Safety,hazard,hazard,46,/// CreateTargetHazardRecognizer - Return the hazard recognizer to use for; /// this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:110,Energy Efficiency,schedul,scheduling,110,/// CreateTargetPostRAHazardRecognizer - Return the postRA hazard recognizer; /// to use for this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:59,Safety,hazard,hazard,59,/// CreateTargetPostRAHazardRecognizer - Return the postRA hazard recognizer; /// to use for this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:50,Energy Efficiency,schedul,scheduling,50,// FIXME: Leaving this as-is until we have POWER9 scheduling info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:182,Deployability,pipeline,pipelined,182,"// The default implementation of getInstrLatency calls getStageLatency, but; // getStageLatency does not do the right thing for us. While we have; // itinerary, most cores are fully pipelined, and so the itineraries only; // express the first part of the pipeline, not every stage. Instead, we need; // to use the listed output operand cycle number (using operand 0 here, which; // is an output).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:255,Deployability,pipeline,pipeline,255,"// The default implementation of getInstrLatency calls getStageLatency, but; // getStageLatency does not do the right thing for us. While we have; // itinerary, most cores are fully pipelined, and so the itineraries only; // express the first part of the pipeline, not every stage. Instead, we need; // to use the listed output operand cycle number (using operand 0 here, which; // is an output).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:158,Energy Efficiency,reduce,reduce,158,"// This function does not list all associative and commutative operations, but; // only those worth feeding through the machine combiner in an attempt to; // reduce the critical path. Mostly, this means floating-point operations,; // because they have high latencies(>=5) (compared to other operations, such as; // and/or, which are also associative and commutative, but have low latencies).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:637,Deployability,pipeline,pipeline,637,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:6,Energy Efficiency,Power,PowerPC,6,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:694,Energy Efficiency,Reduce,Reduce,694,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:543,Integrability,depend,dependency,543,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:658,Integrability,depend,depending,658,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:68,Energy Efficiency,reduce,reduce,68,// For now we only need to fix up placeholder for register pressure reduce; // patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Energy Efficiency,reduce,reduce,25,// Not register pressure reduce patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,Performance,load,load,28,// Generate instructions to load the const fp from constant pool.; // We only support PPC64 and medium code model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Performance,load,load,37,// Fill the placeholder with the new load from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:399,Performance,load,load,399,"// Currently, we only enable register pressure reducing in machine combiner; // for: 1: PPC64; 2: Code Model is Medium; 3: Power9 which also has vector; // support.; //; // So we need following instructions to access a TOC entry:; //; // %6:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, %const.0; // %7:vssrc = DFLOADf32 target-flags(ppc-toc-lo) %const.0,; // killed %6:g8rc_and_g8rc_nox0, implicit $x2 :: (load 4 from constant-pool); //; // FIXME: add more supported targets, like Small and Large code model, PPC32,; // AIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:210,Security,access,access,210,"// Currently, we only enable register pressure reducing in machine combiner; // for: 1: PPC64; 2: Code Model is Medium; 3: Power9 which also has vector; // support.; //; // So we need following instructions to access a TOC entry:; //; // %6:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, %const.0; // %7:vssrc = DFLOADf32 target-flags(ppc-toc-lo) %const.0,; // killed %6:g8rc_and_g8rc_nox0, implicit $x2 :: (load 4 from constant-pool); //; // FIXME: add more supported targets, like Small and Large code model, PPC32,; // AIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:8,Energy Efficiency,reduce,reduce,8,// Only reduce register pressure when pressure is high.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:42,Performance,load,load,42,// I has only one memory operand which is load from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,Security,access,access,101,"// Now we only support PPC64, Medium code model and P9 with vector.; // We have immutable pattern to access const pool. See function; // shouldReduceRegisterPressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Performance,Load,Load,12,// Generate Load from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:18,Performance,load,load,18,// Insert the toc load instructions into InsInstrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:75,Performance,load,load,75,// This function returns the const value in constant pool if the \p I is a load; // from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:103,Performance,optimiz,optimizations,103,"// Using the machine combiner in this way is potentially expensive, so; // restrict to when aggressive optimizations are desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update flags for newly created instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update flags for newly created instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:395,Performance,load,load,395,"// We don't want to get negative const from memory pool too early, as the; // created entry will not be deleted even if it has no users. Since all; // operand of Leaf and Root are virtual register, we use zero register; // here as a placeholder. When the InsInstrs is selected in; // MachineCombiner, we call finalizeInsInstrs to replace the zero register; // with a virtual register which is a load from constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Safety,Detect,Detect,3,// Detect 32 -> 64-bit extensions where we may reuse the low sub-register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:184,Availability,mask,mask,184,"// Note that RLWIMI can be commuted as a 32-bit instruction, but not as a; // 64-bit instruction (so we don't handle PPC::RLWIMI8 here), because; // changing the relative order of the mask operands might change what happens; // to the high-bits of the mask (and, thus, the result).; // Cannot commute if it has a non-zero rotate count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:252,Availability,mask,mask,252,"// Note that RLWIMI can be commuted as a 32-bit instruction, but not as a; // 64-bit instruction (so we don't handle PPC::RLWIMI8 here), because; // changing the relative order of the mask operands might change what happens; // to the high-bits of the mask (and, thus, the result).; // Cannot commute if it has a non-zero rotate count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:52,Availability,mask,mask,52,"// If we have a zero rotate count, we have:; // M = mask(MB,ME); // Op0 = (Op1 & ~M) | (Op2 & M); // Change this to:; // M = mask((ME+1)&31, (MB-1)&31); // Op0 = (Op2 & ~M) | (Op1 & M); // Swap op1/op2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:125,Availability,mask,mask,125,"// If we have a zero rotate count, we have:; // M = mask(MB,ME); // Op0 = (Op1 & ~M) | (Op2 & M); // Change this to:; // M = mask((ME+1)&31, (MB-1)&31); // Op0 = (Op2 & ~M) | (Op1 & M); // Swap op1/op2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:57,Deployability,update,update,57,"// If machine instrs are no longer in two-address forms, update; // destination register as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Availability,Mask,Masks,3,// Masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:30,Availability,mask,mask,30,// We can't commute a trivial mask (there is no way to represent an all-zero; // mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Availability,mask,mask,81,// We can't commute a trivial mask (there is no way to represent an all-zero; // mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Availability,mask,mask,12,// Swap the mask around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:29,Energy Efficiency,schedul,scheduling,29,"// This function is used for scheduling, and the nop wanted here is the type; // that terminates dispatch groups on the POWER cores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:120,Energy Efficiency,POWER,POWER,120,"// This function is used for scheduling, and the nop wanted here is the type; // that terminates dispatch groups on the POWER cores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Deployability,Update,Update,10,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:70,Deployability,Update,Update,70,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:89,Energy Efficiency,schedul,scheduling,89,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:6,Deployability,update,update,6,// We update iterator after deleting the last branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:146,Performance,latency,latency,146,"// FIXME: These numbers are for the A2, how well they work for other cores is; // an open question. On the A2, the isel instruction has a 2-cycle latency; // but single-cycle throughput. These numbers are used in combination with; // the MispredictPenalty setting from the active SchedMachineModel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:175,Performance,throughput,throughput,175,"// FIXME: These numbers are for the A2, how well they work for other cores is; // an open question. On the A2, the isel instruction has a 2-cycle latency; // but single-cycle throughput. These numbers are used in combination with; // the MispredictPenalty setting from the active SchedMachineModel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:83,Availability,mask,mask,83,// Rotate the CR bit in the CR fields to be the least significant bit and; // then mask with 0x1 (MB = ME = 31).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:141,Deployability,pipeline,pipeline,141,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:247,Deployability,pipeline,pipeline,247,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:80,Performance,latency,latency,80,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,Performance,latency,latency,191,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:408,Performance,latency,latency,408,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:219,Performance,load,load,219,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,Safety,avoid,avoid,14,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:219,Performance,load,load,219,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,Safety,avoid,avoid,14,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:97,Performance,perform,performs,97,"// For some instructions, it is legal to fold ZERO into the RA register field.; // This function performs that fold by replacing the operand with PPC::ZERO,; // it does not consider whether the load immediate zero is no longer in use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:194,Performance,load,load,194,"// For some instructions, it is legal to fold ZERO into the RA register field.; // This function performs that fold by replacing the operand with PPC::ZERO,; // it does not consider whether the load immediate zero is no longer in use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Performance,load,loaded,37,// A zero immediate should always be loaded with a single li.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:208,Testability,log,logical,208,"// Note that we cannot here invert the arguments of an isel in order to fold; // a ZERO into what is presented as the second argument. All we have here; // is the condition bit, and that might come from a CR-logical bit operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:104,Usability,UX,UX,104,"// Make sure this is not tied to an output register (or otherwise; // constrained). This is true for ST?UX registers, for example, which; // are tied to their output registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:45,Performance,load,load,45,// Folds zero into instructions which have a load immediate zero as an operand; // but also recognize zero as immediate zero. If the definition of the load; // has no more users it is deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:151,Performance,load,load,151,// Folds zero into instructions which have a load immediate zero as an operand; // but also recognize zero as immediate zero. If the definition of the load; // has no more users it is deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Energy Efficiency,schedul,scheduling,25,"// Set MFFS and MTFSF as scheduling boundary to avoid unexpected code motion; // across them, since some FP operations may change content of FPSCR.; // TODO: Model FPSCR in PPC instruction definitions and remove the workaround",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:48,Safety,avoid,avoid,48,"// Set MFFS and MTFSF as scheduling boundary to avoid unexpected code motion; // across them, since some FP operations may change content of FPSCR.; // TODO: Model FPSCR in PPC instruction definitions and remove the workaround",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:34,Testability,test,test,34,// P1 can only subsume P2 if they test the same condition register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:419,Integrability,depend,depend,419,"// The record forms set the condition register based on a signed comparison; // with zero (so says the ISA manual). This is not as straightforward as it; // seems, however, because this is always a 64-bit comparison on PPC64, even; // for instructions that are 32-bit in nature (like slw for example).; // So, on PPC32, for unsigned comparisons, we can use the record forms only; // for equality checks (as those don't depend on the sign). On PPC64,; // we are restricted to equality for unsigned 64-bit comparisons and for; // signed 32-bit comparisons the applicability is more restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:59,Modifiability,extend,extending,59,// We can perform this optimization only if SrcReg is sign-extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Performance,perform,perform,10,// We can perform this optimization only if SrcReg is sign-extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:23,Performance,optimiz,optimization,23,// We can perform this optimization only if SrcReg is sign-extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:74,Modifiability,extend,extending,74,"// We can perform this optimization, equality only, if SrcReg is; // zero-extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Performance,perform,perform,10,"// We can perform this optimization, equality only, if SrcReg is; // zero-extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:23,Performance,optimiz,optimization,23,"// We can perform this optimization, equality only, if SrcReg is; // zero-extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:144,Safety,avoid,avoid,144,// FIXME: Conservatively refuse to convert an instruction which isn't in the; // same BB as the comparison. This is to allow the check below to avoid calls; // (and other explicit clobbers); instead we should really check for these; // more explicitly (in at least a few predecessors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:355,Performance,optimiz,optimize,355,"// The record-form instructions set CR bit based on signed comparison; // against 0. We try to convert a compare against 1 or -1 into a compare; // against 0 to exploit record-form instructions. For example, we change; // the condition ""greater than -1"" into ""greater than or equal to 0""; // and ""less than 1"" into ""less than or equal to 0"".; // Since we optimize comparison based on a specific branch condition,; // we don't optimize if condition code is used by more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:426,Performance,optimiz,optimize,426,"// The record-form instructions set CR bit based on signed comparison; // against 0. We try to convert a compare against 1 or -1 into a compare; // against 0 to exploit record-form instructions. For example, we change; // the condition ""greater than -1"" into ""greater than or equal to 0""; // and ""less than 1"" into ""less than or equal to 0"".; // Since we optimize comparison based on a specific branch condition,; // we don't optimize if condition code is used by more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:149,Performance,optimiz,optimization,149,// Convert the comparison and its user to a compare against zero with the; // appropriate predicate on the branch. Zero comparison might provide; // optimization opportunities post-RA (see optimization in; // PPCPreEmitPeephole.cpp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:189,Performance,optimiz,optimization,189,// Convert the comparison and its user to a compare against zero with the; // appropriate predicate on the branch. Zero comparison might provide; // optimization opportunities post-RA (see optimization in; // PPCPreEmitPeephole.cpp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Availability,redundant,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Safety,redund,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:30,Energy Efficiency,POWER,POWER,30,"// FIXME: On the non-embedded POWER architectures, only some of the record; // forms are fast, and we should use only the fast ones.; // The defining instruction has a record form (or is already a record; // form). It is possible, however, that we'll need to reverse the condition; // code of the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Performance,perform,performed,37,"// This transformation should not be performed if `nsw` is missing and is not; // `equalityOnly` comparison. Since if there is overflow, sub_lt, sub_gt in; // CRReg do not reflect correct order. If `equalityOnly` is true, sub_eq in; // CRReg can reflect if compared values are equal, this optz is still valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:91,Deployability,update,updated,91,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on CMP; // needs to be updated to be based on SUB. Push the condition code; // operands to OperandsToUpdate. If it is safe to remove CmpInstr, the; // condition code of these operands will be modified.; // Here, Value == 0 means we haven't converted comparison against 1 or -1 to; // comparison against 0, which may modify predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:186,Safety,safe,safe,186,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on CMP; // needs to be updated to be based on SUB. Push the condition code; // operands to OperandsToUpdate. If it is safe to remove CmpInstr, the; // condition code of these operands will be modified.; // Here, Value == 0 means we haven't converted comparison against 1 or -1 to; // comparison against 0, which may modify predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:26,Deployability,release,release,26,// To suppress warning in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,Safety,abort,abort,14,// We need to abort on a user we don't understand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:48,Availability,alive,alive,48,"// Even if CR0 register were dead before, it is alive now since the; // instruction we just built uses it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:56,Availability,mask,mask,56,// We can only do this if both the start and end of the mask are in the; // same halfword.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:7,Availability,mask,mask,7,// The mask value needs to shift right 16 if we're emitting andis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:64,Availability,mask,mask,64,"// If we are rotating by the exact number of bits as are in the mask; // and the mask is in the least significant bits of the register,; // that's just an andis. (as long as the GPR result has no uses).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Availability,mask,mask,81,"// If we are rotating by the exact number of bits as are in the mask; // and the mask is in the least significant bits of the register,; // that's just an andis. (as long as the GPR result has no uses).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:20,Availability,mask,mask,20,"// If we've set the mask, we can transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Performance,optimiz,optimize,10,// Try to optimize the comparison against 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:107,Performance,optimiz,optimizeCompareInstr,107,"// The record forms set the condition register based on a signed comparison; // with zero (see comments in optimizeCompareInstr). Since we can't do the; // equality checks in post-RA, we are more restricted on a unsigned; // comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Performance,load,load,25,"// If this is a volatile load/store, don't mess with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:76,Deployability,update,update,76,"// Can't cluster if the instruction modifies the base register; // or it is update form. e.g. ld r2,3(r2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:102,Energy Efficiency,Power,PowerPC,102,"// Only cluster instruction pair that have the same opcode, and they are; // clusterable according to PowerPC specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC backend has opcode STW/STW8 for instruction ""stw"" to deal with; // 32bit and 64bit instruction selection. They are clusterable pair though; // they are different opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,// Cluster the load/store only when they have the same base; // register or FI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Energy Efficiency,Power,PowerPC,60,// Check if the load/store are clusterable according to the PowerPC; // specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:16,Performance,load,load,16,// Check if the load/store are clusterable according to the PowerPC; // specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:112,Energy Efficiency,Power,PowerPC,112,"// Cluster the load/store only when they have the same opcode, and they are; // clusterable opcode according to PowerPC specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,"// Cluster the load/store only when they have the same opcode, and they are; // clusterable opcode according to PowerPC specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:17,Performance,load,load,17,// Can't cluster load/store that have ordered or volatile memory reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,Availability,mask,mask,28,// PPC always uses a direct mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:198,Performance,latency,latency,198,// Expand VSX Memory Pseudo instruction to either a VSX or a FP instruction.; // The VSX versions have the advantage of a full 64-register target whereas; // the FP ones have the advantage of lower latency and higher throughput. So; // what we are after is using the faster instructions in low register pressure; // situations and using the larger register file in high register pressure; // situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:217,Performance,throughput,throughput,217,// Expand VSX Memory Pseudo instruction to either a VSX or a FP instruction.; // The VSX versions have the advantage of a full 64-register target whereas; // the FP ones have the advantage of lower latency and higher throughput. So; // what we are after is using the faster instructions in low register pressure; // situations and using the larger register file in high register pressure; // situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Energy Efficiency,Power,PowerPC,37,// FIXME: Maybe we can expand it in 'PowerPC Expand Atomic' pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:254,Integrability,depend,depending,254,"// Essentially a compile-time implementation of a compare->isel sequence.; // It takes two constants to compare, along with the true/false registers; // and the comparison type (as a subreg to a CR field) and returns one; // of the true/false registers, depending on the comparison results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:61,Modifiability,extend,extended,61,// Signed comparisons. The immediates are assumed to be sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:73,Performance,load,load-immediate,73,// Is this register defined by some form of add-immediate (including; // load-immediate) within this basic block?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:98,Modifiability,variab,variables,98,"// This opt tries to convert the following imm form to an index form to save an; // add for stack variables.; // Return false if no such pattern found.; //; // ADDI instr: ToBeChangedReg = ADDI FrameBaseReg, OffsetAddi; // ADD instr: ToBeDeletedReg = ADD ToBeChangedReg(killed), ScaleReg; // Imm instr: Reg = op OffsetImm, ToBeDeletedReg(killed); //; // can be converted to:; //; // new ADDI instr: ToBeChangedReg = ADDI FrameBaseReg, (OffsetAddi + OffsetImm); // Index instr: Reg = opx ScaleReg, ToBeChangedReg(killed); //; // In order to eliminate ADD instr, make sure that:; // 1: (OffsetAddi + OffsetImm) must be int16 since this offset will be used in; // new ADDI instr and ADDI can only take int16 Imm.; // 2: ToBeChangedReg must be killed in ADD instr and there is no other use; // between ADDI and ADD instr since its original def in ADDI will be changed; // in new ADDI instr. And also there should be no new def for it between; // ADD and Imm instr as ToBeChangedReg will be used in Index instr.; // 3: ToBeDeletedReg must be killed in Imm instr and there is no other use; // between ADD and Imm instr since ADD instr will be eliminated.; // 4: ScaleReg must not be redefined between ADD and Imm instr since it will be; // moved to Index instr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:94,Security,expose,expose,94,"// Do this opt after PEI which is after RA. The reason is stack slot expansion; // in PEI may expose such opportunities since in PEI, stack slot offsets to; // frame base(OffsetAddi) are determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update ADDI instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update Imm instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,// Only handle load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:18,Testability,log,logic,18,// TODO: sync the logic between instrHasImmForm() and ImmToIdxMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,Performance,load,load-immediate,90,"// If this instruction has an immediate form and one of its operands is a; // result of a load-immediate or an add-immediate, convert it to; // the immediate form if the constant is in range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:115,Deployability,update,updated,115,// Conservatively add defs from DefMI and defs/uses from MI to the set of; // registers that need their kill flags updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:161,Availability,Mask,MaskMI,161,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:333,Availability,Mask,MaskMI,333,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:470,Availability,mask,mask,470,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:579,Availability,Mask,MaskMI,579,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,Integrability,wrap,wrap,90,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:254,Integrability,wrap,wrap,254,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:89,Availability,mask,mask,89,"// In MI, we only need low 32 bits of SrcMI, just consider about low 32; // bit of SrcMI mask. Note that in APInt, lowerest bit is at index 0,; // while in PowerPC ISA, lowerest bit is at index 63.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:156,Energy Efficiency,Power,PowerPC,156,"// In MI, we only need low 32 bits of SrcMI, just consider about low 32; // bit of SrcMI mask. Note that in APInt, lowerest bit is at index 0,; // while in PowerPC ISA, lowerest bit is at index 63.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Availability,mask,mask,12,"// If final mask is 0, MI result should be 0 too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Usability,clear,clear,38,"// About to replace MI.getOperand(1), clear its kill flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Availability,mask,mask,12,"// If SrcMI mask is full, no need to update MBMI and MEMI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Deployability,update,update,37,"// If SrcMI mask is full, no need to update MBMI and MEMI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Usability,clear,clear,38,"// About to replace MI.getOperand(1), clear its kill flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:107,Safety,safe,safe,107,"// If FoldingReg has no non-debug use and it has no implicit def (it; // is not RLWINMO or RLWINM8o), it's safe to delete its def SrcMI.; // Otherwise keep it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:166,Deployability,update,update,166,// The vast majority of the instructions would need their operand 2 replaced; // with an immediate when switching to the reg+imm form. A marked exception; // are the update form loads/stores for which a constant operand 2 would need; // to turn into a displacement and move operand 1 to the operand 2 position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:178,Performance,load,loads,178,// The vast majority of the instructions would need their operand 2 replaced; // with an immediate when switching to the reg+imm form. A marked exception; // are the update form loads/stores for which a constant operand 2 would need; // to turn into a displacement and move operand 1 to the operand 2 position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,Performance,load,loaded,101,"// This isn't actually true, but the instructions ignore any of the; // upper bits, so any immediate loaded with an LI is acceptable.; // This does not apply to shift right algebraic because a value; // out of range will produce a -1/0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,Performance,load,loaded,101,"// This isn't actually true, but the instructions ignore any of the; // upper bits, so any immediate loaded with an LI is acceptable.; // This does not apply to shift right algebraic because a value; // out of range will produce a -1/0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Performance,Load,Loads,3,// Loads and stores:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:228,Performance,load,loaded,228,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:65,Security,access,access,65,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:120,Security,access,access,120,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:133,Integrability,depend,depending,133,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:29,Performance,load,loads,29,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:154,Performance,load,load,154,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:168,Performance,load,load,168,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:235,Performance,load,loads,235,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:66,Modifiability,extend,extend,66,"// It is Imm, we need to check if the Imm fit the range.; // Sign-extend to 64-bits.; // DefMI may be folded with another imm form instruction, the result Imm is; // the sum of Imm of DefMI and BaseImm which is from imm form instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:8,Modifiability,extend,extend,8,// Sign-extend to 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:57,Availability,reliab,reliably,57,// Doing this post-RA would require dataflow analysis to reliably find uses; // of the CR register set by the compare.; // No need to fixup killed/dead flag since this transformation is only valid; // before RA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Usability,simpl,simply,25,// Immediate forms - may simply be convertable to an LI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:62,Modifiability,extend,extend,62,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:173,Modifiability,extend,extend,173,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,Safety,safe,safe,191,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Usability,clear,clear,81,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:62,Modifiability,extend,extend,62,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:173,Modifiability,extend,extend,173,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,Safety,safe,safe,191,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Usability,clear,clear,81,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:19,Performance,load,load-immediate,19,"// If the defining load-immediate has no other uses, we can just replace; // the immediate with the new immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:111,Integrability,depend,depending,111,"// If we're not using the GPR result of the CR-setting instruction, we; // just need to and with zero/non-zero depending on the new immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:41,Performance,load,load-immediate,41,"// If we're setting the CR, the original load-immediate must be kept (as an; // operand to ANDI_rec/ANDI8_rec).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Modifiability,extend,extend,10,// FIXME: extend this to post-ra. Need to do some change in getForwardingDefMI; // for post-ra.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,// Only handle load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:132,Safety,safe,safe,132,"// We know that, the MI and DefMI both meet the pattern, and; // the Imm also meet the requirement with the new Imm-form.; // It is safe to do the transformation now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update the base reg first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:9,Deployability,update,update,9,"// Then, update the imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:22,Integrability,interface,interface,22,"// MI didn't have the interface such as MI.setOperand(i) though; // it has MI.getOperand(i). To repalce the ZERO MachineOperand with; // ImmMO, we need to remove ZERO operand and all the operands behind it,; // and, add the ImmMO, then, move back all the operands behind ZERO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update the opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,Modifiability,extend,extend,28,// Get Imm operand and Sign-extend to 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:84,Safety,unsafe,unsafe,84,"// If R0 is in the operand where zero is special for the new instruction,; // it is unsafe to transform if the constant operand isn't that operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Modifiability,extend,extended,38,// The first def of LBZU/LHZU is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Modifiability,extend,extended,25,// RLDICL generates sign-extended output if it clears at least; // 33 bits from the left (MSB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:47,Usability,clear,clears,47,// RLDICL generates sign-extended output if it clears at least; // 33 bits from the left (MSB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:52,Availability,mask,masked,52,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:155,Modifiability,extend,extended,155,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:109,Usability,clear,cleared,109,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:93,Usability,clear,cleared,93,"// If the most significant bit of immediate in ANDIS is zero,; // all of 0 to 32-th bits are cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:44,Modifiability,extend,extended,44,// The first def of LBZU/LHZU/LWZU are zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:32,Modifiability,extend,extended,32,"// The 16-bit immediate is sign-extended in li/lis.; // If the most significant bit is zero, all higher bits are zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:41,Availability,mask,mask,41,// We have some variations of rotate-and-mask instructions; // that clear higher 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:68,Usability,clear,clear,68,// We have some variations of rotate-and-mask instructions; // that clear higher 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:91,Safety,avoid,avoid,91,// We limit the max depth to track incoming values of PHIs or binary ops; // (e.g. AND) to avoid excessive cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Modifiability,extend,extended,60,"// If we know the instruction always returns sign- and zero-extended result,; // return here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,Modifiability,extend,extended,90,"// In both ELFv1 and v2 ABI, method parameters and the return value; // are sign- or zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:41,Modifiability,extend,extended,41,"// If all incoming values are sign-/zero-extended,; // the output of OR, ISEL or PHI is also sign-/zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:104,Modifiability,extend,extended,104,"// If all incoming values are sign-/zero-extended,; // the output of OR, ISEL or PHI is also sign-/zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Modifiability,extend,extended,60,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:102,Modifiability,extend,extended,102,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:156,Modifiability,extend,extended,156,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:194,Modifiability,extend,extended,194,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:122,Energy Efficiency,adapt,adapt,122,"// Do nothing. We want the LOOP setup instruction to stay in the *old*; // preheader, so we can use BDZ in the prologs to adapt the loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:122,Modifiability,adapt,adapt,122,"// Do nothing. We want the LOOP setup instruction to stay in the *old*; // preheader, so we can use BDZ in the prologs to adapt the loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:138,Performance,load,loaded,138,"// Return true if get the base operand, byte offset of an instruction and the; // memory width. Width is the size of memory that is being loaded/stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,loads,15,// Handle only loads/stores with base register followed by immediate offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:118,Performance,load,loaded,118,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:218,Security,access,access,218,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:287,Security,access,access,287,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:315,Security,access,accesses,315,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:25,Energy Efficiency,Power,PowerPC,25,"//===-- PPCInstrInfo.h - PowerPC Instruction Information --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCInstrInfo.h - PowerPC Instruction Information --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:120,Performance,load,load,120,"// Instructions that have an immediate form might be convertible to that; // form if the correct input is a result of a load immediate. In order to; // know whether the transformation is special, we might need to know some; // of the details of the two forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:18,Performance,load,load,18,// Define list of load and store spill opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:25,Performance,load,load,25,// Initialize arrays for load and store spill opcodes on supported subtargets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:7,Energy Efficiency,Power,PowerPC,7,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:53,Energy Efficiency,reduce,reduce,53,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:216,Energy Efficiency,reduce,reduce,216,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:7,Energy Efficiency,Power,PowerPC,7,"/// On PowerPC, we try to reassociate FMA chain which will increase; /// instruction size. Set extension resource length limit to 1 for edge case.; /// Resource Length is calculated by scaled resource usage in getCycles().; /// Because of the division in getCycles(), it returns different cycles due to; /// legacy scaled resource usage. So new resource length may be same with; /// legacy or 1 bigger than legacy.; /// We need to execlude the 1 bigger case even the resource length is not; /// perserved for more FMA chain reassociations on PowerPC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:542,Energy Efficiency,Power,PowerPC,542,"/// On PowerPC, we try to reassociate FMA chain which will increase; /// instruction size. Set extension resource length limit to 1 for edge case.; /// Resource Length is calculated by scaled resource usage in getCycles().; /// Because of the division in getCycles(), it returns different cycles due to; /// legacy scaled resource usage. So new resource length may be same with; /// legacy or 1 bigger than legacy.; /// We need to execlude the 1 bigger case even the resource length is not; /// perserved for more FMA chain reassociations on PowerPC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC specific version of setSpecialOperandAttr that copies Flags to MI; // and clears nuw, nsw, and exact flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:85,Usability,clear,clears,85,"// PowerPC specific version of setSpecialOperandAttr that copies Flags to MI; // and clears nuw, nsw, and exact flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:14,Performance,optimiz,optimization,14,// Comparison optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:145,Performance,load,loaded,145,"/// Return true if get the base operand, byte offset of an instruction and; /// the memory width. Width is the size of memory that is being; /// loaded/stored (e.g. 1, 2, 4, 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:62,Energy Efficiency,schedul,scheduled,62,/// Returns true if the two given memory operations should be scheduled; /// adjacent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:27,Security,access,access,27,/// Return true if two MIs access different memory addresses and false; /// otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:39,Modifiability,extend,extended,39,// Return true if the register is sign-extended from 32 to 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:39,Modifiability,extend,extended,39,// Return true if the register is zero-extended from 32 to 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:123,Deployability,Pipeline,PipelinerLoopInfo,123,"/// Analyze loop L, which must be a single-basic-block loop, and if the; /// conditions can be understood enough produce a PipelinerLoopInfo object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:445,Energy Efficiency,Power,PowerPC,445,"//===-- PPCISelDAGToDAG.cpp - PPC --pattern matching inst selector --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pattern matching instruction selector for PowerPC,; // converting from a legalized dag to a PPC dag.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:54,Security,Hash,Hash,54,// Create a place on the stack for the ROP Protection Hash.; // The ROP Protection Hash will always be 8 bytes and aligned to 8; // bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Security,Hash,Hash,83,// Create a place on the stack for the ROP Protection Hash.; // The ROP Protection Hash will always be 8 bytes and aligned to 8; // bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Availability,Mask,Mask,38,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:90,Availability,mask,mask,90,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:106,Availability,mask,mask,106,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:37,Performance,LOAD,LOAD,37,// tryTLSXFormLoad - Convert an ISD::LOAD fed by a PPCISD::ADD_TLS into; // an X-Form load instruction with the offset being a relocation coming from; // the PPCISD::ADD_TLS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:86,Performance,load,load,86,// tryTLSXFormLoad - Convert an ISD::LOAD fed by a PPCISD::ADD_TLS into; // an X-Form load instruction with the offset being a relocation coming from; // the PPCISD::ADD_TLS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:331,Performance,load,load,331,"/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for; /// inline asm expressions. It is always correct to compute the value into; /// a register. The case of adding a (possibly relocatable) constant to a; /// register can be improved, but it is wrong to substitute Reg+Reg for; /// Reg in an asm, because the load or store opcode would have to change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:96,Security,access,accessing,96,/// getGlobalBaseReg - Output the instructions required to put the; /// base address to use for accessing globals into a register.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,Integrability,wrap,wrapping,154,"// We must ensure that this sequence is dominated by the prologue.; // FIXME: This is a bit of a big hammer since we don't get the benefits; // of shrink-wrapping whenever we emit this instruction. Considering; // this is used in any function where we emit a jump table, this may be; // a significant limitation. We should consider inserting this in the; // block where it is used and then commoning this sequence up if it; // appears in multiple places.; // Note: on ISA 3.0 cores, we can use lnia (addpcis) instead of; // MovePCtoLR8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:33,Deployability,update,updated,33,"// TODO: These asserts should be updated as more support for the toc data; // transformation is added (struct support, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Testability,assert,asserts,15,"// TODO: These asserts should be updated as more support for the toc data; // transformation is added (struct support, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Testability,test,tests,35,/// isInt32Immediate - This method tests to see if the node is a 32-bit constant; /// operand. If so Imm will receive the 32-bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Testability,test,tests,35,/// isInt64Immediate - This method tests to see if the node is a 64-bit constant; /// operand. If so Imm will receive the 64-bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:34,Testability,test,tests,34,// isInt32Immediate - This method tests to see if a constant operand.; // If so Imm will receive the 32 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Testability,test,tests,35,/// isInt64Immediate - This method tests to see if the value is a 64-bit; /// constant operand. If so Imm will receive the 64-bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,Safety,predict,predict,50,"// We only want to handle cases which are easy to predict at static time, e.g.; // C++ throw statement, that is very likely not taken, or calling never; // returned function, e.g. stdlib exit(). So we set Threshold to filter; // unwanted cases.; //; // Below is LLVM branch weight table, we only want to handle case 1, 2; //; // Case Taken:Nontaken Example; // 1. Unreachable 1048575:1 C++ throw, stdlib exit(),; // 2. Invoke-terminating 1:1048575; // 3. Coldblock 4:64 __builtin_expect; // 4. Loop Branch 124:4 For loop; // 5. PH/ZH/FPH 20:12",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,Testability,test,tests,39,// isOpcWithIntImmediate - This method tests to see if the node is a specific; // opcode and that it has a immediate integer right operand.; // If so Imm will receive the 32 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Availability,down,down,17,"// Don't even go down this path for i64, since different logic will be; // necessary for rldicl/rldicr/rldimi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:57,Testability,log,logic,57,"// Don't even go down this path for i64, since different logic will be; // necessary for rldicl/rldicr/rldimi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:7,Availability,mask,mask,7,// bit mask marking indeterminant results,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Availability,mask,mask,23,// apply shift left to mask if it comes first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:24,Availability,mask,mask,24,// apply shift right to mask if it comes first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,Availability,mask,mask,10,// if the mask doesn't intersect any Indeterminant bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Availability,mask,mask,17,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:33,Availability,mask,mask,33,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,Integrability,wrap,wrap,39,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:401,Modifiability,variab,variable,401,"// Account for when ADD_TLS is used for the initial-exec TLS model on Linux.; //; // Although ADD_TLS does not explicitly use the thread pointer; // register when LD_GOT_TPREL_L is one of it's operands, the LD_GOT_TPREL_L; // instruction will have a relocation specifier, @got@tprel, that is used to; // generate a GOT entry. The linker replaces this entry with an offset for a; // for a thread local variable, which will be relative to the thread pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:32,Performance,Optimiz,Optimize,32,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:172,Performance,optimiz,optimized,172,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:199,Performance,load,load,199,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Security,access,accesses,45,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Performance,perform,perform,15,"// In order to perform this optimization inside tryTLSXForm[Load|Store],; // Base is expected to be an ADD_TLS node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:28,Performance,optimiz,optimization,28,"// In order to perform this optimization inside tryTLSXForm[Load|Store],; // Base is expected to be an ADD_TLS node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:60,Performance,Load,Load,60,"// In order to perform this optimization inside tryTLSXForm[Load|Store],; // Base is expected to be an ADD_TLS node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:7,Performance,optimiz,optimization,7,// The optimization to convert the D-Form load/store into its X-Form; // counterpart should only occur if the source value offset of the load/; // store is 0. This also means that The offset should always be undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:42,Performance,load,load,42,// The optimization to convert the D-Form load/store into its X-Form; // counterpart should only occur if the source value offset of the load/; // store is 0. This also means that The offset should always be undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:137,Performance,load,load,137,// The optimization to convert the D-Form load/store into its X-Form; // counterpart should only occur if the source value offset of the load/; // store is 0. This also means that The offset should always be undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:9,Performance,optimiz,optimize,9,// Don't optimize if there are ADD_TLS users that aren't load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:57,Performance,load,load,57,// Don't optimize if there are ADD_TLS users that aren't load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:32,Performance,load,load,32,"// Does the ADD_TLS node of the load/store use the thread pointer?; // If the thread pointer is not used as one of the operands of ADD_TLS,; // then this optimization is not valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,Performance,optimiz,optimization,154,"// Does the ADD_TLS node of the load/store use the thread pointer?; // If the thread pointer is not used as one of the operands of ADD_TLS,; // then this optimization is not valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Availability,mask,masked,22,/// Turn an or of two masked values into the rotate left word immediate then; /// mask insert (rlwimi) instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:82,Availability,mask,mask,82,/// Turn an or of two masked values into the rotate left word immediate then; /// mask insert (rlwimi) instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:11,Availability,mask,mask,11,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:102,Availability,mask,masking,102,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:167,Availability,mask,mask,167,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:262,Availability,mask,mask,262,"// 2-2) Patterns : {zeros}{ones}{15-bit value}{zeros}; // {zeros}{15-bit value}{zeros}; // {zeros}{ones}{15-bit value}; // {ones}{15-bit value}{zeros}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:209,Availability,mask,mask,209,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:502,Usability,clear,clear,502,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:725,Usability,clear,clear,725,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:196,Availability,mask,mask,196,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:734,Usability,clear,clear,734,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:295,Availability,mask,mask,295,"// 2-6) Patterns : {******}{49 zeros}{******}; // {******}{49 ones}{******}; // If the Imm contains 49 consecutive zeros/ones, it means that a total of 15; // bits remain on both sides. Rotate right the Imm to construct an int<16>; // value, use LI for int<16> value and then use RLDICL without mask to rotate; // it back.; //; // 1) findContiguousZerosAtLeast(Imm, 49); // +------|--zeros-|------+ +---ones--||---15 bit--+; // |bbbbbb0000000000aaaaaa| -> |0000000000aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0; //; // 2) findContiguousZerosAtLeast(~Imm, 49); // +------|--ones--|------+ +---ones--||---15 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Integrability,depend,depending,83,"// 2-7) Patterns : High word == Low word; // This may require 2 to 3 instructions, depending on whether Lo32 can be; // materialized in 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:296,Availability,mask,mask,296,"// 3-1) Patterns : {zeros}{ones}{31-bit value}{zeros}; // {zeros}{31-bit value}{zeros}; // {zeros}{ones}{31-bit value}; // {ones}{31-bit value}{zeros}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDIC to mask off the; // ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:244,Availability,mask,mask,244,"// 3-2) Pattern : {zeros}{31-bit value}{ones}; // Shift right the Imm by (32 - LZ) bits to construct a negative 32 bits; // value, therefore we can take advantage of LIS's sign-extension semantics,; // add the remaining bits with ORI, and then mask them off after rotation.; // This is similar to Pattern 2-3, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:230,Availability,mask,mask,230,"// 3-3) Patterns : {zeros}{ones}{31-bit value}{ones}; // {ones}{31-bit value}{ones}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDICL to mask off the; // ones in left sides (if required) after rotation.; // This is similar to Pattern 2-4, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:302,Availability,mask,mask,302,"// 3-4) Patterns : {******}{33 zeros}{******}; // {******}{33 ones}{******}; // If the Imm contains 33 consecutive zeros/ones, it means that a total of 31; // bits remain on both sides. Rotate right the Imm to construct an int<32>; // value, use LIS + ORI for int<32> value and then use RLDICL without mask to; // rotate it back.; // This is similar to Pattern 2-6, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:242,Modifiability,variab,variable,242,// Try to select instructions to generate a 64 bit immediate using prefix as; // well as non prefix instructions. The function will return the SDNode; // to materialize that constant or it will return nullptr if it does not; // find one. The variable InstCnt is set to the number of instructions that; // were selected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:258,Availability,mask,mask,258,"// Patterns : {zeros}{ones}{33-bit value}{zeros}; // {zeros}{33-bit value}{zeros}; // {zeros}{ones}{33-bit value}; // {ones}{33-bit value}{zeros}; // We can take advantage of PLI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones on both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:205,Availability,mask,mask,205,"// Pattern : {zeros}{33-bit value}{ones}; // Shift right the Imm by (30 - LZ) bits to construct a negative 34 bit value,; // therefore we can take advantage of PLI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-33-bit-||--TO--+ +-------------|--34-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; //; // +----sext-----|--34-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:466,Usability,clear,clear,466,"// Pattern : {zeros}{33-bit value}{ones}; // Shift right the Imm by (30 - LZ) bits to construct a negative 34 bit value,; // therefore we can take advantage of PLI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-33-bit-||--TO--+ +-------------|--34-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; //; // +----sext-----|--34-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:206,Availability,mask,mask,206,"// Patterns : {zeros}{ones}{33-bit value}{ones}; // {ones}{33-bit value}{ones}; // Similar to LI we can take advantage of PLI's sign-extension semantics to; // generate leading ones, and then use RLDICL to mask off the ones in left; // sides (if required) after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:281,Availability,mask,mask,281,"// Patterns : {******}{31 zeros}{******}; // : {******}{31 ones}{******}; // If Imm contains 31 consecutive zeros/ones then the remaining bit count; // is 33. Rotate right the Imm to construct a int<33> value, we can use PLI; // for the int<33> value and then use RLDICL without a mask to rotate it back.; //; // +------|--ones--|------+ +---ones--||---33 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:36,Availability,mask,mask,36,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:229,Availability,mask,mask,229,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,Modifiability,Variab,Variable,50,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:88,Modifiability,variab,variable,88,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:102,Modifiability,Variab,VariableKnownToBeZero,102,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:158,Modifiability,variab,variable,158,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Availability,mask,masking,83,"// We need to sort so that the non-Repl32 come first because, when we're; // doing masking, the Repl32 bit groups might be subsumed into the 64-bit; // masking operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:152,Availability,mask,masking,152,"// We need to sort so that the non-Repl32 come first because, when we're; // doing masking, the Repl32 bit groups might be subsumed into the 64-bit; // masking operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:19,Availability,mask,masks,19,"// AND instruction masks this bit. If the input is already zero,; // we have nothing to do here. Otherwise, make the bit ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,Modifiability,Variab,VariableKnownToBeZero,79,"// If both inputs are known to be zero and one is ConstZero and; // another is VariableKnownToBeZero, we can select whichever; // we like. To minimize the number of bit groups, we select; // VariableKnownToBeZero if this bit is the next bit of the same; // input variable from the previous bit. Otherwise, we select; // ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:191,Modifiability,Variab,VariableKnownToBeZero,191,"// If both inputs are known to be zero and one is ConstZero and; // another is VariableKnownToBeZero, we can select whichever; // we like. To minimize the number of bit groups, we select; // VariableKnownToBeZero if this bit is the next bit of the same; // input variable from the previous bit. Otherwise, we select; // ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:263,Modifiability,variab,variable,263,"// If both inputs are known to be zero and one is ConstZero and; // another is VariableKnownToBeZero, we can select whichever; // we like. To minimize the number of bit groups, we select; // VariableKnownToBeZero if this bit is the next bit of the same; // input variable from the previous bit. Otherwise, we select; // ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:7,Testability,Assert,AssertZext,7,"// For AssertZext, we look through the operand and; // mark the bits known to be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:132,Availability,mask,masking,132,// These bits are known to be zero but the AssertZext may be from a value; // that already has some constant zero bits (i.e. from a masking and).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:43,Testability,Assert,AssertZext,43,// These bits are known to be zero but the AssertZext may be from a value; // that already has some constant zero bits (i.e. from a masking and).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:8,Modifiability,extend,extending,8,"// Zero-extending load itself cannot be optimized. So, it is not; // interesting by itself though it gives useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Performance,load,load,18,"// Zero-extending load itself cannot be optimized. So, it is not; // interesting by itself though it gives useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:40,Performance,optimiz,optimized,40,"// Zero-extending load itself cannot be optimized. So, it is not; // interesting by itself though it gives useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,Availability,mask,masking,114,"// Collect groups of consecutive bits with the same underlying value and; // rotation factor. If we're doing late masking, we ignore zeros, otherwise; // they break up groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Availability,mask,masking,23,"// If we're doing late masking, then the first bit group always starts; // at zero (even if the first bits were zero).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:206,Safety,avoid,avoid,206,"// Take all (SDValue, RLAmt) pairs and sort them by the number of groups; // associated with each. If the number of groups are same, we prefer a group; // which does not require rotate, i.e. RLAmt is 0, to avoid the first rotate; // instruction. If there is a degeneracy, pick the one that occurs; // first (in the final value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:138,Availability,mask,mask,138,"// In 64-bit mode, rlwinm and friends have a rotation operator that; // replicates the low-order 32 bits into the high-order 32-bits. The mask; // indices of these instructions can only be in the lower 32 bits, so they; // can only represent some 64-bit bit groups. However, when they can be used,; // the 32-bit replication can be used to represent, as a single bit group,; // otherwise separate bit groups. We'll convert to replicated-32-bit bit; // groups when possible. Returns true if any of the bit groups were; // converted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Modifiability,extend,extends,15,"// This method extends an input value to 64 bit if input is 32-bit integer.; // While selecting instructions in BitPermutationSelector in 64-bit mode,; // an input value can be a 32-bit integer if a ZERO_EXTEND node is included.; // In such case, we extend it to 64 bit to be consistent with other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:250,Modifiability,extend,extend,250,"// This method extends an input value to 64 bit if input is 32-bit integer.; // While selecting instructions in BitPermutationSelector in 64-bit mode,; // an input value can be a 32-bit integer if a ZERO_EXTEND node is included.; // In such case, we extend it to 64 bit to be consistent with other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:95,Availability,mask,mask,95,"// Depending on the number of groups for a particular value, it might be; // better to rotate, mask explicitly (using andi/andis), and then or the; // result. Select this part of the result first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Integrability,Depend,Depending,3,"// Depending on the number of groups for a particular value, it might be; // better to rotate, mask explicitly (using andi/andis), and then or the; // result. Select this part of the result first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Availability,mask,masks,15,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:398,Availability,mask,mask,398,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:658,Availability,mask,mask,658,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:441,Energy Efficiency,schedul,schedule,441,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:529,Energy Efficiency,POWER,POWER,529,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:627,Performance,latency,latency,627,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Availability,mask,masks,58,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:72,Availability,avail,available,72,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:104,Availability,avail,available,104,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:142,Availability,mask,mask,142,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:207,Availability,mask,mask,207,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Availability,mask,mask,16,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:56,Availability,Mask,MaskStart,56,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Availability,mask,masks,58,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:72,Availability,avail,available,72,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:100,Availability,mask,mask-and-insert,100,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,Availability,avail,available,126,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:142,Availability,mask,mask,142,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:207,Availability,mask,mask,207,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Availability,mask,mask,16,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:56,Availability,Mask,MaskStart,56,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:328,Availability,mask,masking,328,"// The idea here is the same as in the 32-bit version, but with additional; // complications from the fact that Repl32 might be true. Because we; // aggressively convert bit groups to Repl32 form (which, for small; // rotation factors, involves no other change), and then coalesce, it might; // be the case that a single 64-bit masking operation could handle both; // some Repl32 groups and some non-Repl32 groups. If converting to Repl32; // form allowed coalescing, then we must use a 32-bit rotaton in order to; // completely capture the new combined bit group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Availability,mask,mask,25,"// We need to add to the mask all bits from the associated bit groups.; // If Repl32 is false, we need to add bits from bit groups that have; // Repl32 true, but are trivially convertable to Repl32 false. Such a; // group is trivially convertable if it overlaps only with the lower 32; // bits, and the group has not been coalesced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:53,Availability,mask,mask,53,// We can use the 32-bit andi/andis technique if the mask does not; // require any higher-order bits. This can save an instruction compared; // to always using the general 64-bit technique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Availability,mask,masks,15,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,Energy Efficiency,POWER,POWER,114,"// When we'd use andi/andis, we bias toward using the rotates (andi only; // has a record form, and is cracked on POWER cores). However, when using; // general 64-bit constant formation, bias toward the constant form,; // because that exposes more opportunities for CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:235,Security,expose,exposes,235,"// When we'd use andi/andis, we bias toward using the rotates (andi only; // has a record form, and is cracked on POWER cores). However, when using; // general 64-bit constant formation, bias toward the constant form,; // because that exposes more opportunities for CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:173,Safety,avoid,avoided,173,"// When merging multiple bit groups, instruction or is used.; // But when rotate is used, rldimi can inert the rotated value into any; // register, so instruction or can be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:205,Availability,mask,mask,205,"// We actually need to generate a rotation if we have a non-zero rotation; // factor or, in the Repl32 case, if we care about any of the; // higher-order replicated bits. In the latter case, we generate a mask; // backward so that it actually includes the entire 64 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Modifiability,flexible,flexible,35,"// Because 64-bit rotates are more flexible than inserts, we might have a; // preference regarding which one we do first (to save one instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:53,Availability,mask,mask,53,// We can use the 32-bit andi/andis technique if the mask does not; // require any higher-order bits. This can save an instruction compared; // to always using the general 64-bit technique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Availability,mask,masks,15,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,Availability,mask,masking,79,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:110,Availability,mask,masking,110,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:124,Availability,mask,masking,124,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:311,Availability,mask,masking,311,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:411,Availability,mask,mask,411,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:456,Availability,mask,masking,456,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,Energy Efficiency,efficient,efficient,154,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:139,Modifiability,extend,extend,139,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:201,Modifiability,extend,extend,201,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:267,Modifiability,extend,extend,267,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:329,Modifiability,extend,extend,329,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Usability,guid,guide,16,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Modifiability,extend,extending,18,"// If we are zero-extending the result of a logical operation on i1; // values, we can keep the values in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:44,Testability,log,logical,44,"// If we are zero-extending the result of a logical operation on i1; // values, we can keep the values in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:14,Performance,perform,perform,14,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:219,Performance,latency,latency,219,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Testability,log,logical,22,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:170,Testability,log,logical,170,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:46,Modifiability,extend,extend,46,// Look through any 32-bit to 64-bit implicit extend nodes to find the; // opcode that is input to the XORI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:43,Testability,log,logical,43,"// If this is not an XORI, it is a reg-reg logical op and we can convert; // it to record-form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:61,Testability,log,logical,61,// Convert the right node to record-form. This is either the logical we're; // looking at or it is the input node to the negation (if we're looking at; // a bitwise negation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:11,Testability,log,logical,11,"// Lower a logical operation on i1 values into a GPR sequence if possible.; // The result can be kept in a GPR if requested.; // Three types of inputs can be handled:; // - SETCC; // - TRUNCATE; // - Logical operation (AND/OR/XOR); // There is also a special case that is handled (namely a complement operation; // achieved with xor %a, -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:200,Testability,Log,Logical,200,"// Lower a logical operation on i1 values into a GPR sequence if possible.; // The result can be kept in a GPR if requested.; // Three types of inputs can be handled:; // - SETCC; // - TRUNCATE; // - Logical operation (AND/OR/XOR); // There is also a special case that is handled (namely a complement operation; // achieved with xor %a, -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Testability,log,logic,58,"// Produces a GPR sequence for each operand of the binary logic operation.; // For SETCC, it produces the respective comparison, for TRUNCATE it truncates; // the value in a GPR and for logic operations, it will recursively produce; // a GPR sequence for the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:186,Testability,log,logic,186,"// Produces a GPR sequence for each operand of the binary logic operation.; // For SETCC, it produces the respective comparison, for TRUNCATE it truncates; // the value in a GPR and for logic operations, it will recursively produce; // a GPR sequence for the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Modifiability,extend,extended,45,"/// If the value isn't guaranteed to be sign-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:66,Modifiability,extend,extend,66,"/// If the value isn't guaranteed to be sign-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Modifiability,extend,extended,22,// The value was sign extended and then truncated to 32-bits. No need to; // sign extend it again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:82,Modifiability,extend,extend,82,// The value was sign extended and then truncated to 32-bits. No need to; // sign extend it again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Modifiability,extend,extending,23,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:52,Modifiability,extend,extending,52,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:77,Modifiability,extend,extend,77,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:33,Performance,load,load,33,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:62,Performance,load,loads,62,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Modifiability,extend,extend,17,// We don't sign-extend constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Modifiability,extend,extended,45,"/// If the value isn't guaranteed to be zero-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:66,Modifiability,extend,extend,66,"/// If the value isn't guaranteed to be zero-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:57,Modifiability,extend,extend,57,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:168,Modifiability,extend,extending,168,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:221,Modifiability,extend,extended,221,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:145,Performance,load,load,145,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:178,Performance,load,load,178,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:41,Modifiability,extend,extend,41,// The input is a load that doesn't sign-extend (it will be zero-extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:65,Modifiability,extend,extended,65,// The input is a load that doesn't sign-extend (it will be zero-extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Performance,load,load,18,// The input is a load that doesn't sign-extend (it will be zero-extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Modifiability,extend,extend,35,"// None of the above, need to zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Modifiability,extend,extended,58,// Produce the value that needs to be either zero or sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:86,Safety,avoid,avoid,86,// The above case covers all the enumerators so it can't have a default clause; // to avoid compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a zero-extended result of comparing two 32-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a sign-extended result of comparing two 32-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a zero-extended result of comparing two 64-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a sign-extended result of comparing two 64-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:109,Modifiability,extend,extending,109,"// For values that have a single use, the caller should obviously already have; // checked if that use is an extending use. We check the other uses here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Modifiability,extend,extended,45,"// We want the value in a GPR if it is being extended, used for a select, or; // used in logical operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:89,Testability,log,logical,89,"// We want the value in a GPR if it is being extended, used for a select, or; // used in logical operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:178,Energy Efficiency,power,power,178,/// Returns an equivalent of a SETCC node but with the result the same width as; /// the inputs. This can also be used for SELECT_CC if either the true or false; /// values is a power of two while the other is zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:8,Performance,optimiz,optimization,8,// This optimization will emit code that assumes 64-bit registers; // so we don't want to run it in 32-bit mode. Also don't run it; // on functions that are not to be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:167,Performance,optimiz,optimized,167,// This optimization will emit code that assumes 64-bit registers; // so we don't want to run it in 32-bit mode. Also don't run it; // on functions that are not to be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:37,Energy Efficiency,efficient,efficiently,37,"// We can codegen setcc op, imm very efficiently compared to a brcond.; // Check for those cases here.; // setcc op, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:31,Performance,load,load,31,/// Does this node represent a load/store node whose address can be represented; /// with a register plus an immediate that's a multiple of \p Val:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,Performance,optimiz,optimization,21,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:284,Performance,optimiz,optimization,284,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:400,Performance,latency,latency,400,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:438,Safety,avoid,avoid,438,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:88,Availability,mask,mask,88,"// If this is an and of a value rotated between 0 and 31 bits and then and'd; // with a mask, emit rlwinm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,Availability,mask,masked,21,"// If this is just a masked value where the input is not handled, and; // is not a rotate-left (handled by a pattern in the .td file), emit rlwinm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,Availability,mask,mask,79,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:103,Availability,mask,mask,103,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:117,Integrability,wrap,wrapped,117,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Performance,Optimiz,Optimized,3,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:134,Availability,mask,mask,134,// Rotate left by OnesOnLeft (so leading ones are now trailing ones) and clear; // on the left the bits that are already zeros in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:73,Usability,clear,clear,73,// Rotate left by OnesOnLeft (so leading ones are now trailing ones) and clear; // on the left the bits that are already zeros in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:235,Usability,undo,undo,235,// MB-ME+63 ME MB; // +----------------------+ +----------------------+; // |0000001111111111111111| -> |0001111100000011111111|; // +----------------------+ +----------------------+; // 0 63 0 63; // Rotate back by 64 - OnesOnLeft to undo previous rotate. Then clear on the; // left the number of ones we previously added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:262,Usability,clear,clear,262,// MB-ME+63 ME MB; // +----------------------+ +----------------------+; // |0000001111111111111111| -> |0001111100000011111111|; // +----------------------+ +----------------------+; // 0 63 0 63; // Rotate back by 64 - OnesOnLeft to undo previous rotate. Then clear on the; // left the number of ones we previously added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:113,Availability,mask,mask,113,"// The idea here is to check whether this is equivalent to:; // (c1 & m) | (x & ~m); // where m is a run-of-ones mask. The logic here is that, for each bit in; // c1 and c2:; // - if both are 1, then the output will be 1.; // - if both are 0, then the output will be 0.; // - if the bit in c1 is 0, and the bit in c2 is 1, then the output will; // come from x.; // - if the bit in c1 is 1, and the bit in c2 is 0, then the output will; // be 0.; // If that last condition is never the case, then we can form m from the; // bits that are the same between c1 and c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:123,Testability,log,logic,123,"// The idea here is to check whether this is equivalent to:; // (c1 & m) | (x & ~m); // where m is a run-of-ones mask. The logic here is that, for each bit in; // c1 and c2:; // - if both are 1, then the output will be 1.; // - if both are 0, then the output will be 0.; // - if the bit in c1 is 0, and the bit in c2 is 1, then the output will; // come from x.; // - if the bit in c1 is 1, and the bit in c2 is 0, then the output will; // be 0.; // If that last condition is never the case, then we can form m from the; // bits that are the same between c1 and c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,Safety,avoid,avoid,21,"// Looking to try to avoid a situation like this one:; // %2 = tail call i64 @llvm.fshl.i64(i64 %word, i64 %word, i64 23); // %and1 = and i64 %2, 9223372036854775807; // In this function we are looking to try to match RLDCL. However, the above; // DAG would better match RLDICL instead which is not what we are looking; // for here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Availability,mask,mask,38,"// If this is a 64-bit zero-extension mask, emit rldicl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:218,Availability,mask,mask,218,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:233,Availability,mask,mask,233,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:264,Availability,mask,mask,264,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:276,Availability,mask,mask,276,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Testability,log,logical,23,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:46,Availability,mask,mask,46,"// If this is a negated 64-bit zero-extension mask,; // i.e. the immediate is a sequence of ones from most significant side; // and all zero for reminder, we should use rldicr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Performance,optimiz,optimizations,35,"// In case any misguided DAG-level optimizations form an ADD with a; // TargetConstant operand, crash here instead of miscompiling (by selecting; // an r+r add instead of some kind of r+i add).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:122,Performance,optimiz,optimized,122,// We will emit PPC::TD or PPC::TW if the 2nd and 3rd operands are reg +; // reg or imm + imm. The imm + imm form will be optimized to either an; // unconditional trap or a nop in a later pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:302,Availability,error,error,302,"// We emit the PPC::FSELS instruction here because of type conflicts with; // the comparison operand. The FSELS instruction is defined to use an 8-byte; // comparison like the FSELD version. The fsels intrinsic takes a 4-byte; // value for the comparison. When selecting through a .td file, a type; // error is raised. Must check this first so we never break on the; // !Subtarget->isISA3_1() check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Deployability,update,update,38,// Vector string isolate instructions update the EQ bit of CR6.; // Generate a SETBC instruction to extract the bit and place it in a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:76,Security,secur,secure,76,// Attach global base pointer on GETtlsADDR32 node in order to; // generate secure plt code for TLS symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Performance,load,loads,23,// Handle preincrement loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,Performance,load,loads,10,// Normal loads are handled by code generated from the .td file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:61,Performance,load,loads,61,// Change TLS initial-exec (or TLS local-exec on AIX) D-form loads to; // X-form loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:81,Performance,load,loads,81,// Change TLS initial-exec (or TLS local-exec on AIX) D-form loads to; // X-form loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Performance,load,loads,38,// Handle PPC32 integer and normal FP loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Performance,load,loads,38,// Handle PPC32 integer and normal FP loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:30,Availability,mask,mask,30,"// If this is an 'and' with a mask, try to emit rlwinm/rldicl/rldicr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:329,Safety,avoid,avoid,329,"// Make use of SelectCC to generate the comparison to set CR bits, for; // equality comparisons having one literal operand, SelectCC probably; // doesn't need to materialize the whole literal and just use xoris to; // check it first, it leads the following comparison result can't; // exactly represent GT/LT relationship. So to avoid this we specify; // SETGT/SETUGT here instead of SETEQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:73,Availability,mask,mask,73,"// For little endian, we must swap the input operands and adjust; // the mask elements (reverse and invert them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,Testability,log,logical,259,"// A signed comparison of i1 values produces the opposite result to an; // unsigned one if the condition code includes less-than or greater-than.; // This is because 1 is the most negative signed i1 number and the most; // positive unsigned i1 number. The CR-logical operations used for such; // comparisons are non-commutative so for signed comparisons vs. unsigned; // ones, the input operands just need to be swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC only support small, medium and large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:49,Security,access,access,49,// 32-bit ELF always uses a small code model toc access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:65,Performance,load,load,65,"// If it is accessed as got-indirect, we need an extra LWZ/LD to load; // the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:12,Security,access,accessed,12,"// If it is accessed as got-indirect, we need an extra LWZ/LD to load; // the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Safety,safe,safe,18,// Generate a PIC-safe GOT reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Integrability,depend,depending,45,"// This expands into one of three sequences, depending on whether; // the first operand is odd or even, positive or negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:32,Performance,load,load,32,"// Here we want to handle splat load for type v16i8 and v8i16 when there is; // no direct move, we don't need to use stack for this case. If target has; // direct move, we should be able to get the best selection in the .td file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Availability,mask,mask,83,"// If the alignment for the load is 16 or bigger, we don't need the; // permutated mask to get the required value. The value must be the 0; // element in big endian target or 7/15 in little endian target in the; // result vsx register of lvx instruction.; // Select the instruction in the .td file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:28,Performance,load,load,28,"// If the alignment for the load is 16 or bigger, we don't need the; // permutated mask to get the required value. The value must be the 0; // element in big endian target or 7/15 in little endian target in the; // result vsx register of lvx instruction.; // Select the instruction in the .td file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,Availability,Mask,Mask,39,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:125,Availability,Mask,Mask,125,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:204,Availability,Mask,Mask,204,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:324,Availability,Mask,Mask,324,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:68,Performance,Load,LoadLow,68,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:107,Performance,Load,LoadLow,107,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:116,Performance,Load,LoadLow,116,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:233,Performance,Load,LoadLow,233,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,Performance,Load,LoadHigh,259,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:305,Performance,Load,LoadLow,305,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:314,Performance,Load,LoadHigh,314,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:344,Availability,mask,masking,344,"// If the target supports the cmpb instruction, do the idiom recognition here.; // We don't do this as a DAG combine because we don't want to do it as nodes; // are being combined (because we might miss part of the eventual idiom). We; // don't want to do it during instruction selection because we want to reuse; // the logic for lowering the masking operations already part of the; // instruction selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:321,Testability,log,logic,321,"// If the target supports the cmpb instruction, do the idiom recognition here.; // We don't do this as a DAG combine because we don't want to do it as nodes; // are being combined (because we might miss part of the eventual idiom). We; // don't want to do it during instruction selection because we want to reuse; // the logic for lowering the masking operations already part of the; // instruction selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:152,Integrability,depend,depending,152,"// When we have small integers (i16 to be specific), the form present; // post-legalization uses SETULT in the SELECT_CC for the; // higher-order byte, depending on the fact that the; // even-higher-order bytes are known to all be zero, for example:; // select_cc (xor $lhs, $rhs), 256, 65280, 0, setult; // (so when the second byte is the same, because all higher-order; // bits from bytes 3 and 4 are known to be zero, the result of the; // xor can be at most 255)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:117,Availability,Mask,Mask,117,"// Because we'll be zero-extending the output anyway if don't have a specific; // value for each input byte (via the Mask), we can 'anyext' the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Modifiability,extend,extending,25,"// Because we'll be zero-extending the output anyway if don't have a specific; // value for each input byte (via the Mask), we can 'anyext' the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:9,Availability,Mask,Mask,9,// Res = Mask & CMPB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Availability,Mask,Mask,17,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,Availability,Mask,MaskedMerge,126,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:185,Availability,Mask,Mask,185,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:229,Availability,Mask,Mask,229,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:60,Modifiability,variab,variable,60,"// When CR bit registers are enabled, an extension of an i1 variable to a i32; // or i64 value is lowered in terms of a SELECT_I[48] operation, and thus; // involves constant materialization of a 0 or a 1 or both. If the result of; // the extension is then operated upon by some operator that can be constant; // folded with a constant 0 or 1, and that constant can be materialized using; // only one instruction (like a zero or one), then we should fold in those; // operations with the select.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:81,Usability,clear,clearly,81,"// FIXME: When the semantics of the interaction between select and undef; // are clearly defined, it may turn out to be unnecessary to break here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Performance,Perform,Perform,25,/// PostprocessISelDAG - Perform some late peephole optimizations; /// on the DAG representation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:52,Performance,optimiz,optimizations,52,/// PostprocessISelDAG - Perform some late peephole optimizations; /// on the DAG representation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:157,Availability,mask,mask,157,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:171,Integrability,wrap,wrap,171,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:65,Usability,clear,clear,65,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:233,Usability,clear,clear,233,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Usability,clear,clear,22,// SLW and SRW always clear the higher-order bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:84,Modifiability,extend,extended,84,"// For LI and LIS, we need the immediate to be positive (so that it is not; // sign extended).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:26,Usability,clear,clear,26,// LHBRX and LWBRX always clear the higher-order bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:69,Modifiability,extend,extended,69,"// CNT[LT]ZW always produce a 64-bit value in [0,32], and so is zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:76,Availability,mask,mask,76,"// Next, check for those instructions we can look through.; // Assuming the mask does not wrap around, then the higher-order bits are; // taken directly from the first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:90,Integrability,wrap,wrap,90,"// Next, check for those instructions we can look through.; // Assuming the mask does not wrap around, then the higher-order bits are; // taken directly from the first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:157,Modifiability,extend,extended,157,"// For ORI and ORIS, we need the higher-order bits of the first operand to be; // zero, and also for the constant to be positive (so that it is not sign; // extended).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:168,Modifiability,extend,extended,168,"// For ANDI and ANDIS, the higher-order bits are zero if either that is true; // of the first operand, or if the second operand is positive (so that it is; // not sign extended).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Modifiability,extend,extend,16,"// When we zero-extend from i32 to i64, we use a pattern like this:; // def : Pat<(i64 (zext i32:$in)),; // (RLDICL (INSERT_SUBREG (i64 (IMPLICIT_DEF)), $in, sub_32),; // 0, 32)>;; // There are several 32-bit shift/rotate instructions, however, that will; // clear the higher-order bits of their output, rendering the RLDICL; // unnecessary. When that happens, we remove it here, and redefine the; // relevant 32-bit operation to be a 64-bit operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,Usability,clear,clear,259,"// When we zero-extend from i32 to i64, we use a pattern like this:; // def : Pat<(i64 (zext i32:$in)),; // (RLDICL (INSERT_SUBREG (i64 (IMPLICIT_DEF)), $in, sub_32),; // 0, 32)>;; // There are several 32-bit shift/rotate instructions, however, that will; // clear the higher-order bits of their output, rendering the RLDICL; // unnecessary. When that happens, we remove it here, and redefine the; // relevant 32-bit operation to be a 64-bit operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,Usability,clear,clear,50,"// There are some 32-bit instructions that always clear the high-order 32; // bits, there are also some instructions (like AND) that we can look; // through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:123,Safety,abort,abort,123,"// If the ToPromote set contains nodes that have uses outside of the set; // (except for the original INSERT_SUBREG), then abort the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,Safety,safe,safely,126,"// Because all to-be-promoted nodes only have users that are other; // promoted nodes (or the original INSERT_SUBREG), we can safely replace; // the i32 result value type with i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:36,Modifiability,extend,extend,36,// Now we replace the original zero extend and its associated INSERT_SUBREG; // with the value feeding the INSERT_SUBREG (which has now been promoted to; // return an i64).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,Usability,simpl,simplify,10,// Try to simplify (xxswap (vec-op (xxswap) (xxswap))) where vec-op is; // lane-insensitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Performance,load,load,16,"// If this is a load or store with a zero offset, or within the alignment,; // we may be able to fold an add-immediate into the memory operation.; // The check against alignment is below, as it can't occur until we check; // the arguments to N",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:202,Performance,load,load,202,"// When the feeding operation is an add-immediate of some sort,; // determine whether we need to add relocation information to the; // target flags on the immediate operand when we fold it into the; // load instruction.; //; // For something like ADDItocL, the relocation information is; // inferred from the opcode; when we process it in the AsmPrinter,; // we add the necessary relocation there. A load, though, can receive; // relocation from various flavors of ADDIxxx, so we need to carry; // the relocation information in the target flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:400,Performance,load,load,400,"// When the feeding operation is an add-immediate of some sort,; // determine whether we need to add relocation information to the; // target flags on the immediate operand when we fold it into the; // load instruction.; //; // For something like ADDItocL, the relocation information is; // inferred from the opcode; when we process it in the AsmPrinter,; // we add the necessary relocation there. A load, though, can receive; // relocation from various flavors of ADDIxxx, so we need to carry; // the relocation information in the target flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:145,Deployability,update,update,145,"// If we have a addi(toc@l)/addis(toc@ha) pair, and the addis has only; // one use, then we can do this for any offset, we just need to also; // update the offset (i.e. the symbol addend) on the addis also.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:116,Security,access,access,116,"// If we're directly folding the addend from an addi instruction, then:; // 1. In general, the offset on the memory access must be zero.; // 2. If the addend is a constant, then it can be combined with a; // non-zero offset, but only if the result meets the encoding; // requirements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:135,Deployability,update,update,135,"// We found an opportunity. Reverse the operands from the add; // immediate and substitute them into the load or store. If; // needed, update the target flags for the immediate operand to; // reflect the necessary relocation information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:105,Performance,load,load,105,"// We found an opportunity. Reverse the operands from the add; // immediate and substitute them into the load or store. If; // needed, update the target flags for the immediate operand to; // reflect the necessary relocation information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:12,Performance,perform,perform,12,// We can't perform this optimization for data whose alignment; // is insufficient for the instruction encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Performance,optimiz,optimization,25,// We can't perform this optimization for data whose alignment; // is insufficient for the instruction encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Performance,Load,Load,3,// Load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:70,Energy Efficiency,Power,PowerPC-specific,70,"/// createPPCISelDag - This pass converts a legalized DAG into a; /// PowerPC-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// createPPCISelDag - This pass converts a legalized DAG into a; /// PowerPC-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:124,Modifiability,variab,variables,124,"// A faster local-exec TLS access sequence (enabled with the; // -maix-small-local-exec-tls option) can be produced for TLS variables;; // consistent with the IBM XL compiler, we apply a max size of slightly under; // 32KB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:27,Security,access,access,27,"// A faster local-exec TLS access sequence (enabled with the; // -maix-small-local-exec-tls option) can be produced for TLS variables;; // consistent with the IBM XL compiler, we apply a max size of slightly under; // 32KB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:87,Performance,load,load,87,// Initialize map that relates the PPC addressing modes to the computed flags; // of a load/store instruction. The map is used to determine the optimal; // addressing mode when selecting load and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Performance,load,load,187,// Initialize map that relates the PPC addressing modes to the computed flags; // of a load/store instruction. The map is used to determine the optimal; // addressing mode when selecting load and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,Modifiability,extend,extended,53,"// On PPC32/64, arguments smaller than 4/8 bytes are extended, so all; // arguments are at least 4/8 bytes aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:66,Modifiability,extend,extended,66,// Sub-word ATOMIC_CMP_SWAP need to ensure that the input is zero-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has an i16 but no i8 (or i1) SEXTLOAD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:6,Modifiability,extend,extending,6,// No extending loads from f16 or HW conversions back and forth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,loads,16,// No extending loads from f16 or HW conversions back and forth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has pre-inc load and store's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,// PowerPC has pre-inc load and store's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC uses ADDC/ADDE/SUBC/SUBE to propagate carry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not support direct load/store of condition registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:35,Performance,load,load,35,// PowerPC does not support direct load/store of condition registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Availability,avail,available,102,// Expand ppcf128 to i32 by hand for the benefit of llvm-gcc bootstrap on; // PPC (the libcall is not available).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Energy Efficiency,Power,PowerPC,52,// We do not currently implement these libm ops for PowerPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:217,Energy Efficiency,efficient,efficient,217,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:403,Performance,perform,performs,403,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Performance,optimiz,optimizations,24,"// If we're enabling GP optimizations, use hardware square root",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Energy Efficiency,Power,PowerPC,17,"// Prior to P10, PowerPC does not have BSWAP, but we can use vector BSWAP; // instruction xxbrd to speed up scalar BSWAP64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have ROTR,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have Select,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC wants to turn select_cc of FP into fsel when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC wants to optimize integer setcc a bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Performance,optimiz,optimize,20,// PowerPC wants to optimize integer setcc a bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have BRCOND which requires SetCC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC turns FP_TO_SINT into FCTIWZ and some load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Performance,load,load,49,// PowerPC turns FP_TO_SINT into FCTIWZ and some load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have [U|S]INT_TO_FP,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:251,Integrability,interface,interfaces,251,"// NOTE: EH_SJLJ_SETJMP/_LONGJMP supported here is NOT intended to support; // SjLj exception handling but a light-weight setjmp/longjmp replacement to; // support continuation, user-level threading, and etc.. As a result, no; // other SjLj exception interfaces are implemented and please don't build; // your own exception handling based on them.; // LLVM/Clang supports zero-cost DWARF exception handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have FP_TO_UINT on 32-bit implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,Power,PowerPC,10,// 64-bit PowerPC implementations can support i64 types directly,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,Power,PowerPC,10,// 64-bit PowerPC wants to expand i128 shifts itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,Power,PowerPC,10,// 32-bit PowerPC wants to expand i64 shifts itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has better expansions for funnel shifts than the generic; // TargetLowering::expandFunnelShift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,Safety,unsafe,unsafe,111,// The nearbyint variants are not allowed to raise the inexact exception; // so we can only code-gen them with unsafe math.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Availability,avail,available,122,"// 128 bit shifts can be accomplished via 3 instructions for SHL and; // SRL, but not for SRA because of the instructions available:; // VS{RL} and VS{RL}O. However due to direct move costs, it's not worth; // doing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:67,Safety,predict,predictor,67,// Handle constrained floating-point operations of vector.; // The predictor is `hasVSX` because altivec instruction has; // no exception but VSX vector instruction has.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Energy Efficiency,Power,PowerPC,39,// No implementation for these ops for PowerPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Testability,Test,Test,3,// Test data class instructions store results in CR bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Availability,avail,available,122,"// 128 bit shifts can be accomplished via 3 instructions for SHL and; // SRL, but not for SRA because of the instructions available:; // VS{RL} and VS{RL}O.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,Safety,avoid,avoid,31,// Set FADD/FSUB as libcall to avoid the legalizer to expand the; // fp_to_uint and int_to_fp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:224,Safety,predict,predict,224,// TODO: The default entry number is set to 64. This stops most jump table; // generation on PPC. But it is good for current PPC HWs because the indirect; // branch instruction mtctr to the jump table may lead to bad branch predict.; // Re-evaluate this value on future HWs that can do better with mtctr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Safety,predict,predictable,39,// Let the subtarget (CPU) decide if a predictable select is more expensive; // than the corresponding branch. This information is used in CGP to decide; // when to convert selects into branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1121,Availability,avail,available,1121,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1684,Deployability,update,updated,1684,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1138,Energy Efficiency,Power,Power,1138,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,Performance,load,load,99,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:264,Performance,load,load,264,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1021,Performance,load,load,1021,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1089,Performance,load,load,1089,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1213,Performance,load,load,1213,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1504,Performance,load,load,1504,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1903,Performance,load,load,1903,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1972,Performance,load,load,1972,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,load,34,// TODO: Add mapping for quadword load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Availability,mask,mask,62,"/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUHUM instruction.; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Availability,mask,mask,62,"/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUWUM instruction.; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Availability,mask,mask,62,"/// isVPKUDUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUDUM instruction, AND the VPKUDUM instruction exists for the; /// current subtarget.; ///; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,Availability,mask,mask,58,"/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGL* instruction with the specified unit size (1,2 or 4 bytes).; /// The ShuffleKind distinguishes between big-endian merges with two; /// different inputs (0), either-endian merges with two identical inputs (1),; /// and little-endian merges with two different inputs (2). For the latter,; /// the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,Availability,mask,mask,58,"/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGH* instruction with the specified unit size (1,2 or 4 bytes).; /// The ShuffleKind distinguishes between big-endian merges with two; /// different inputs (0), either-endian merges with two identical inputs (1),; /// and little-endian merges with two different inputs (2). For the latter,; /// the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Availability,mask,mask,153,"/**; * Common function used to match vmrgew and vmrgow shuffles; *; * The indexOffset determines whether to look for even or odd words in; * the shuffle mask. This is based on the of the endianness of the target; * machine.; * - Little Endian:; * - Use offset of 0 to check for odd elements; * - Use offset of 4 to check for even elements; * - Big Endian:; * - Use offset of 0 to check for even elements; * - Use offset of 4 to check for odd elements; * A detailed description of the vector element ordering for little endian and; * big endian can be found at; * http://www.ibm.com/developerworks/library/l-ibm-xl-c-cpp-compiler/index.html; * Targeting your applications - what little endian and big endian IBM XL C/C++; * compiler differences mean to you; *; * The mask to the shuffle vector instruction specifies the indices of the; * elements from the two input vectors to place in the result. The elements are; * numbered in array-access order, starting with the first vector. These vectors; * are always of type v16i8, thus each vector will contain 16 elements of size; * 8. More info on the shuffle vector can be found in the; * http://llvm.org/docs/LangRef.html#shufflevector-instruction; * Language Reference.; *; * The RHSStartValue indicates whether the same input vectors are used (unary); * or two different input vectors are used, based on the following:; * - If the instruction uses the same vector for both inputs, the range of the; * indices will be 0 to 15. In this case, the RHSStart value passed should; * be 0.; * - If the instruction has two different vectors then the range of the; * indices will be 0 to 31. In this case, the RHSStart value passed should; * be 16 (indices 0-15 specify elements in the first vector while indices 16; * to 31 specify elements in the second vector).; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] IndexOffset Specifies whether to look for even or odd elements; * \param[in] RHSStartValue Specifies the starting index for th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:766,Availability,mask,mask,766,"/**; * Common function used to match vmrgew and vmrgow shuffles; *; * The indexOffset determines whether to look for even or odd words in; * the shuffle mask. This is based on the of the endianness of the target; * machine.; * - Little Endian:; * - Use offset of 0 to check for odd elements; * - Use offset of 4 to check for even elements; * - Big Endian:; * - Use offset of 0 to check for even elements; * - Use offset of 4 to check for odd elements; * A detailed description of the vector element ordering for little endian and; * big endian can be found at; * http://www.ibm.com/developerworks/library/l-ibm-xl-c-cpp-compiler/index.html; * Targeting your applications - what little endian and big endian IBM XL C/C++; * compiler differences mean to you; *; * The mask to the shuffle vector instruction specifies the indices of the; * elements from the two input vectors to place in the result. The elements are; * numbered in array-access order, starting with the first vector. These vectors; * are always of type v16i8, thus each vector will contain 16 elements of size; * 8. More info on the shuffle vector can be found in the; * http://llvm.org/docs/LangRef.html#shufflevector-instruction; * Language Reference.; *; * The RHSStartValue indicates whether the same input vectors are used (unary); * or two different input vectors are used, based on the following:; * - If the instruction uses the same vector for both inputs, the range of the; * indices will be 0 to 15. In this case, the RHSStart value passed should; * be 0.; * - If the instruction has two different vectors then the range of the; * indices will be 0 to 31. In this case, the RHSStart value passed should; * be 16 (indices 0-15 specify elements in the first vector while indices 16; * to 31 specify elements in the second vector).; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] IndexOffset Specifies whether to look for even or odd elements; * \param[in] RHSStartValue Specifies the starting index for th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:935,Security,access,access,935,"/**; * Common function used to match vmrgew and vmrgow shuffles; *; * The indexOffset determines whether to look for even or odd words in; * the shuffle mask. This is based on the of the endianness of the target; * machine.; * - Little Endian:; * - Use offset of 0 to check for odd elements; * - Use offset of 4 to check for even elements; * - Big Endian:; * - Use offset of 0 to check for even elements; * - Use offset of 4 to check for odd elements; * A detailed description of the vector element ordering for little endian and; * big endian can be found at; * http://www.ibm.com/developerworks/library/l-ibm-xl-c-cpp-compiler/index.html; * Targeting your applications - what little endian and big endian IBM XL C/C++; * compiler differences mean to you; *; * The mask to the shuffle vector instruction specifies the indices of the; * elements from the two input vectors to place in the result. The elements are; * numbered in array-access order, starting with the first vector. These vectors; * are always of type v16i8, thus each vector will contain 16 elements of size; * 8. More info on the shuffle vector can be found in the; * http://llvm.org/docs/LangRef.html#shufflevector-instruction; * Language Reference.; *; * The RHSStartValue indicates whether the same input vectors are used (unary); * or two different input vectors are used, based on the following:; * - If the instruction uses the same vector for both inputs, the range of the; * indices will be 0 to 15. In this case, the RHSStart value passed should; * be 0.; * - If the instruction has two different vectors then the range of the; * indices will be 0 to 31. In this case, the RHSStart value passed should; * be 16 (indices 0-15 specify elements in the first vector while indices 16; * to 31 specify elements in the second vector).; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] IndexOffset Specifies whether to look for even or odd elements; * \param[in] RHSStartValue Specifies the starting index for th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Availability,mask,mask,42,/**; * Determine if the specified shuffle mask is suitable for the vmrgew or; * vmrgow instructions.; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] CheckEven Check for an even merge (true) or an odd merge (false); * \param[in] ShuffleKind Identify the type of merge:; * - 0 = big-endian merge with two different inputs;; * - 1 = either-endian merge with two identical inputs;; * - 2 = little-endian merge with two different inputs (inputs are swapped for; * little-endian merges).; * \param[in] DAG The current SelectionDAG; * \return true iff this shuffle mask; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:581,Availability,mask,mask,581,/**; * Determine if the specified shuffle mask is suitable for the vmrgew or; * vmrgow instructions.; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] CheckEven Check for an even merge (true) or an odd merge (false); * \param[in] ShuffleKind Identify the type of merge:; * - 0 = big-endian merge with two different inputs;; * - 1 = either-endian merge with two identical inputs;; * - 2 = little-endian merge with two different inputs (inputs are swapped for; * little-endian merges).; * \param[in] DAG The current SelectionDAG; * \return true iff this shuffle mask; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:54,Availability,mask,mask,54,"/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the shift; /// amount, otherwise return -1.; /// The ShuffleKind distinguishes between big-endian operations with two; /// different inputs (0), either-endian operations with two identical inputs; /// (1), and little-endian operations with two different inputs (2). For the; /// latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Availability,mask,mask,49,// Find the first non-undef value in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Availability,mask,mask,105,"// Check that the indices are consecutive, in the case of a multi-byte element; // splatted with a v16i8 mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Availability,mask,mask,19,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:93,Availability,mask,mask,93,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:453,Availability,mask,mask,453,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:535,Availability,mask,mask,535,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,"// Now we look at mask elements 0,4,8,12",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,Availability,mask,mask,59,"// Below, let H and L be arbitrary elements of the shuffle mask; // where H is in the range [4,7] and L is in the range [0,3].; // H, 1, 2, 3 or L, 5, 6, 7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,"// Now we look at mask elements 0,4,8,12, which are the beginning of words.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Availability,Mask,Mask,47,// Ensure each word index of the ShuffleVector Mask is consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:168,Usability,simpl,simply,168,// Input vectors need to be swapped if the leading element; // of the result is one of the 3 left elements of the first vector; // (or if we're shifting by 4 - thereby simply swapping the vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:456,Availability,mask,mask,456,"/// Can node \p N be lowered to an XXPERMDI instruction? If so, set \p Swap; /// if the inputs to the instruction should be swapped and set \p DM to the; /// value for the immediate.; /// Specifically, set \p Swap to true only if \p N can be lowered to XXPERMDI; /// AND element 0 of the result comes from the first input (LE) or second input; /// (BE). Set \p DM to the calculated result (0-3) only if \p N can be lowered.; /// \return true iff the given mask of shuffle node \p N is a XXPERMDI shuffle; /// mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:509,Availability,mask,mask,509,"/// Can node \p N be lowered to an XXPERMDI instruction? If so, set \p Swap; /// if the inputs to the instruction should be swapped and set \p DM to the; /// value for the immediate.; /// Specifically, set \p Swap to true only if \p N can be lowered to XXPERMDI; /// AND element 0 of the result comes from the first input (LE) or second input; /// (BE). Set \p DM to the calculated result (0-3) only if \p N can be lowered.; /// \return true iff the given mask of shuffle node \p N is a XXPERMDI shuffle; /// mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:224,Testability,log,logical,224,"// If ByteSize of the splat is bigger than the element size of the; // build_vector, then we have a case where we are checking for a splat where; // multiple elements of the buildvector are folded together into a single; // logical element of the splat (e.g. ""vsplish 1"" to splat {0,1}*8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Modifiability,extend,extend,17,// Properly sign extend the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:230,Testability,test,tests,230,"//===----------------------------------------------------------------------===//; // Addressing Mode Selection; //===----------------------------------------------------------------------===//; /// isIntS16Immediate - This method tests to see if the node is either a 32-bit; /// or 64-bit immediate, and if the value can be accurately represented as a; /// sign extension from a 16-bit value. If so, this returns true and the; /// immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Performance,load,loads,52,"/// Used when computing address flags for selecting loads and stores.; /// If we have an OR, check if the LHS and RHS are provably disjoint.; /// An OR of two provably disjoint values is equivalent to an ADD.; /// Most PPC load/store instructions compute the effective address as a sum,; /// so doing this conversion is useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:223,Performance,load,load,223,"/// Used when computing address flags for selecting loads and stores.; /// If we have an OR, check if the LHS and RHS are provably disjoint.; /// An OR of two provably disjoint values is equivalent to an ADD.; /// Most PPC load/store instructions compute the effective address as a sum,; /// so doing this conversion is useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Testability,test,tests,36,"/// isIntS34Immediate - This method tests if value of node given can be; /// accurately represented as a sign extension from a 34-bit value. If so,; /// this returns true and the immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:168,Energy Efficiency,efficient,efficiently,168,"/// SelectAddressRegReg - Given the specified addressed, check to see if it; /// can be represented as an indexed [r+r] operation. Returns false if it; /// can be more efficiently represented as [r+imm]. If \p EncodingAlignment is; /// non-zero and N can be represented by a base register plus a signed 16-bit; /// displacement, make a more precise judgement by checking (displacement % \p; /// EncodingAlignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Performance,load,load,20,"// Is there any SPE load/store (f64), which can't handle 16bit offset?; // SPE load/store can only handle 8-bit offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:79,Performance,load,load,79,"// Is there any SPE load/store (f64), which can't handle 16bit offset?; // SPE load/store can only handle 8-bit offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:480,Energy Efficiency,allocate,allocated,480,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:35,Performance,load,load,35,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:174,Performance,load,load,174,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:508,Performance,load,load,508,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:108,Testability,test,test,108,"// NOTE: We'll exclude negative FIs here, which come from argument; // lowering, because there are no known test cases triggering this problem; // using packed structures (or similar). We can remove this exclusion if; // we find such a test case. The reason why this is so test-case driven is; // because this entire 'fixup' is only to prevent crashes (from the; // register scavenger) on not-really-valid inputs. For example, if we have:; // %a = alloca i1; // %b = bitcast i1* %a to i64*; // store i64* a, i64 b; // then the store should really be marked as 'align 1', but is not. If it; // were marked as 'align 1' then the indexed form would have been; // instruction-selected initially, and the problem this 'fixup' is preventing; // won't happen regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:236,Testability,test,test,236,"// NOTE: We'll exclude negative FIs here, which come from argument; // lowering, because there are no known test cases triggering this problem; // using packed structures (or similar). We can remove this exclusion if; // we find such a test case. The reason why this is so test-case driven is; // because this entire 'fixup' is only to prevent crashes (from the; // register scavenger) on not-really-valid inputs. For example, if we have:; // %a = alloca i1; // %b = bitcast i1* %a to i64*; // store i64* a, i64 b; // then the store should really be marked as 'align 1', but is not. If it; // were marked as 'align 1' then the indexed form would have been; // instruction-selected initially, and the problem this 'fixup' is preventing; // won't happen regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:273,Testability,test,test-case,273,"// NOTE: We'll exclude negative FIs here, which come from argument; // lowering, because there are no known test cases triggering this problem; // using packed structures (or similar). We can remove this exclusion if; // we find such a test case. The reason why this is so test-case driven is; // because this entire 'fixup' is only to prevent crashes (from the; // register scavenger) on not-really-valid inputs. For example, if we have:; // %a = alloca i1; // %b = bitcast i1* %a to i64*; // store i64* a, i64 b; // then the store should really be marked as 'align 1', but is not. If it; // were marked as 'align 1' then the indexed form would have been; // instruction-selected initially, and the problem this 'fixup' is preventing; // won't happen regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,load,36,"// FIXME dl should come from parent load or store, not from address",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,LOAD,LOAD,9,"// Match LOAD (ADD (X, Lo(G))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Loading,3,"// Loading from a constant address.; // If this address fits entirely in a 16-bit sext immediate field, codegen; // this as ""d, 0""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Availability,down,down,25,"// Otherwise, break this down into an LIS + disp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Performance,load,loads,105,/// Similar to the 16-bit case but for instructions that take a 34-bit; /// displacement field (prefixed loads/stores).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,Energy Efficiency,reduce,reduce,143,"// If the address is the result of an add, we will utilize the fact that the; // address calculation includes an implicit add. However, we can reduce; // register pressure if we do not materialize a constant just for use as the; // index register. We only get rid of the add if it is not an add of a; // value and a 16-bit signed constant and both have a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:43,Performance,load,load,43,"/// Returns true if we should use a direct load into vector instruction; /// (such as lxsd or lfd), instead of a load into gpr + direct move sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,Performance,load,load,113,"/// Returns true if we should use a direct load into vector instruction; /// (such as lxsd or lfd), instead of a load into gpr + direct move sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,Performance,load,load,99,"// If there are any other uses other than scalar to vector, then we should; // keep it as a scalar load -> direct move pattern to prevent multiple; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:151,Performance,load,loads,151,"// If there are any other uses other than scalar to vector, then we should; // keep it as a scalar load -> direct move pattern to prevent multiple; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:194,Performance,load,load,194,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Energy Efficiency,efficient,efficient,134,"// Do not generate pre-inc forms for specific loads that feed scalar_to_vector; // instructions because we can fold these into a more efficient instruction; // instead, (such as LXSD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,load,loads,46,"// Do not generate pre-inc forms for specific loads that feed scalar_to_vector; // instructions because we can fold these into a more efficient instruction; // instead, (such as LXSD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC doesn't have preinc load/store instructions for vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,Performance,load,load,31,// PowerPC doesn't have preinc load/store instructions for vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:66,Performance,load,load,66,"// PPC64 doesn't have lwau, but it does have lwaux. Reject preinc load of; // sext i32 to i64 when addr mode is r+i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,Security,access,accesses,41,// Generate non-pic code that has direct accesses to the constant pool.; // The address of the global is just (hi(&g)+lo(&g)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Energy Efficiency,Power,PowerPC,14,"// For 64-bit PowerPC, prefer the more compact relative encodings.; // This trades 32 bits per jump table entry for one or two instructions; // on the jump site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Modifiability,variab,variable,102,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:171,Modifiability,variab,variable,171,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,Performance,load,load,90,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:164,Performance,load,loaded,164,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:103,Modifiability,variab,variables,103,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:267,Modifiability,variab,variable,267,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:64,Security,access,access,64,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:234,Security,access,access,234,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:100,Modifiability,variab,variable,100,"// For local-exec and initial-exec on AIX (32-bit), the sequence generated; // involves loading the variable offset from the TOC, generating a call to; // .__get_tpointer to get the thread pointer (which will be in R3), and; // adding the two together:; // lwz reg1,var[TC](2); // bla .__get_tpointer; // add reg2, reg1, r3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:88,Performance,load,loading,88,"// For local-exec and initial-exec on AIX (32-bit), the sequence generated; // involves loading the variable offset from the TOC, generating a call to; // .__get_tpointer to get the thread pointer (which will be in R3), and; // adding the two together:; // lwz reg1,var[TC](2); // bla .__get_tpointer; // add reg2, reg1, r3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Security,access,access,56,// We do not implement the 32-bit version of the faster access sequence; // for local-exec that is controlled by -maix-small-local-exec-tls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:286,Modifiability,variab,variable,286,"// Only Local-Exec, Initial-Exec and General-Dynamic TLS models are currently; // supported models. If Local- or Initial-exec are not possible or specified,; // all GlobalTLSAddress nodes are lowered using the general-dynamic model.; // We need to generate two TOC entries, one for the variable offset, one for; // the region handle. The global address for the TOC entry of the region; // handle is created with the MO_TLSGDM_FLAG flag and the global address; // for the TOC entry of the variable offset is created with MO_TLSGD_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:488,Modifiability,variab,variable,488,"// Only Local-Exec, Initial-Exec and General-Dynamic TLS models are currently; // supported models. If Local- or Initial-exec are not possible or specified,; // all GlobalTLSAddress nodes are lowered using the general-dynamic model.; // We need to generate two TOC entries, one for the variable offset, one for; // the region handle. The global address for the TOC entry of the region; // handle is created with the MO_TLSGDM_FLAG flag and the global address; // for the TOC entry of the variable offset is created with MO_TLSGD_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Security,expose,expose,44,"// If we're comparing for equality to zero, expose the fact that this is; // implemented as a ctlz/srl pair on ppc, so that the dag combiner can; // fold the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:79,Performance,optimiz,optimized,79,"// Leave comparisons against 0 and -1 alone for now, since they're usually; // optimized. FIXME: revisit this when we can custom lower all setcc; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:149,Performance,optimiz,optimizations,149,"// Leave comparisons against 0 and -1 alone for now, since they're usually; // optimized. FIXME: revisit this when we can custom lower all setcc; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Availability,mask,masking,191,"// If we have an integer seteq/setne, turn it into a compare against zero; // by xor'ing the rhs with the lhs, which is faster than setting a; // condition register, reading it back out, and masking the correct bit. The; // normal approach here uses sub to do this instead of xor. Using xor exposes; // the result to other bit-twiddling opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:291,Security,expose,exposes,291,"// If we have an integer seteq/setne, turn it into a compare against zero; // by xor'ing the rhs with the lhs, which is faster than setting a; // condition register, reading it back out, and masking the correct bit. The; // normal approach here uses sub to do this instead of xor. Using xor exposes; // the result to other bit-twiddling opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Performance,load,load,26,// determine if we should load from reg_save_area or overflow_area,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:115,Energy Efficiency,allocate,allocated,115,"// For the 32-bit SVR4 ABI we follow the layout of the va_list struct.; // We suppose the given va_list is already allocated.; //; // typedef struct {; // char gpr; /* index into the array of 8 GPRs; // * stored in the register save area; // * gpr=0 corresponds to r3,; // * gpr=1 to r4, etc.; // */; // char fpr; /* index into the array of 8 FPRs; // * stored in the register save area; // * fpr=0 corresponds to f1,; // * fpr=1 to f2, etc.; // */; // char *overflow_arg_area;; // /* location on stack that holds; // * the next overflow argument; // */; // char *reg_save_area;; // /* where r3:r10 and f1:f8 (if saved); // * are stored; // */; // } va_list[1];",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Energy Efficiency,allocate,allocated,49,/// FPR - The set of FP registers that should be allocated for arguments; /// on Darwin and AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,Availability,Avail,AvailableFPRs,143,"/// CalculateStackSlotUsed - Return whether this argument will use its; /// stack slot (instead of being passed in registers). ArgOffset,; /// AvailableFPRs, and AvailableVRs must hold the current argument; /// position, and will be updated to account for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:162,Availability,Avail,AvailableVRs,162,"/// CalculateStackSlotUsed - Return whether this argument will use its; /// stack slot (instead of being passed in registers). ArgOffset,; /// AvailableFPRs, and AvailableVRs must hold the current argument; /// position, and will be updated to account for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:233,Deployability,update,updated,233,"/// CalculateStackSlotUsed - Return whether this argument will use its; /// stack slot (instead of being passed in registers). ArgOffset,; /// AvailableFPRs, and AvailableVRs must hold the current argument; /// position, and will be updated to account for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate argument on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:962,Energy Efficiency,Power,PowerPC,962,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:952,Integrability,Interface,Interface,952,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1026,Integrability,Interface,Interface,1026,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:622,Modifiability,variab,variable,622,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Modifiability,extend,extended,11,// Get the extended size of the argument type in stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load,10,// Create load nodes to retrieve arguments from the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:128,Modifiability,variab,variable,128,"// Assign locations to all of the incoming aggregate by value arguments.; // Aggregates passed by value are stored in the local variable space of the; // caller's stack frame, right above the parameter list area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,optimiz,optimized,84,// Set the size that is at least reserved in caller of this function. Tail; // call optimized function's reserved stack space needs to be aligned so that; // taking the difference between two stack areas will result in an aligned; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,load,loaded,127,// The fixed integer arguments of a variadic function are stored to the; // VarArgsFrameIndex on the stack so that they may be loaded by; // dereferencing the result of va_next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Energy Efficiency,allocate,allocated,102,"// Do a first pass over the arguments to determine whether the ABI; // guarantees that our caller has allocated the parameter save area; // on its stack frame. In the ELFv1 ABI, this is always the case;; // in the ELFv2 ABI, it is true if this is a vararg function or if; // any parameter is located in a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Performance,load,load,20,"// Add DAG nodes to load the arguments or copy them out of registers. On; // entry to a function on PPC, the arguments start after the linkage area,; // although the first ones are often in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:208,Energy Efficiency,allocate,allocated,208,"// Create a stack object covering all stack doublewords occupied; // by the argument. If the argument is (fully or partially) on; // the stack, or if the argument is fully in registers but the; // caller has allocated the parameter save anyway, we can refer; // directly to the caller's stack frame. Otherwise, create a; // local copy in our own frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Safety,avoid,avoid,153,"// These can be scalar arguments or elements of an integer array type; // passed directly. Clang may use those instead of ""byval"" aggregate; // types to avoid forcing arguments to memory unnecessarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load,14,// We need to load the argument to a virtual register if we determined; // above that we ran out of physical registers of the appropriate type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,optimiz,optimized,84,// Set the size that is at least reserved in caller of this function. Tail; // call optimized functions' reserved stack space needs to be aligned so that; // taking the difference between two stack areas will result in an aligned; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.; // On ELFv2ABI spec, it writes:; // C programs that are intended to be *portable* across different compilers; // and architectures must use the header file <stdarg.h> to deal with variable; // argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:226,Modifiability,portab,portable,226,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.; // On ELFv2ABI spec, it writes:; // C programs that are intended to be *portable* across different compilers; // and architectures must use the header file <stdarg.h> to deal with variable; // argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:334,Modifiability,variab,variable,334,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.; // On ELFv2ABI spec, it writes:; // C programs that are intended to be *portable* across different compilers; // and architectures must use the header file <stdarg.h> to deal with variable; // argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Performance,load,loaded,125,"// If this function is vararg, store any remaining integer argument regs; // to their spots on the stack so that they may be loaded by dereferencing; // the result of va_next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Testability,stub,stub,71,"// If the callee is preemptable, then the static linker will use a plt-stub; // which saves the toc to the stack, and needs a nop after the call; // instruction to convert to a toc-restore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Safety,safe,safely,10,"// We can safely tail call both fastcc and ccc callees from a c calling; // convention caller. If the caller is fastcc, we may have less stack space; // than a non-fastcc caller with the same signature so disable tail-calls in; // that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:220,Performance,optimiz,optimization,220,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:343,Testability,test,test,343,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:445,Testability,test,test,445,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:460,Testability,test,test,460,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:531,Testability,test,test,531,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:546,Testability,test,test,546,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:561,Testability,test,test,561,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:620,Testability,test,test,620,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Modifiability,Variab,Variable,3,// Variable argument functions are not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,Performance,optimiz,optimized,131,/// EmitTailCallStoreFPAndRetAddr - Move the frame pointer and return address to; /// the appropriate stack slot for the tail call optimized function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,load,34,/// EmitTCFPAndRetAddrLoad - Emit load from frame pointer and return address; /// stack slot. Returns the chain as result and the loaded frame pointers in; /// LROpOut/FPOpout. Used when tail calling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:130,Performance,load,loaded,130,/// EmitTCFPAndRetAddrLoad - Emit load from frame pointer and return address; /// stack slot. Returns the chain as result and the loaded frame pointers in; /// LROpOut/FPOpout. Used when tail calling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the LR and FP stack slot for later adjusting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,optimiz,optimization,127,// Emit a sequence of copyto/copyfrom virtual registers for arguments that; // might overwrite each other in case of tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Patch,PatchPoint,3,// PatchPoint calls are not indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:407,Performance,load,load,407,"// AIX and the 64-bit ELF ABIs need to maintain the TOC pointer accross; // indirect calls. The save of the caller's TOC pointer to the stack will be; // inserted into the DAG as part of call lowering. The restore of the TOC; // pointer is modeled by using a pseudo instruction for the call opcode that; // represents the 2 instruction sequence of an indirect branch and link,; // immediately followed by a load of the TOC pointer from the stack save; // slot into gpr2. For 64-bit ELFv2 ABI with PCRel, do not restore the TOC; // as it is not saved or used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:470,Modifiability,rewrite,rewrite,470,"// The ABIs that maintain a TOC pointer accross calls need to have a nop; // immediately following the call instruction if the caller and callee may; // have different TOC bases. At link time if the linker determines the calls; // may not share a TOC base, the call is redirected to a trampoline inserted; // by the linker. The trampoline will (among other things) save the callers; // TOC pointer at an ABI designated offset in the linkage area and the; // linker will rewrite the nop to be a load of the TOC pointer from the; // linkage area into gpr2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:494,Performance,load,load,494,"// The ABIs that maintain a TOC pointer accross calls need to have a nop; // immediately following the call instruction if the caller and callee may; // have different TOC bases. At link time if the linker determines the calls; // may not share a TOC base, the call is redirected to a trampoline inserted; // by the linker. The trampoline will (among other things) save the callers; // TOC pointer at an ABI designated offset in the linkage area and the; // linker will rewrite the nop to be a load of the TOC pointer from the; // linkage area into gpr2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Security,secur,secure-PLT,191,"// The PLT is only used in 32-bit ELF PIC mode. Attempting to use the PLT in; // a static relocation model causes some versions of GNU LD (2.17.50, at; // least) to force BSS-PLT, instead of secure-PLT, even if all objects are; // built with secure-PLT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:242,Security,secur,secure-PLT,242,"// The PLT is only used in 32-bit ELF PIC mode. Attempting to use the PLT in; // a static relocation model causes some versions of GNU LD (2.17.50, at; // least) to force BSS-PLT, instead of secure-PLT, even if all objects are; // built with secure-PLT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1017,Energy Efficiency,schedul,scheduled,1017,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1161,Energy Efficiency,schedul,scheduled,1161,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1266,Energy Efficiency,schedul,scheduled,1266,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:447,Performance,perform,performed,447,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:603,Performance,Load,Load,603,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:689,Performance,Load,Load,689,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:761,Performance,Load,Load,761,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1007,Performance,load,loads,1007,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1399,Performance,load,loading,1399,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1236,Security,access,access,1236,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Performance,load,load,7,// One load for the functions entry point address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Performance,load,loading,11,// One for loading the TOC anchor for the module that contains the called; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Performance,load,loading,11,// One for loading the environment pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,loaded,23,// Then copy the newly loaded TOC anchor to the TOC pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:264,Performance,load,load,264,"// For the TOC based ABIs, we have saved the TOC pointer to the linkage area; // on the stack (this would have been done in `LowerCall_64SVR4` or; // `LowerCall_AIX`). The call instruction is a pseudo instruction that; // represents both the indirect branch and a load that restores the TOC; // pointer from the linkage area. The operand for the TOC restore is an add; // of the TOC save offset to the stack pointer. This must be the second; // operand: after the chain input but before any other variadic arguments.; // For 64-bit ELFv2 ABI with PCRel, do not restore the TOC as it is not; // saved or used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Deployability,PATCH,PATCHPOINT,46,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,Integrability,depend,dependencies,94,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:151,Integrability,depend,dependency,151,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,perform,performing,8,// When performing tail call optimization the callee pops its arguments off; // the stack. Account for this here so these bytes can be pushed back on in; // PPCFrameLowering::eliminateCallFramePseudoInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,optimiz,optimization,29,// When performing tail call optimization the callee pops its arguments off; // the stack. Account for this here so these bytes can be pushed back on in; // PPCFrameLowering::eliminateCallFramePseudoInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:185,Performance,load,load,185,// PC Relative calls no longer guarantee that the callee is a Global; // Address Node. The callee could be an indirect tail call in which; // case the SDValue for the callee could be a load (to load the address; // of a function pointer) or it may be a register copy (to move the; // address of the callee from a function parameter into a virtual; // register). It may also be an ExternalSymbolSDNode (ex memcopy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:194,Performance,load,load,194,// PC Relative calls no longer guarantee that the callee is a Global; // Address Node. The callee could be an indirect tail call in which; // case the SDValue for the callee could be a load (to load the address; // of a function pointer) or it may be a register copy (to move the; // address of the callee from a function parameter into a virtual; // register). It may also be an ExternalSymbolSDNode (ex memcopy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,Modifiability,variab,variable,133,"// Count how many bytes are to be pushed on the stack, including the linkage; // area, parameter list area and the part of the local variable space which; // contains copies of aggregates which are passed by value.; // Assign locations to all of the outgoing arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,Availability,avail,available,133,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Modifiability,variab,variable,20,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:144,Modifiability,Variab,Variable,144,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,Modifiability,variab,variable,85,"// Size of the linkage area, parameter list area and the part of the local; // space variable where copies of aggregates which are passed by value are; // stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,Performance,optimiz,optimization,85,// Calculate by how many bytes the stack has to be adjusted in case of tail; // call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the return address and frame pointer so it can be moved somewhere else; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Availability,avail,available,118,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,load,loading,46,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,Energy Efficiency,allocate,allocated,117,"// Walk the register/memloc assignments, inserting copies/loads.; // i - Tracks the index into the list of registers allocated for the call; // RealArgIdx - Tracks the index into the list of actual function arguments; // j - Tracks the index into the list of byval arguments",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.; // i - Tracks the index into the list of registers allocated for the call; // RealArgIdx - Tracks the index into the list of actual function arguments; // j - Tracks the index into the list of byval arguments",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Modifiability,variab,variable,107,"// Argument is an aggregate which is passed by value, thus we need to; // create a copy of it in the local variable space of the current stack; // frame (which is the stack frame of the caller) and pass the address of; // this copy to the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,Modifiability,variab,variable,32,// Memory reserved in the local variable space of the callers stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:178,Modifiability,Extend,Extend,178,"// When useCRBits() is true, there can be i1 arguments.; // It is because getRegisterType(MVT::i1) => MVT::i1,; // and for other integer types getRegisterType() => MVT::i32.; // Extend i1 and ensure callee will get i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Safety,avoid,avoid,20,"// On ELFv2, we can avoid allocating the parameter area if all the arguments; // can be passed to the callee in registers.; // For the fast calling convention, there is another check below.; // Note: We should keep consistent with LowerFormalArguments_64SVR4()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid allocating parameter area for fastcc functions if all the arguments; // can be passed in the registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:422,Energy Efficiency,allocate,allocate,422,"// In the old ELFv1 ABI,; // the prolog code of the callee may store up to 8 GPR argument registers to; // the stack, allowing va_start to index over them in memory if its varargs.; // Because we cannot tell if this is needed on the caller side, we have to; // conservatively assume that it is needed. As such, make sure we have at; // least enough stack space for the caller to store the 8 GPRs.; // In the ELFv2 ABI, we allocate the parameter area iff a callee; // really requires memory operands, e.g. a vararg function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,Performance,optimiz,optimization,85,// Calculate by how many bytes the stack has to be adjusted in case of tail; // call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,Performance,load,loads,92,"// To protect arguments on the stack from being clobbered in a tail call,; // force all the loads to happen before doing any other lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the return address and frame pointer so it can be move somewhere else; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Availability,avail,available,118,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,load,loading,46,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:246,Availability,avail,available,246,"// Figure out which arguments are going to go in registers, and which in; // memory. Also, if this is a vararg function, floating point operations; // must be stored to our stack, and loaded into integer regs as well, if; // any integer regs are available for argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:184,Performance,load,loaded,184,"// Figure out which arguments are going to go in registers, and which in; // memory. Also, if this is a vararg function, floating point operations; // must be stored to our stack, and loaded into integer regs as well, if; // any integer regs are available for argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:287,Energy Efficiency,allocate,allocate,287,"// Copy the object to parameter save area if it can not be entirely passed ; // by registers.; // FIXME: we only need to copy the parts which need to be passed in; // parameter save area. For the parts passed by registers, we don't need; // to copy them to the stack although we need to allocate space for them; // in parameter save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,avail,available,22,"// When a register is available, pass a small aggregate right-justified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:132,Modifiability,variab,variable,132,"// The easiest way to get this right-justified in a register; // is to copy the structure into the rightmost portion of a; // local variable slot, then load the whole slot into the; // register.; // FIXME: The memcpy seems to produce pretty awful code for; // small aggregates, particularly for packed ones.; // FIXME: It would be preferable to use the slot in the; // parameter save area instead of a new local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:412,Modifiability,variab,variable,412,"// The easiest way to get this right-justified in a register; // is to copy the structure into the rightmost portion of a; // local variable slot, then load the whole slot into the; // register.; // FIXME: The memcpy seems to produce pretty awful code for; // small aggregates, particularly for packed ones.; // FIXME: It would be preferable to use the slot in the; // parameter save area instead of a new local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:152,Performance,load,load,152,"// The easiest way to get this right-justified in a register; // is to copy the structure into the rightmost portion of a; // local variable slot, then load the whole slot into the; // register.; // FIXME: The memcpy seems to produce pretty awful code for; // small aggregates, particularly for packed ones.; // FIXME: It would be preferable to use the slot in the; // parameter save area instead of a new local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the slot into the register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Safety,avoid,avoid,153,"// These can be scalar arguments or elements of an integer array type; // passed directly. Clang may use those instead of ""byval"" aggregate; // types to avoid forcing arguments to memory unnecessarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:439,Integrability,rout,routines,439,"// These can be scalar arguments or elements of a float array type; // passed directly. The latter are used to implement ELFv2 homogenous; // float aggregates.; // Named arguments go into FPRs first, and once they overflow, the; // remaining arguments go into GPRs and then the parameter save area.; // Unnamed arguments for vararg functions always go to GPRs and; // then the parameter save area. For now, put all arguments to vararg; // routines always in both locations (FPR *and* GPR or stack slot).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,Availability,avail,available,41,// First load the argument into the next available FPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,load,load,9,// First load the argument into the next available FPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,load,load,9,"// Next, load the argument into GPR or stack slot if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Modifiability,extend,extended,30,// Non-array float values are extended and passed in a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load r2 into a virtual register and store it to the TOC save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:88,Energy Efficiency,allocate,allocated,88,// Vectors passed on the stack do not shadow GPRs or FPRs even though they; // might be allocated in the portion of the PSA that is shadowed by the; // GPRs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,allocate,allocate,10,// Shadow allocate register and its stack shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:109,Availability,avail,available,109,// Vectors that are passed as fixed arguments are handled differently.; // They are passed in VRs if any are available (unlike arguments passed; // through ellipses) and shadow GPRs (unlike arguments to non-vaarg; // functions),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,allocate,allocate,10,// Shadow allocate GPRs and stack space even though we pass in a VR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:818,Modifiability,variab,variable,818,// AIX ABI Stack Frame Layout:; //; // Low Memory +--------------------------------------------+; // SP +---> | Back chain | ---+; // | +--------------------------------------------+ | ; // | | Saved Condition Register | |; // | +--------------------------------------------+ |; // | | Saved Linkage Register | |; // | +--------------------------------------------+ | Linkage Area; // | | Reserved for compilers | |; // | +--------------------------------------------+ |; // | | Reserved for binders | |; // | +--------------------------------------------+ |; // | | Saved TOC pointer | ---+; // | +--------------------------------------------+; // | | Parameter save area |; // | +--------------------------------------------+; // | | Alloca space |; // | +--------------------------------------------+; // | | Local variable space |; // | +--------------------------------------------+; // | | Float/int conversion temporary |; // | +--------------------------------------------+; // | | Save area for AltiVec registers |; // | +--------------------------------------------+; // | | AltiVec alignment padding |; // | +--------------------------------------------+; // | | Save area for VRSAVE register |; // | +--------------------------------------------+; // | | Save area for General Purpose registers |; // | +--------------------------------------------+; // | | Save area for Floating Point registers |; // | +--------------------------------------------+; // +---- | Back chain |; // High Memory +--------------------------------------------+; //; // Specifications:; // AIX 7.2 Assembler Language Reference; // Subroutine linkage convention,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,Availability,avail,available,133,"// For compatibility with the AIX XL compiler, the float args in the; // parameter save area are initialized even if the argument is available; // in register. The caller is required to initialize both the register; // and memory, however, the callee can choose to expect it in either.; // The memloc is dismissed here because the argument is retrieved from; // the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Availability,avail,available,84,"// Vector arguments to VaArg functions are passed both on the stack, and; // in any available GPRs. Load the value from the stack and add the GPRs; // as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:100,Performance,Load,Load,100,"// Vector arguments to VaArg functions are passed both on the stack, and; // in any available GPRs. Load the value from the stack and add the GPRs; // as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:87,Usability,simpl,simply,87,"// Since the callers side has left justified the aggregate in the; // register, we can simply store the entire register into the stack; // slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:110,Performance,load,load,110,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:132,Performance,optimiz,optimize,132,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Security,access,accessing,56,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,optimiz,optimized,84,// Set the size that is at least reserved in caller of this function. Tail; // call optimized function's reserved stack space needs to be aligned so; // that taking the difference between two stack areas will result in an; // aligned stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,load,loaded,127,// The fixed integer arguments of a variadic function are stored to the; // VarArgsFrameIndex on the stack so that they may be loaded by; // dereferencing the result of va_next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Availability,avail,available,114,// Set up a copy of the stack pointer for loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Performance,load,loading,42,// Set up a copy of the stack pointer for loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Energy Efficiency,power,power-of-,153,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:137,Performance,Load,Loads,137,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:276,Performance,load,loads,276,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Performance,load,load,68,"// By-val arguments are passed left-justfied in register.; // Every load here needs to be shifted, otherwise a full register load; // should have been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Performance,load,load,125,"// By-val arguments are passed left-justfied in register.; // Every load here needs to be shifted, otherwise a full register load; // should have been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,load,load,8,// Then load the GPRs from the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Availability,avail,available,21,"// If only 1 GPR was available, there will only be one custom GPR and; // the argument will also pass in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the old link SP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load,10,"// First, load 8 bits into 32 bits, then truncate to 1 bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Modifiability,extend,extend,15,"// First, zero extend to 32 bits, then use a truncating store to 8 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Availability,down,down,118,"// Implements a vector truncate that fits in a vector register as a shuffle.; // We want to legalize vector truncates down to where the source fits in; // a vector register (and target is therefore smaller than vector register; // size). At that point legalization will try to custom lower the sub-legal; // result and get here - where we can contain the truncate as a single target; // operation.; // For example a trunc <2 x i16> to <2 x i8> could be visualized as follows:; // <MSB1|LSB1, MSB2|LSB2> to <LSB1, LSB2>; //; // We will implement it for big-endian ordering as this (where x denotes; // undefined):; // < MSB1|LSB1, MSB2|LSB2, uu, uu, uu, uu, uu, uu> to; // < LSB1, LSB2, u, u, u, u, u, u, u, u, u, u, u, u, u, u>; //; // The same operation in little-endian ordering will be:; // <uu, uu, uu, uu, uu, uu, LSB2|MSB2, LSB1|MSB1> to; // <u, u, u, u, u, u, u, u, u, u, u, u, u, u, LSB2, LSB1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,Performance,optimiz,optimization,141,"// We might be able to do better than this under some circumstances, but in; // general, fsel-based lowering of select is a finite-math-only optimization.; // For more information, see section F.3 of the 2.06 ISA specification.; // With ISA 3.0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Performance,load,load,15,"// Result is a load from the stack slot. If loading 4 bytes, make sure to; // add in a bias on big endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Performance,load,loading,44,"// Result is a load from the stack slot. If loading 4 bytes, make sure to; // add in a bias on big endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Availability,avail,available,97,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:146,Performance,load,load,146,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Safety,avoid,avoid,122,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Availability,avail,available,102,// Expand ppcf128 to i32 by hand for the benefit of llvm-gcc bootstrap on; // PPC (the libcall is not available).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Performance,load,load,57,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:101,Performance,load,load,101,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,Performance,load,load,141,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:262,Performance,load,load,262,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:329,Performance,load,load,329,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Performance,load,load,24,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,Performance,load,loads,117,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:173,Performance,load,loads,173,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:239,Performance,load,load,239,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,Performance,load,load,59,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Performance,load,load,71,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,load,134,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:33,Performance,load,loaded,33,// Only look at the users of the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Availability,avail,available,97,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:146,Performance,load,load,146,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Safety,avoid,avoid,122,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:73,Performance,load,load,73,"// If we have direct moves, we can do all the conversion, skip the store/load; // however, without FPCVT we can't do most conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,Safety,avoid,avoid,141,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:450,Safety,unsafe,unsafe-fp-math,450,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:509,Safety,avoid,avoid,509,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Modifiability,extend,extend,114,"// Since we only generate this in 64-bit mode, we can take advantage of; // 64-bit registers. In particular, sign extend the input value into the; // 64-bit register with extsw, store the WHOLE 64-bit value into the stack; // then lfd it and fcfid it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Modifiability,extend,extended,11,// STD the extended value into the stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the value as a double.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:296,Performance,perform,perform,296,"/*; The rounding mode is in bits 30:31 of FPSR, and has the following; settings:; 00 Round to nearest; 01 Round to 0; 10 Round to +inf; 11 Round to -inf. GET_ROUNDING, on the other hand, expects the following:; -1 Undefined; 0 Round to 0; 1 Round to nearest; 2 Round to +inf; 3 Round to -inf. To perform the conversion, we do:; ((FPSCR & 0x3) ^ ((~FPSCR & 0x3) >> 1)); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load FP Control Word from low 32 bits of stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Integrability,depend,depend,63,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Testability,log,logical,26,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Integrability,depend,depend,63,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Testability,log,logical,26,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Testability,log,logical,26,"// Expand into a bunch of logical ops, followed by a select_cc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Energy Efficiency,Power,PowerPC,187,// fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW)); // This is simpler than TargetLowering::expandFunnelShift because we can rely; // on PowerPC shift by BW being well defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,Usability,simpl,simpler,113,// fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW)); // This is simpler than TargetLowering::expandFunnelShift because we can rely; // on PowerPC shift by BW being well defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Energy Efficiency,efficient,efficient,18,"/// Do we have an efficient pattern in a .td file for this node?; ///; /// \param V - pointer to the BuildVectorSDNode being matched; /// \param HasDirectMove - does this subtarget have VSR <-> GPR direct moves?; ///; /// There are some patterns where it is beneficial to keep a BUILD_VECTOR; /// node as a BUILD_VECTOR node rather than expanding it. The patterns where; /// the opposite is true (expansion is beneficial) are:; /// - The node builds a vector out of integers that are not 32 or 64-bits; /// - The node builds a vector out of constants; /// - The node is a ""load-and-splat""; /// In all other cases, we will choose to keep the BUILD_VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:573,Performance,load,load-and-splat,573,"/// Do we have an efficient pattern in a .td file for this node?; ///; /// \param V - pointer to the BuildVectorSDNode being matched; /// \param HasDirectMove - does this subtarget have VSR <-> GPR direct moves?; ///; /// There are some patterns where it is beneficial to keep a BUILD_VECTOR; /// node as a BUILD_VECTOR node rather than expanding it. The patterns where; /// the opposite is true (expansion is beneficial) are:; /// - The node builds a vector out of integers that are not 32 or 64-bits; /// - The node builds a vector out of constants; /// - The node is a ""load-and-splat""; /// In all other cases, we will choose to keep the BUILD_VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Performance,load,load-and-splat,42,// We want to expand nodes that represent load-and-splat even if the; // loaded value is a floating point truncation or conversion to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:73,Performance,load,loaded,73,// We want to expand nodes that represent load-and-splat even if the; // loaded value is a floating point truncation or conversion to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:55,Performance,load,load,55,"// If the operands are different or the input is not a load and has more; // uses than just this BV node, then it isn't a splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:67,Modifiability,extend,extending,67,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:101,Modifiability,extend,extending,101,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Performance,load,load,52,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,Performance,load,loads,111,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Modifiability,extend,extending,30,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Modifiability,extend,extending,187,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:40,Performance,load,loads,40,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,loads,134,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Modifiability,extend,extend,13,"// Check the extend type, when the input type is i32, and the output vector; // type is v2i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:240,Energy Efficiency,efficient,efficiently,240,"// If this is a case we can't handle, return null and let the default; // expansion code take care of it. If we CAN select this case, and if it; // selects to a single instruction, return Op. Otherwise, if we can codegen; // this case more efficiently than a constant pool load, lower it to the; // sequence of ops that should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:273,Performance,load,load,273,"// If this is a case we can't handle, return null and let the default; // expansion code take care of it. If we CAN select this case, and if it; // selects to a single instruction, return Op. Otherwise, if we can codegen; // this case more efficiently than a constant pool load, lower it to the; // sequence of ops that should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Performance,load,load,13,"// If either load is 0, then we should generate XXLXOR to set to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load-and-splat,10,// Handle load-and-splat patterns as we have instructions that will do this; // in one go.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:115,Deployability,update,update,115,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:27,Modifiability,extend,extending,27,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:72,Modifiability,extend,extending,72,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,load,16,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Performance,load,load,37,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:82,Performance,load,load,82,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Performance,load,load,37,"// Checking for a single use of this load, we have to check for vector; // width (128 bits) / ElementSize uses (since each operand of the; // BUILD_VECTOR is a separate use of the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:458,Modifiability,extend,extend,458,"// Exclude somes case where LD_SPLAT is worse than scalar_to_vector:; // Below cases should also happen for ""lfiwzx/lfiwax + LE target + index; // 1"" and ""lxvrhx + BE target + index 7"" and ""lxvrbx + BE target + index; // 15"", but function IsValidSplatLoad() now will only return true when; // the data at index 0 is not nullptr. So we will not get into trouble for; // these cases.; //; // case 1 - lfiwzx/lfiwax; // 1.1: load result is i32 and is sign/zero extend to i64;; // 1.2: build a v2i64 vector type with above loaded value;; // 1.3: the vector has only one value at index 0, others are all undef;; // 1.4: on BE target, so that lfiwzx/lfiwax does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:422,Performance,load,load,422,"// Exclude somes case where LD_SPLAT is worse than scalar_to_vector:; // Below cases should also happen for ""lfiwzx/lfiwax + LE target + index; // 1"" and ""lxvrhx + BE target + index 7"" and ""lxvrbx + BE target + index; // 15"", but function IsValidSplatLoad() now will only return true when; // the data at index 0 is not nullptr. So we will not get into trouble for; // these cases.; //; // case 1 - lfiwzx/lfiwax; // 1.1: load result is i32 and is sign/zero extend to i64;; // 1.2: build a v2i64 vector type with above loaded value;; // 1.3: the vector has only one value at index 0, others are all undef;; // 1.4: on BE target, so that lfiwzx/lfiwax does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:519,Performance,load,loaded,519,"// Exclude somes case where LD_SPLAT is worse than scalar_to_vector:; // Below cases should also happen for ""lfiwzx/lfiwax + LE target + index; // 1"" and ""lxvrhx + BE target + index 7"" and ""lxvrbx + BE target + index; // 15"", but function IsValidSplatLoad() now will only return true when; // the data at index 0 is not nullptr. So we will not get into trouble for; // these cases.; //; // case 1 - lfiwzx/lfiwax; // 1.1: load result is i32 and is sign/zero extend to i64;; // 1.2: build a v2i64 vector type with above loaded value;; // 1.3: the vector has only one value at index 0, others are all undef;; // 1.4: on BE target, so that lfiwzx/lfiwax does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,Performance,load,load,31,"// case 2 - lxvr[hb]x; // 2.1: load result is at most i16;; // 2.2: build a vector with above loaded value;; // 2.3: the vector has only one value at index 0, others are all undef;; // 2.4: on LE target, so that lxvr[hb]x does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,Performance,load,loaded,94,"// case 2 - lxvr[hb]x; // 2.1: load result is at most i16;; // 2.2: build a vector with above loaded value;; // 2.3: the vector has only one value at index 0, others are all undef;; // 2.4: on LE target, so that lxvr[hb]x does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Performance,load,load,56,// Replace all uses of the output chain of the original load with the; // output chain of the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:98,Performance,load,load,98,// Replace all uses of the output chain of the original load with the; // output chain of the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:189,Energy Efficiency,efficient,efficient,189,"// In 64BIT mode BUILD_VECTOR nodes that are not constant splats of up to; // 32-bits can be lowered to VSX instructions under certain conditions.; // Without VSX, there is no pattern more efficient than expanding the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Modifiability,extend,extended,15,"// If the sign extended value is in the range [-16,15], use VSPLTI[bhw].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,optimiz,optimizations,25,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:6,Safety,avoid,avoid,6,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Usability,undo,undone,39,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,Availability,mask,mask,12,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa.; // Possible permutations inserting an element from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // 0, X, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // ...; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, X; // Inserting from V1 into V2 will be similar, except mask range will be; // [16,31].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:400,Availability,mask,mask,400,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa.; // Possible permutations inserting an element from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // 0, X, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // ...; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, X; // Inserting from V1 into V2 will be similar, except mask range will be; // [16,31].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask; // will contain only elements from the first one and the second one will be; // undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,// Go through the mask of half-words to find an element that's being moved; // from one vector to the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:77,Availability,Mask,Mask,77,"// If 2nd operand is undefined, we should only look for element 7 in the; // Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Availability,Mask,Mask,37,// Examine the other elements in the Mask to see if they're in original; // order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:64,Availability,Mask,Mask,64,"// If CurrentElement is from V1 [0,15], then we the rest of the Mask to be; // from V2 [16,31] and vice versa. Unless the 2nd operand is undefined,; // in which we always assume we're always picking from the 1st operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,"// Now we look at mask elements 0,2,4,6,8,10,12,14. Pack the mask into a; // 32-bit space, only need 4-bit nibbles per element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:61,Availability,mask,mask,61,"// Now we look at mask elements 0,2,4,6,8,10,12,14. Pack the mask into a; // 32-bit space, only need 4-bit nibbles per element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,Availability,mask,mask,12,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa. Possible permutations inserting an element; // from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7; // 0, X, 2, 3, 4, 5, 6, 7; // 0, 1, X, 3, 4, 5, 6, 7; // 0, 1, 2, X, 4, 5, 6, 7; // 0, 1, 2, 3, X, 5, 6, 7; // 0, 1, 2, 3, 4, X, 6, 7; // 0, 1, 2, 3, 4, 5, X, 7; // 0, 1, 2, 3, 4, 5, 6, X; // Inserting from V1 into V2 will be similar, except mask range will be [8,15].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:438,Availability,mask,mask,438,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa. Possible permutations inserting an element; // from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7; // 0, X, 2, 3, 4, 5, 6, 7; // 0, 1, X, 3, 4, 5, 6, 7; // 0, 1, 2, X, 4, 5, 6, 7; // 0, 1, 2, 3, X, 5, 6, 7; // 0, 1, 2, 3, 4, X, 6, 7; // 0, 1, 2, 3, 4, 5, X, 7; // 0, 1, 2, 3, 4, 5, 6, X; // Inserting from V1 into V2 will be similar, except mask range will be [8,15].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,// Go through the mask of half-words to find an element that's being moved; // from one vector to the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask; // will contain only elements from the first one and the second one will be; // undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:38,Availability,mask,mask,38,// Skip if not the correct element or mask of other elements don't equal; // to our expected order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,Availability,mask,mask,75,"// If both operands are defined.; // Target order is [8,15] if the current mask is between [0,7].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Availability,mask,mask,11,// Skip if mask of other elements don't equal our expected order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Availability,mask,mask,26,"// Check that the shuffle mask matches the semantics of XXSPLTI32DX.; // The instruction splats a constant C into two words of the source vector; // producing { C, Unchanged, C, Unchanged } or { Unchanged, C, Unchanged, C }.; // Thus we check that the shuffle mask is the equivalent of; // <0, [4-7], 2, [4-7]> or <[4-7], 1, [4-7], 3> respectively.; // Note: the check above of isNByteElemShuffleMask() ensures that the bytes; // within each word are consecutive, so we only need to check the first byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:260,Availability,mask,mask,260,"// Check that the shuffle mask matches the semantics of XXSPLTI32DX.; // The instruction splats a constant C into two words of the source vector; // producing { C, Unchanged, C, Unchanged } or { Unchanged, C, Unchanged, C }.; // Thus we check that the shuffle mask is the equivalent of; // <0, [4-7], 2, [4-7]> or <[4-7], 1, [4-7], 3> respectively.; // Note: the check above of isNByteElemShuffleMask() ensures that the bytes; // within each word are consecutive, so we only need to check the first byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,load-and-splat,16,"// If this is a load-and-splat, we can do that with a single instruction; // in some cases. However if the load has multiple uses, we don't want to; // combine it because that will just produce multiple loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Performance,load,load,107,"// If this is a load-and-splat, we can do that with a single instruction; // in some cases. However if the load has multiple uses, we don't want to; // combine it because that will just produce multiple loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:203,Performance,load,loads,203,"// If this is a load-and-splat, we can do that with a single instruction; // in some cases. However if the load has multiple uses, we don't want to; // combine it because that will just produce multiple loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,Performance,load,loads,32,// The splat index for permuted loads will be in the left half of the vector; // which is strictly wider than the loaded value by 8 bytes. So we need to; // adjust the splat index to point to the correct address in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Performance,load,loaded,114,// The splat index for permuted loads will be in the left half of the vector; // which is strictly wider than the loaded value by 8 bytes. So we need to; // adjust the splat index to point to the correct address in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load-and-splat,14,"// For 4-byte load-and-splat, we need Power9.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,"// If the width of the load is the same as the width of the splat,; // loading with an offset would load the wrong memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Performance,load,loading,71,"// If the width of the load is the same as the width of the splat,; // loading with an offset would load the wrong memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:100,Performance,load,load,100,"// If the width of the load is the same as the width of the splat,; // loading with an offset would load the wrong memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Availability,mask,mask,125,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:181,Availability,mask,mask,181,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:309,Availability,mask,mask,309,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:374,Availability,mask,mask,374,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:579,Availability,avail,available,579,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:700,Performance,load,load,700,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Safety,avoid,avoid,23,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:632,Safety,avoid,avoid,632,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,"// The SHUFFLE_VECTOR mask is almost exactly what we want for vperm, except; // that it is in input element units, not in bytes. Convert now.; // For little endian, the order of the input vectors is reversed, and; // the permutation mask is complemented with respect to 31. This is; // necessary to produce proper semantics with the big-endian-based vperm; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:233,Availability,mask,mask,233,"// The SHUFFLE_VECTOR mask is almost exactly what we want for vperm, except; // that it is in input element units, not in bytes. Convert now.; // For little endian, the order of the input vectors is reversed, and; // the permutation mask is complemented with respect to 31. This is; // necessary to produce proper semantics with the big-endian-based vperm; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,Availability,mask,mask,53,"// Only need to place items backwards in LE,; // the mask was properly calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Deployability,toggle,toggle,26,"// If we are supposed to, toggle the bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Testability,Test,Testing,10,// FIXME: Testing one of two paired registers is sufficient to guarantee; // ordering?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Modifiability,extend,extend,44,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:147,Modifiability,extend,extend,147,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:121,Performance,load,loaded,121,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:136,Performance,load,loads,136,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Modifiability,extend,extended,37,"// If this is already correctly zero-extended, leave it alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear the high bits of the compare operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Modifiability,extend,extended,63,// Replace the existing compare operand with the properly zero-extended one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,load,load,25,// Lower quadword atomic load to int_ppc_atomic_load_i128 which will be; // lowered to ppc instructions by pattern matching instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Testability,test,test,37,// When it's cheaper or necessary to test reverse flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,Power,3,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Testability,test,testing,25,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Testability,Test,Test,62,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:91,Testability,test,test,91,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:73,Testability,Test,Test,73,"// The instruction doesn't differentiate between signaling or quiet NaN. Test; // the rest first, and test if it 'is NaN and is signaling/quiet'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Testability,test,test,102,"// The instruction doesn't differentiate between signaling or quiet NaN. Test; // the rest first, and test if it 'is NaN and is signaling/quiet'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load it out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:170,Modifiability,refactor,refactored,170,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,load,load,9,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:138,Performance,load,load,138,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:181,Performance,load,load,181,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:244,Performance,load,loads,244,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:355,Performance,load,load,355,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:397,Performance,load,load,397,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:427,Performance,load,load,427,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:487,Performance,load,load,487,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:51,Modifiability,variab,variable,51,"// On P10, we have legal lowering for constant and variable indices for; // all vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,Modifiability,variab,variable,75,"// Before P10, we have legal lowering for constant indices but not for; // variable ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Performance,load,loads,102,// Type v256i1 is used for pairs and v512i1 is used for accumulators.; // Here we create 2 or 4 v16i8 loads to load the pair or accumulator value in; // 2 or 4 vsx registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,Performance,load,load,111,// Type v256i1 is used for pairs and v512i1 is used for accumulators.; // Here we create 2 or 4 v16i8 loads to load the pair or accumulator value in; // 2 or 4 vsx registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Modifiability,extend,extends,17,// FIXME: handle extends from half precision float vectors on P9.; // We only want to custom lower an extend from v2f32 to v2f64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Modifiability,extend,extend,102,// FIXME: handle extends from half precision float vectors on P9.; // We only want to custom lower an extend from v2f32 to v2f64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,load,loads,25,// Ensure both input are loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,load,16,// Generate new load node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Modifiability,Variab,Variable,3,// Variable argument lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:104,Performance,scalab,scalability,104,// See http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html and; // http://www.rdrop.com/users/paulmck/scalability/paper/N2745r.2011.03.04a.html; // and http://www.cl.cam.ac.uk/~pes20/cppppc/ for justification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Modifiability,extend,extended,62,// Signed comparisons of byte or halfword values must be sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:91,Modifiability,extend,extended,91,"// If this is a signed comparison and the value being compared is not known; // to be sign extended, sign extend it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:106,Modifiability,extend,extend,106,"// If this is a signed comparison and the value being compared is not known; // to be sign extended, sign extend it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:375,Availability,mask,mask,375,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:482,Availability,mask,mask,482,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:506,Availability,mask,mask,506,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load,14,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Safety,avoid,avoid,37,// We need use 32-bit subregister to avoid mismatch register class in 64-bit; // mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Modifiability,extend,extend,118,"// For unsigned comparisons, we can directly compare the shifted values.; // For signed comparisons we shift and sign extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Usability,clear,clear,56,"// Since the shift amount is not a constant, we need to clear; // the upper bits with a separate RLWINM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Deployability,update,updated,20,"// Since FP is only updated here but NOT referenced, it's treated as GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Availability,down,down,9,// Round down to the stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:444,Deployability,update,update,444,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:106,Testability,Test,TestMBB,106,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:350,Testability,Test,TestMBB,350,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:359,Testability,test,test,359,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:486,Testability,Test,TestMBB,486,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,Availability,redundant,redundant,139,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Energy Efficiency,allocate,allocated,97,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:129,Safety,avoid,avoid,129,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,Safety,redund,redundant,139,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:38,Deployability,update,update,38,// Materialize a scratch register for update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Integrability,depend,dependence,63,"// Call lowering should have added an r2 operand to indicate a dependence; // on the TOC base pointer value. It can't however, because there is no; // way to mark the dependence as implicit there, and so the stackmap code; // will confuse it with a regular operand. Instead, add the dependence; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:167,Integrability,depend,dependence,167,"// Call lowering should have added an r2 operand to indicate a dependence; // on the TOC base pointer value. It can't however, because there is no; // way to mark the dependence as implicit there, and so the stackmap code; // will confuse it with a regular operand. Instead, add the dependence; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:283,Integrability,depend,dependence,283,"// Call lowering should have added an r2 operand to indicate a dependence; // on the TOC base pointer value. It can't however, because there is no; // way to mark the dependence as implicit there, and so the stackmap code; // will confuse it with a regular operand. Instead, add the dependence; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,Integrability,wrap,wrapped,113,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:213,Performance,load,load,213,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:245,Performance,load,load,245,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:277,Performance,load,load,277,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:409,Availability,mask,mask,409,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:454,Availability,mask,mask,454,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:485,Availability,mask,mask,485,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:549,Availability,mask,mask,549,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:630,Availability,mask,mask,630,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load,14,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Safety,avoid,avoid,37,// We need use 32-bit subregister to avoid mismatch register class in 64-bit; // mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Performance,perform,performs,15,// This pseudo performs an FADD with rounding mode temporarily forced; // to round-to-zero. We emit this via custom inserter since the FPSCR; // is not modeled at the SelectionDAG level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform addition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,"// Load from the stack where SrcReg is stored, and save to DestReg,; // so we have done the RegClass conversion from RegClass::SrcReg to; // RegClass::DestReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Availability,mask,mask,7,// The mask 255 means that put the 32:63 bits of NewFPSCRReg to the 32:63; // bits of FPSCR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,Performance,Optimiz,Optimization,92,//===----------------------------------------------------------------------===//; // Target Optimization Hooks; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:27,Testability,Test,Test,27,// We only have VSX Vector Test for software Square Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,Availability,redundant,redundant,204,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:564,Deployability,pipeline,pipeline,564,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Safety,unsafe,unsafe-fp-math,46,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:137,Safety,unsafe,unsafe-fp-math,137,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,Safety,redund,redundant,204,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:244,Testability,log,logic,244,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Availability,down,down,122,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Performance,load,load,49,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:181,Performance,load,loads,181,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:292,Performance,load,load,292,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:317,Performance,load,load,317,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:259,Safety,safe,safe,259,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Performance,load,load,107,"// First, search up the chain, branching to follow all token-factor operands.; // If we find a consecutive load, then we're done, otherwise, record all; // nodes just above the top-level loads and token factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Performance,load,loads,187,"// First, search up the chain, branching to follow all token-factor operands.; // If we find a consecutive load, then we're done, otherwise, record all; // nodes just above the top-level loads and token factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,down,down,18,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:156,Performance,load,loads,156,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:239,Performance,load,loads,239,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
